id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html530/TFile.html:44711,Performance,load,loaded,44711,"d lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:45452,Performance,cache,cache,45452,"eamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""fi",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:45494,Performance,cache,cache,45494,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:47365,Performance,cache,cache,47365,"rned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, .",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:47408,Performance,cache,cache,47408,"e plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support as",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:50417,Performance,cache,caches,50417,"buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInte",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51036,Performance,cache,cacheDir,51036,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51157,Performance,cache,cache,51157,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51305,Performance,cache,cache,51305,"n(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUr",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51421,Performance,cache,cache,51421,"hat might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51593,Performance,cache,cache,51593,"t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(c",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:52884,Performance,load,loading,52884,"When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListO",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:52920,Performance,cache,cache,52920,"When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListO",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:53030,Performance,cache,cache,53030,"nst char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree; }. Int_t GetNfree() const; { return fFree->GetSize(); }. Int_",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:13927,Safety,timeout,timeout,13927,"eread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t maxCacheSize = 10, I",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:26587,Safety,detect,detect,26587," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:26821,Safety,detect,detected,26821,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:27042,Safety,recover,recovery,27042,"ttings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject* obj, const c",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35240,Safety,recover,recover,35240," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35334,Safety,recover,recovered,35334,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35364,Safety,recover,recovered,35364,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35619,Safety,recover,recover,35619,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35765,Safety,recover,recovered,35765," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35807,Safety,safe,safely,35807," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36015,Safety,recover,recovered,36015," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36118,Safety,recover,recovered,36118,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36190,Safety,recover,recovered,36190," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36350,Safety,recover,recovered,36350,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36550,Safety,recover,recovery,36550,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:47111,Safety,timeout,timeout,47111,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:47157,Safety,timeout,timeout,47157,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51639,Safety,timeout,timeout,51639,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from s",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51659,Safety,timeout,timeout,51659,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from s",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51698,Safety,timeout,timeout,51698,"sRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; k",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:51751,Safety,timeout,timeout,51751,"bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:23287,Security,access,access,23287,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:23675,Security,access,access,23675,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:23754,Security,access,access,23754,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:24248,Security,access,access,24248,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:24404,Security,access,access,24404,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:24431,Security,access,access,24431,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:31328,Security,access,access,31328,"len); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36686,Security,access,access,36686," gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:26927,Testability,log,logical,26927,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:30356,Testability,log,logical,30356," cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:30797,Testability,log,logical,30797,"eviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead() const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:32373,Testability,log,logical,32373,"st();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of a file sequentially.; For each logical record found, it prints:; Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor. Example of output; 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 2",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35894,Testability,test,test,35894,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:36092,Testability,test,test,36092,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35788,Usability,usab,usable,35788," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:35867,Usability,usab,usable,35867,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFile.html:43255,Usability,clear,clear,43255,"w classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objec",MatchSource.WIKI,root/html530/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFile.html
https://root.cern/root/html530/TFileCacheRead.html:1998,Availability,error,error,1998,"actMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:2082,Availability,error,error,2082,"); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9343,Availability,error,error,9343,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:318,Performance,cache,cache,318,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:476,Performance,cache,cache,476,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:508,Performance,cache,cache,508,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:639,Performance,cache,cache,639,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:8650,Performance,cache,cache,8650,"fPrefetchedBlocksNumber of blocks prefetched.; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base functi",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:8961,Performance,cache,cache,8961,"uffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be pre",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9038,Performance,cache,cache,9038,"ed (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers ",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9367,Performance,cache,cache,9367,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9394,Performance,cache,cache,9394,"e. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9863,Performance,cache,cache,9863,"head = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Long64_t GetPrefetchedBlocks() const; { return fPrefetchedBlocks; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); { fEnablePrefetching = setPrefetching; }. Bool_t IsEnablePrefetchin",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:592,Safety,avoid,avoiding,592,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* err",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheRead.html:9774,Safety,avoid,avoid,9774,"tes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize() const; { return fBufferSize; }. Int_t GetUnzipBuffer(char** , Long64_t , Int_t , Bool_t* ); { return -1; }. Long64_t GetPrefetchedBlocks() const; { return fPrefetchedBlocks; }. Bool_t IsAsyncReading() const; { return fAsyncReading; }. void SetEnablePrefetching(Bool_t setPrefetch",MatchSource.WIKI,root/html530/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html
https://root.cern/root/html530/TFileCacheWrite.html:1883,Availability,error,error,1883,"eWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:1967,Availability,error,error,1967," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6681,Availability,error,error,6681,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:7279,Availability,error,error,7279,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:322,Performance,cache,cache,322,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:480,Performance,cache,cache,480,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:512,Performance,cache,cache,512,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:644,Performance,cache,cache,644,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:753,Performance,cache,cache,753,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6078,Performance,cache,cached,6078,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6187,Performance,cache,cache,6187,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6426,Performance,cache,cache,6426,"evel, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCach",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6476,Performance,cache,cache,6476,"t::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6834,Performance,cache,cache,6834,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6892,Performance,cache,cache,6892,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documenta",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6939,Performance,cache,cache,6939,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:7337,Performance,cache,cache,7337,"Delete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }.  Author: Rene Brun 19/05/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileCacheWrite.h 23122 2008-04-10 14:56:30Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:596,Safety,avoid,avoiding,596,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCacheWrite.html:6117,Safety,avoid,avoid,6117,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html530/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCacheWrite.html
https://root.cern/root/html530/TFileCollection.html:1847,Availability,error,error,1847,"Int_tAdd(const char* path); Int_tAddFromFile(const char* file, Int_t nfiles = -1, Int_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGe",MatchSource.WIKI,root/html530/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCollection.html
https://root.cern/root/html530/TFileCollection.html:1931,Availability,error,error,1931,"t_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGetNStagedFiles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root/html530/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCollection.html
https://root.cern/root/html530/TFileCollection.html:9181,Availability,avail,available,9181,"ented lines) are ignored.; If nfiles > 0 only nfiles files are added, starting from file 'firstfile' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); merge all TFileCollection objects in li into this TFileCollection object. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name o",MatchSource.WIKI,root/html530/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCollection.html
https://root.cern/root/html530/TFileCollection.html:9314,Availability,failure,failure,9314,"specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); merge all TFileCollection objects in li into this TFileCollection object. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name of the first tree in the meta data list.; Returns 0 in case no trees are found in the meta data list. Long64_t GetTotalEntries(const char* tree) const; Returns the number of entries for the specified tree (retrieve",MatchSource.WIKI,root/html530/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCollection.html
https://root.cern/root/html530/TFileCollection.html:9198,Deployability,update,updates,9198,"e' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); merge all TFileCollection objects in li into this TFileCollection object. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines). void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() const; Returns the tree set with SetDefaultTreeName if set; Returns the name of the first tree in the meta data list.; Returns 0 in case no trees are found in the meta data lis",MatchSource.WIKI,root/html530/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileCollection.html
https://root.cern/root/html530/TFileDrawMap.html:3623,Availability,error,error,3623,"(const char* method) const; virtual voidAnimateTree(const char* branches = """")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html530/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileDrawMap.html
https://root.cern/root/html530/TFileDrawMap.html:3707,Availability,error,error,3707," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) ",MatchSource.WIKI,root/html530/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileDrawMap.html
https://root.cern/root/html530/TFileHandler.html:430,Availability,mask,mask,430," TFileHandler(int fd, int mask); virtual~TFileHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal =",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:3749,Availability,error,error,3749,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObje",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:3833,Availability,error,error,3833,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:7405,Availability,mask,mask,7405,"ers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Bool_tReadNotify(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidResetReadyMask(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFd(int fd); virtual voidSetInterest(Int_t mask); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadReady(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWriteReady(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Bool_tWriteNotify().",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9333,Availability,mask,mask,9333,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9413,Availability,mask,mask,9413,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9741,Availability,mask,mask,9741,"der(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void Set",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9791,Availability,mask,mask,9791,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9859,Availability,mask,mask,9859,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9921,Availability,mask,mask,9921,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:10457,Availability,mask,mask,10457,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }.  Author: Fons Rademakers 16/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:10477,Availability,mask,mask,10477,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }.  Author: Fons Rademakers 16/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:10486,Availability,mask,mask,10486,"ess mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }.  Author: Fons Rademakers 16/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TSysEvtHandler.h 21455 2007-12-18 15:44:33Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9819,Energy Efficiency,monitor,monitor,9819,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9880,Energy Efficiency,monitor,monitor,9880,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileHandler.html:9948,Energy Efficiency,monitor,monitor,9948,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html530/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileHandler.html
https://root.cern/root/html530/TFileInfo.html:1555,Availability,error,error,1555," voidTObject::AbstractMethod(const char* method) const; Bool_tAddMetaData(TObject* meta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const;",MatchSource.WIKI,root/html530/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfo.html
https://root.cern/root/html530/TFileInfo.html:1639,Availability,error,error,1639,"eta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() c",MatchSource.WIKI,root/html530/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfo.html
https://root.cern/root/html530/TFileInfo.html:6290,Security,access,access,6290,"arning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileInfo&operator=(const TFileInfo&); voidParseInput(const char* in). Data Members; public:. enum EStatusBits { kStaged; kCorrupted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the",MatchSource.WIKI,root/html530/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfo.html
https://root.cern/root/html530/TFileInfo.html:8121,Security,hash,hashed,8121," file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the entry range. obj:<name>,<class>,<entries>; meta-information about a generic object in the file;; the should be in the form <subdir>/obj-name; 'class'; is the object class; 'entries' is the number of occurences; for this object.; Multiple occurences of 'tree:' or 'obj:' can be specified.; The initializations done via the input string are superseeded by the ones by other; parameters in the constructor, if any.; If no key is given, the token is interpreted as URL(s). void SetUUID(const char* uuid); Set the UUID to the value associated to the string 'uuid'. This is; useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the list; Return kFALSE if not in the list. Bool_t SetCurrentUrl(TUrl* url); Set 'url' as current URL, if i",MatchSource.WIKI,root/html530/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfo.html
https://root.cern/root/html530/TFileInfoMeta.html:1770,Availability,error,error,1770,"st = -1, Long64_t totbytes = -1, Long64_t zipbytes = -1); virtual~TFileInfoMeta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html530/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfoMeta.html
https://root.cern/root/html530/TFileInfoMeta.html:1854,Availability,error,error,1854,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetZipBytes() const; virtual Bool_tTObject::HandleTimer",MatchSource.WIKI,root/html530/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileInfoMeta.html
https://root.cern/root/html530/TFileIter.html:1195,Availability,avail,available,1195," members; data members; class charts. ROOT;  MISC;  TABLE;  TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size-1; (int)readObj >= 0; --readObj); {; nextObject = *readObj;; if (nextObject) {; printf("" Object \""%s\"" of class \",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:10548,Modifiability,config,config,10548,"e that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:10667,Modifiability,config,config,10667,"is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int() const. { return CurrentCursorPosition(); }. int operator==(const char* name) const. { return name ? !strcmp(name,GetK",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:8124,Safety,avoid,avoid,8124,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:9742,Safety,avoid,avoid,9742,"Keys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator is not changed. nSkip > 0; iterator skips nSkip objects in the container.; the direction of the iteration is; sign(nSkip)*kIterForward. Returns: TKey that can be used to fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}.",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:562,Testability,test,tests,562,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:786,Testability,test,test,786,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:1130,Testability,test,test,1130,"hy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:7423,Testability,assert,assert,7423,"_tfRunNumbercurrent ""run number""; Bool_tTListIter::fStartediteration started. private:. TDirectory*fDirectoryBackUp! to save/restore TFile/TDirectory global scope; TFile*fFileBackUp! temporary data-members; TFileIter*fNestedIterator! The inner TFidrectory interator;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileIter(TFile* file = 0); Create iterator over all objects from the TFile provided. TFileIter(TDirectory* directory); Create iterator over all objects from the TDirectory provided. TFileIter(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDi",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:10230,Testability,log,logical,10230,"o fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileIter.html:652,Usability,simpl,simple,652,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MISC;  TABLE;  TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html530/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileIter.html
https://root.cern/root/html530/TFileMergeInfo.html:1368,Availability,down,down,1368,"fo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); TFileMergeInfo(const TFileMergeInfo&); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; TFileMergeInfo&operator=(const TFileMergeInfo&); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }.  Author: Philippe Canal May, 2011  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/proofplayer:$Id: TFileMergeInfo.h 39495 2011-05-31 05:59:31Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMergeInfo.html
https://root.cern/root/html530/TFileMergeInfo.html:379,Security,access,access,379,". TFileMergeInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TFileMergeInfo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); TFileMergeInfo(const TFileMergeInfo&); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; TFileMergeInfo&operator=(const TFileMergeInfo&); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }.  Author: Philippe Canal May, 2011  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/proofplayer:$Id: TFile",MatchSource.WIKI,root/html530/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMergeInfo.html
https://root.cern/root/html530/TFileMerger.html:1795,Availability,error,error,1795,"al~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetMergeList() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasCompressionChange() const; virtual ULong_",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:1879,Availability,error,error,1879,"l_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetMergeList() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasCompressionChange() const; virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* ms",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:7821,Availability,error,error,7821,"ult is kFALSE); TFile*fOutputFilethe outputfile for merging; TStringfOutputFilenamethe name of the outputfile for merging; Int_tfPrintLevelHow much information to print out at run time.; TStopwatchfWatchstop watch to measure file copy speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); Create file merger object. ~TFileMerger(); Cleanup. void Reset(); Reset merger file list. Bool_t AddFile(const char* url, Bool_t cpProgress = kTRUE); Add file to file merger. Bool_t OutputFile(const char* url, Bool_t force, Int_t compressionLevel); Open merger output file. Bool_t OutputFile(const char* url, Bool_t force = kTRUE); Open merger output file. void PrintFiles(Option_t* options); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist); Merge all objects in a directory; NB. This function is a copy of the hadd function MergeROOTFile. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}.  Author: Andreas Peters + Fons Rademakers 26/5/20",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:588,Integrability,interface,interface,588,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* met",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:8512,Integrability,interface,interface,8512,"FileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); Create file merger object. ~TFileMerger(); Cleanup. void Reset(); Reset merger file list. Bool_t AddFile(const char* url, Bool_t cpProgress = kTRUE); Add file to file merger. Bool_t OutputFile(const char* url, Bool_t force, Int_t compressionLevel); Open merger output file. Bool_t OutputFile(const char* url, Bool_t force = kTRUE); Open merger output file. void PrintFiles(Option_t* options); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist); Merge all objects in a directory; NB. This function is a copy of the hadd function MergeROOTFile. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}.  Author: Andreas Peters + Fons Rademakers 26/5/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFileMerger.h 39826 2011-06-20 11:55:08Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:453,Modifiability,plugin,plugins,453,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* met",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:446,Security,access,access,446,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* met",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFileMerger.html:534,Security,access,accessable,534,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* met",MatchSource.WIKI,root/html530/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileMerger.html
https://root.cern/root/html530/TFilePrefetch.html:1585,Availability,error,error,1585," Bool_tBinarySearchReadList(TFPBlock*, Long64_t, Int_t, Int_t*); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); Bool_tCheckCachePath(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidT",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:1669,Availability,error,error,1669,"::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); Bool_tCheckCachePath(const char*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::I",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:6069,Performance,cache,cache,6069," method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static TThread::VoidRtnFunc_tThreadProc(void*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedcondition used to signal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending block to be read; TCondition*fReadBlockAddedcondition usd to signal the addition of a new red block; TList*fReadBlockslist of block read; TSemaphore*fSemsemaphore used to kill the consumer thread; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle o",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:7817,Performance,cache,cache,7817,"uctor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ).  Author: Elvin Sindrilaru 19/05/2011  Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:7892,Performance,cache,cache,7892,"uctor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ).  Author: Elvin Sindrilaru 19/05/2011  Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:7960,Performance,cache,cache,7960,"uctor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ).  Author: Elvin Sindrilaru 19/05/2011  Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:8028,Performance,cache,cache,8028,"uctor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ).  Author: Elvin Sindrilaru 19/05/2011  Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFilePrefetch.html:8091,Performance,cache,cache,8091,"uctor. ~TFilePrefetch(); Destructor. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ).  Author: Elvin Sindrilaru 19/05/2011  Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TFilePrefetch.h 39675 2011-06-10 16:19:12Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFilePrefetch.html
https://root.cern/root/html530/TFileSet.html:2035,Availability,error,error,2035," virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html530/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileSet.html
https://root.cern/root/html530/TFileSet.html:2119,Availability,error,error,2119,"ataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainS",MatchSource.WIKI,root/html530/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileSet.html
https://root.cern/root/html530/TFileStager.html:1659,Availability,error,error,1659,"tager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:1743,Availability,error,error,1743,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tT",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:312,Integrability,interface,interface,312,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:474,Modifiability,plug-in,plug-in,474,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:6808,Modifiability,plugin,plugin,6808,"TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileStager(const char* stager); { }. virtual ~TFileStager(); { }. TList * GetStaged(TCollection* pathlist). Bool_t IsStaged(const char* ). Int_t Locate(const char* u, TString& f). Bool_t Matches(const char* s); { return ((s && (fName == s)) ? kTRUE : kFALSE); }. Bool_t Stage(const char* , Option_t* = 0); { return kTRUE; }. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0). Bool_t IsValid() const; { return kTRUE; }. TString GetPathName(TObject* o); Extract the path name from supported object types. TFileStager * Open(const char* stager); --- Load desired plugin.  Author: A. Peters, G. Ganis 7/2/2007  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/net:$Id: TFileStager.h 23091 2008-04-09 15:04:27Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:455,Performance,load,load,455,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFileStager.html:539,Performance,load,load,539,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html530/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFileStager.html
https://root.cern/root/html530/TFitEditor.html:1420,Availability,error,error,1420,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:1960,Availability,robust,robust,1960,"nd shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw fun",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:2269,Availability,error,errors,2269,"implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; val",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:2412,Availability,error,error,2412,"ed string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desir",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:2522,Availability,error,error,2522,"ent; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages ",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:3745,Availability,avail,available,3745,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:3798,Availability,avail,available,3798,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:4038,Availability,toler,tolerance,4038,"draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignal",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:9266,Availability,error,error,9266,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_t",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:9350,Availability,error,error,9350,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelecte",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:24439,Availability,error,errors,24439,,MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:25205,Availability,robust,robust,25205,"CheckButton*fAdd2FuncListswitch on/off option 'add to list'; TGCheckButton*fAllWeights1switch on/off option 'all weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayout",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:25317,Availability,error,error,25317," weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayou",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:25398,Availability,mask,mask,25398,"estErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayoutHints*fLayoutNonelayout hints of fNone radio button; TGRadioButton*fLibFumiliset",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:28384,Availability,robust,robust,28384,,MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:29409,Availability,toler,tolerance,29409,GLabel*fSelLabelcontains selected fit function; TGTextButton*fSetParamopen set parameters dialog; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGDoubleHSlider*fSliderXslider to set fit range along x-axis; TGNumberEntry*fSliderXMaxentry to set the maximum in the range; TGNumberEntry*fSliderXMinentry to set the minumum in the range; TGHorizontalFrame*fSliderXParentparent of fSliderX; TGDoubleHSlider*fSliderYslider to set fit range along y-axis; TGNumberEntry*fSliderYMaxentry to set the maximum in the range; TGNumberEntry*fSliderYMinentry to set the minumum in the range; TGHorizontalFrame*fSliderYParentparent of fSliderY; TGDoubleHSlider*fSliderZslider to set fit range along z-axis; TGHorizontalFrame*fSliderZParentparent of fSliderZ; TGStatusBar*fStatusBarstatusbar widget; vector<TF1*>fSystemFuncsfunctions managed by the fitpanel; TGTab*fTabtab widget holding the editor; TGCompositeFrame*fTabContainermain tab container; TGNumberEntryField*fTolerancecontains tolerance set for minimization; EObjectTypefTypeobject type info; TGComboBox*fTypeFitcontains the types of functions to be selected; TGTextButton*fUpdateButtonupdates data from gROOT and gDirectory; TGCheckButton*fUseGradientswitch on/off option 'use gradient'; TGCheckButton*fUseRangeswitch on/off option 'use function range'; TGTextButton*fUserButtonopens a dialog for user-defined fit method; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; TAxis*f,MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:34679,Availability,robust,robust,34679,"ted to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable fo",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:392,Integrability,interface,interface,392,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  FITPANEL;  TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:1426,Integrability,message,message,1426,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:1677,Integrability,interface,interface,1677,"ation settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF ",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:33090,Integrability,depend,depending,33090,"eate 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doe",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:33201,Integrability,depend,depending,33201,"nect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:36506,Integrability,depend,depending,36506,"id SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined by text or if it is an existing one. void GetRanges(ROOT::Fit::DataRange& ); Return the ranges selected by the sliders. TList* GetFitObjectListOfFunctions(); Get the list of functions previously used in the fitobject. void GetFunctionsFromSystem(); Looks for all the functions registered in the current ROOT; session. TList* GetListOfFittingFunctions(TObject* obj = 0); This function returns a TList with all the functions used in the; FitPanel to fit a given object. If the object passed is NULL,; then the object used is the currently selected one. It is; important to notice that the FitPanel is still the owner of; those functions. This means that the user SHOULD NOT delete any; of these functions, as the FitPanel will do so in the; destructor. TF1* GetFitFunction(); Get the fit function selected or declared in the fiteditor. TFitEditor(const TFitEditor& ). TFitEditor& operator=(const TFitEditor& ).  Author: Ilka Antcheva, Lorenzo Moneta, David Gon",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:23244,Modifiability,variab,variables,23244,"_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGComboBox*BuildMethodList(TGFrame* parent, Int_t id); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCheckFunctionString(const char* str); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCreateFunctionGroup(); voidCreateGeneralTab(); voidCreateMinimizationTab(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawSelection(bool restore = false); voidFillDataSetList(); TF1*FindFunction(); TF1*GetFitFunction(); TList*GetFitObjectListOfFunctions(); voidGetFunctionsFromSystem(); static Time_tTGFrame::GetLastClick(); TStringTGMainFrame::GetMWMfuncString() const; TStringTGMainFrame::GetMWMinpString() const; TStringTGMainFrame::GetMWMvalueString() const; TStringTGFrame::GetOptionString() const; voidGetRanges(ROOT::Fit::DataRange&); const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TF1*HasFitFunction(); voidMakeTitle(TGCompositeFrame* parent, const char* title); voidTObject::MakeZombie(); voidProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); virtual voidSetCanvas(TCanvas* c); virtual voidSetEditable(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TFitEditor(const TFitEditor&); TFitEditor&operator=(const TFitEditor&); voidRetrieveOptions(Foption_t&, TString&, ROOT::Math::Min",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:34253,Modifiability,variab,variables,34253," Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:320,Performance,perform,perform,320,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  FITPANEL;  TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:4297,Performance,perform,performs,4297,"the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidT",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:35588,Performance,perform,performed,35588,"near fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitEditor.html:32980,Usability,clear,clear,32980,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root/html530/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitEditor.html
https://root.cern/root/html530/TFitParametersDialog.html:4835,Availability,error,error,4835,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:4919,Availability,error,error,4919,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:19249,Availability,error,error,19249,,MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:19827,Availability,mask,mask,19827,,MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:21798,Availability,error,errors,21798,l_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKOK button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGF,MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:8323,Deployability,update,update,8323,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:20242,Deployability,update,updated,20242,"of error values; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContStpcontainer of step values; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:22288,Deployability,update,update,22288,ton*fOKOK button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame:,MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:24931,Deployability,update,update,24931,"ectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods.  Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/fitpanel:$Id: TFitParametersDialog.h 26245 2008-11-17 16:32:49Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitParametersDialog.html:24958,Integrability,depend,dependent,24958,"ectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods.  Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/fitpanel:$Id: TFitParametersDialog.h 26245 2008-11-17 16:32:49Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitParametersDialog.html
https://root.cern/root/html530/TFitResult.html:1742,Availability,error,error,1742,"irtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResult.html:1826,Availability,error,error,1826," char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::FittedFunction() const; voidROOT::Fit::FitResult::GetConfidenceIntervals(const ROO",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResult.html:9904,Availability,error,errors,9904,"of limited parameters; doubleROOT::Fit::FitResult::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym G",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResult.html:10268,Availability,error,errors,10268,"of limited parameters; doubleROOT::Fit::FitResult::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; vector<unsigned int>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym G",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResult.html:10902,Availability,error,errors,10902,"rorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. {}. virtual ~TFitResult(); {}.  Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResult.html:10944,Availability,error,error,10944,"rorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. {}. virtual ~TFitResult(); {}.  Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; ",MatchSource.WIKI,root/html530/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResult.html
https://root.cern/root/html530/TFitResultPtr.html:1341,Testability,assert,assert,1341,"sultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }.  Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *;  Last changed: root/mathcore:$Id: TFitResultPtr.h 31262 2009-11-18 07:38:37Z brun $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResultPtr.html
https://root.cern/root/html530/TFitResultPtr.html:1519,Testability,assert,assert,1519,"sultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }.  Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009  Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *;  Last changed: root/mathcore:$Id: TFitResultPtr.h 31262 2009-11-18 07:38:37Z brun $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitResultPtr.html
https://root.cern/root/html530/TFITSHDU.html:1654,Availability,error,error,1654,"); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() cons",MatchSource.WIKI,root/html530/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFITSHDU.html
https://root.cern/root/html530/TFITSHDU.html:1738,Availability,error,error,1738,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() const; Int_tGetTabNRows() const; TVectorD*GetTabRealVectorCell(Int_t rownum, Int_t colnu",MatchSource.WIKI,root/html530/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFITSHDU.html
https://root.cern/root/html530/TFITSHDU.html:298,Integrability,interface,interface,298,". TFITSHDU. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  FITSIO;  TFITSHDU. class TFITSHDU: public TNamed. FITS file interface class; TFITS is a class that allows extracting images and data from FITS files and contains; several methods to manage them.; . Function Members (Methods); public:. TFITSHDU(const char* filepath_with_filter); TFITSHDU(const TFITSHDU&); TFITSHDU(const char* filepath, Int_t extension_number); TFITSHDU(const char* filepath, const char* extension_name); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html530/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFITSHDU.html
https://root.cern/root/html530/TFITSHDU.html:10959,Integrability,depend,depending,10959,"""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows). TImage * ReadAsImage(Int_t layer = 0, TImagePalette* pal = 0); Read image HDU as a displayable image. Return 0 if conversion cannot be done.; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0). void Draw(Option_t* opt = """"); If the HDU is an image, draw the first layer of the primary array; To set a title to the canvas, pass it in ""opt"". TMatrixD* ReadAsMatrix(Int_t layer = 0, Option_t* opt = """"); Read image HDU as a matrix. Return 0 if conversion cannot be done; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0) in matrix form.; Options (value of 'opt'):; ""S"": stretch pixel values to a range from 0.0 to 1.0. TH1 * ReadAsHistogram(); Read image HDU as a histogram. Return 0 if conversion cannot be done.; The returned object can be TH1D, TH2D or TH3D depending on data dimensionality.; Please, check condition (returnedValue->IsA() == TH*D::Class()) to; determine the object class.; NOTE: do not confuse with image histogram! This function interprets; the array as a histogram. It does not compute the histogram of pixel; values of an image! Here ""pixels"" are interpreted as number of entries. TVectorD* GetArrayRow(UInt_t row); Get a row from the image HDU when it's a 2D array. TVectorD* GetArrayColumn(UInt_t col); Get a column from the image HDU when it's a 2D array. Int_t GetColumnNumber(const char* colname); Get column number given its name. TObjArray* GetTabStringColumn(Int_t colnum); Get a string-typed column from a table HDU given its column index (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const ",MatchSource.WIKI,root/html530/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFITSHDU.html
https://root.cern/root/html530/TFITSHDU.html:13088,Security,access,access,13088,"ndex (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }.  Author: Claudi Martinez, July 19th 2010  Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *;  Last changed: root/graf2d:$Id: TFITS.h 38935 2011-04-19 20:38:15Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFITSHDU.html
https://root.cern/root/html530/TFitter.html:1344,Availability,error,error,1344,"r = 25); virtual~TFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceI",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:1428,Availability,error,error,1428,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:12109,Availability,error,errors,12109," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:12122,Availability,error,errors,12122," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:12360,Availability,error,error,12360,"x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumber",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13032,Availability,error,errors,13032," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13095,Availability,error,error,13095," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13117,Availability,error,error,13117," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13143,Availability,error,error,13143," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13409,Availability,error,error,13409,"al value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) co",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:13769,Availability,error,error,13769," * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Dou",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:15140,Availability,error,error,15140,"ouble_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:15521,Availability,error,error,15521,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:15849,Availability,error,error,15849,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16492,Availability,error,error,16492," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:17081,Availability,error,error,17081,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:14228,Modifiability,variab,variable,14228,"globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for t",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:9580,Performance,cache,cache,9580,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFit",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:15457,Performance,cache,cache,15457,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:15782,Performance,cache,cache,15782,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16428,Performance,cache,cache,16428," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z r",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:17014,Performance,cache,cache,17014,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16249,Safety,predict,predict,16249,"rameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16858,Safety,predict,predict,16858,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:10603,Testability,log,logs,10603,"eNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitter(Int_t maxpar = 25); default constructor*-*-; *-* ===================. ~TFitter(); default destructor*-*-*-; *-* ==================. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* option = """"); reset the fitter environment. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in o",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:14325,Testability,log,log,14325,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:14347,Testability,log,log,14347,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:14874,Testability,log,loglikelihood,14874,"alue for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content,",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16321,Testability,log,logs,16321,"* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitter.html:16930,Testability,log,logs,16930,"ble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}.  Author: Rene Brun 31/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/minuit:$Id: TFitter.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitter.html
https://root.cern/root/html530/TFitterFumili.html:1414,Availability,error,error,1414," TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html530/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterFumili.html
https://root.cern/root/html530/TFitterFumili.html:1498,Availability,error,error,1498," TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html530/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterFumili.html
https://root.cern/root/html530/TFitterFumili.html:11931,Integrability,interface,interface,11931,"tringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN().  Author: L. Moneta 10/2005  Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/minuit2:$Id: TFitterFumili.h 22730 2008-03-19 10:22:46Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterFumili.html
https://root.cern/root/html530/TFitterFumili.html:11921,Modifiability,inherit,inherited,11921,"tringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN().  Author: L. Moneta 10/2005  Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/minuit2:$Id: TFitterFumili.h 22730 2008-03-19 10:22:46Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterFumili.html
https://root.cern/root/html530/TFitterFumili.html:10833,Performance,cache,cache,10833,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMini",MatchSource.WIKI,root/html530/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterFumili.html
https://root.cern/root/html530/TFitterMinuit.html:1470,Availability,error,error,1470,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:1554,Availability,error,error,1554,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:13643,Availability,toler,tolerance,13643,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize().  Author: L. Moneta 10/2005  Copyright (c) 2005 RO",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:13701,Availability,toler,tolerances,13701,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize().  Author: L. Moneta 10/2005  Copyright (c) 2005 RO",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:14574,Availability,error,error,14574,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize().  Author: L. Moneta 10/2005  Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:11704,Integrability,interface,interface,11704," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:13058,Integrability,interface,interface,13058,"nst; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. voi",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:11694,Modifiability,inherit,inherited,11694," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:10274,Performance,cache,cache,10274,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:14344,Performance,perform,perform,14344,"nctions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize().  Author: L. Moneta 10/2005  Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/minuit2:$Id: TFitterMinuit.h 20880 2007-11-19 11:23:41Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFitterMinuit.html:13656,Safety,avoid,avoid,13656,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize().  Author: L. Moneta 10/2005  Copyright (c) 2005 RO",MatchSource.WIKI,root/html530/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFitterMinuit.html
https://root.cern/root/html530/TFoam.html:5966,Availability,error,error,5966," = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCarver(Int_t&, Double_t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:6050,Availability,error,error,6050,"t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPrimary() ",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:12214,Availability,error,error,12214,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:20880,Availability,avail,available,20880,"-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t ,",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:23056,Availability,failure,failures,23056,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:23097,Availability,failure,failures,23097,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:813,Deployability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:1042,Deployability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:1257,Deployability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:3500,Deployability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:11784,Deployability,integrat,integration,11784,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:17193,Deployability,update,updated,17193,"alization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Inte",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:18565,Deployability,update,updated,18565,"t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used by Initialize.; It finds out number of active cells fNoAct,; creates list of active cell fCellsAct and primary cumulative fPrimAcu.; They are used during the MC generation to choose randomly an active cell. void ResetPseRan(TRandom* PseRan); User may optionally reset random number generator using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing random number generator registered in the FOAM object.; In particular such an object is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distr",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:829,Energy Efficiency,efficient,efficient,829,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:840,Energy Efficiency,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:3561,Energy Efficiency,allocate,allocated,3561,"mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distribution, while using OptRej=0. Past versions of FOAM: August 2003, v.",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:14942,Energy Efficiency,allocate,allocated,14942,"ector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(const Char_t* ); User constructor, to be employed by the user. ~TFoam(); Default destructor; cout<<"" DESTRUCTOR entered ""<<endl;. TFoam(const TFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure E",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:15409,Energy Efficiency,allocate,allocated,15409,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:16592,Energy Efficiency,allocate,allocated,16592,"edu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the M",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:813,Integrability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:1042,Integrability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:1257,Integrability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:3500,Integrability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:11784,Integrability,integrat,integration,11784,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:17311,Integrability,rout,routine,17311,"tion object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the pur",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:774,Modifiability,variab,variable,774,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:840,Modifiability,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:20979,Modifiability,variab,variable,20979,"ribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; R",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:22334,Modifiability,variab,variables,22334,"program which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable f",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:22457,Modifiability,variab,variable,22457,"ovides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom *",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:22695,Modifiability,variab,variable,22695,"ORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCell",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:13078,Performance,optimiz,optimization,13078,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWt; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMax; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(con",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:15369,Performance,perform,performs,15369,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:15632,Performance,optimiz,optimization,15632,"itialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Ini",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:17832,Performance,optimiz,optimization,17832,"rue and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used b",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:15899,Security,access,access,15899,"ializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average ",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:952,Usability,simpl,simplified,952,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoam.html:20275,Usability,simpl,simple,20275,"ject is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set (register) random number generator used by; the given instance of the FOAM event generator. Note that single r.n. generator; may serve several FOAM objects. void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distribution using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing distribution object registered in the FOAM object.; In particular such an object is created by the streamer diring the disk-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(",MatchSource.WIKI,root/html530/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoam.html
https://root.cern/root/html530/TFoamCell.html:1578,Availability,error,error,1578,"l(); TFoamCell(Int_t); TFoamCell(TFoamCell&); virtual~TFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGet",MatchSource.WIKI,root/html530/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamCell.html
https://root.cern/root/html530/TFoamCell.html:1662,Availability,error,error,1662,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGetSerial() const; Int_tGetStat() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html530/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamCell.html
https://root.cern/root/html530/TFoamCell.html:6929,Energy Efficiency,allocate,allocated,6929,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. Double_t GetPrim() ",MatchSource.WIKI,root/html530/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamCell.html
https://root.cern/root/html530/TFoamCell.html:6723,Testability,test,tested,6723,"lic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double",MatchSource.WIKI,root/html530/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamCell.html
https://root.cern/root/html530/TFoamIntegrand.html:437,Availability,avail,available,437,". TFoamIntegrand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoamIntegrand. class TFoamIntegrand: public TObject. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html530/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamIntegrand.html
https://root.cern/root/html530/TFoamIntegrand.html:1457,Availability,error,error,1457," virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html530/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamIntegrand.html
https://root.cern/root/html530/TFoamIntegrand.html:1541,Availability,error,error,1541," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamIntegrand.html
https://root.cern/root/html530/TFoamMaxwt.html:1675,Availability,error,error,1675,"(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html530/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamMaxwt.html
https://root.cern/root/html530/TFoamMaxwt.html:1759,Availability,error,error,1759," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_t",MatchSource.WIKI,root/html530/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamMaxwt.html
https://root.cern/root/html530/TFoamMaxwt.html:6271,Availability,toler,tolerance,6271,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run.  Last changed: root/foam:$Id: TFoamMaxwt.h 22726 2008-03-19 09:53:41Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamMaxwt.html
https://root.cern/root/html530/TFoamMaxwt.html:6435,Availability,toler,tolerance,6435,"; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run.  Last changed: root/foam:$Id: TFoamMaxwt.h 22726 2008-03-19 09:53:41Z pcanal $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamMaxwt.html
https://root.cern/root/html530/TFoamMaxwt.html:412,Integrability,depend,depending,412,". TFoamMaxwt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoamMaxwt. class TFoamMaxwt: public TObject. Class TFoamMaxwt. Small auxiliary class for controlling MC weight.; It provides certain measure of the ""maximum weight""; depending on small user-parameter ""epsilon"".; It creates and uses 2 histograms of the TH1D class.; User defines no. of bins nBin, nBin=1000 is recommended; wmax defines weight range (1,wmax), it is adjusted ""manually"". Function Members (Methods); public:. TFoamMaxwt(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual",MatchSource.WIKI,root/html530/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamMaxwt.html
https://root.cern/root/html530/TFoamSampler.html:1314,Availability,error,error,1314," charts. ROOT;  MATH;  FOAM;  TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:1434,Availability,error,errors,1434," charts. ROOT;  MATH;  FOAM;  TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:3175,Availability,error,error,3175,"etRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfOneDimflag to indicate if the function is 1 dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case).  Author: L. Moneta Fri Sep 22 15:06:47 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id: TFoamSampler.h 37419 2010-12-08 21:19:45Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:380,Integrability,interface,interface,380,". TFoamSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FOAM;  TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:2284,Integrability,interface,interface,2284,"ror = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer; boolfOneDimflag to indicate if the function is 1 dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunctio",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:760,Modifiability,extend,extend,760," charts. ROOT;  MATH;  FOAM;  TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamSampler.html:901,Modifiability,extend,extend,901," charts. ROOT;  MATH;  FOAM;  TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html530/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamSampler.html
https://root.cern/root/html530/TFoamVect.html:1446,Availability,error,error,1446," TFoamVect(); TFoamVect(Int_t); TFoamVect(const TFoamVect&); virtual~TFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virt",MatchSource.WIKI,root/html530/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamVect.html
https://root.cern/root/html530/TFoamVect.html:1530,Availability,error,error,1530," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inh",MatchSource.WIKI,root/html530/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamVect.html
https://root.cern/root/html530/TFoamVect.html:6059,Security,access,access,6059,"Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension; TFoamVect*fNextpointer for tree construction; TFoamVect*fPrevpointer for tree construction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""cout"". void PrintList(void); Printout of all member vectors in the list starting from ""this"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}.  Last changed: root/foam:$Id: TFoamVect.h 20882 20",MatchSource.WIKI,root/html530/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFoamVect.html
https://root.cern/root/html530/TFolder.html:4519,Availability,error,error,4519,"idTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:4603,Availability,error,error,4603,"TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:944,Energy Efficiency,efficient,efficient,944,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:1032,Modifiability,coupling,coupling,1032,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a fold",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:3337,Modifiability,variab,variable,3337,"xample, the following folders exist:; //root/Files with the list of currently connected Root files; //root/Classes with the list of active classes; //root/Geometries with active geometries; //root/Canvases with the list of active canvases; //root/Styles with the list of graphics styles; //root/Colors with the list of active colors. For example, if a file ""myFile.root"" is added to the list of files, one can; retrieve a pointer to the corresponding TFile object with a statement like:; TFile *myFile = (TFile*)gROOT->FindObject(""//root/Files/myFile.root"");; The above statement can be abbreviated to:; TFile *myFile = (TFile*)gROOT->FindObject(""/Files/myFile.root"");; or even to:; TFile *myFile = (TFile*)gROOT->FindObjectAny(""myFile.root"");; In this last case, the TROOT::FindObjectAny function will scan the folder hierarchy; starting at //root and will return the first object named ""myFile.root"". Because a string-based search mechanism is expensive, it is recommended; to save the pointer to the object as a class member or local variable; if this pointer is used frequently or inside loops. /*. */. Function Members (Methods); public:. TFolder(); TFolder(const char* name, const char* title); virtual~TFolder(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:716,Security,access,access,716,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFolder.html:1326,Security,access,access,1326,"ders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a folder does not own its contained objects.; NOTE that folder ownership can be set; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. Standard Root objects are automatically added to the folder hierarchy.; For example, the following folders exi",MatchSource.WIKI,root/html530/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFolder.html
https://root.cern/root/html530/TFormula.html:5484,Availability,error,error,5484,"Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tCompile(const char* expression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:5568,Availability,error,error,5568,"ression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char* name) const; virtual Double_t*GetParameters() const; virtual voidGetParameters(Dou",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:15890,Availability,error,errors,15890, 0); Analyze a sub-expression in one formula*-*-; *-* =======================================; -; *-* Expressions in one formula are recursively analyzed.; *-* Result of analysis is stored in the object tables.; -; *-* Table of function codes and errors; *-* ==================================; -; *-* * functions :; -; *-* + 1 pow 20; *-* - 2 sq 21; *-* * 3 sqrt 22; *-* / 4 strstr 23; *-* % 5 min 24; *-* max 25; *-* log 30; *-* cos 10 exp 31; *-* sin 11 log10 32; *-* tan 12; *-* acos 13 abs 41; *-* asin 14 sign 42; *-* atan 15 int 43; *-* atan2 16; *-* fmod 17 rndm 50; -; *-* cosh 70 acosh 73; *-* sinh 71 asinh 74; *-* tanh 72 atanh 75; -; *-* expo 100 gaus 110 gausn (see note below); *-* expo(0) 100 0 gaus(0) 110 0 gausn(0); *-* expo(1) 100 1 gaus(1) 110 1 gausn(1); *-* xexpo 100 x xgaus 110 x xgausn; *-* yexpo 101 x ygaus 111 x ygausn; *-* zexpo 102 x zgaus 112 x zgausn; *-* xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special,MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:19051,Availability,error,errors,19051,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:2915,Deployability,update,updated,2915,"t to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware;",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:27146,Integrability,depend,depend,27146,"s is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter*-*-*-*-*-*-*-*-; *-* ============================. Int_t GetParNumber(const char* name) const; return parameter number by name. Bool_t IsString(Int_t oper) const; return true if the expression at the index 'oper' is to be treated as; as string. void Print(Option_t* option = ",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:2810,Modifiability,inherit,inheriting,2810,"t to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware;",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:4748,Modifiability,variab,variable,4748,,MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:13826,Modifiability,variab,variables,13826,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:17497,Modifiability,variab,variables,17497," xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special cases for normalized gaussian or landau distributions; *-* =============================================================; *-* the expression ""gaus"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2); *-* to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; *-* the expression ""gausn"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); *-* WARNING: gaus and gausn are mutually exclusive in the same expression.; -; *-* In the same way the expression ""landau"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kFALSE); *-* to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; *-* the expression ""landaun"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kTRUE); *-* WARNING: landau and landaun are mutually exclusive in the same expression.; -; *-* boolean optimization (kBoolOptmize) :; *-* ===================",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:19902,Modifiability,variab,variable,19902,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:24791,Modifiability,variab,variable,24791,"e,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:24865,Modifiability,variab,variables,24865,"e,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:26017,Modifiability,variab,variables,26017,"function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* inst",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:26391,Modifiability,variab,variables,26391,"ructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:26748,Modifiability,variab,variables,26748,"has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parNam",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:26850,Modifiability,variab,variables,26850,"has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal TFormula member variables; *-* =======================================; -; *-* This function uses the internal member variables of TFormula to; *-* construct the mathematical expression associated with the TFormula; *-* instance. This function can be used to get an expanded version of the; *-* expression originally assigned to the TFormula instance, i.e. that; *-* the string returned by GetExpFormula() doesn't depend on other; *-* TFormula object names.; -; *-* if option contains ""p"" the returned string will contain the formula; *-* expression with symbolic parameters, eg [0] replaced by the actual value; *-* of the parameter. Example:; *-* if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; *-* and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; *-* ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; return value of parameter number ipar. Double_t GetParameter(const char* name) const; return value of parameter named parNam",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:30335,Modifiability,variab,variables,30335,"nst char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10""); Set up to 10 parameter names*-*-*-*-*-; *-* ============================. void Streamer(TBuffer& b); Stream a class object*-*-*-*-*-*-*-; *-* =========================================. void Convert(UInt_t fromVersion); Convert the fOper of a TFormula version fromVersion to the current in memory version. void MakePrimitive(const char* expr, Int_t pos). MakePrimitive; find TFormulaPrimitive replacement for some operands. void Optimize(). MI include. Optimize formula; 1.) Minimize the number of operands; a.) several operanands are glued togther; b.) some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); c.) maximize number of standard calls minimizing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is choosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Do",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:31253,Modifiability,variab,variable,31253,"zing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is choosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from t",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:32117,Modifiability,variab,variables,32117,":TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*; ; */. -; -; -. Int_t PreCompile(). Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:2532,Performance,perform,performance,2532,"ned names can be given. For example, if the formula; *-* TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a freq",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:3077,Performance,perform,performant,3077," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:13070,Performance,cache,cache,13070,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:13441,Performance,optimiz,optimization,13441,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor*-*-*-; *-* ============================. TFormula(const cha",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:18478,Performance,optimiz,optimization,18478,"144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special cases for normalized gaussian or landau distributions; *-* =============================================================; *-* the expression ""gaus"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2); *-* to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; *-* the expression ""gausn"" is a substitute for; *-* [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); *-* WARNING: gaus and gausn are mutually exclusive in the same expression.; -; *-* In the same way the expression ""landau"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kFALSE); *-* to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; *-* the expression ""landaun"" is a substitute for; *-* [0]*TMath::Landau(x,[1],[2],kTRUE); *-* WARNING: landau and landaun are mutually exclusive in the same expression.; -; *-* boolean optimization (kBoolOptmize) :; *-* =====================================; -; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial ",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:32952,Performance,perform,performance,32952,"imitive2(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params). Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*; ; */. -; -; -. Int_t PreCompile(). Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code) const; { return fOper[code] >> kTFOperShift; }. Int_t GetActionParam(Int_t code) const; { return fOper[code] & kTFOperMask; }. void SetAction(Int_t code, Int_t value, Int_t param = 0). Int_t * GetOperOptimized() const; { return fOperOptimized; }. Short_t GetActionOptimized(Int_t code) const; { return fOperOptimized[code] >> kTFOperShift; }. Int_t GetActionParamOptimized(Int_t code) const; { return fOperOptimized[code] & kTFOperMask; }. void SetActionOptimized(Int_t code, Int_t value, Int_t param = 0). Double_t EvalPar(const Double_t* x, const Double_t* params = 0); {return ((*this).*fOptimal)(x,params);}. Int_t GetN",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:3008,Security,access,access,3008," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:3088,Security,access,access,3088," and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompiling this class) to know about all possible user defined data types.; *-* This also apply to the case of a static class function.; *-* Because TMath is a special and frequent case, TFormula is aware; *-* of all TMath functions.; -; -. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:19939,Security,access,accessible,19939,"; *-* Those pseudo operation are used to implement lazy evaluation of; *-* && and ||. When the left hand of the expression if false; *-* (respectively true), the evaluation of the right is entirely skipped; *-* (since it would not change the value of the expreession).; -; *-* && 142 11 (one operation on right) 142 21 (2 operations on right); *-* || 142 12 (one operation on right) 142 22 (2 operations on right); -; *-* * functions calls (kFunctionCall) :; -; *-* f0 145 0 f1 145 1 etc..; -; *-* errors :; *-* ========; -; *-* 1 : Division By Zero; *-* 2 : Invalid Floating Point Operation; *-* 4 : Empty String; *-* 5 : invalid syntax; *-* 6 : Too many operators; *-* 7 : Too many parameters; *-* 10 : z specified but not x and y; *-* 11 : z and y specified but not x; *-* 12 : y specified but not x; *-* 13 : z and x specified but not y; *-* 20 : non integer value for parameter number; *-* 21 : atan2 requires two arguments; *-* 22 : pow requires two arguments; *-* 23 : degree of polynomial not specified; *-* 24 : Degree of polynomial must be positive; *-* 25 : Degree of polynomial must be less than 20; *-* 26 : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* I",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:2068,Testability,log,logic,2068,"; *-* expo(3) is a substitute for exp([3]+[4]*x); *-* pol3(5) is a substitute for par[5]+par[6]*x+par[7]*x**2+par[8]*x**3; *-* (here Pol3 stands for Polynomial of degree 3); -; *-* TMath functions can be part of the expression, eg:; *-* - TMath::Landau(x)*sin(x); *-* - TMath::Erf(x); -; *-* Comparisons operators are also supported (&&, ||, ==, <=, >=, !); *-* Examples:; *-* sin(x*(x<0.5 || x>1)); *-* If the result of a comparison is TRUE, the result is 1, otherwise 0.; -; *-* Already predefined names can be given. For example, if the formula; *-* TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* ",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:16062,Testability,log,log,16062, 0); Analyze a sub-expression in one formula*-*-; *-* =======================================; -; *-* Expressions in one formula are recursively analyzed.; *-* Result of analysis is stored in the object tables.; -; *-* Table of function codes and errors; *-* ==================================; -; *-* * functions :; -; *-* + 1 pow 20; *-* - 2 sq 21; *-* * 3 sqrt 22; *-* / 4 strstr 23; *-* % 5 min 24; *-* max 25; *-* log 30; *-* cos 10 exp 31; *-* sin 11 log10 32; *-* tan 12; *-* acos 13 abs 41; *-* asin 14 sign 42; *-* atan 15 int 43; *-* atan2 16; *-* fmod 17 rndm 50; -; *-* cosh 70 acosh 73; *-* sinh 71 asinh 74; *-* tanh 72 atanh 75; -; *-* expo 100 gaus 110 gausn (see note below); *-* expo(0) 100 0 gaus(0) 110 0 gausn(0); *-* expo(1) 100 1 gaus(1) 110 1 gausn(1); *-* xexpo 100 x xgaus 110 x xgausn; *-* yexpo 101 x ygaus 111 x ygausn; *-* zexpo 102 x zgaus 112 x zgausn; *-* xyexpo 105 x xygaus 115 x xygausn; *-* yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); *-* xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); -; *-* landau 120 x landaun (see note below); *-* landau(0) 120 0 landaun(0); *-* landau(1) 120 1 landaun(1); *-* xlandau 120 x xlandaun; *-* ylandau 121 x ylandaun; *-* zlandau 122 x zlandaun; *-* xylandau 125 x xylandaun; *-* ylandau(5) 121 5 ylandaun(5); *-* xylandau(2) 125 2 xylandaun(2); -; *-* pol0 130 x pol1 130 1xx; *-* pol0(0) 130 0 pol1(0) 130 100; *-* pol0(1) 130 1 pol1(1) 130 101; *-* xpol0 130 x xpol1 130 101; *-* ypol0 131 x ypol1 131 101; *-* zpol0 132 x zpol1 132 1xx; *-* ypol0(5) 131 5 ypol1(5) 131 105; -; *-* pi 40; -; *-* && 60 < 64; *-* || 61 > 65; *-* == 62 <= 66; *-* != 63 => 67; *-* ! 68; *-* ==(string) 76 & 78; *-* !=(string) 77 | 79; *-* <<(shift) 80 >>(shift) 81; *_* ? : 82; -; *-* * constants (kConstants) :; -; *-* c0 141 1 c1 141 2 etc..; -; *-* * strings (kStringConst):; -; *-* sX 143 x; -; *-* * variables (kFormulaVar) :; -; *-* x 144 0 y 144 1 z 144 2 t 144 3; -; *-* * parameters :; -; *-* [1] 140 1; *-* [2] 140 2; *-* etc.; -; *-* special,MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:2610,Usability,simpl,simple,2610," to the formula. By default; *-* the name of the object = title = formula itself.; *-* old.SetName(""old"").; *-* then, old can be reused in a new expression.; *-* TFormula new(""x*old"") is equivalent to:; *-* TFormula new(""x*sin(x*(x<0.5 || x>1))""); -; *-* Up to 4 dimensions are supported (indicated by x, y, z, t); *-* An expression may have 0 parameters or a list of parameters; *-* indicated by the sequence [par_number]; -; *-* A graph showing the logic to compile and analyze a formula; *-* is shown in TFormula::Compile and TFormula::Analyze.; *-* Once a formula has been compiled, it can be evaluated for a given; *-* set of parameters. see graph in TFormula::EvalPar.; -; *-* This class is the base class for the function classes TF1,TF2 and TF3.; *-* It is also used by the ntuple selection mechanism TNtupleFormula.; -; *-* In version 7 of TFormula, the usage of fOper has been changed; *-* to improve the performance of TFormula::EvalPar.; *-* Conceptually, fOper was changed from a simple array of Int_t; *-* to an array of composite values.; *-* For example a 'ylandau(5)' operation used to be encoded as 4105;; *-* it is now encoded as (klandau >> kTFOperShit) + 5; *-* Any class inheriting from TFormula and using directly fOper (which; *-* is now a private data member), needs to be updated to take this; *-* in consideration. The member functions recommended to set and; *-* access fOper are: SetAction, GetAction, GetActionParam; *-* For more performant access to the information, see the implementation; *-* TFormula::EvalPar; -; *-* CHANGING DEFAULT SETTINGS; *-* =========================; *-* When creating complex formula , it may be necessary to increase; *-* some default parameters. see static function TFormula::SetMaxima; -; *-* WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; *-* ====================================================; *-* This is a frequently asked question.; *-* C++ is a strongly typed language. There is no way for TFormula (without; *-* recompili",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:20221,Usability,simpl,simple,20221," : Unknown name; *-* 27 : Too many constants in expression; *-* 28 : strstr requires two arguments; *-* 29 : interpreted or compiled function have to return a numerical type; *-* 30 : Bad numerical expression; *-* 31 : Part of the variable exist but some of it is not accessible or useable; *-* 40 : '(' is expected; *-* 41 : ')' is expected; *-* 42 : '[' is expected; *-* 43 : ']' is expected. /*. */. -; *-* Special functions; *-* -----------------; *-* By default, the formula is assigned fNumber=0. However, the following; *-* formula built with simple functions are assigned fNumber:; *-* ""gaus"" 100 (or gausn); *-* ""xygaus"" 110; *-* ""expo"" 200; *-* ""polN"" 300+N; *-* ""landau"" 400; *-* ""xylandau"" 410; *-* Note that expressions like gaus(0), expo(1) will force fNumber=0; -; *-* Warning when deriving a class from TFormula; *-* -------------------------------------------; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; -. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are compatible with the operation at 'oper'. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void Clear(Option_t* option = """"); Resets the objects*-*-; *-* ==",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormula.html:25719,Usability,usab,usable,25719,"-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if expression is in the list of defined variables; *-* =======================================================; -; *-* This member function can be overloaded in derived classes; -; *-* If you overload this member function, you also HAVE TO; *-* never call the constructor:; -; *-* TFormula::TFormula(const char *name,const char *expression); -; *-* and write your own constructor; -; *-* MyClass::MyClass(const char *name,const char *expression) : TFormula(); -; *-* which has to call the TFormula default constructor and whose implementation; *-* should be similar to the implementation of the normal TFormula constructor; -; *-* This is necessary because the normal TFormula constructor call indirectly; *-* the virtual member functions Analyze, DefaultString, DefaultValue; *-* and DefaultVariable.; -; *-* The expected returns values are; *-* -2 : the name has been recognized but won't be usable; *-* -1 : the name has not been recognized; *-* >=0 : the name has been recognized, return the action parameter.; -; -. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through x, y, z and t.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams; -; -. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula*-*-*-*-*-*-; *-* =====================; -; *-* The current value of variables x,y,z,t is passed through the pointer x.; *-* The parameters used will be the ones in the array params if params is given; *-* otherwise parameters will be taken from the stored data members fParams. /*. */. -; -; -. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from*-*-; *-* the internal ",MatchSource.WIKI,root/html530/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormula.html
https://root.cern/root/html530/TFormulaPrimitive.html:2571,Availability,error,error,2571,"FormulaPrimitive* formula); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html530/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormulaPrimitive.html
https://root.cern/root/html530/TFormulaPrimitive.html:2655,Availability,error,error,2655,"irtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULon",MatchSource.WIKI,root/html530/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFormulaPrimitive.html
https://root.cern/root/html530/TFPBlock.html:1565,Availability,error,error,1565," TFPBlock(const TFPBlock&); TFPBlock(Long64_t*, Int_t*, Int_t); virtual~TFPBlock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root/html530/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFPBlock.html
https://root.cern/root/html530/TFPBlock.html:1649,Availability,error,error,1649," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFullSize() const; virtual const char*TObject::GetIconName() const; Int_t*GetLen() const; Int_tGetLen(Int_t) const; virtual const char*TObject::GetName() const; Int_tGetNoElem() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_t*GetPos() const; Long64_tGetPos(Int_t) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html530/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFPBlock.html
https://root.cern/root/html530/TFractionFitter.html:4476,Availability,error,errors,4476,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:4543,Availability,error,error,4543,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:5370,Availability,error,error,5370," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:6554,Availability,error,error,6554,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:6638,Availability,error,error,6638,"ual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:7472,Availability,error,error,7472,"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIncludeBin(Int_t bin); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator dele",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:13499,Availability,error,error,13499," TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetR",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:13799,Availability,error,error,13799,"aration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; h",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:14178,Availability,error,error,14178," verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:14488,Availability,error,error,14488,"revious fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y bin number; high: upper Y bin number. void ReleaseRangeY(); Release restrictions on the Y range of the histogram to be used in the fit. void SetRangeZ(Int_t low, Int_t high); Set",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:16886,Availability,error,error,16886,"de the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:17165,Availability,error,error,17165," the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare(",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:13108,Integrability,message,message,13108,"ension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:1822,Performance,perform,perform,1822,"ters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }. Assumptions. A few assumptions need to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; temp",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:11574,Performance,perform,performed,11574," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:16686,Performance,perform,performed,16686,"bin number. void ReleaseRangeZ(); Release restrictions on the Z range of the histogram to be used in the fit. void ExcludeBin(Int_t bin); Exclude the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& mi",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:17081,Performance,perform,perform,17081,"ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:698,Safety,predict,predictions,698,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""sam",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:4609,Safety,predict,prediction,4609,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:11327,Safety,predict,predictions,11327," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:12319,Safety,predict,predictions,12319," double& Aki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:17329,Safety,predict,prediction,17329,"e input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambd",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:18144,Safety,predict,prediction,18144,"INOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the num",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:19659,Safety,predict,prediction,19659,"pute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221, ; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1.  Last changed: root/hist:$Id: TFractionFitter.h 38775 2011-04-08 08:27:27Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:3283,Security,access,access,3283,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by speci",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:14252,Security,access,access,14252,"); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y ",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:3163,Usability,simpl,simplify,3163,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:4649,Usability,simpl,simple,4649,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFractionFitter.html:17550,Usability,simpl,simply,17550,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double* fractions, double& Ti, int& k0, double& Aki) const; Function used internally to obtain the template prediction in the individual bins. Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> de",MatchSource.WIKI,root/html530/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFractionFitter.html
https://root.cern/root/html530/TFrame.html:1710,Availability,error,error,1710,"voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html530/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrame.html
https://root.cern/root/html530/TFrame.html:1794,Availability,error,error,1794,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::G",MatchSource.WIKI,root/html530/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrame.html
https://root.cern/root/html530/TFrame.html:7671,Availability,down,down,7671,"CurrentStyle()MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TBox::[unnamed] { kCannotMove; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Short_tTWbox::fBorderModeBordermode (-1=down, 0 = no border, 1=up); Short_tTWbox::fBorderSizewindow box bordersize in pixels; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tTBox::fResizing!True if box is being resized; Double_tTBox::fX1X of 1st point; Double_tTBox::fX2X of 2nd point; Double_tTBox::fY1Y of 1st point; Double_tTBox::fY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFrame(); Frame default constructor. TFrame(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Frame normal constructor. TFrame(const TFrame& frame); Frame copy constructor. ~TFrame(); Frame default destructor. void Copy(TObject& frame) const; Copy this frame to frame. void Draw(Option_t* option = """"); Draw this frame with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TFrame object is clicked. void Paint(Option_t* option = """"); Paint this wbox with its current attributes. void Pop(); Do not pop frame's, if allowed they would cover t",MatchSource.WIKI,root/html530/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrame.html
https://root.cern/root/html530/TFrameEditor.html:4655,Availability,error,error,4655,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrameEditor.html
https://root.cern/root/html530/TFrameEditor.html:4739,Availability,error,error,4739,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrameEditor.html
https://root.cern/root/html530/TFrameEditor.html:17766,Availability,mask,mask,17766,,MatchSource.WIKI,root/html530/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFrameEditor.html
https://root.cern/root/html530/TFree.html:2009,Availability,error,error,2009," last); virtual~TFree(); voidTObject::AbstractMethod(const char* method) const; TFree*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const",MatchSource.WIKI,root/html530/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFree.html
https://root.cern/root/html530/TFree.html:2093,Availability,error,error,2093,"e*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html530/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFree.html
https://root.cern/root/html530/TFriendElement.html:1918,Availability,error,error,1918,"s); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html530/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFriendElement.html
https://root.cern/root/html530/TFriendElement.html:2002,Availability,error,error,2002," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, co",MatchSource.WIKI,root/html530/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFriendElement.html
https://root.cern/root/html530/TFriendElement.html:468,Modifiability,variab,variable,468,". TFriendElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TFriendElement. class TFriendElement: public TNamed. TFriendElement. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. To add a TFriendElement to an existing TTree T, do:; T.AddFriend(""friendTreename"",""friendTreeFile"");. See TTree::AddFriend for more information. Function Members (Methods); public:. TFriendElement(); TFriendElement(TTree* tree, const char* treename, const char* filename); TFriendElement(TTree* tree, const char* treename, TFile* file); TFriendElement(TTree* tree, TTree* friendtree, const char* alias); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html530/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFriendElement.html
https://root.cern/root/html530/TFTP.html:1969,Availability,error,error,1969,"ectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t p",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:2053,Availability,error,error,2053,"onst; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Long64_tGetRestartAt() const; TSocket*GetSocket() const; virtual con",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8641,Availability,error,error,8641,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8667,Availability,error,error,8667,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8806,Availability,error,error,8806,"d Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of f",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9106,Availability,error,error,9106,":port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you ar",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9149,Availability,error,error,9149,"will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can forc",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9197,Availability,failure,failure,9197,"is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(con",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9728,Availability,error,error,9728," EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote dire",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9771,Availability,error,error,9771,"essage kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in c",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:9819,Availability,failure,failure,9819,"and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = ",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10376,Availability,echo,echoed,10376," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10437,Availability,failure,failure,10437,"otd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Re",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10630,Availability,failure,failure,10630," file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permission",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10804,Availability,failure,failure,10804,"nection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10999,Availability,failure,failure,10999,"esired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remot",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11124,Availability,failure,failure,11124," the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in ca",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11303,Availability,failure,failure,11303,"e remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a File",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11462,Availability,failure,failure,11462,"ure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, ",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11661,Availability,failure,failure,11661,"nt_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, biza",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11755,Availability,failure,failure,11755,"t delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:11917,Availability,error,error,11917,"e options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetResta",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:12138,Availability,error,error,12138," cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii)",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8925,Energy Efficiency,power,power,8925,"el = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() i",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:348,Integrability,protocol,protocol,348,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:7467,Integrability,protocol,protocol,7467,"Zombie(). private:. TFTP(); TFTP(const TFTP&); voidInit(const char* url, Int_t parallel, Int_t wsize); voidoperator=(const TFTP&); voidPrintError(const char* where, Int_t err) const; Int_tRecv(Int_t& status, EMessageTypes& kind) const; voidSetMode(Int_t mode). Data Members; public:. enum { kDfltBlockSize; kDfltWindowSize; kBinary; kAscii; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBlockSizesize of data buffer used to transfer; Long64_tfBytesReadnumber of bytes received; Long64_tfBytesWritenumber of bytes sent; TStringfCurrentFilefile currently being get or put; Bool_tfDirIndicates if a remote directory is open; TStringfHostFQDN of remote host; Int_tfLastBlocklast block successfully transfered; Int_tfModebinary or ascii file transfer mode; Int_tfParallelnumber of parallel sockets; Int_tfPortport to which to connect; Int_tfProtocolrootd protocol level; Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t ",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8476,Integrability,message,message,8476," Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; ",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8654,Integrability,depend,depending,8654,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:8769,Integrability,message,message,8769,"tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of er",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:10313,Integrability,message,message,10313," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:322,Performance,perform,performant,322,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:444,Performance,perform,performance,444,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:12524,Security,access,access,12524,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:12558,Security,access,access,12558,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFTP.html:12605,Security,access,access,12605,"ge permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir); }. void rmdir(const char* dir) const; { DeleteDirectory(dir); }. void ls(Option_t* cmd = """") const; { ListDi",MatchSource.WIKI,root/html530/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFTP.html
https://root.cern/root/html530/TFumili.html:971,Availability,error,errors,971,". TFumili. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FUMILI;  TFumili. class TFumili: public TVirtualFitter. FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. ; FUMILI minimization package; FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function.; Experimentally measured values $F_i$ are fitted with theoretical; functions $f_i({\vec x}_i,\vec\theta\,\,)$, where ${\vec x}_i$ are; coordinates, and $\vec\theta$ -- vector of parameters.; For better convergence Chi-square function has to be the following form; $$; {\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \eqno(1); $$; where $\sigma_i$ are errors of measured function.; The minimum condition is; $$; {\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; {\partial f_j\over\partial\theta_i}\left[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expressi",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:2200,Availability,down,down,2200,"ft[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expression is used when last term in (4) is discarded. It is often; done, not always wittingly, and sometimes causes troubles, for example,; if user wants to limit parameters with positive values by writing down; $\theta_i^2$ instead of $\theta_i$. FUMILI will fail if one tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:4794,Availability,error,error,4794,"; virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ip",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:4878,Availability,error,error,4878,"(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:15651,Availability,error,errors,15651,"next iteration; Double_t*fGr[fMaxParam] Gradients of objective function; Int_tfINDFLG[5]internal flags;; Int_tfLastFixedLast fixed parameter number; Bool_tfLogLikeLogLikelihood flag; Int_tfMaxParam; Int_tfMaxParam2fMaxParam*fMaxParam; Int_tfNED1Number of experimental vectors X=(x1,x2,...xK); Int_tfNED12fNED1+fNED2; Int_tfNED2K - Length of vector X plus 2 (for chi2); Int_tfNfcnNumber of FCN calls;; Int_tfNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; Int_tfNlog; Int_tfNmaxIterfNmaxIter - maximum number of iterations; Int_tfNparfNpar - number of parameters; Int_tfNstepDecfNstepDec - maximum number of step decreasing counter; Bool_tfNumericDerivatives; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vec",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:16487,Availability,error,errors,16487,"ves; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:18296,Availability,error,errors,18296,"; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar paramete",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:19087,Availability,error,error,19087," nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; us",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:19411,Availability,error,error,19411,": command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:19716,Availability,error,errors,19716," Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Opti",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:20972,Availability,error,error,20972,"ar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:21206,Availability,error,errors,21206,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:21251,Availability,error,errors,21251,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:21295,Availability,error,errors,21295,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:21360,Availability,error,errors,21360,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:21803,Availability,error,error,21803,"de data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization func",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:22383,Availability,error,error,22383,"- print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bi",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:22968,Availability,error,error,22968,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23293,Availability,error,error,23293," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23933,Availability,error,error,23933,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:24519,Availability,error,error,24519,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:22520,Deployability,release,released,22520,"; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Li",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:24768,Integrability,wrap,wrapper,24768,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:17030,Modifiability,variab,variable,17030,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:17079,Modifiability,variab,variable,17079,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:19963,Modifiability,variab,variable,19963,"otalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following valu",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:20256,Modifiability,variab,variable,20256,"_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors a",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:13255,Performance,cache,cache,13255,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fA[fMaxParam] Fit parameter array; Double_tfAKAPPA; Double_t*fAMN[fMaxParam] Minimum param value; Double_t*fAMX[fMaxParam] Maximum param value; TString*fANames[fMaxParam] Parameter names; Double_t*fCmPar[fMaxParam] parameters of commands; TStringfCwordCommand st",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:17747,Performance,perform,performs,17747,"f theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer t",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:22905,Performance,cache,cache,22905,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23227,Performance,cache,cache,23227," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23870,Performance,cache,cache,23870,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:24453,Performance,cache,cache,24453,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23691,Safety,predict,predict,23691,"arded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:24297,Safety,predict,predict,24297,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:3423,Testability,log,logarithm,3423,"sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dra",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:20059,Testability,log,log,20059,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:20081,Testability,log,log,20081,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:22174,Testability,log,loglikelihood,22174,"arameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:23763,Testability,log,logs,23763,"uble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:24369,Testability,log,logs,24369,"n width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}.  Last changed: root/fumili:$Id: TFumili.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumili.html:3193,Usability,simpl,simple,3193,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual In",MatchSource.WIKI,root/html530/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumili.html
https://root.cern/root/html530/TFumiliMinimizer.html:4938,Availability,error,errors,4938,"ues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is pri",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7271,Availability,error,errors,7271," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8100,Availability,error,error,8100," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8110,Availability,error,error,8110," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8180,Availability,error,errors,8180," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8419,Availability,error,errors,8419," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7220,Deployability,update,update,7220," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:387,Integrability,interface,interface,387,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FUMILI;  TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:5889,Integrability,interface,interface,5889,"r::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, cons",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6139,Integrability,interface,interface,6139," doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. b",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6223,Integrability,interface,interface,6223,"d by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6414,Integrability,interface,interface,6414,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:460,Modifiability,plug-in,plug-in,460,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FUMILI;  TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:478,Modifiability,plug-in,plug-in,478,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  FUMILI;  TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsRO",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6749,Modifiability,variab,variable,6749,"ivate). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of f",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6880,Modifiability,variab,variable,6880,"passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is t",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:6965,Modifiability,variab,variable,6965,"ll be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7037,Modifiability,variab,variable,7037," & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7844,Modifiability,variab,variables,7844,"ep, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7941,Modifiability,variab,variables,7941," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8333,Modifiability,variab,variable,8333," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:8391,Modifiability,variab,variables,8391," a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/fumili:$Id: TFumiliMinimizer.h 31604 2009-12-07 19:04:33Z moneta $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:7070,Performance,perform,perform,7070,"ulti-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and er",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFumiliMinimizer.html:4955,Security,validat,validated,4955,"ues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is pri",MatchSource.WIKI,root/html530/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFumiliMinimizer.html
https://root.cern/root/html530/TFunction.html:1568,Availability,error,error,1568," TFunction(MethodInfo_t* info = 0); TFunction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetPrototype() const; const char*GetReturnTypeName() const; const char*GetSignature(); virtual const char*TNamed::GetTitle() con",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunction.html:1652,Availability,error,error,1652,"ion(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetPrototype() const; const char*GetReturnTypeName() const; const char*GetSignature(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(T",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunction.html:7656,Availability,error,error,7656,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error.  Author: Fons Rademakers 07/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunction.html:7771,Availability,error,error,7771,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error.  Author: Fons Rademakers 07/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunction.html:7402,Integrability,interface,interface,7402,"on arguments; TStringTNamed::fNameobject identifier; TStringfSignaturestring containing function signature; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunction(MethodInfo_t* info = 0); Default TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error.  Author: Fons Rademakers 07/02/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TFunction.h 24077 2008-05-31 19:39:09Z brun $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunction.html:484,Security,access,accessible,484,". TFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TFunction. class TFunction: public TDictionary. Global functions class (global functions are obtaine from CINT).; This class describes one single global function.; The TROOT class contains a list of all currently defined global; functions (accessible via TROOT::GetListOfGlobalFunctions()). Function Members (Methods); public:. TFunction(MethodInfo_t* info = 0); TFunction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject",MatchSource.WIKI,root/html530/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunction.html
https://root.cern/root/html530/TFunctionParametersDialog.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:19598,Availability,mask,mask,19598,,MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:21460,Availability,error,errors,21460,::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y positi,MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:8265,Deployability,update,update,8265,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:20013,Deployability,update,updated,20013,"class name; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:21957,Deployability,update,update,21957,dow used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTG,MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:24444,Deployability,update,update,24444,"mitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog.  Author: Ilka Antcheva 08/05/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TFunctionParametersDialog.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TFunctionParametersDialog.html:24471,Integrability,depend,dependent,24471,"mitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog.  Author: Ilka Antcheva 08/05/06  Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TFunctionParametersDialog.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TFunctionParametersDialog.html
https://root.cern/root/html530/TG16ColorSelector.html:784,Availability,down,down,784,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TG16ColorSelector(const TGWindow* p = 0); virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual",MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TG16ColorSelector.html:4773,Availability,error,error,4773,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDef",MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TG16ColorSelector.html:4857,Availability,error,error,4857,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFram",MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TG16ColorSelector.html:17319,Availability,mask,mask,17319,,MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TG16ColorSelector.html:18085,Integrability,message,messages,18085,"ame*fCe[16]matrix of color cells; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TG16ColorSelector.html:19798,Integrability,message,messages,19798,"w::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TG16ColorSelector(const TGWindow* p = 0); TG16ColorSelector constructor.; The TG16ColorSelector is a composite frame with 16 TGColorFrames. ~TG16ColorSelector(); TG16ColorSelector destructor. void SetActive(Int_t newat); Set active color frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TG16ColorSelector. TGColorFrame& operator=(const TG16ColorSelector& ). TG16ColorSelector(const TG16ColorSelector& ). Int_t GetActive(); { return fActive; }.  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGColorSelect.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TG16ColorSelector.html
https://root.cern/root/html530/TGApplication.html:3918,Availability,error,error,3918,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:4002,Availability,error,error,4002,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:4146,Availability,error,error,4146,"); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:8007,Availability,error,error,8007,"Libs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const c",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:8128,Availability,error,error,8128,"tual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); voidTApplication::SetReturnFromRun(Bool_t ret); virtual vo",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:11168,Availability,error,error,11168,"t_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGApplication(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidLoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelet",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGApplication.html:12087,Availability,avail,available,12087,"; static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. ",MatchSource.WIKI,root/html530/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGApplication.html
https://root.cern/root/html530/TGaxis.html:3726,Availability,error,error,3726,"nst TObject* obj) const; virtual voidTLine::Copy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual c",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:3810,Availability,error,error,3810,"Object::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; virtual Short_tTAttText::GetTextAlign() const; virtual ",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:20770,Modifiability,inherit,inherited,20770,"tripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeOffset(Double_t toffset, Option_t* option = ""local""); Change the time offset.; If option =",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:18236,Performance,optimiz,optimization,18236,"k mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:18280,Performance,optimiz,optimized,18280,"tered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary d",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:18313,Performance,optimiz,optimization,18313,"divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary divisions); nbins : New NDIV . void LabelsLimits(const ",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:14033,Testability,log,logarithmic,14033,"axis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* funcname, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); TGaxis constructor with a TF1 to map axis values. See explanation of parameters in PaintAxis; Instead of the wmin,wmax arguments of the normal constructor, the; name of a TF1 function can be specified. This function will be used; by TGaxis::PaintAxis to map the user coordinates to the axis values; and ticks.; Examples:; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();. TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }. /*; ; */. TGaxis(const TGaxis& ); Copy constructor. TGaxis& operator=(const TGaxis& ); Assignement operator. ~TGaxis(); TGaxis default destructor. void CenterLabels(Bool_t center = kTRUE); If center = kTRUE axis labels are centered in the center of the bin.; The default is to center on the primary tick marks.; This option does not make sense if there are more bins than tick marks. void CenterTitle(Bool_t center = kTRUE); If center = kTRUE axis title will be centered.; The default is right adjusted. void DrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); Draw this axis with new attributes. Int_t GetMaxDigits(); Static function returning fgMaxDigits (See SetMaxDigits). void ImportAxisAttributes(TAxis* axis); Copy TAxis attributes to",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:18107,Testability,log,log,18107," adjusted on tick mark.; (default is centered); chopt='L': labels are Left adjusted on tick mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer valu",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGaxis.html:20674,Testability,log,log,20674,"etDecimals(Bool_t dot = kTRUE); Set the Decimals flag; By default, blank characters are stripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeO",MatchSource.WIKI,root/html530/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGaxis.html
https://root.cern/root/html530/TGButton.html:2205,Availability,avail,available,2205,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGButton(const TGWindow* p = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtu",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:6719,Availability,error,error,6719,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::Ge",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:6803,Availability,error,error,6803,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:19353,Availability,mask,mask,19353,,MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:20401,Availability,down,down,20401,element; TGButtonGroup*fGroupbutton group this button belongs to; UInt_tTGFrame::fHeightframe height; Pixel_tfHighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC,MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:21543,Deployability,release,released,21543,s from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tfgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:1931,Integrability,message,message,1931,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:738,Performance,perform,perform,738,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:628,Security,access,access,628,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButton.html:1406,Testability,log,logical,1406," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html530/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButton.html
https://root.cern/root/html530/TGButtonGroup.html:2047,Availability,down,down,2047," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetD",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:7078,Availability,error,error,7078,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCom",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:7162,Availability,error,error,7162,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBack",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:16309,Availability,down,down,16309,"t(UInt_t emask); virtual voidTGGroupFrame::Rename(const char* title)MENU ; virtual voidTGFrame::ReparentWindow(const TGWindow* p, Int_t x = 0, Int_t y = 0); virtual voidTGWindow::RequestFocus(); voidTObject::ResetBit(UInt_t f); virtual voidTGFrame::Resize(TGDimension size); virtual voidTGFrame::Resize(UInt_t w = 0, UInt_t h = 0); virtual voidTGObject::SaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGCompositeFrame::SavePrimitiveSubframes(ostream& out, Option_t* option = """"); voidTGFrame::SaveUserColor(ostream& out, Option_t*); virtual voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderDrawn(Bool_t enable = kTRUE); virtual voidSetButton(Int_t id, Bool_t down = kTRUE); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetExclusive(Bool_t flag = kTRUE); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutHints(TGLayoutHints* l, TGButton* button = 0); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWi",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:21098,Availability,mask,mask,21098,,MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:25759,Availability,down,down,25759,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:25807,Availability,down,down,25807,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:798,Deployability,toggle,toggle,798,". TGButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGButtonGroup. class TGButtonGroup: public TGGroupFrame. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is e",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:2164,Deployability,release,released,2164,"parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TStrin",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:25120,Deployability,toggle,toggle,25120," column. TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); Constructor. Layout defined by TGMatrixLayout:; r = number of rows; c = number of columns; s = interval between frames; h = layout hints. void Init(); Default init. ~TGButtonGroup(); Destructor, we do not delete the buttons. void DoRedraw(); Redraw the group frame. Need special DoRedraw() since we need to; redraw with fBorderWidth=0. void DrawBorder(); Draw border of around the group frame. if frame is kRaisedFrame - a frame border is of ""wall style"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as the",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:1378,Modifiability,inherit,inherits,1378,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:2520,Modifiability,inherit,inherits,2520,"th id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendP",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGButtonGroup.html:2733,Modifiability,inherit,inherits,2733,"no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtua",MatchSource.WIKI,root/html530/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGButtonGroup.html
https://root.cern/root/html530/TGCanvas.html:5256,Availability,error,error,5256,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() ",MatchSource.WIKI,root/html530/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCanvas.html
https://root.cern/root/html530/TGCanvas.html:5340,Availability,error,error,5340,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDro",MatchSource.WIKI,root/html530/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCanvas.html
https://root.cern/root/html530/TGCanvas.html:16857,Availability,mask,mask,16857,,MatchSource.WIKI,root/html530/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCanvas.html
https://root.cern/root/html530/TGCanvas.html:19455,Integrability,message,message,19455,":fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCanvas(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& )",MatchSource.WIKI,root/html530/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCanvas.html
https://root.cern/root/html530/TGCheckButton.html:2208,Availability,avail,available,2208,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGCheckButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p = 0, const c",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:7188,Availability,error,error,7188,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:7272,Availability,error,error,7272,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDDa",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:21629,Availability,mask,mask,21629,,MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:23368,Availability,down,down,23368,tButton::fMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*fOffbutton OFF picture; const TGPicture*fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:24840,Deployability,release,released,24840, window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:1934,Integrability,message,message,1934,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:741,Performance,perform,perform,741,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:631,Security,access,access,631,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGCheckButton.html:1409,Testability,log,logical,1409," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html530/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCheckButton.html
https://root.cern/root/html530/TGClient.html:3690,Availability,error,error,3690,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:3774,Availability,error,error,3774,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; TGFontPool*GetFontPool() const; TGGC*GetGC(GCValues_t* values, Bool_t rw = ",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:14590,Availability,error,error,14590," is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value o",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:15338,Availability,error,error,15338,"use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHand",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:16927,Availability,down,down,16927," Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. void RemoveUnknownWindowHandler(TGUnknownWindowHandler* h); Remove handler for unknown (i.e. unregistered) windows. void AddIdleHandler(TGIdleHandler* h); Add handler for idle events. void RemoveIdleHandler(TGIdleHandler* h); Remove handler for idle events. TGWindow * GetWindowById(Window_t sw) const; Find a TGWindow via its handle. If window is not found return 0. TGWindow * GetWindowByName(const char* name) const; Find a TGWindow via its name (unique name used in TGWindow::SavePrimitive).; If window is not found return 0. ~TGClient(); Closing down client: cleanup and close X connection. Bool_t ProcessOneEvent(); Process one event. This method should only be called when there is; a GUI event ready to be processed. If event has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the win",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:18277,Availability,mask,masked,18277," more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& opera",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:18410,Availability,mask,masked,18410,"s input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForce",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:18449,Availability,mask,masked,18449,"cessed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForceRedraw = kTRUE; }. EGEventType GetWaitForEvent() const; { return fWaitForEvent;}. W",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:12993,Integrability,message,message,12993,"odern or classic); TList*fUWHandlerslist of event handlers for unknown windows; EGEventTypefWaitForEventevent to wait for; Window_tfWaitForWindowwindow in which to wait for event; Pixel_tfWhitewhite color index; THashList*fWlistlist of frames; Int_tfXfdfile descriptor of connection to server; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGClient(const char* dpyName = 0); Create a connection with the display sever on host dpyName and setup; the complete GUI system, i.e., graphics contexts, fonts, etc. for all; widgets. const TGWindow * GetRoot() const; Returns current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. const TGWindow * GetDefaultRoot() const; Returns the root (i.e. desktop) window. Should only be used as parent; for frames that will never be embedded, like popups, message boxes,; etc. (like TGToolTips, TGMessageBox, etc.). void SetRoot(TGWindow* root = 0); Sets the current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(G",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:14303,Integrability,interface,interface,14303,"nother window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not f",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:15350,Performance,load,loaded,15350," FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. v",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:18114,Performance,queue,queue,18114," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGClient.html:18138,Security,expose,expose,18138," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html530/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGClient.html
https://root.cern/root/html530/TGColorDialog.html:5115,Availability,error,error,5115,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; st",MatchSource.WIKI,root/html530/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorDialog.html
https://root.cern/root/html530/TGColorDialog.html:5199,Availability,error,error,5199,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeF",MatchSource.WIKI,root/html530/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorDialog.html
https://root.cern/root/html530/TGColorDialog.html:20093,Availability,mask,mask,20093,,MatchSource.WIKI,root/html530/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorDialog.html
https://root.cern/root/html530/TGColorDialog.html:24431,Integrability,message,messages,24431,"tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorDialog(const TGWindow* p = 0, const TGWindow* m = 0, Int_t* retc = 0, Pixel_t* color = 0, Bool_t wait = kTRUE); Color selection dialog constructor.; The TGColorDialog presents a full featured color selection dialog.; It uses 2 TGColorPalette's and the TGColorPick widgets. ~TGColorDialog(); TGColorDialog destructor. void SetCurrentColor(Pixel_t col); Change current color. void ColorSelected(Pixel_t ); Emit signal about selected color. void CloseWindow(); Called when window is closed via window manager. void UpdateRGBentries(Pixel_t* c); Update RGB text entries with RGB values of color c. void UpdateHLSentries(Pixel_t* c); Update HLS text entries with HLS values of color c. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for the color selection dialog. void SetColorInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Set the color info in RGB and HLS parts. void DoPreview(); Slot method called when Preview button is clicked. TGColorPalette& operator=(const TGColorDialog& ). TGColorDialog(const TGColorDialog& ). TGColorPalette * GetPalette() const; { return fPalette; }. TGColorPalette * GetCustomPalette() const; { return fCpalette; }.  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorDialog.html
https://root.cern/root/html530/TGColorFrame.html:760,Availability,down,down,760,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorFrame(const TGWindow* p = 0, Pixel_t c = 0, Int_t n = 1); virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connec",MatchSource.WIKI,root/html530/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorFrame.html
https://root.cern/root/html530/TGColorFrame.html:4563,Availability,error,error,4563,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragTyp",MatchSource.WIKI,root/html530/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorFrame.html
https://root.cern/root/html530/TGColorFrame.html:4647,Availability,error,error,4647,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::Ge",MatchSource.WIKI,root/html530/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorFrame.html
https://root.cern/root/html530/TGColorFrame.html:15854,Availability,mask,mask,15854,,MatchSource.WIKI,root/html530/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorFrame.html
https://root.cern/root/html530/TGColorFrame.html:16400,Integrability,message,messages,16400,,MatchSource.WIKI,root/html530/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorFrame.html
https://root.cern/root/html530/TGColorPalette.html:4704,Availability,error,error,4704,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPalette.html
https://root.cern/root/html530/TGColorPalette.html:4788,Availability,error,error,4788,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPalette.html
https://root.cern/root/html530/TGColorPalette.html:16766,Availability,mask,mask,16766,,MatchSource.WIKI,root/html530/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPalette.html
https://root.cern/root/html530/TGColorPick.html:4683,Availability,error,error,4683,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetD",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:4767,Availability,error,error,4767,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject:",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:16844,Availability,mask,mask,16844,,MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:19974,Availability,error,error,19974,". Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }.  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rd",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:19655,Energy Efficiency,allocate,allocate,19655,"ton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pix",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:19767,Energy Efficiency,allocate,allocated,19767,"UserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. Int_tfColormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:19928,Energy Efficiency,reduce,reduced,19928,"ormap[64][3]colormap; Pixel_tfPixel[64]pixel values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPick(const TGWindow* p = 0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }.  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 199",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPick.html:20026,Integrability,rout,routine,20026,"0, Int_t w = 1, Int_t h = 1, Int_t id = -1); TGColorPick constructor.; TGColorPick is a widget which allows a color to be picked from HLS space.; It consists of two elements: a color map window from where the user can; select the hue and saturation level of a color, and a slider to select; color's lightness. ~TGColorPick(); TGColorPick destructor. Bool_t HandleButton(Event_t* event); Handle mouse button events in color pick widget. Bool_t HandleMotion(Event_t* event); Handle mouse motion events in color pick widget. void CreateImages(); Create colormap and color slider images. void AllocColors(); Try to allocate first a palette of 64 colors. Used by the dithered; version of the color maps. void FreeColors(); Free allocated colors. void CreateDitheredImage(Pixmap_t image, Int_t which); Create a dithered version of the color map and lightness images for; display modes with reduced number of colors. The Floyd-Steinberg error; diffusion dithering algorithm is used.; This routine is called in PseudoColor modes only. void InitImages(); Initialize color palette and slider images. void SetSliderColor(); Set slider colors. void SetColor(Pixel_t color); Position the slider cursor on right color position. void UpdateCurrentColor(); Assign the current cursor position as currently selected color. void DoRedraw(); Redraw the color pick widget. void SetHScursor(Int_t x, Int_t y); Set hue / saturation cursor position. void SetLcursor(Int_t z); Set lightness slider cursor position. void DrawHScursor(Int_t onoff); Draw hue / saturation cursor. void DrawLcursor(Int_t onoff); Draw lightness slider cursor. Pixel_t GetCurrentColor() const. void ColorSelected(Pixel_t col = 0); { Emit(""ColorSelected(Pixel_t)"", col ? col : GetCurrentColor()); }.  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGColorDialog.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been ",MatchSource.WIKI,root/html530/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPick.html
https://root.cern/root/html530/TGColorPopup.html:769,Availability,down,down,769,". TGColorPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGColorPopup. class TGColorPopup: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); virtual~TGColorPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_",MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorPopup.html:4806,Availability,error,error,4806,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorPopup.html:4890,Availability,error,error,4890,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorPopup.html:17362,Availability,mask,mask,17362,,MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorPopup.html:18184,Integrability,message,messages,18184,"orcurrently selected color value; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Int_tfLaunchDialogflag used for launching color dialog; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorPopup.html:20171,Integrability,message,messages,20171,"ls; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorPopup(const TGWindow* p = 0, const TGWindow* m = 0, Pixel_t color = 0); TGColorPopup constructor.; The TGColorPopup is a popup containing a TG16ColorSelector and a ""More...""; button which popups up a TGColorDialog allowing custom color selection. ~TGColorPopup(); TGColorPopup destructor. void EndPopup(); Ungrab pointer and unmap window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Popup TGColorPopup at x,y position. Bool_t HandleButton(Event_t* event); Handle mouse button events for TGColorPopup. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorPopup. void PreviewColor(Pixel_t color); Emit a signal to see preview. TGColorFrame& operator=(const TGColorPopup& ). TGColorPopup(const TGColorPopup& ).  Author: Bertrand Bellenot + Fons Rademakers 22/08/02  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGColorSelect.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGColorPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorPopup.html
https://root.cern/root/html530/TGColorSelect.html:769,Availability,down,down,769,". TGColorSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGColorSelect. class TGColorSelect: public TGCheckButton. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); virtual~TGColorSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ",MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:4895,Availability,error,error,4895,"nal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelected",MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:4979,Availability,error,error,4979,"ject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetD",MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:19795,Availability,mask,mask,19795,,MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:21638,Availability,down,down,21638, frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGPositionfPressPospsotion of frame on button press event; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:23609,Availability,down,down,23609,"me::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods j",MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:23140,Deployability,release,released,23140,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColorSelect.html:23789,Integrability,message,messages,23789,"ound; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorSelect(const TGWindow* p = 0, Pixel_t color = 0, Int_t id = -1); TGColorSelect constructor.; The TGColorSelect widget is like a checkbutton but instead of the check; mark there is color area with a little down arrow.; When clicked on the arrow the TGColorPopup pops up. ~TGColorSelect(); TGColorSelect destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TGColorSelect. Bool_t HandleButton(Event_t* event); Handle button events for TGColorSelect. void Enable(Bool_t on = kTRUE); Set state of widget as enabled. void Disable(); Set state of widget as disabled. void DoRedraw(); Redraw TGColorSelect widget. void DrawTriangle(GContext_t gc, Int_t x, Int_t y); Draw triangle (arrow) on which user can click to open TGColorPopup. void SetColor(Pixel_t color, Bool_t emit = kTRUE); Set color. void SavePrimitive(ostream& out, Option_t* = """"); Save a color select widget as a C++ statement(s) on output stream out. TGColorFrame& operator=(const TGColorSelect& ). Pixel_t GetColor() const; { return fColor; }. TGColorSelect(const TGColorSelect& ). void SetDown(Bool_t on = kTRUE, Bool_t emit = kFALSE); dummy methods just to remove from context menu. { TGButton::SetDown(on, emit); }. void Rename(const char* title); { TGTextButton::SetTitle(title); }. void SetEnabled(Bool_t e = kTRUE); {TGButton::SetEnabled(e); }. TGDimensio",MatchSource.WIKI,root/html530/TGColorSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColorSelect.html
https://root.cern/root/html530/TGColumnLayout.html:787,Availability,down,downward,787,". TGColumnLayout. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGColumnLayout. class TGColumnLayout: public TGRowLayout. A number of different layout classes (TGLayoutManager,; TGVerticalLayout, TGHorizontalLayout, TGLayoutHints, etc.). Concerning the TGMatrixLayout class:. It arranges frames in a matrix-like way.; This manager provides :; - a column number (0 means unlimited); - a row number (0 means unlimited); - horizontal & vertical separators. Notes : If both column and row are fixed values, any remaining; frames outside the count won't be managed.; Unlimited rows means the frame can expand downward; (the default behaviour in most UI).; Both unlimited rows and columns is undefined (read: will; crash the algorithm ;-).; With fixed dimensions, frames are always arranged in rows.; That is: 1st frame is at position (0,0), next one is at; row(0), column(1) and so on...; When specifying one dimension as unlimited (i.e. row=0 or; column=0) the frames are arranged according to the direction; of the fixed dimension. This layout manager does not make; use of TGLayoutHints. Function Members (Methods); public:. TGColumnLayout(const TGColumnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(O",MatchSource.WIKI,root/html530/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColumnLayout.html
https://root.cern/root/html530/TGColumnLayout.html:2329,Availability,error,error,2329,"umnLayout&); TGColumnLayout(TGCompositeFrame* main, Int_t s = 0); ~TGColumnLayout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColumnLayout.html
https://root.cern/root/html530/TGColumnLayout.html:2413,Availability,error,error,2413," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGDimensionGetDefaultSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/TGColumnLayout.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGColumnLayout.html
https://root.cern/root/html530/TGComboBox.html:377,Availability,down,down,377,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:614,Availability,down,down,614,". TGComboBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGComboBox. class TGComboBox: public TGCompositeFrame, public TGWidget. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); virtual~TGComboBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddEntry(TGString* s, Int_t id); virtual voidAddEntry(const char* s, Int_t id); virtual voidAddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:5231,Availability,error,error,5231,"le_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefa",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:5315,Availability,error,error,5315,"t(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTextInput(Bool_t on)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGLBEntry*FindEntry(const char* s) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TD",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:18950,Availability,down,down,18950,,MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:19105,Availability,mask,mask,19105,,MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:22453,Deployability,update,update,22453," static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGComboBox(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create a combo box widget. TGComboBox(const TGWindow* p, const char* text, Int_t id = -1, UInt_t options = kHorizontalFrame|kSunkenFrame|kDoubleBorder, Pixel_t back = GetWhitePixel()); Create an editable combo box widget. ~TGComboBox(); Delete a combo box widget. void Init(); Initiate the internal classes of a combo box. void DrawBorder(); Draw border of combo box widget. void EnableTextInput(Bool_t on); Switch text input or readonly mode of combobox (not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t wi",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:23271,Integrability,message,messages,23271,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBox(const TGComboBox& ). TGComboBox& operator=(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); Resiz",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:23318,Integrability,message,messages,23318,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBox(const TGComboBox& ). TGComboBox& operator=(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); Resiz",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBox.html:23343,Integrability,message,message,23343,"(not perfect yet). TGLBEntry * FindEntry(const char* s) const; Find entry by name. void SetTopEntry(TGLBEntry* e, TGLayoutHints* lh); Set a new combo box value (normally update of text string in; fSelEntry is done via fSelEntry::Update()). void Select(Int_t id, Bool_t emit = kTRUE); Make the selected item visible in the combo box window; and emit signals according to the second parameter. Bool_t HandleButton(Event_t* event); Handle mouse button events in the combo box. void RemoveEntry(Int_t id = -1); Remove entry. If id == -1, the currently selected entry is removed. void Layout(); layout combobox. Bool_t HandleDoubleClick(Event_t* event); Handle double click in text entry. Bool_t HandleMotion(Event_t* event); Handle pointer motion in text entry. Bool_t HandleSelection(Event_t* event); Handle selection in text entry. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request in text entry. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the listbox and forward; messages to the combobox message handling window. Parm2 contains; the id of the selected listbox entry. void Selected(Int_t widgetId, Int_t id); Emit signal. void SetEnabled(Bool_t on = kTRUE); Set state of combo box. If kTRUE=enabled, kFALSE=disabled. void ReturnPressed(); Add new entry to combo box when return key pressed inside text entry; ReturnPressed signal is emitted. void RemoveAll(); Remove all entries from combo box. void SavePrimitive(ostream& out, Option_t* option = """"); Save a combo box widget as a C++ statement(s) on output stream out. TGComboBox(const TGComboBox& ). TGComboBox& operator=(const TGComboBox& ). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. void AddEntry(TGString* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(const char* s, Int_t id); { fListBox->AddEntry(s, id); Resize(); }. void AddEntry(TGLBEntry* lbe, TGLayoutHints* lhints); { fListBox->AddEntry(lbe, lhints); Resiz",MatchSource.WIKI,root/html530/TGComboBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBox.html
https://root.cern/root/html530/TGComboBoxPopup.html:375,Availability,down,down,375,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html530/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBoxPopup.html
https://root.cern/root/html530/TGComboBoxPopup.html:612,Availability,down,down,612,". TGComboBoxPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGComboBoxPopup. class TGComboBoxPopup: public TGCompositeFrame. TGComboBox, TGComboBoxPopup. A combobox (also known as a drop down listbox) allows the selection; of one item out of a list of items. The selected item is visible in; a little window. To view the list of possible items one has to click; on a button on the right of the little window. This will drop down; a listbox. After selecting an item from the listbox the box will; disappear and the newly selected item will be shown in the little; window. The TGComboBox is user callable. The TGComboBoxPopup is a service; class of the combobox. Selecting an item in the combobox will generate the event:; kC_COMMAND, kCM_COMBOBOX, combobox id, item id. Function Members (Methods); public:. TGComboBoxPopup(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kVerticalFrame, Pixel_t back = GetWhitePixel()); ~TGComboBoxPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObj",MatchSource.WIKI,root/html530/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBoxPopup.html
https://root.cern/root/html530/TGComboBoxPopup.html:4824,Availability,error,error,4824,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBoxPopup.html
https://root.cern/root/html530/TGComboBoxPopup.html:4908,Availability,error,error,4908,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBoxPopup.html
https://root.cern/root/html530/TGComboBoxPopup.html:17293,Availability,mask,mask,17293,,MatchSource.WIKI,root/html530/TGComboBoxPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGComboBoxPopup.html
https://root.cern/root/html530/TGCommandPlugin.html:4359,Availability,error,error,4359,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html530/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCommandPlugin.html
https://root.cern/root/html530/TGCommandPlugin.html:4443,Availability,error,error,4443,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html530/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCommandPlugin.html
https://root.cern/root/html530/TGCommandPlugin.html:18675,Availability,mask,mask,18675,,MatchSource.WIKI,root/html530/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCommandPlugin.html
https://root.cern/root/html530/TGCommandPlugin.html:20193,Deployability,update,update,20193,tions! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Int_tfPidcurrent process id; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGTextView*fStatusoutput capture view; TTimer*fTimerfor local/remote update; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby;,MatchSource.WIKI,root/html530/TGCommandPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCommandPlugin.html
https://root.cern/root/html530/TGCompositeFrame.html:5277,Availability,error,error,5277,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:5361,Availability,error,error,5361,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tGetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tGetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:16882,Availability,mask,mask,16882,,MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:19820,Performance,load,load,19820,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:1364,Testability,log,logically,1364,"rame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidChangeOptions(UInt_t options); virtual voidChangeSubframesBackground(Pixel_t back); stat",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:19802,Testability,test,test,19802,"lass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a composite frame. A composite frame has in addition to a TGFrame; also a layout manager and a list of child frames. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); Create a frame using an externally created window. For example; to register the root window (called by TGClient), or a window; created via TVirtualX::InitWindow() (id is obtained with TVirtualX::GetWindowID()). ~TGCompositeFrame(); Delete a composite frame. Bool_t IsEditable() const; Return kTRUE if frame is being edited. void SetEditable(Bool_t on = kTRUE); Switch ON/OFF edit mode.; If edit mode is ON it is possible:. 1. embed other ROOT GUI application (a la ActiveX). For example:; TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; m->SetEditable();; gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; Aclock a;; gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; m->SetEditable(0);; m->MapWindow();. void Cleanup(); Cleanup and delete all objects contained in this composite frame.; This will delete all objects added via AddFrame().; CAUTION: all objects (frames and layout hints) must be unique, i.e.; cannot be shared. void SetLayoutManager(TGLayoutManager* l); Set the layout manager for the composite frame.; The layout manager is adopted by the frame and will be deleted; by the frame. void SetLayoutBroken(Bool_t on = kTRUE); Set broken layout. No Layout method is called. void SetEditDisabled(UInt_t on = 1); Set edit disable flag for this frame and subframes. - if (on & kEditDisable) - disable edit for this frame and all subframes. void ChangeOptions(UInt_t options); Change composite frame options. Options is an OR of the EFrameTypes. void SetCleanup(Int_t mode = kLocalCleanup); Turn on automatic cleanup of child frames in dtor. if mod",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGCompositeFrame.html:566,Usability,simpl,simple,566,". TGCompositeFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGCompositeFrame. class TGCompositeFrame: public TGFrame. TGFrame, TGCompositeFrame, TGVerticalFrame, TGHorizontalFrame,; TGMainFrame, TGTransientFrame and TGGroupFrame. The frame classes describe the different ""dressed"" GUI windows. The TGFrame class is a subclasses of TGWindow, and is used as base; class for some simple widgets (buttons, labels, etc.).; It provides:; - position & dimension fields; - an 'options' attribute (see constant above); - a generic event handler; - a generic layout mechanism; - a generic border. The TGCompositeFrame class is the base class for composite widgets; (menu bars, list boxes, etc.).; It provides:; - a layout manager; - a frame container (TList *). The TGVerticalFrame and TGHorizontalFrame are composite frame that; layout their children in vertical or horizontal way. The TGMainFrame class defines top level windows that interact with; the system Window Manager. The TGTransientFrame class defines transient windows that typically; are used for dialogs windows. The TGGroupFrame is a composite frame with a border and a title.; It is typically used to group a number of logically related widgets; visually together. /*. */. Function Members (Methods); public:. TGCompositeFrame(TGClient* c, Window_t id, const TGWindow* parent = 0); TGCompositeFrame(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGCompositeFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSigna",MatchSource.WIKI,root/html530/TGCompositeFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGCompositeFrame.html
https://root.cern/root/html530/TGContainer.html:6042,Availability,error,error,6042," signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); ",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:6126,Availability,error,error,6126,"TQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnd(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*GetCanvas() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:12341,Availability,mask,mask,12341,"tual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidInvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidKeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidLayout(); virtual voidLineDown(Bool_t select = kFALSE); virtual voidLineLeft(Bool_t select = kFALSE); virtual voidLineRight(Bool_t select = kFALSE); virtual voidLineUp(Bool_t select = kFALSE); static voidTQObject::LoadRQ_OBJECT(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tNumItems() const; virtual ",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:20342,Availability,mask,mask,20342,,MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:24210,Availability,mask,mask,24210,":fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicke",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:24320,Availability,mask,mask,24320,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:24340,Availability,mask,mask,24340,"tation; TGContainer(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). TGContainer(TGCanvas* p, UInt_t options = kSunkenFrame, Pixel_t back = GetDefaultFrameBackground()); Create a canvas container. This is the (large) frame that contains; all the list items. It will be shown through a TGViewPort (which is; created by the TGCanvas). ~TGContainer(); Delete canvas container. void Layout(); Layout container entries. void CurrentChanged(Int_t x, Int_t y); Emit signal when current position changed. void CurrentChanged(TGFrame* f); Emit signal when current selected frame changed. void KeyPressed(TGFrame* , UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. frame - activated frame; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGFrame* ); Signal emitted when Return/Enter key pressed.; It's equivalent to ""double click"" of mouse button. void SpacePressed(TGFrame* ); Signal emitted when space key pressed.; Pressing space key inverts selection. void OnMouseOver(TGFrame* ); Signal emitted when pointer is over entry. void Clicked(TGFrame* f, Int_t btn); Emit Clicked() signal. void Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGFrame* f, Int_t btn); Emit DoubleClicked() signal. void DoubleClicked(TGFrame* f, Int_t btn, Int_t x",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:28526,Availability,down,down,28526,"The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRU",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:28658,Availability,down,down,28658,"ment * FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); Find frame located int container at position x,y. void * FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE). TGHScrollBar * GetHScrollbar() const; returns pointer to hor. scroll bar. TGVScrollBar * GetVScrollbar() const; returns pointer to vert. scroll bar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetHsbPosition(Int_t newPos); set new hor. position. void AdjustPosition(); Move content to position of highlighted/activated frame. void LineLeft(Bool_t select = kFALSE); Move current position one column left. void LineRight(Bool_t select = kFALSE); Move current position one column right. void LineUp(Bool_t select = kFALSE); Make current position first line in window by scrolling up. void LineDown(Bool_t select = kFALSE); Move one line down. void PageUp(Bool_t select = kFALSE); Move position one page up. void PageDown(Bool_t select = kFALSE); Move position one page down. void Home(Bool_t select = kFALSE); Move to upper-left corner of container. void End(Bool_t select = kFALSE); Move to the bottom-right corner of container. const TGGC & GetLineGC(); Get graphics context for line drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas container as a C++ statement(s) on output stream out. TGContainer(const TGContainer& ). TGContainer& operator=(const TGContainer& ). void Associate(const TGWindow* w); { fMsgWindow = w; }. TGCanvas * GetCanvas() const; { return fCanvas; }. const TGWindow * GetMessageWindow() const; { return fMsgWindow; }. Int_t NumSelected() const; { return fSelected; }. Int_t NumItems() const; { return fTotal; }. TGFrame * GetLastActive() const; { return fLastActiveEl ? fLastActiveEl->fFrame : 0; }. Bool_t HandleDNDFinished(); { fBdown = kFALSE; return kTRUE; }.  Author: Fons Rademakers 11/01/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:21520,Integrability,message,messages,21520,; TStringfKeyInputkeyboard input (buffer); TTimer*fKeyTimerkeyboard timer; Bool_tfKeyTimerActivekTRUE - keyboard timer is active; TGFrameElement*fLastActiveEllast active item; Bool_tfLastCasecase sensetivity of last search; Bool_tfLastDirdirection of last search; TStringfLastNamethe name of object of last search; Bool_tfLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tfOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*fScrollTimerautoscroll timer; Bool_tfScrollingkTRUE - when scrolling is ON; Int_tfSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tfTotaltotal items; TGViewPort*fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfX0; Int_tfXDND; Int_tfXf; Int_tfXp; Int_tTGFrame::fYframe y position; Int_tfY0corner of rubber band box; Int_tfYDND; Int_tfYfother corner of rubber band box; Int_tfYpprevious pointer position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; stati,MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGContainer.html:26657,Security,expose,expose,26657,"emove all items from the container. void RemoveItem(TGFrame* item); Remove item from container. const TGFrame * GetNextSelected(void** current); Return next selected item. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root/html530/TGContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGContainer.html
https://root.cern/root/html530/TGDMLParse.html:1307,Availability,error,error,1307,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GDML;  TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:1391,Availability,error,error,1391,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GDML;  TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:10700,Integrability,depend,depending,10700,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. const char* GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces i",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:10684,Modifiability,variab,variable,10684,"nd the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePointer_t ConProcess(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the define section of the GDML file, constants can be declared.; when the constant keyword is found, this function is called, and the; name and value of the constant is stored in the ""fformvec"" vector as; a TFormula class, representing a constant function. const char* GetScale(const char* unit); Throughout the GDML file, a unit can de specified. Whether it be; angular or linear, values can be used as well as abbreviations such as; 'mm' or 'deg'. This function is passed the specified unit and if it is; found, replaces i",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:1717,Testability,test,test,1717,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GDML;  TGDMLParse. class TGDMLParse: public TObject. Function Members (Methods); public:. TGDMLParse(); TGDMLParse(const TGDMLParse&); virtual~TGDMLParse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGeoVolume*GDMLReadFile(const char* filename = ""test.gdml""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:10077,Testability,test,test,10077,"dium names and the TGeoMedium for it; TGDMMapHelper<TGeoMixture>fmixmap!Map containing mixture names and the TGeoMixture for it; TGDMMapHelper<TGeoTranslation>fposmap!Map containing position names and the TGeoTranslation for it; map<string,string>freflectmap!Map containing reflection names and the Solid name ir references to; TGDMMapHelper<TGDMLRefl>freflsolidmap!Map containing reflection names and the TGDMLRefl for it - containing refl matrix; map<string,string>freflvolmap!Map containing reflected volume names and the solid ref for it; TGDMMapHelper<TGeoRotation>frotmap!Map containing rotation names and the TGeoRotation for it; TGDMMapHelper<TGeoScale>fsclmap!Map containing scale names and the TGeoScale for it; TGDMMapHelper<TGeoShape>fsolmap!Map containing solid names and the TGeoShape for it; TGDMMapHelper<TGeoVolume>fvolmap!Map containing volume names and the TGeoVolume for it. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoVolume* GDMLReadFile(const char* filename = ""test.gdml""); creates the new instance of the XMLEngine called 'gdml', using the filename >>; then parses the file and creates the DOM tree. Then passes the DOM to the; next function to translate it. const char* ParseGDML(TXMLEngine* gdml, XMLNodePointer_t node); this function recursively moves thru the DOM tree of the GDML file. It checks for; key words along the way and if a key word is found it calls the corresponding; function to interpret the node. double Evaluate(const char* evalline). Int_t SetAxis(const char* axisString); When using the 'divide' process in the geometry this function; sets the variable 'axis' depending on what is specified. const char* NameShort(const char* name); this function looks thru a string for the chars '0x' next to; each other, when it finds this, it calls another function to strip; the hex address. It does this recursively until the end of the; string is reached, returning a string without any hex addresses. XMLNodePoin",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLParse.html:17200,Usability,simpl,simple,17200,"the original assembly using TGeoVolume->AddNode. XMLNodePointer_t TopProcess(TXMLEngine* gdml, XMLNodePointer_t node); In the setup section of the GDML file, the top volume need to be; declared. when the setup keyword is found, this function is called,; and the top volume ref is taken and 'world' is set. XMLNodePointer_t Box(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a box may be declared.; when the box keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Ellipsoid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an ellipsoid may be declared.; Unfortunately, the ellipsoid is not supported under ROOT so,; when the ellipsoid keyword is found, this function is called; to convert it to a simple box with similar dimensions, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoBBox and stored in fsolmap map using the name; as its key. XMLNodePointer_t Paraboloid(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, a Paraboloid may be declared.; when the paraboloid keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoParaboloid and stored in fsolmap map using the name; as its key. XMLNodePointer_t Arb8(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrPointer_t attr); In the solids section of the GDML file, an Arb8 may be declared.; when the arb8 keyword is found, this function is called, and the; dimensions required are taken and stored, these are then bound and; converted to type TGeoArb8 and stored in fsolmap map using the name; as its key. XMLNodePointer_t Tube(TXMLEngine* gdml, XMLNodePointer_t node, XMLAttrP",MatchSource.WIKI,root/html530/TGDMLParse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLParse.html
https://root.cern/root/html530/TGDMLRefl.html:1445,Availability,error,error,1445,"LRefl(const char* name, const char* solid, TGeoMatrix* matrix); virtual~TGDMLRefl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(co",MatchSource.WIKI,root/html530/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLRefl.html
https://root.cern/root/html530/TGDMLRefl.html:1529,Availability,error,error,1529," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html530/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLRefl.html
https://root.cern/root/html530/TGDMLRefl.html:5617,Security,access,accessor,5617," voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TGeoMatrix*fMatrix!matrix of reflected solid; const char*fNameS!reflected solid name; const char*fSolid!solid name being reflected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix); this constructor method stores the values brought in as params. TGeoMatrix* GetMatrix(); this accessor method returns the matrix. TGDMLRefl(). virtual ~TGDMLRefl(); {}. TGDMLRefl(const char* name, const char* solid, TGeoMatrix* matrix).  Last changed: Mon Jul 4 15:28:32 2011  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGDMLRefl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDMLRefl.html
https://root.cern/root/html530/TGDNDManager.html:1477,Availability,error,error,1477,"ctMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:1561,Availability,error,error,1561,"= """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDrag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Bool_tDrop(); virtual voidTObject::Dump() constMENU ; Bool_tEndDrag(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static Atom_tGetDNDActionAsk(); static Atom_tGetDNDActionCopy(); static Atom_tGetDNDActionDescrip(); static Atom_tGetDNDActionLink(); static Atom_tGetDNDActionList(); static Atom_tGetDNDActionMove(); static Atom_tGetDNDActionPrivate(); static Atom_tGetDNDAware(); static Atom_tGetDNDDrop(); static Atom_tGetDNDEnter(); static Atom_tGetDNDFinished(); static Atom_tGetDNDLeave(); static Atom_tGetDNDPosition(); static Atom_tGetDNDProxy(); static Atom_tGetDNDSelection(); static Atom_tGetDNDStatus(); static Atom_tGetDNDTypeList(); static Atom_tGetDNDVersion(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGFrame*GetMainFrame() const; v",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:4902,Availability,mask,mask,4902,"::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRemoveRootProxy(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMainFrame(TGFrame* main); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRootProxy(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); Bool_tStartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:7529,Availability,mask,mask,7529,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:11562,Availability,mask,mask,11562," to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(Int_t x_root, Int_t y_root, Atom_t action, Time_t timestamp); Process drag event. Bool_t SetRootProxy(); Set root window proxy. Bool_t RemoveRootProxy(); Remove root window proxy. TDNDData& operator=(const TGDNDManager& ). TGDNDManager(const TGDNDManager& ). Bool_t IsTopLevel(Window_t win). TGFrame * GetMainFrame() const; --- called by widgets. { return fMain; }. void SetMainFrame(TGFrame* main); { fMain = main; }. Bool_t IsDragging() const; { return fDragging; }. Window_t GetSource() const; { return fSource; }. Window_t GetTarget() const; { return fTarget; }. Atom_t * GetTypeList() const; { return fTypelist; }.  Author: Bertrand Bellenot 19/04/07  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGDNDManager.h 23115 2008-04",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10248,Integrability,message,messages,10248,"gDNDStatus; }. Atom_t GetDNDDrop(); { return fgDNDDrop; }. Atom_t GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND s",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10361,Integrability,message,message,10361,"n(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target)",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10438,Integrability,message,message,10438,"nCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); H",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10568,Integrability,message,message,10568,"DNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void Set",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10662,Integrability,message,message,10662,"gDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t ",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10737,Integrability,message,message,10737,"DNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start ",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10817,Integrability,message,message,10817,"return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp); Handle DND drop event. Bool_t HandleDNDFinished(Window_t target); Handle DND finished event. Bool_t HandleSelectionRequest(Event_t* event); Handle selection request event. Bool_t HandleSelection(Event_t* event); Handle selection event. void SetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); Set drag window pixmaps and hotpoint. Bool_t StartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); Start dragging. Bool_t Drop(); Drop. Bool_t EndDrag(); End dragging. Bool_t Drag(In",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:7455,Safety,timeout,timeout,7455,"num TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Atom_tfAcceptedAction; Cursor_tfDNDNoDropCursorno drop cursor type; TGDragWindow*fDragWindrag window; Atom_t*fDraggerTypeslists of DND types; Bool_tfDraggingkTRUE while dragging; Bool_tfDropAcceptedkTRUE if drop accepted; TTimer*fDropTimeoutdrop timeout; Atom_tfDropTypedrop type; UInt_tfGrabEventMaskpointer grab event mask; Int_tfHotx; Int_tfHotyhot point coordinates; Atom_tfLocalActionaccepted and local actions; TGFrame*fLocalSource; TGFrame*fLocalTargetlocal source and target; TGFrame*fMainpointer on TGMainFrame; Pixmap_tfMaskpixmap used for the drag window; Pixmap_tfPic; Bool_tfProxyOurskTRUE if root proxy is ours; Window_tfSource; Bool_tfStatusPendingkTRUE if status is pending; Window_tfTargetsource and target windows; Bool_tfTargetIsDNDAwarekTRUE if target is DND aware; Atom_t*fTypelist; Bool_tfUseVersionkTRUE if DND version is used; Atom_tfVersionnot really an Atom, but a long; static Atom_tfgDNDActionAsk; static Atom_tfgDNDActionCopy; static Atom_tfgDNDActionDescrip; static Atom_tfgDNDActionLink; static Atom_tfgDNDActionList; static Atom_tfgDNDActionMove; static Atom_tfgDNDActionPrivate; static Atom_tfgDNDAware; static Atom_tfgDNDDrop; static Atom_tfgDNDEnter; static Atom_tfgDNDFinished; static Atom_tfgDNDLeave; static Atom_tfgDNDPosition; static Atom_tfgDNDProxy; static Atom_tfgDNDSelection; static Atom_tfgDNDStatus; static Atom_tfgDNDTypeList; static Atom_tfgDNDVersion; static Bool_tfgInit; static Atom_tfgXAWMState; static Atom_tfgXCDNDData. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDNDManager(TGFrame* toplevel, Atom_t* typelist); TGDNDManager constructor. ~TGDNDManager(); TGDNDManager destructor. Atom_t GetDNDAware(); { return fgDNDAware; }. Atom_t",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDNDManager.html:10301,Safety,timeout,timeout,10301,"GetDNDFinished(); { return fgDNDFinished; }. Atom_t GetDNDVersion(); { return fgDNDVersion; }. Atom_t GetDNDActionCopy(); { return fgDNDActionCopy; }. Atom_t GetDNDActionMove(); { return fgDNDActionMove; }. Atom_t GetDNDActionLink(); { return fgDNDActionLink; }. Atom_t GetDNDActionAsk(); { return fgDNDActionAsk; }. Atom_t GetDNDActionPrivate(); { return fgDNDActionPrivate; }. Atom_t GetDNDTypeList(); { return fgDNDTypeList; }. Atom_t GetDNDActionList(); { return fgDNDActionList; }. Atom_t GetDNDActionDescrip(); { return fgDNDActionDescrip; }. Atom_t GetXCDNDData(); { return fgXCDNDData; }. void InitAtoms(); Initialize drag and drop atoms. Bool_t IsDNDAware(Window_t win, Atom_t* typelist = 0); Check if window win is DND aware. Window_t FindWindow(Window_t root, Int_t x, Int_t y, Int_t maxd); Search for DND aware window at position x,y. Window_t GetRootProxy(); Get root window proxy. Bool_t HandleClientMessage(Event_t* event); Handle DND related client messages. Bool_t HandleTimer(TTimer* t); Handle Drop timeout. void SendDNDEnter(Window_t target); Send DND enter message to target window. void SendDNDLeave(Window_t target); Send DND leave message to target window. void SendDNDPosition(Window_t target, int x, int y, Atom_t action, Time_t timestamp); Send DND position message to target window. void SendDNDStatus(Window_t target, Atom_t action); Send DND status message to source window. void SendDNDDrop(Window_t target); Send DND drop message to target window. void SendDNDFinished(Window_t src); Send DND finished message to source window. Bool_t HandleDNDEnter(Window_t src, long vers, Atom_t* dataTypes); Handle DND enter event. Bool_t HandleDNDLeave(Window_t src); Handle DND leave event. Bool_t HandleDNDPosition(Window_t src, int x_root, int y_root, Atom_t action, Time_t timestamp); Handle DND position event. Bool_t HandleDNDStatus(Window_t from, int accepted, Rectangle_t skip, Atom_t action); Handle DND status event. Bool_t HandleDNDDrop(Window_t src, Time_t timestamp);",MatchSource.WIKI,root/html530/TGDNDManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDNDManager.html
https://root.cern/root/html530/TGDockableFrame.html:4760,Availability,error,error,4760,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:4844,Availability,error,error,4844,"t char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; vir",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:18112,Availability,mask,mask,18112,,MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:21236,Integrability,message,messages,21236,"efault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }.  Author: Abdelhalim Ssadik 07/07/04  Copyright (C) 1995-20",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:393,Usability,undo,undocked,393,". TGDockableFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGDockableFrame. class TGDockableFrame: public TGCompositeFrame, public TGWidget. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); virtual~TGDockableFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidAddFrame(TGFrame* f, TGLayoutHints* hints); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::C",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:18055,Usability,undo,undocked,18055,,MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:18212,Usability,undo,undocked,18212,,MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:21286,Usability,undo,undocking,21286,"lectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }.  Author: Abdelhalim Ssadik 07/07/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id:",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockableFrame.html:21426,Usability,undo,undock,21426,"n; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDockableFrame(const TGWindow* p = 0, Int_t id = -1, UInt_t options = kHorizontalFrame); Create a dockable frame widget. ~TGDockableFrame(); Cleanup dockable frame. void AddFrame(TGFrame* f, TGLayoutHints* hints); Add frame to dockable frame container. Frame and hints are NOT adopted. void UndockContainer(); Undock container. void DockContainer(Int_t del = kTRUE); Dock container back to TGDockableFrame. void ShowContainer(); Show dock container. void HideContainer(); Hide dock container. Bool_t ProcessMessage(Long_t , Long_t , Long_t ); Process dockable frame messages. void EnableUndock(Bool_t onoff); Enable undocking. void EnableHide(Bool_t onoff); Enable hiding. void SetWindowName(const char* name); Set window name so it appear as title of the undock window. void SavePrimitive(ostream& out, Option_t* option = """"); Save a dockable frame widget as a C++ statement(s) on output stream out. TGUndockedFrame& operator=(const TGDockableFrame& ). TGDockableFrame(const TGDockableFrame& ). void Docked(); { Emit(""Docked()""); }. void Undocked(); { Emit(""Undocked()""); }. void EnableUndock(Bool_t onoff). void EnableHide(Bool_t onoff). Bool_t IsUndocked() const; { return (fFrame != 0); }. Bool_t IsHidden() const; { return fHidden; }. Bool_t IsFixedSize() const; { return fFixedSize; }. void SetFixedSize(Bool_t fixed); { fFixedSize = fixed; }. TGCompositeFrame * GetContainer() const; { return fContainer; }. TGUndockedFrame * GetUndocked() const; { return fFrame; }.  Author: Abdelhalim Ssadik 07/07/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $  Last generated: 2011-07-04 15:28; This page has been automati",MatchSource.WIKI,root/html530/TGDockableFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockableFrame.html
https://root.cern/root/html530/TGDockButton.html:4384,Availability,error,error,4384,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockButton.html:4468,Availability,error,error,4468,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockButton.html:17312,Availability,mask,mask,17312,,MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockButton.html:18532,Availability,down,down,18532,HighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockButton.html:19754,Deployability,release,released,19754, frame width; Bool_tfMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tfNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockButton.html:359,Usability,undo,undocked,359,". TGDockButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGDockButton. class TGDockButton: public TGButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockButton(const TGCompositeFrame* p = 0, Int_t id = 1); virtual~TGDockButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal,",MatchSource.WIKI,root/html530/TGDockButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockButton.html
https://root.cern/root/html530/TGDockHideButton.html:4387,Availability,error,error,4387,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*T",MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDockHideButton.html:4471,Availability,error,error,4471,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Optio",MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDockHideButton.html:17411,Availability,mask,mask,17411,,MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDockHideButton.html:18673,Availability,down,down,18673,ndle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Bool_tTGDockButton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static con,MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDockHideButton.html:19895,Deployability,release,released,19895,tton::fMouseOntrue when mouse on button; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; ULong_tTGDockButton::fNormBgnormal background color; GContext_tTGButton::fNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDockHideButton.html:375,Usability,undo,undocked,375,". TGDockHideButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TGDockHideButton. class TGDockHideButton: public TGDockButton. A TGDockableFrame is a frame with handles that allow it to be; undocked (i.e. put in a transient frame of its own) and to be docked; again or hidden and shown again. It uses the TGDockButton, which is; a button with two vertical bars (||) and TGDockHideButton, which is; a button with a small triangle. The TGUndockedFrame is a transient; frame that on closure will put the frame back in the dock. Function Members (Methods); public:. TGDockHideButton(const TGCompositeFrame* p = 0); ~TGDockHideButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* sign",MatchSource.WIKI,root/html530/TGDockHideButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDockHideButton.html
https://root.cern/root/html530/TGDoubleHSlider.html:5340,Availability,error,error,5340,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html530/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleHSlider.html
https://root.cern/root/html530/TGDoubleHSlider.html:5424,Availability,error,error,5424,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html530/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleHSlider.html
https://root.cern/root/html530/TGDoubleHSlider.html:17542,Availability,mask,mask,17542,,MatchSource.WIKI,root/html530/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleHSlider.html
https://root.cern/root/html530/TGDoubleHSlider.html:18942,Availability,down,downright,18942,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tfXphorizontal slider x position in pixel coordinates; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTG",MatchSource.WIKI,root/html530/TGDoubleHSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleHSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:1681,Availability,avail,available,1681,"nge the max value press the mouse near to the right / top; edge of the slider.; To change both values simultaneously press the mouse near to the; center of the slider. TGDoubleSlider is an abstract base class. Use the concrete; TGDoubleVSlider and TGDoubleHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_POS, slider id, 0 (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Use the functions GetMinPosition(), GetMaxPosition() and; GetPosition() to retrieve the position of the slider. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TGDoubleSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQ",MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:5259,Availability,error,error,5259,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGF",MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:5343,Availability,error,error,5343,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual ",MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:17272,Availability,mask,mask,17272,,MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:18512,Availability,down,downright,18512,"ls! list of signals from this object; Bool_tfMarkEndslines marking where stretch zones begin; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tfMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tfPoslogical position between fVmin and fVmax; Int_tfPressPointmouse position at button press event; Float_tfPressSmaxlogical max position at button press event; Float_tfPressSminlogical min position at button press event; Int_tfRelPosslider position in pixel coordinates; Bool_tfReversedScalereverse which end is min and max; Int_tfScaletick mark scale; Int_tfScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*fSliderPicpicture to draw slider ends; Float_tfSmaxlogical position of max value of Slider; Float_tfSminlogical position of min value of Slider; Float_tfVmaxlogical upper limit of slider; Float_tfVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFram",MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleSlider.html:20154,Integrability,depend,depending,20154," for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FixBounds(Float_t& min, Float_t& max); Avoid boundaries to be equal. TString GetSString() const; Returns the slider type as a string - used in SavePrimitive(). void ChangeCursor(Event_t* event); Change the cursor shape depending on the slider area. TGDoubleSlider& operator=(const TGDoubleSlider& ). virtual ~TGDoubleSlider(); { }. Bool_t HandleButton(Event_t* event). Bool_t HandleMotion(Event_t* event). void SetScale(Int_t scale); { fScale = scale; }. void SetRange(Float_t min, Float_t max). void SetPosition(Float_t min, Float_t max). Float_t GetMinPosition() const. Float_t GetMaxPosition() const. void GetPosition(Float_t& min, Float_t& max) const. void GetPosition(Float_t* min, Float_t* max) const. void MapSubwindows(); { TGWindow::MapSubwindows(); }. void PositionChanged(); { Emit(""PositionChanged()""); }. void Pressed(); { Emit(""Pressed()""); }. void Released(); { Emit(""Released()""); }.  Author: Reiner Rohlfs 30/09/98  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGDoubleSlider.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html530/TGDoubleSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleSlider.html
https://root.cern/root/html530/TGDoubleVSlider.html:5338,Availability,error,error,5338,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::Get",MatchSource.WIKI,root/html530/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleVSlider.html
https://root.cern/root/html530/TGDoubleVSlider.html:5422,Availability,error,error,5422,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFr",MatchSource.WIKI,root/html530/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleVSlider.html
https://root.cern/root/html530/TGDoubleVSlider.html:17540,Availability,mask,mask,17540,,MatchSource.WIKI,root/html530/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleVSlider.html
https://root.cern/root/html530/TGDoubleVSlider.html:18940,Availability,down,downright,18940,"t_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGDoubleSlider::fMove1: move min value; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Float_tTGDoubleSlider::fPoslogical position between fVmin and fVmax; Int_tTGDoubleSlider::fPressPointmouse position at button press event; Float_tTGDoubleSlider::fPressSmaxlogical max position at button press event; Float_tTGDoubleSlider::fPressSminlogical min position at button press event; Int_tTGDoubleSlider::fRelPosslider position in pixel coordinates; Bool_tTGDoubleSlider::fReversedScalereverse which end is min and max; Int_tTGDoubleSlider::fScaletick mark scale; Int_tTGDoubleSlider::fScaleTypetick mark scale type (no, downright, both); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; const TGPicture*TGDoubleSlider::fSliderPicpicture to draw slider ends; Float_tTGDoubleSlider::fSmaxlogical position of max value of Slider; Float_tTGDoubleSlider::fSminlogical position of min value of Slider; Float_tTGDoubleSlider::fVmaxlogical upper limit of slider; Float_tTGDoubleSlider::fVminlogical lower limit of slider; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; Int_tfYpvertical slider y position in pixel coordinates; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFr",MatchSource.WIKI,root/html530/TGDoubleVSlider.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDoubleVSlider.html
https://root.cern/root/html530/TGDragWindow.html:459,Availability,mask,mask,459," TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); virtual~TGDragWindow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual",MatchSource.WIKI,root/html530/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDragWindow.html
https://root.cern/root/html530/TGDragWindow.html:4018,Availability,error,error,4018,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html530/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDragWindow.html
https://root.cern/root/html530/TGDragWindow.html:4102,Availability,error,error,4102,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static Long_tTO",MatchSource.WIKI,root/html530/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDragWindow.html
https://root.cern/root/html530/TGDragWindow.html:15127,Availability,mask,mask,15127,,MatchSource.WIKI,root/html530/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDragWindow.html
https://root.cern/root/html530/TGDragWindow.html:17064,Availability,mask,mask,17064,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Cursor_tfgDefaultCursorDefault Cursor; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGDragWindow(const TGWindow* p, Pixmap_t pic, Pixmap_t mask, UInt_t options = kChildFrame, Pixel_t back = GetWhitePixel()); TGDragWindow constructor. ~TGDragWindow(); TGDragWindow destructor. void MapWindow(); Map TGDragWindow. void UnmapWindow(); Unmap TGDragWindow. void RaiseWindow(); Raise TGDragWindow. void LowerWindow(); Lower TGDragWindow. void MapRaised(); Map and Raise TGDragWindow. void Layout(); Layout TGDragWindow. void DoRedraw(); Redraw TGDragWindow. TGDimension GetDefaultSize() const; { return TGDimension(fPw, fPh); }. Window_t GetInputId() const; { return fInput; }. Bool_t HasWindow(Window_t w) const; { return (w == fId || w == fInput); }.  Author: Bertrand Bellenot 19/04/07  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGDNDManager.h 23115 2008-04-10 13:35:37Z rdm $  Last generated: 2011-07-04 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGDragWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGDragWindow.html
https://root.cern/root/html530/TGedEditor.html:6571,Availability,error,error,6571,"ram); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtu",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:6655,Availability,error,error,6655," char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefau",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:22864,Availability,mask,mask,22864,,MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:23006,Availability,avail,available,23006,,MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:1394,Integrability,interface,interface,1394,"ts editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UI",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:26753,Integrability,depend,dependent,26753,"(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static TStringTVirtualPadEditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* ",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:1551,Performance,load,loaded,1551,"he; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:1595,Performance,cache,cached,1595," follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Members (Methods); public:. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); virtual~TGedEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateEditor(TClass* cl, Bool_t recurse); voidActivateEditors(TList* bcl, Bool_t recurse); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const ",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:9589,Performance,load,load,9589,"Name() const; const char*TGMainFrame::GetIconPixmap() const; Handle_tTGObject::GetId() const; virtual TGLayoutManager*TGCompositeFrame::GetLayoutManager() const; virtual TList*TGCompositeFrame::GetList() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const TGWindow*TGWindow::GetMainFrame() const; UInt_tTGFrame::GetMaxHeight() const; UInt_tTGFrame::GetMaxWidth() const; UInt_tTGFrame::GetMinHeight() const; UInt_tTGFrame::GetMinWidth() const; virtual TObject*GetModel() const; voidTGMainFrame::GetMWMHints(UInt_t& value, UInt_t& funcs, UInt_t& input) const; virtual const char*TGWindow::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; virtual TVirtualPad*GetPad() const; static TVirtualPadEditor*TVirtualPadEditor::GetPadEditor(Bool_t load = kTRUE); const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; TGTab*GetTab() const; TGCanvas*GetTGCanvas() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual voidGlobalClosed(); virtual voidGlobalSetModel(TVirtualPad*, TObject*, Int_t); virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual Bool_tTGMainFrame::H",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:617,Usability,simpl,simple,617,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:950,Usability,simpl,simple,950,". TGedEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedEditor. class TGedEditor: public TVirtualPadEditor, public TGMainFrame. TGedEditor. The main class of ROOT graphics editor. It manages the appearance; of objects editors according to the selected object in the canvas; (an object became selected after the user click on it using the; left-mouse button). Every object editor provides an object specific GUI and follows a; simple naming convention: it has as a name the object class name; concatinated with 'Editor' (e.g. for TGraph objects the object; editor is TGraphEditor). The ROOT graphics editor can be activated by selecting 'Editor'; from the View canvas menu, or SetLine/Fill/Text/MarkerAttributes; from the context menu. The algorithm in use is simple: according to; the selected object <obj> in the canvas it looks for a class name; <obj>Editor. If a class with this name exists, the editor verifies; that this class derives from the base editor class TGedFrame.; It makes an instance of the object editor, scans all object base; classes searching the corresponding object editors and makes an; instance of the base class editor too. Once the object editor is in; place, it sets the user interface elements according to the object; state and is ready for interactions. When a new object of a; different class is selected, a new object editor is loaded in the; editor frame. The old one is cached in memory for potential reuse. Any created canvas will be shown with the editor if you have a; .rootrc file in your working directory containing the the line:; Canvas.ShowEditor: true. An created object can be set as selected in a macro by:; canvas->Selected(parent_pad_of_object, object, 1);; The first parameter can be the canvas itself or the pad containing; 'object'. //; /*. */. Function Member",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedEditor.html:26792,Usability,simpl,simply,26792,"ditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root/html530/TGedEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedEditor.html
https://root.cern/root/html530/TGedFrame.html:491,Availability,avail,available,491,". TGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedFrame. class TGedFrame: public TGCompositeFrame. TGedFrame. Base frame for implementing GUI - a service class. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidAddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static ",MatchSource.WIKI,root/html530/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedFrame.html
https://root.cern/root/html530/TGedFrame.html:4415,Availability,error,error,4415,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedFrame.html
https://root.cern/root/html530/TGedFrame.html:4499,Availability,error,error,4499,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedFrame.html
https://root.cern/root/html530/TGedFrame.html:17110,Availability,mask,mask,17110,,MatchSource.WIKI,root/html530/TGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedFrame.html
https://root.cern/root/html530/TGedMarkerPopup.html:494,Availability,down,down,494,". TGedMarkerPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedMarkerPopup. class TGedMarkerPopup: public TGedPopup. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); virtual~TGedMarkerPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, v",MatchSource.WIKI,root/html530/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerPopup.html
https://root.cern/root/html530/TGedMarkerPopup.html:4548,Availability,error,error,4548,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerPopup.html
https://root.cern/root/html530/TGedMarkerPopup.html:4632,Availability,error,error,4632,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerPopup.html
https://root.cern/root/html530/TGedMarkerPopup.html:17016,Availability,mask,mask,17016,,MatchSource.WIKI,root/html530/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerPopup.html
https://root.cern/root/html530/TGedMarkerPopup.html:19363,Integrability,message,messages,19363,":fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerPopup(const TGWindow* p, const TGWindow* m, Style_t markerStyle); Create marker popup window. ~TGedMarkerPopup(); Destructor. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by the marker popup window.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TGedMarkerSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedMarkerPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerPopup.html
https://root.cern/root/html530/TGedMarkerSelect.html:498,Availability,down,down,498,". TGedMarkerSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedMarkerSelect. class TGedMarkerSelect: public TGedSelect. TGedMarkerSelect, TGedMarkerPopup. The TGedMarkerPopup is a popup containing buttons to; select marker style. The TGedMarkerSelect widget is a button showing selected marker; and a little down arrow. When clicked on the arrow the; TGedMarkerPopup pops up. Selecting a marker in this widget will generate the event:; kC_MARKERSEL, kMAR_SELCHANGED, widget id, style. and the signal:; MarkerSelected(Style_t marker). Function Members (Methods); public:. TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); virtual~TGedMarkerSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:4585,Availability,error,error,4585,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:4669,Availability,error,error,4669,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:19480,Availability,mask,mask,19480,,MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:21380,Availability,down,down,21380,ame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPictureimage used for popup window; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:22882,Deployability,release,released,22882,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedMarkerSelect.html:23315,Integrability,message,messages,23315,"ndow_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedMarkerSelect(const TGWindow* p, Style_t markerStyle, Int_t id); Create and show marker popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages according to the user input. void DoRedraw(); Draw selected marker type as current one. void SetMarkerStyle(Style_t pattern); Set marker. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. virtual ~TGedMarkerSelect(); { if(fPicture) gClient->FreePicture(fPicture);}. Style_t GetMarkerStyle() const; { return fMarkerStyle; }. void MarkerSelected(Style_t marker = 0); { Emit(""MarkerSelected(Style_t)"", marker ? marker : GetMarkerStyle()); }. TGDimension GetDefaultSize() const; { return TGDimension(38, 21); }.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TGedMarkerSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedMarkerSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html
https://root.cern/root/html530/TGedNameFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedNameFrame.html
https://root.cern/root/html530/TGedNameFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedNameFrame.html
https://root.cern/root/html530/TGedNameFrame.html:17367,Availability,mask,mask,17367,,MatchSource.WIKI,root/html530/TGedNameFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedNameFrame.html
https://root.cern/root/html530/TGedPatternFrame.html:710,Availability,down,down,710,". TGedPatternFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedPatternFrame. class TGedPatternFrame: public TGFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternFrame(const TGWindow* p, Style_t pattern, Int_t width = 40, Int_t height = 20); virtual~TGedPatternFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls);",MatchSource.WIKI,root/html530/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternFrame.html
https://root.cern/root/html530/TGedPatternFrame.html:4643,Availability,error,error,4643,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option",MatchSource.WIKI,root/html530/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternFrame.html
https://root.cern/root/html530/TGedPatternFrame.html:4727,Availability,error,error,4727,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDropType() const; static",MatchSource.WIKI,root/html530/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternFrame.html
https://root.cern/root/html530/TGedPatternFrame.html:15867,Availability,mask,mask,15867,,MatchSource.WIKI,root/html530/TGedPatternFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternFrame.html
https://root.cern/root/html530/TGedPatternPopup.html:712,Availability,down,down,712,". TGedPatternPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedPatternPopup. class TGedPatternPopup: public TGedPopup. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); virtual~TGedPatternPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Clea",MatchSource.WIKI,root/html530/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternPopup.html
https://root.cern/root/html530/TGedPatternPopup.html:4858,Availability,error,error,4858,"it(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternPopup.html
https://root.cern/root/html530/TGedPatternPopup.html:4942,Availability,error,error,4942,"t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTGedPopup::EndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternPopup.html
https://root.cern/root/html530/TGedPatternPopup.html:17304,Availability,mask,mask,17304,,MatchSource.WIKI,root/html530/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternPopup.html
https://root.cern/root/html530/TGedPatternPopup.html:19672,Integrability,message,messages,19672,"p mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternPopup(const TGWindow* p, const TGWindow* m, Style_t pattern); Pattern popup constructor. ~TGedPatternPopup(); Destructor of pattern popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by pattern popup window.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedPatternPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternPopup.html
https://root.cern/root/html530/TGedPatternSelect.html:716,Availability,down,down,716,". TGedPatternSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedPatternSelect. class TGedPatternSelect: public TGedSelect. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); virtual~TGedPatternSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* =",MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:4895,Availability,error,error,4895,"t char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:4979,Availability,error,error,4979,"); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTGedSelect::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virt",MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:19805,Availability,mask,mask,19805,,MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:21636,Availability,down,down,21636,Widthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Style_tfPattern; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:23138,Deployability,release,released,23138,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelect.html:23572,Integrability,message,message,23572," windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelect(const TGWindow* p, Style_t pattern, Int_t id); Create and pop up pattern select window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message according to the user input. void DoRedraw(); Draw selected pattern as current one. void SetPattern(Style_t pattern, Bool_t emit = kTRUE); Set pattern. void SavePrimitive(ostream& out, Option_t* = """"); Save the pattern select widget as a C++ statement(s) on output stream out. Style_t GetPattern() const; { return fPattern; }. virtual ~TGedPatternSelect(); {}. TGDimension GetDefaultSize() const; { return TGDimension(55, 21); }. void PatternSelected(Style_t pattern = 0); { Emit(""PatternSelected(Style_t)"", pattern ? pattern : GetPattern()); }.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedPatternSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html
https://root.cern/root/html530/TGedPatternSelector.html:728,Availability,down,down,728,". TGedPatternSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedPatternSelector. class TGedPatternSelector: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPatternSelector(const TGWindow* p); virtual~TGedPatternSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual",MatchSource.WIKI,root/html530/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelector.html
https://root.cern/root/html530/TGedPatternSelector.html:4817,Availability,error,error,4817,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::",MatchSource.WIKI,root/html530/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelector.html
https://root.cern/root/html530/TGedPatternSelector.html:4901,Availability,error,error,4901,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_t",MatchSource.WIKI,root/html530/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelector.html
https://root.cern/root/html530/TGedPatternSelector.html:17267,Availability,mask,mask,17267,,MatchSource.WIKI,root/html530/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelector.html
https://root.cern/root/html530/TGedPatternSelector.html:19650,Integrability,message,message,19650,"ed in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPatternSelector(const TGWindow* p); Create pattern popup window. ~TGedPatternSelector(); Delete pattern popup window. void SetActive(Int_t newat); Set selected the current style. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process message generated by pattern popup window. Int_t GetActive() const; { return fActive; }.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedPatternSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPatternSelector.html
https://root.cern/root/html530/TGedPopup.html:698,Availability,down,down,698,". TGedPopup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedPopup. class TGedPopup: public TGCompositeFrame. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); virtual~TGedPopup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() co",MatchSource.WIKI,root/html530/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPopup.html
https://root.cern/root/html530/TGedPopup.html:4886,Availability,error,error,4886,"QObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPopup.html
https://root.cern/root/html530/TGedPopup.html:4970,Availability,error,error,4970,"gnal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPopup.html
https://root.cern/root/html530/TGedPopup.html:17286,Availability,mask,mask,17286,,MatchSource.WIKI,root/html530/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPopup.html
https://root.cern/root/html530/TGedPopup.html:19875,Integrability,message,messages,19875,"Object::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedPopup(const TGWindow* p, const TGWindow* m, UInt_t w, UInt_t h, UInt_t options = 0, Pixel_t back = GetDefaultFrameBackground()); Create a popup frame. void EndPopup(); Ungrab pointer and unmap popup window. void PlacePopup(Int_t x, Int_t y, UInt_t w, UInt_t h); Place popup window at the specified place. Bool_t HandleButton(Event_t* event); Handle mouse button event in popup window. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages generated by popup window. virtual ~TGedPopup(); { }.  Author: Marek Biskup, Ilka Antcheva 24/07/03  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id: TGedPatternSelect.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGedPopup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedPopup.html
https://root.cern/root/html530/TGedSelect.html:698,Availability,down,down,698,". TGedSelect. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TGedSelect. class TGedSelect: public TGCheckButton. TGedPatternFrame, TGedPatternSelector, TGedPatternPopup; and TGedPatternColor. The TGedPatternFrame is a small frame with border showing; a specific pattern (fill style. The TGedPatternSelector is a composite frame with TGedPatternFrames; of all diferent styles. The TGedPatternPopup is a popup containing a TGedPatternSelector. The TGedPatternSelect widget is a button with pattern area with; a little down arrow. When clicked on the arrow the; TGedPatternPopup pops up. Selecting a pattern in this widget will generate the event:; kC_PATTERNSEL, kPAT_SELCHANGED, widget id, style. and the signal:; PatternSelected(Style_t pattern). TGedSelect is button that shows popup window when clicked.; TGedPopup is a popup window. Function Members (Methods); public:. TGedSelect(const TGWindow* p, Int_t id); virtual~TGedSelect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); voidTGTextButton::ChangeText(const char* title)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidTGButton::Clicked()SIGNAL ; vir",MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGedSelect.html:4822,Availability,error,error,4822,"t::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGD",MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGedSelect.html:4906,Availability,error,error,4906,"Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCheckButton::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidt",MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGedSelect.html:19576,Availability,mask,mask,19576,,MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGedSelect.html:21378,Availability,down,down,21378,e height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TGedPopup*fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGedSelect.html:22880,Deployability,release,released,22880,eprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*TGCheckButton::fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html530/TGedSelect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGedSelect.html
https://root.cern/root/html530/TGenCollectionProxy.html:4187,Energy Efficiency,allocate,allocate,4187,"Streamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies;",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:8963,Energy Efficiency,allocate,allocated,8963,"of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:9459,Energy Efficiency,allocate,allocated,9459,"CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); Set of functions to iterate easily throught the collection. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);; begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. Next_t GetFunctionNext(Bool_t read = kTRUE); typedef void* (*CopyIterator_t)(void *dest, const void *source);; Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE); typedef void* (*Next_t)(void *iter, const void *end);; iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); typedef void (*DeleteIterator_t)(void *iter);; typedef void (*DeleteTwoIterators_t)(void *begin, void *end);; If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:3818,Performance,cache,cache,3818,"ual voidResize(UInt_t n, Bool_t force_delete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:6265,Safety,avoid,avoid,6265,"tream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initialization of collection proxy. TGenCollectionProxy* InitializeEx(); Some hack to avoid const-ness. void CheckFunctions() const; Allow to check function pointers. TGenCollectionProxy(). TVirtualCollectionProxy* Generate() const; Virtual copy constructor. TGenCollectionProxy(const TGenCollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:489,Security,access,access,489,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncr",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:3838,Security,access,accessors,3838,"ual voidResize(UInt_t n, Bool_t force_delete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:3968,Security,access,accessors,3968,"ual voidResize(UInt_t n, Bool_t force_delete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:4244,Security,access,accessors,4244,"onProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:4376,Security,access,accessors,4376,"onProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:4442,Security,access,accessors,4442,"onProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGen",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:4690,Security,access,accessors,4690,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initializat",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:5288,Security,access,accessors,5288,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initializat",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:5391,Security,access,accessors,5391,"locate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyKeptOptimization: Keep proxies once they were created; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<ROOT::TCollectionProxyInfo::EnvironBase*> >fProxyListStack of recursive proxies; TObjArray*fReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read); void*fResizeContainer accessors: resize container; intfSTL_typeSTL container type; TGenCollectionProxy::MethodfSizeContainer accessors: size of container; vector<TGenCollectionProxy::TStaging*,allocator<TGenCollectionProxy::TStaging*> >fStagedOptimization: Keep staged array once they were created; type_info&fTypeinfoType information; TGenCollectionProxy::Value*fValDescriptor of the Value_type; intfValDiffOffset between two consecutive value_types (memory layout).; intfValOffsetOffset from key to value (in maps); TGenCollectionProxy::Value*fValueDescriptor of the container value type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeleteItem(void* ptr); Delete individual item from STL container. s. Streamer(TBuffer& refBuffer). s. Streamer(TBuffer& refBuffer). else s-> Clear(). void Resize(size_t nelement). TGenCollectionProxy* Initialize() const; Late initializat",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:629,Usability,clear,clear,629,". TGenCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy. class TGenCollectionProxy: public TVirtualCollectionProxy. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. TGenCollectionProxy(const TGenCollectionProxy& copy); TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual~TGenCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void* env); virtual voidTVirtualCollectionProxy::DeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidTVirtualCollectionProxy::Destructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncr",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:3849,Usability,clear,clear,3849,"ual voidResize(UInt_t n, Bool_t force_delete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize() const; virtual TGenCollectionProxy*InitializeEx(). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy.html:7461,Usability,simpl,simple,7461,"CollectionProxy& copy); Copy constructor. TGenCollectionProxy(TGenCollectionProxy::Info_t typ, size_t iter_size); Initializing constructor. TGenCollectionProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl). virtual ~TGenCollectionProxy(); Standard destructor. TClass * GetCollectionClass(); Return a pointer to the TClass representing the container. Int_t GetCollectionType(); Return the type of collection see TClassEdit::ESTLType. ULong_t GetIncrement(); Return the offset between two consecutive value_types (memory layout). UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objstart); Push new proxy environment. void PopProxy(); Pop old proxy environment. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. void SetValueClass(TClass* newcl); Set pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete); Block allocation of containees. void Commit(void* env); Block commit of containees. void operator()(TBuffer& refBuffer, void* pObject); TClassStreamer I/O overload. void ReadBuffer(TBuffer& b, void* obj); Routine to read the content of the buffer into 'obj'. void ReadBuffer(TBuffer& b, void* obj, const TClass* onfileClass). void SetOnFileClass(TClass* cl); { fOnFileClass = cl; }. TClass* GetOnFileClass() const; { return fOnFileClass; }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_",MatchSource.WIKI,root/html530/TGenCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy.html
https://root.cern/root/html530/TGenCollectionProxy__Method.html:481,Security,access,access,481,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method&). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. void* invoke(void* obj) const; { return (*call)(obj); }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Method.html
https://root.cern/root/html530/TGenCollectionProxy__Method.html:621,Usability,clear,clear,621,". TGenCollectionProxy::Method. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Method. class TGenCollectionProxy::Method. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Method(); void*invoke(void* obj) const; TGenCollectionProxy::MethodMethod(); TGenCollectionProxy::MethodMethod(TGenCollectionProxy::Method::Call_t c); TGenCollectionProxy::MethodMethod(const TGenCollectionProxy::Method& m); TGenCollectionProxy::Method&operator=(const TGenCollectionProxy::Method&). Data Members; public:. TGenCollectionProxy::Method::Call_tcall. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Method(); { }. Method(Call_t c); { }. Method(const Method& m); { }. void* invoke(void* obj) const; { return (*call)(obj); }.  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Method.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Method.html
https://root.cern/root/html530/TGenCollectionProxy__Value.html:1048,Performance,cache,cache,1048,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid().  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html
https://root.cern/root/html530/TGenCollectionProxy__Value.html:1100,Performance,cache,cache,1100,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid().  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html
https://root.cern/root/html530/TGenCollectionProxy__Value.html:1145,Performance,cache,cache,1145,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid().  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html
https://root.cern/root/html530/TGenCollectionProxy__Value.html:478,Security,access,access,478,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid().  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html
https://root.cern/root/html530/TGenCollectionProxy__Value.html:618,Usability,clear,clear,618,". TGenCollectionProxy::Value. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TGenCollectionProxy::Value. class TGenCollectionProxy::Value. TGenCollectionProxy. Proxy around an arbitrary container, which implements basic; functionality and iteration. In particular this is used to implement splitting and abstract; element access of any container. Access to compiled code is necessary; to implement the abstract iteration sequence and functionality like; size(), clear(), resize(). resize() may be a void operation. Function Members (Methods); public:. ~Value(); voidDeleteItem(void* ptr); Bool_tIsValid(); TGenCollectionProxy::Value&operator=(const TGenCollectionProxy::Value&); TGenCollectionProxy::ValueValue(const TGenCollectionProxy::Value& inside); TGenCollectionProxy::ValueValue(const string& info). Data Members; public:. unsigned intfCasetype of data of Value_type; void*fCtorMethod cache for containee constructor; void*fDeleteMethod cache for containee delete; void*fDtorMethod cache for containee destructor; EDataTypefKindkind of ROOT-fundamental type; size_tfSizefSize of the contained object; TClassReffTypeTClass reference of Value_type in collection. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Value(const Value& inside); Copy constructor. Value(const std::string& info); Initializing constructor. void DeleteItem(void* ptr); Delete individual item from STL container. Bool_t IsValid().  Author: Markus Frank 28/10/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id: TGenCollectionProxy.h 38934 2011-04-19 20:26:28Z pcanal $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenCollectionProxy__Value.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenCollectionProxy__Value.html
https://root.cern/root/html530/TGenerator.html:4642,Availability,error,error,4642,,MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:4726,Availability,error,error,4726,"""); virtual~TGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*GetListOfParticles() const; virtual const char*TNamed::GetName() const; Int_tGetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetParameter(const char*) const; virtual TParticle*GetParticle(Int_t i) const; virtual TObjArray*GetPrimaries(Option_t* option = """"); Float_tGetPtCut() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:341,Integrability,interface,interface,341,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MONTECARLO;  EG;  TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various 	; event generators. Every event generator should inherit from 	; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:1753,Integrability,interface,interfaces,1753,"articles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerat",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:10230,Integrability,rout,routine,10230,"ts { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TObjArray*fParticles->static container of the primary particles; Float_tfPtCut!Pt cut. Do not show primaries below; Bool_tfShowNeutrons!display neutrons if true; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =============",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:10693,Integrability,rout,routine,10693,"eobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenerator(const char* name, const char* title = ""Generator class""); Event generator default constructor. ~TGenerator(); Event generator default destructor. void GenerateEvent(); must be implemented in concrete class (see eg TPythia6). TObjArray* ImportParticles(Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The default action is to store only the stable particles (ISTHEP =; 1) This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"). It reads the /HEPEVT/ common block which has been filled by the; GenerateEvent method. If the event generator does not use the; HEPEVT common block, This routine has to be overloaded by the; subclasses. The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles. The default; action is to store only the stable particles (ISTHEP = 1) This can; be demanded explicitly by setting the option = ""Final"" If the; option = ""All"", all the particles are stored. void Browse(TBrowser* b); browse generator. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*Compute distance from point px,py to objects in event; *-* =====================================================; -. void Draw(Option_t* option = """"). Insert one event in the pad list. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================. Int_t GetNumberOfParticles() const; Return the number of particles in the stack. TParticle * GetParticle(Int_t i) const; Returns pointer to primary number i;. void Paint(Option_t* option = """"). ",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:420,Modifiability,inherit,inherit,420,". TGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MONTECARLO;  EG;  TGenerator. class TGenerator: public TNamed. TGenerator. Is an base class, that defines the interface of ROOT to various 	; event generators. Every event generator should inherit from 	; TGenerator or its subclasses. Derived class can overload the member function GenerateEvent; to do the actual event generation (e.g., call PYEVNT or similar). The derived class should overload the member function; ImportParticles (both types) to read the internal storage of the; generated event into either the internal TObjArray or the passed; TClonesArray of TParticles. If the generator code stores event data in the /HEPEVT/ common block; Then the default implementation of ImportParticles should suffice.; The common block /HEPEVT/ is structed like. C; typedef struct {; Int_t nevhep; // Event number; Int_t nhep; // # of particles; Int_t isthep[4000]; // Status flag of i'th particle; Int_t idhep[4000]; // PDG # of particle; Int_t jmohep[4000][2]; // 1st & 2nd mother particle #	; Int_t jdahep[4000][2]; // 1st & 2nd daughter particle #; Double_t phep[4000][5]; // 4-momentum and 1 word; Double_t vhep[4000][4]; // 4-position of production; } HEPEVT_DEF;. C Fortran; COMMON/HEPEVT/NEVHEP,NHEP,ISTHEP(4000),IDHEP(4000),; + JMOHEP(2,4000),JDAHEP(2,4000),PHEP(5,4000),VHEP(4,4000); INTEGER NEVHEP,NHEP,ISTHEP,IDHEP,JMOHEP,JDAHEP; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:2639,Performance,load,loaded,2639,"meter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially useful for example with TVirtualMC or similar. Function Members (Methods); public:. T",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:2598,Safety,safe,safe,2598,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenerator.html:2557,Security,access,accessing,2557,"P; DOUBLE PRECISION PHEP,VHEP. The generic member functions SetParameter and GetParameter can be; overloaded to set and get parameters of the event generator. Note, if the derived class interfaces a (set of) Fortran common; blocks (like TPythia, TVenus does), one better make the derived; class a singleton. That is, something like. class MyGenerator : public TGenerator; {; public:; static MyGenerator* Instance(); {; if (!fgInstance) fgInstance = new MyGenerator;; return fgInstance;; }; void GenerateEvent() { ... }; void ImportParticles(TClonesArray* a, Option_t opt="""") {...}; Int_t ImportParticles(Option_t opt="""") { ... }; Int_t SetParameter(const char* name, Double_t val) { ... }; Double_t GetParameter(const char* name) { ... }; virtual ~MyGenerator() { ... }; protected:; MyGenerator() { ... }; MyGenerator(const MyGenerator& o) { ... }; MyGenerator& operator=(const MyGenerator& o) { ... }; static MyGenerator* fgInstance;; ClassDef(MyGenerator,0);; };. Having multiple objects accessing the same common blocks is not; safe. concrete TGenerator classes can be loaded in scripts and subseqent-; ly used in compiled code:. MyRun.h; class MyRun : public TObject; {; public:; static MyRun* Instance() { ... }; void SetGenerator(TGenerator* g) { fGenerator = g; }; void Run(Int_t n, Option_t* option=""""); {; TFile* file = TFile::Open(""file.root"",""RECREATE"");; TTree* tree = new TTree(""T"",""T"");; TClonesArray* p = new TClonesArray(""TParticles"");; tree->Branch(""particles"", &p);; for (Int_t event = 0; event < n; event++) {; fGenerator->GenerateEvent();; fGenerator->ImportParticles(p,option);; tree->Fill();; }; file->Write();; file->Close();; }. protected:; TGenerator* fGenerator;; ClassDef(MyRun,0);; };. Config.C; void Config(); {; MyRun* run = MyRun::Instance();; run->SetGenerator(MyGenerator::Instance());; }. main.cxx; int; main(int argc, char** argv); {; TApplication app("""", 0, 0);; gSystem->ProcessLine("".x Config.C"");; MyRun::Instance()->Run(10);; return 0;; }. This is especially us",MatchSource.WIKI,root/html530/TGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenerator.html
https://root.cern/root/html530/TGenericTable.html:4959,Availability,error,error,4959,"ed) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:5043,Availability,error,error,5043,"stRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorend(); TGenericTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:16763,Energy Efficiency,allocate,allocated,16763,"st char*TTable::fgTypeName[13]. protected:. TTableDescriptor*fColDescriptors; TSeqCollection*TDataSet::fListList of the the the objects included into this dataset; Long_tTTable::fMaxIndexThe used capacity of this array; Int_tTTable::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:16998,Energy Efficiency,allocate,allocated,16998,"::fNNumber of array elements; TStringTNamed::fNameobject identifier; TDataSet*TDataSet::fParentpointer to mother of the directory; Long_tTTable::fSizeSize of the one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTab",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:17220,Energy Efficiency,allocate,allocated,17220,"f (fN*fSize) longs; TStringTNamed::fTitleobject title; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGenericTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. T",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:17433,Energy Efficiency,allocate,allocated,17433,"ricTable(const TTableDescriptor& dsc, const char* name). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object. TGenericTable(const TTableDescriptor& dsc, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < G",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:17664,Energy Efficiency,allocate,allocated,17664," Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - ""TGenericTable""; n - The initial number of allocated rows. TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n). Create TGenericTable by TTableDescriptor pointer:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator b",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:2088,Modifiability,variab,variable,2088,"the generic table for 1000 rows (it may grow then); ! TGenericTable *allStaff = new TGenericTable(""staff_t"",""Staff-data"",1000);; !; ! // Fill the memory resident table; ! while (fgets(&line,80,fp)) {; ! sscanf(&line[0] ,""%d%d%d%d"", &staff.cat,&staff.division,&staff.flag,&staff.age);; ! sscanf(&line[13],""%d%d%d%d"", &staff.service,&staff.children,&staff.grade,&staff.step);; ! sscanf(&line[24],""%d%d%d"", &staff.nation,&staff.hrweek,&staff.cost);; ! allStaff->AddAt(&staff);; ! }; ! fclose(fp);; ! // Delete unused space;; ! allStaff->Purge();; !; ! allStaff->Print(0,10);; !; !// Create ROOT file; ! TFile *f = new TFile(""aptuple.root"",""RECREATE"");; ! allStaff->Write();; ! f->Write();; !; ! // We should close TFile otherwise all histograms we create below; ! // may be written to the file too occasionaly; ! f->Close();; !; !// Create ROOT Browser; ! new TBrowser(""staff"",allStaff);; !; !// Create couple of the histograms; ! TCanvas *canva = new TCanvas(""Staff"",""CERN Population"",600,600);; ! canva->Divide(1,2);; !; !; !// one can use 2 meta variable:; !// n$ - the total number of the rows in the table; !// i$ - stands for the current row index i = [0 -> (n$-1)]; !; ! gStyle->SetHistFillColor(10);; ! gStyle->SetHistFillStyle(3013);; ! canva->cd(1);; ! allStaff->Draw(""age"");; ! canva->Update();; ! canva->cd(2);; ! allStaff->Draw(""cost"");; ! canva->Update();; !}. Function Members (Methods); public:. TGenericTable(); TGenericTable(const TGenericTable&); TGenericTable(const char* structName, const char* name); TGenericTable(const char* structName, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name); TGenericTable(const TTableDescriptor& dsc, Int_t n); TGenericTable(const char* structName, const char* name, Int_t n); TGenericTable(const TTableDescriptor& dsc, const char* name, Int_t n); virtual~TGenericTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tTTable::AddAt(const void* c); virtual void",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:18372,Testability,assert,assert,18372,"e table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}.  Last changed: root/table:$Id: TGenericTable.h 27157 2009-01-15 14:05:12Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenericTable.html:18470,Testability,assert,assert,18470,"e table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. TGenericTable(const char* structName, const char* name, Int_t n). Create TGenericTable by C structure name provided:. dsc - Pointer to the table descriptor; name - The name of this object; n - The initial number of allocated rows. ~TGenericTable(); destructor. TTableDescriptor * GetDescriptorPointer() const; { return fColDescriptors;}. void SetDescriptorPointer(TTableDescriptor* list); { fColDescriptors = list;}. void SetGenericType(); { TTable::SetType(GetDescriptorPointer()->GetName()); }. TGenericTable(); {SetType(""generic"");}. TGenericTable(const char* structName, const char* name); Create TGenericTable by C structure name provided. char * GetTable(Int_t i = 0) const; { return ((char *)GetArray())+i*GetRowSize();}. TTableDescriptor * GetTableDescriptors() const; { return GetDescriptorPointer();}. TTableDescriptor * GetRowDescriptors() const; { return GetDescriptorPointer();}. char & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const char & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const char *)(GetTable(i))); }. iterator begin(); { return ((const TGenericTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*this, *GetTable(0)):end();}. iterator end(); { return ((const TGenericTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*this, *GetTable(i)):iterator(*this);}.  Last changed: root/table:$Id: TGenericTable.h 27157 2009-01-15 14:05:12Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenericTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenericTable.html
https://root.cern/root/html530/TGenPhaseSpace.html:1873,Availability,error,error,1873,"enPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:1957,Availability,error,error,1957," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGenerate(); TLorentzVector*GetDecay(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWtMax() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:400,Energy Efficiency,energy,energy,400,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:6086,Energy Efficiency,energy,energy,6086,"od, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross se",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:7016,Energy Efficiency,energy,energy,7016,"le_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}.  Last changed: root/physics:$Id: TGenPhaseSpace.h 38051 2011-02-11 14:30:29Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:407,Integrability,depend,dependence,407,". TGenPhaseSpace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TGenPhaseSpace. class TGenPhaseSpace: public TObject. Utility class to generate n-body event,; with constant cross-section (default); or with Fermi energy dependence (opt=""Fermi"").; The event is generated in the center-of-mass frame,; but the decay products are finally boosted; using the betas of the original particle. The code is based on the GENBOD function (W515 from CERNLIB); using the Raubold and Lynch method; F. James, Monte Carlo Phase Space, CERN 68-15 (1968). see example of use in $ROOTSYS/tutorials/physics/PhaseSpace.C. Note that Momentum, Energy units are Gev/C, GeV. Function Members (Methods); public:. TGenPhaseSpace(); TGenPhaseSpace(const TGenPhaseSpace& gen); virtual~TGenPhaseSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEven",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGenPhaseSpace.html:7023,Integrability,depend,dependece,7023,"le_tPDK(Double_t a, Double_t b, Double_t c). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfBeta[3]betas of decaying particle; TLorentzVectorfDecPro[18]kinematics of the generated particles ; Double_tfMass[18]masses of particles; Int_tfNtnumber of decay particles; Double_tfTeCmTmtotal energy in the C.M. minus the total mass; Double_tfWtMaxmaximum weigth . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t PDK(Double_t a, Double_t b, Double_t c); the PDK function. TGenPhaseSpace(const TGenPhaseSpace& gen); copy constructor. Double_t Generate(); Generate a random final state.; The function returns the weigth of the current event.; The TLorentzVector of each decay product can be obtained using GetDecay(n). Note that Momentum, Energy units are Gev/C, GeV. TLorentzVector * GetDecay(Int_t n); return Lorentz vector corresponding to decay n. Bool_t SetDecay(TLorentzVector& P, Int_t nt, const Double_t* mass, Option_t* opt = """"); input:; TLorentzVector &P: decay particle (Momentum, Energy units are Gev/C, GeV); Int_t nt: number of decay products; Double_t *mass: array of decay product masses; Option_t *opt: default -> constant cross section; ""Fermi"" -> Fermi energy dependece; return value:; kTRUE: the decay is permitted by kinematics; kFALSE: the decay is forbidden by kinematics. TGenPhaseSpace(); {}. virtual ~TGenPhaseSpace(); {}. Int_t GetNt() const; { return fNt;}. Double_t GetWtMax() const; { return fWtMax;}.  Last changed: root/physics:$Id: TGenPhaseSpace.h 38051 2011-02-11 14:30:29Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGenPhaseSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGenPhaseSpace.html
https://root.cern/root/html530/TGeoArb8.html:3568,Availability,error,error,3568,"* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const;",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:3652,Availability,error,error,3652,"virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:2638,Safety,safe,safe,2638,"hape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* para",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:2779,Safety,safe,safe,2779,"es = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidComputeTwist(); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:14560,Safety,safe,safe,14560,"if the vertices are defined; clockwise or anti-clockwise. Double_t GetTwist(Int_t iseg) const; Get twist for segment I in range [0,3]. Double_t GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t*",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:14755,Safety,safe,safe,14755,"t_t& isegment) const; Get index of the edge of the quadrilater represented by vert closest to point.; If [P1,P2] is the closest segment and P is the point, the function returns the fraction of the; projection of (P1P) over (P1P2). If projection of P is not in range [P1,P2] return -1. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; Test if point is inside this shape.; first check Z range. Double_t DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; Computes distance to plane ipl :; ipl=0 : points 0,4,1,5; ipl=1 : points 1,5,2,6; ipl=2 : points 2,6,3,7; ipl=3 : points 3,7,0,4. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Computes distance from outside point to surface of the shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide this shape along one axis. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get shape range on a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2; --- first compute rmin/rmax. Int_t GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of inde",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:16328,Safety,safe,safety,16328,"at, Double_t& dx, Double_t& dy, Double_t& dz) const; Fills real parameters of a positioned box inside this arb8. Returns 0 if successfull. void GetPlaneNormal(Double_t* p1, Double_t* p2, Double_t* p3, Double_t* norm); Computes normal to plane defined by P1, P2 and P3. Bool_t GetPointsOnFacet(Int_t , Int_t , Double_t* ) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t InsidePolygon(Double_t x, Double_t y, Double_t* pts); Finds if a point in XY plane is inside the polygon defines by PTS. void InspectShape() const; Prints shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. Double_t SafetyToFace(Double_t* point, Int_t iseg, Bool_t in) const; Estimate safety to lateral plane defined by segment iseg in range [0,3]; Might be negative: plane seen only from inside. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPlaneVertices(Double_t zpl, Double_t* vertices) const; Computes intersection points between plane at zpl and non-horizontal edges. void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = x0; param[2] = y0. void SetPoints(Double_t* points) const; Creates arb8 mesh points. void SetPoints(Float_t* points) const; Creates arb8 mesh points. void SetVertex(Int_t vnum, Double_t x, Double_t y); Set values for a given vertex. void Sizeof3D() const; Fill size of this 3-D object. void Streamer(TBuffer& b); Stream an object of class TGeoManager. Int_t GetByteCount() const; {return 100;}. Double_t GetDz() const; {return fDz;}. TGeoShape * GetMakeRuntimeShape(TGeoShape* , TGeoMatrix* ) const; {return 0;}. Double_t * GetVertices(); {return &",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoArb8.html:1761,Testability,test,testNo,1761," TGeoArb8(); TGeoArb8(Double_t dz, Double_t* vertices = 0); TGeoArb8(const char* name, Double_t dz, Double_t* vertices = 0); virtual~TGeoArb8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; v",MatchSource.WIKI,root/html530/TGeoArb8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoArb8.html
https://root.cern/root/html530/TGeoAtt.html:3124,Performance,optimiz,optimization,3124,"{ kUseBoundingBox; kUseVoxels; kUseGsord; };; enum EGeoSavePrimitiveAtt { kSavePrimitiveAtt; kSaveNodesAtt; };. protected:. UInt_tfGeoAttoption flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoAtt(); Default constructor. TGeoAtt(Option_t* vis_opt, Option_t* activity_opt = """", Option_t* optimization_opt = """"); Constructor. ~TGeoAtt(); Destructor. void SetVisBranch(); Set branch type visibility. void SetVisContainers(Bool_t flag = kTRUE); Set branch type visibility. void SetVisLeaves(Bool_t flag = kTRUE); Set branch type visibility. void SetVisOnly(Bool_t flag = kTRUE); Set branch type visibility. void SetVisibility(Bool_t vis = kTRUE); Set visibility for this object. void SetVisDaughters(Bool_t vis = kTRUE); Set visibility for the daughters. void SetVisStreamed(Bool_t vis = kTRUE); Mark attributes as ""streamed to file"". void SetVisTouched(Bool_t vis = kTRUE); Mark visualization attributes as ""modified"". void SetOptimization(Option_t* option); Set optimization flags. TGeoAtt(); constructors. void SetAttBit(UInt_t f); methods. {fGeoAtt |= f & kBitMask;}. void SetAttBit(UInt_t f, Bool_t set); {(set)?SetAttBit(f):ResetAttBit(f);}. void ResetAttBit(UInt_t f); {fGeoAtt &= ~(f & kBitMask);}. Bool_t TestAttBit(UInt_t f) const; {return (Bool_t)((fGeoAtt & f) != 0);}. void SetVisRaytrace(Bool_t flag = kTRUE); {SetAttBit(kVisRaytrace, flag);}. void SetActivity(Bool_t flag = kTRUE); {SetAttBit(kActThis, flag);}. void SetActiveDaughters(Bool_t flag = kTRUE); {SetAttBit(kActDaughters,flag);}. Bool_t IsActive() const; {return TestAttBit(kActThis);}. Bool_t IsActiveDaughters() const; {return TestAttBit(kActDaughters);}. Bool_t IsVisRaytrace() const; {return TestAttBit(kVisRaytrace);}. Bool_t IsVisible() const; {return TestAttBit(kVisThis);}. Bool_t IsVisDaughters() const; {return TestAttBit(kVisDaughters);}. Bool_t IsVisBranch() const; {return TestAttBit(kVisBranch);}. Bool_t IsVisContainers() const; {return TestAttBit(kVisContain",MatchSource.WIKI,root/html530/TGeoAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoAtt.html
https://root.cern/root/html530/TGeoBatemanSol.html:1849,Availability,error,error,1849,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMark",MatchSource.WIKI,root/html530/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBatemanSol.html
https://root.cern/root/html530/TGeoBatemanSol.html:1933,Availability,error,error,1933,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tConcentration(Double_t time) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindSolution(const TObjArray* array); voidGetCoeff(Int_t i, Double_t& cn, Double_t& lambda) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElementRN*GetElement() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; Int_tGetNcoeff() const",MatchSource.WIKI,root/html530/TGeoBatemanSol.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBatemanSol.html
https://root.cern/root/html530/TGeoBBox.html:4793,Availability,error,error,4793,"ble_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:4877,Availability,error,error,4877," TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoMatrix* mat, Double_t& dx, Double_t& dy, Double_t& dz) const; virtual const char*TObj",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:330,Modifiability,inherit,inherit,330,". TGeoBBox. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoBBox. class TGeoBBox: public TGeoShape. TGeoBBox - box class. All shape primitives inherit from this, their; constructor filling automatically the parameters of the box that bounds; the given shape. Defined by 6 parameters :; fDX, fDY, fDZ - half lengths on X, Y and Z axis; fOrigin[3] - position of box origin. --- Building boxes. Normally a box has to be build only with 3 parameters : dx, dy, dz; representing the half lengths on X, Y and Z axis. In this case, the origin; of the box will match the one of its reference frame. The translation of the; origin is used only by the constructors of all other shapes in order to; define their own bounding boxes. Users should be aware that building a; translated box that will represent a physical shape by itself will affect any; further positioning of other shapes inside. Therefore in order to build a; positioned box one should follow the recipe described in class TGeoNode. Creation of boxes; 1. TGeoBBox *box = new TGeoBBox(""BOX"", 20, 30, 40);. /*. */. 2. A volume having a box shape can be built in one step:; TGeoVolume *vbox = gGeoManager->MakeBox(""vbox"", ptrMed, 20,30,40);. Divisions of boxes. Volumes having box shape can be divided with equal-length slices on; X, Y or Z axis. The following options are supported:; a) Dividing the full range of one axis in N slices; TGeoVolume *divx = vbox->Divide(""SLICEX"", 1, N);; - here 1 stands for the division axis (1-X, 2-Y, 3-Z). /*. */. b) Dividing in a limited range - general case.; TGeoVolume *divy = vbox->Divide(""SLICEY"",2,N,start,step);; - start = starting offset within (-fDY, fDY); - step = slicing step. /*. */. Both cases are supported by all shapes.; See also class TGeoShape for utility methods provided by any particular; shape. Function ",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:3593,Safety,safe,safe,3593,"_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() c",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:3909,Safety,safe,safe,3909,"are(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; static Bool_tContains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:14826,Safety,safe,safe,14826," Bool_t CouldBeCrossed(Double_t* point, Double_t* dir) const; Decides fast if the bounding box could be crossed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get ra",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:14911,Safety,safe,safe,14911,"ed by a vector. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with th",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:15164,Safety,safe,safe,15164,"s box shape belonging to volume ""voldiv"" into ndiv equal volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - f",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:15297,Safety,safe,safe,15297,"e given step. Returns pointer; to created division cell volume. In case a wrong division axis is supplied,; returns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; F",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:15383,Safety,safe,safe,15383,"turns pointer to volume to be divided. void ComputeBBox(); Compute bounding box - nothing to do in this case. Bool_t Contains(Double_t* point) const; Test if point is inside this shape. Bool_t Contains(const Double_t* point, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided w",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:15638,Safety,safe,safe,15638,"le_t dz, const Double_t* origin); Test if point is inside this shape. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from inside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to surface of the box.; Boundary safe algorithm. Double_t DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); Compute distance from outside point to surface of the box.; Boundary safe algorithm. const char * GetAxisName(Int_t iaxis) const; Returns name of axis IAXIS. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. Double_t GetFacetArea(Int_t index = 0) const; Get area in internal units of the facet with a given index.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnFacet(Int_t index, Int_t npoints, Double_t* array) const; Fills array with n random points located on the surface of indexed facet.; The output array must be provided with a length of minimum 3*npoints. Returns; true if operation succeeded.; Possible index values:; 0 - all facets togeather; 1 to 6 - facet index from bottom to top Z. Bool_t GetPointsOnSegments(Int_t npoints, Double_t* array) const; Fills array with n ran",MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBox.html:2647,Testability,test,testNo,2647,,MatchSource.WIKI,root/html530/TGeoBBox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBox.html
https://root.cern/root/html530/TGeoBBoxEditor.html:4607,Availability,error,error,4607,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html
https://root.cern/root/html530/TGeoBBoxEditor.html:4691,Availability,error,error,4691,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html
https://root.cern/root/html530/TGeoBBoxEditor.html:18018,Availability,mask,mask,18018,,MatchSource.WIKI,root/html530/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html
https://root.cern/root/html530/TGeoBBoxEditor.html:21426,Usability,undo,undoing,21426,"nst TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBBoxEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoBBoxEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBBoxEditor.html
https://root.cern/root/html530/TGeoBoolNode.html:1341,Availability,avail,available,1341,"n operations between two shapes. A Boolean node describes a Boolean operation between 'left' and 'right'; shapes positioned with respect to an ARBITRARY reference frame. The boolean; node is referenced by a mother composite shape and its shape components may; be primitive but also composite shapes. The later situation leads to a binary; tree hierarchy. When the parent composite shape is used to create a volume,; the reference frame of the volume is chosen to match the frame in which; node shape components were defined. The positioned shape components may or may not be disjoint. The specific; implementations for Boolean nodes are:. TGeoUnion - representing the Boolean union of two positioned shapes. TGeoSubtraction - representing the Boolean subtraction of two positioned; shapes. TGeoIntersection - representing the Boolean intersection of two positioned; shapes. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0)",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:2823,Availability,error,error,2823,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; v",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:2907,Availability,error,error,2907,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*GetRightMatrix() const; TGeoShape*GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:2325,Safety,safe,safe,2325," virtual~TGeoBoolNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual ",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:2451,Safety,safe,safe,2451," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*GetLeftMatrix() const; TGeoShape*GetLeftShape() const; virtua",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:8766,Safety,safe,safe,8766,"ass. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetSelected(Int_t sel); {fSelected = sel;}. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}.  Author: Andrei Gheata 30/05/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBoolNode.html:9272,Safety,safe,safe,9272,"ass. Bool_t MakeBranch(const char* expr, Bool_t left); Expands the boolean expression either on left or right branch, creating; component elements (composite shapes and boolean nodes). Returns true on success. void Paint(Option_t* option); Special schema for feeding the 3D buffers to the painter client. void RegisterMatrices(); Register all matrices of the boolean node and descendents. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetPoints(Double_t* points) const; Fill buffer with shape vertices. void SetPoints(Float_t* points) const; Fill buffer with shape vertices. void Sizeof3D() const; Register size of this 3D object. TGeoBoolNode& operator=(const TGeoBoolNode& ). void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); methods. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm). Bool_t Contains(Double_t* point) const. Int_t DistanceToPrimitive(Int_t px, Int_t py). Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const. EGeoBoolType GetBooleanOperator() const. Int_t GetNpoints(). TGeoMatrix * GetLeftMatrix() const; {return fLeftMat;}. TGeoMatrix * GetRightMatrix() const; {return fRightMat;}. TGeoShape * GetLeftShape() const; {return fLeft;}. TGeoShape * GetRightShape() const; {return fRight;}. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const. void SetSelected(Int_t sel); {fSelected = sel;}. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; {return kGeoUnion;}.  Author: Andrei Gheata 30/05/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoBoolNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBoolNode.html
https://root.cern/root/html530/TGeoBranchArray.html:1890,Availability,error,error,1890,"t; voidAddLevel(UShort_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UShort_t*GetArray() const; TObject*GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; UShort_tGetLevel() const; TGeoHMatrix*GetMatrix() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(UShort_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTim",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBranchArray.html:1974,Availability,error,error,1974,"""""); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UShort_t*GetArray() const; TObject*GetClient() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; UShort_tGetLevel() const; TGeoHMatrix*GetMatrix() const; virtual const char*TObject::GetName() const; TGeoNode*GetNode(UShort_t level) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPath(TString& path) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const ch",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBranchArray.html:5336,Availability,down,down,5336,"tr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(const TGeoBranchArray& other) const; Bool_toperator<(const TGeoBranchArray& other) const; Bool_toperator<=(const TGeoBranchArray& other) const; TGeoBranchArray&operator=(const TGeoBranchArray&); Bool_toperator==(const TGeoBranchArray& other) const; Bool_toperator>(const TGeoBranchArray& other) const; Bool_toperator>=(const TGeoBranchArray& other) const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetClient(TObject* client); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); static voidSort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateNavigator(TGeoNavigator* nav) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBranchArray.html:7794,Availability,down,down,7794,"evel. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(UShort_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. TGeoNode * GetNode(UShort_t level) const. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of branch array pointers. void UpdateNavigator(TGeoNavigator* nav) const; Update the navigator to reflect the branch. TGeoBranchArray(); {}. UShort_t * GetArray() const; {return fArray;}. TObject * GetClient() const; {return fClient;}. UShort_t GetLevel() const; {return fLevel;}. TGeoHMatrix * GetMatrix() const; {return fMatrix;}. Bool_t IsSortable() const; {return kTRUE;}. Bool_t Notify(); {return (fClient)?fClient->Notify():kFALSE;}. void SetClient(TObject* client); {fClient = client;}.  Author: Andrei Gheata 01/03/11  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBranchArray.h 38636 2011-03-26 07:14:47Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBranchArray.html:620,Deployability,update,updated,620,". TGeoBranchArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoBranchArray. class TGeoBranchArray: public TObject. TGeoBranchArray - An array of daughter indices making a geometry path.; Can be used to backup/restore a state. To setup an object of this type,; one should use:; TGeoBranchArray *array = new TGeoBranchArray(level);; array->InitFromNavigator(nav); (To initialize from current navigator state); The navigator can be updated to reflect this path array:; array->UpdateNavigator();. Function Members (Methods); public:. TGeoBranchArray(); TGeoBranchArray(UShort_t level); TGeoBranchArray(const TGeoBranchArray&); virtual~TGeoBranchArray(); voidTObject::AbstractMethod(const char* method) const; voidAddLevel(UShort_t dindex); virtual voidTObject::AppendPad(Option_t* option = """"); static Long64_tBinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanMatrix(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBranchArray.html:6948,Performance,perform,performed,6948,"dTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UShort_t*fArray[fLevel] Array of daughter indices; TObject*fClientClient object to notify; UShort_tfLevelBranch depth; TGeoHMatrix*fMatrixGlobal matrix (owned). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBranchArray(UShort_t level); Constructor. Alocates the array with a size given by level. ~TGeoBranchArray(); Destructor. TGeoBranchArray(const TGeoBranchArray& ); Copy constructor. TGeoBranchArray& operator=(const TGeoBranchArray& ); Assignment. void AddLevel(UShort_t dindex); Add and extra daughter to the current path array. No validity check performed !. Long64_t BinarySearch(Long64_t n, const TGeoBranchArray** array, TGeoBranchArray* value); Binary search in an array of n pointers to branch arrays, to locate value.; Returns element index or index of nearest element smaller than value. Int_t Compare(const TObject* obj) const; Compare with other object of same type. Returns -1 if this is smaller (first; smaller array value prevails), 0 if equal (size and values) and 1 if this is; larger. void CleanMatrix(); Garbage collect the stored matrix. TGeoNode * GetNode(UShort_t level) const. void InitFromNavigator(TGeoNavigator* nav); Init the branch array from current navigator state. void GetPath(TString& path) const; Fill path pointed by the array. void Print(Option_t* option = """") const; Print branch information. void Sort(Int_t n, TGeoBranchArray** array, Int_t* index, Bool_t down = kTRUE); Sorting of an array of branch array pointers. void UpdateNavigator(TGeoNavigator* nav) const; Update the navigator to reflect the branch",MatchSource.WIKI,root/html530/TGeoBranchArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBranchArray.html
https://root.cern/root/html530/TGeoBuilder.html:1814,Availability,error,error,1814,"ject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:1898,Availability,error,error,1898,"atic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:17584,Deployability,continuous,continuous,17584,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:17507,Energy Efficiency,energy,energy,17507,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:4428,Integrability,rout,rout,4428,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, ",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:12316,Integrability,rout,rout,12316,"hemax = 180, Double_t phimin = 0, Double_t phimax = 360); Make in one step a volume pointing to a sphere shape with given medium. TGeoVolume * MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Make in one step a volume pointing to a torus shape with given medium. TGeoVolume * MakeTube(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeTubs(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Make in one step a volume pointing to a cone shape with given medium. TGeoVolume * MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a cone segment ",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:17708,Performance,perform,performed,17708," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:17756,Performance,perform,performed,17756," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoBuilder.html:17803,Performance,perform,performed,17803," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoBuilder.html
https://root.cern/root/html530/TGeoCacheState.html:1363,Availability,error,error,1363," TGeoCacheState(); TGeoCacheState(Int_t capacity); virtual~TGeoCacheState(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSt",MatchSource.WIKI,root/html530/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCacheState.html
https://root.cern/root/html530/TGeoCacheState.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetState(Int_t& level, Int_t& nmany, Double_t* point) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_",MatchSource.WIKI,root/html530/TGeoCacheState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCacheState.html
https://root.cern/root/html530/TGeoChecker.html:4304,Availability,error,error,4304," = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:4388,Availability,error,error,4388,"pe* shape, Int_t testNo, Int_t nsamples, Option_t* option); Double_tCheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:11056,Availability,error,errors,11056,"of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); Geometry checking. Opional overlap checkings (by sampling and by mesh). Optional; boundary crossing check + timing per volume. STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; be called for the suspicious volumes.; STAGE2 : normal overlap checking using the shapes mesh - fills the list of; overlaps.; STAGE3 : shooting NRAYS rays from VERTEX and counting the total number of; crossings per volume (rays propagated from boundary to boundary until; geometry exit). Timing computed and results stored in a histo.; STAGE4 : shooting 1 mi",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:17111,Deployability,update,updated,17111,". Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double_t dirz, Double_t* array, Int_t& nelem, Int_t& dim, Double_t* enpoint = 0) const; Shoot one ray from start point with direction (dirx,diry,dirz). Fills input array; with points just after boundary crossings.; Int_t array_dimension = 3*dim;. void Test(Int_t npoints, Option_t* option); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path); --- Geometry overlap checker based on sampling. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""v""); Estimate weight of top level volume with a precision SIGMA(W)/W; better than PRECISION. Option can be ""v"" - verbose (default). Double_t CheckVoxels(TGeoVolume* vol, TGeoVoxelFinder* voxels, Double_t* xyz, Int_t npoints); count voxel timing. Bool_t TestVoxels(TGeoVolume* vol, Int_t npoints = 1000000); Returns optimal voxelization type for volume vol.; kFALSE - cartesian; kTRUE -",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:446,Performance,perform,performed,446,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOMPAINTER;  TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:1147,Safety,safe,safety,1147," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOMPAINTER;  TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of random points. 5. T",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:10309,Safety,safe,safety,10309,"opagateInGeom(Double_t*, Double_t*); voidScore(TGeoVolume*, Int_t, Double_t); Double_tTimingPerVolume(TGeoVolume*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TBuffer3D*fBuff1Buffer containing mesh vertices for first volume; TBuffer3D*fBuff2Buffer containing mesh vertices for second volume; Bool_t*fFlags! Array of flags per volume.; Bool_tfFullCheckFull overlap checking; TGeoManager*fGeoManagerpointer to geometry manager; Int_tfNchecks! Number of checks for current volume; Int_tfNmeshPoints! Number of points on mesh to be checked; TGeoNode*fSelectedNode! Selected node for overlap checking; TStopwatch*fTimer! Timer; Double_t*fVal1! Array of number of crossings per volume.; Double_t*fVal2! Array of timing per volume.; TGeoVolume*fVsafevolume to which a safety sphere node was added. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoChecker(); Default constructor. TGeoChecker(TGeoManager* geom); Constructor for a given geometry. ~TGeoChecker(); Destructor. void OpProgress(const char* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE); Print current operation progress. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckGeometryFull(Bool_t ch",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:14918,Safety,safe,safety,14918,"er of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:15050,Safety,safe,safety,15050,"""); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the n",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:15707,Safety,safe,safe,15707,"shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. ",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:15794,Safety,safe,safety,15794,"t with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly sho",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:15926,Safety,safe,safety,15926,"and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npo",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:16178,Safety,safe,safety,16178,"ions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; distance to boundary is bigger than safety. void ShapeNormal(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of the normal for a given shape.; Sample points inside the shape. Generate directions randomly in cos(theta); and propagate to boundary. Compute normal and safety at crossing point, plot; the point and generate a random direction so that (dir) dot (norm) <0. TH2F * LegoPlot(Int_t ntheta = 60, Double_t themin = 0., Double_t themax = 180., Int_t nphi = 90, Double_t phimin = 0., Double_t phimax = 360., Double_t rmin = 0., Double_t rmax = 9999999, Option_t* option = """"); Generate a lego plot fot the top volume, according to option. void RandomPoints(TGeoVolume* vol, Int_t npoints, Option_t* option); Draw random points in the bounding box of a volume. void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz); Randomly shoot nrays from point (startx,starty,startz) and plot intersections; with surfaces for current top node. TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path); shoot npoints randomly in a box of 1E-5 arround current point.; return minimum distance to points outside; make sure that path to current node is updated; get the response of tgeo. Double_t * ShootRay(Double_t* start, Double_t dirx, Double_t diry, Double",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:428,Testability,test,tests,428,". TGeoChecker. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOMPAINTER;  TGeoChecker. class TGeoChecker: public TObject. TGeoChecker - Geometry checking package. TGeoChecker class provides several geometry checking methods. There are two; types of tests that can be performed. One is based on random sampling or; ray-tracing and provides a visual check on how navigation methods work for; a given geometry. The second actually checks the validity of the geometry; definition in terms of overlapping/extruding objects. Both types of checks; can be done for a given branch (starting with a given volume) as well as for; the geometry as a whole. 1. TGeoChecker::CheckPoint(Double_t x, Double_t y, Double_t z). This method can be called direcly from the TGeoManager class and print a; report on how a given point is classified by the modeller: which is the; full path to the deepest node containing it, and the (under)estimation; of the distance to the closest boundary (safety). 2. TGeoChecker::RandomPoints(Int_t npoints). Can be called from TGeoVolume class. It first draws the volume and its; content with the current visualization settings. Then randomly samples points; in its bounding box, plotting in the geometry display only the points; classified as belonging to visible volumes. 3. TGeoChecker::RandomRays(Int_t nrays, Double_t startx, starty, startz). Can be called and acts in the same way as the previous, but instead of points,; rays having random isotropic directions are generated from the given point.; A raytracing algorithm propagates all rays untill they exit geometry, plotting; all segments crossing visible nodes in the same color as these. 4. TGeoChecker::Test(Int_t npoints). Implementation of TGeoManager::Test(). Computes the time for the modeller; to find out ""Where am I?"" for a given number of",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:3408,Testability,test,testNo,3408,,MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:14520,Testability,test,testNo,14520," Double_t ovlp); Check if the 2 non-assembly volume candidates overlap/extrude. Returns overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:14610,Testability,test,test,14610,"s overlap object. void CheckOverlapsBySampling(TGeoVolume* vol, Double_t ovlp = 0.1, Int_t npoints = 1000000) const; Check illegal overlaps for volume VOL within a limit OVLP by sampling npoints; inside the volume shape. Int_t NChecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void Sha",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoChecker.html:14866,Testability,test,test,14866,"ecksPerVolume(TGeoVolume* vol); Compute number of overlaps combinations to check per volume. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """"); Check illegal overlaps for volume VOL within a limit OVLP. void PrintOverlaps() const; Print the current list of overlaps held by the manager class. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); --- Draw point (x,y,z) over the picture of the daughers of the volume containing this point.; Generates a report regarding the path to the node containing this point and the distance to; the closest boundary. void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2); 2: Safety test. Sample points inside the bounding and compute safety. Generate; directions randomly in cos(theta) and compute distance to boundary. Check if; Distance to boundary is bigger than safety. void ShapeDistances(TGeoShape* shape, Int_t nsamples, Option_t* option); Test TGeoShape::DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute d1 = DistFromInside and move the; point on the boundary. Compute DistFromOutside and propagate with d2 making sure that; the shape is not re-entered. Swap direction and call DistFromOutside that; should fall back on the same point on the boundary (at d2). Propagate back on boundary; then compute DistFromInside that should be bigger than d1.; Plot d-(d1+d2). void ShapeSafety(TGeoShape* shape, Int_t nsamples, Option_t* option); Check of validity of safe distance for a given shape.; Sample points inside the 2x bounding box and compute safety. Generate; directions randomly in cos(theta) and compu",MatchSource.WIKI,root/html530/TGeoChecker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoChecker.html
https://root.cern/root/html530/TGeoCombiTrans.html:6234,Availability,error,error,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:8349,Availability,error,error,8349,"name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() con",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:8433,Availability,error,error,8433,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslati",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:3106,Integrability,interface,interface,3106," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:6240,Integrability,message,message,6240,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:6985,Modifiability,variab,variable,6985,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRotation& rot); TGeoCombiTrans(Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); TGeoCombiTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, TGeoRotation* rot); virtual~TGeoCombiTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual ",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:490,Performance,optimiz,optimize,490,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:499,Performance,perform,performance,499,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:984,Performance,perform,performed,984,". TGeoCombiTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoCombiTrans. class TGeoCombiTrans: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Sc",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:1710,Performance,perform,performed,1710,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:6217,Performance,perform,performed,6217,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoCombiTrans(); TGeoCombiTrans(const TGeoCombiTrans& other); TGeoCombiTrans(const TGeoMatrix& other); TGeoCombiTrans(const char* name); TGeoCombiTrans(const TGeoTranslation& tr, const TGeoRota",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTrans.html:1723,Usability,simpl,simple,1723,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoCombiTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTrans.html
https://root.cern/root/html530/TGeoCombiTransEditor.html:4726,Availability,error,error,4726,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTransEditor.html
https://root.cern/root/html530/TGeoCombiTransEditor.html:4810,Availability,error,error,4810,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTransEditor.html
https://root.cern/root/html530/TGeoCombiTransEditor.html:17976,Availability,mask,mask,17976,,MatchSource.WIKI,root/html530/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTransEditor.html
https://root.cern/root/html530/TGeoCombiTransEditor.html:22279,Usability,undo,undoing,22279,"w::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoCombiTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCombiTransEditor.html
https://root.cern/root/html530/TGeoCompositeShape.html:1115,Availability,down,down,1115,"eader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent bas",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:6079,Availability,error,error,6079,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t t",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:8728,Availability,error,error,8728,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Doubl",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:8812,Availability,error,error,8812,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; TGeoBoolNode*GetBoolNode() const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingB",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:17803,Availability,error,error,17803,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divi",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:2292,Integrability,interface,interface,2292,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:6085,Integrability,message,messages,6085,"GeoTranslation *t2 = new TGeoTranslation(""T2"",0,0, 20);; TGeoRotation *r1 = new TGeoRotation(""R1""); // transformations need names; r1->SetAngles(90,30,90,120,0,0); // rotation with 30 degrees about Z; TGeoTube *a = new TGeoTube(0, 10,20);; a->SetName(""A""); // shapes need names too; TGeoTube *b = new TGeoTube(0, 20,20);; b->SetName(""B"");; TGeoBBox *c = new TGeoBBox(10,10,50);; c->SetName(""C"");; TGeoBBox *d = new TGeoBBox(50,10,10);; d->SetName(""D"");. TGeoCompositeShape *cs;; cs = new TGeoCompositeShape(""CS"", ""(A:t1+B:t2)\(C+D:r1)"");. The newly created composite looks like 2 cylinders of different radii sitting; one on top of the other and having 2 rectangular holes : a longitudinal one; along Z axis corresponding to C and an other one in the XY plane due to D.; One should have in mind that the same shape or matrix identifier can be; used many times in the same expression. For instance:. (A:t1-A:t2)*B:t1. is a valid expression. Expressions that cannot be parsed or identifiers that; cannot be substituted by existing objects generate error messages.; Composite shapes can be subsequently used for defining volumes. Moreover,; these volumes may have daughters but these have to obbey overlapping/extruding; rules (see TGeoVolume). Volumes created based on composite shapes cannot be; divided. Visualization of such volumes is currently not implemented. Function Members (Methods); public:. TGeoCompositeShape(); TGeoCompositeShape(const char* expression); TGeoCompositeShape(const char* name, const char* expression); TGeoCompositeShape(const char* name, TGeoBoolNode* node); virtual~TGeoCompositeShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t t",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:944,Modifiability,extend,extend,944,". TGeoCompositeShape. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoCompositeShape. class TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are n",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:1284,Performance,perform,performance,1284,"lass TGeoCompositeShape: public TGeoBBox. TGeoCompositeShape - class handling Boolean composition of shapes. Composite shapes are Boolean combination of two or more shape; components. The supported boolean operations are union (+), intersection (*); and subtraction. Composite shapes derive from the base TGeoShape class,; therefore providing all shape features : computation of bounding box, finding; if a given point is inside or outside the combination, as well as computing the; distance to entering/exiting. It can be directly used for creating volumes or; used in the definition of other composite shapes.; Composite shapes are provided in order to complement and extend the set of; basic shape primitives. They have a binary tree internal structure, therefore; all shape-related geometry queries are signals propagated from top level down; to the final leaves, while the provided answers are assembled and interpreted; back at top. This CSG hierarchy is effective for small number of components,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:7879,Safety,safe,safe,7879,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:8020,Safety,safe,safe,8020,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:18288,Safety,safe,safe,18288,". TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:18551,Safety,safe,safe,18551,"hape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide all range of iaxis in range/step cells. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. void MakeNode(const char* expression); Make a booleann node according to the top level boolean operation of expression.; Propagates signal to branches until expression is fully decomposed.; printf(""Making node for : %s\n"", expression);. Bool_t PaintComposite(Option_t* option = """") const; Paint this composite shape into the current 3D viewer; Returns bool flag indicating if the caller should continue to; paint child objects. void RegisterYourself(); Register the shape and all components to TGeoManager class. Double_t Safety(Double",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:7032,Testability,test,testNo,7032,,MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCompositeShape.html:2335,Usability,simpl,simple,2335,"mponents,; while performance drops dramatically for large structures. Building a complete; geometry in this style is virtually possible but highly not recommended. Structure of composite shapes. A composite shape can always be regarded as the result of a Boolean operation; between only two shape components. All information identifying these two; components as well as their positions with respect to the frame of the composite; is represented by an object called Boolean node. A composite shape just have; a pointer to such a Boolean node. Since the shape components may also be; composites, they will also contain binary Boolean nodes branching other two; shapes in the hierarcy. Any such branch ends-up when the final leaves are no; longer composite shapes, but basic primitives. /*. */. Suppose that A, B, C and D represent basic shapes, we will illustrate; how the internal representation of few combinations look like. We do this; only for the sake of understanding how to create them in a proper way, since; the user interface for this purpose is in fact very simple. We will ignore; for the time being the positioning of components. The definition of a composite; shape takes an expression where the identifiers are shape names. The; expression is parsed and decomposed in 2 sub-expressions and the top-level; Boolean operator. 1. A+B+C; This represent the union of A, B and C. Both union operators are at the; same level. Since:; A+B+C = (A+B)+C = A+(B+C); the first (+) is taken as separator, hence the expression splitted:; A and B+C; A Boolean node of type TGeoUnion(""A"", ""B+C"") is created. This tries to replace; the 2 expressions by actual pointers to corresponding shapes.; The first expression (A) contains no operators therefore is interpreted as; representing a shape. The shape named ""A"" is searched into the list of shapes; handled by the manager class and stored as the ""left"" shape in the Boolean; union node. Since the second expression is not yet fully decomposed, the ""right",MatchSource.WIKI,root/html530/TGeoCompositeShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCompositeShape.html
https://root.cern/root/html530/TGeoCone.html:3546,Availability,error,error,3546,"hape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:3630,Availability,error,error,3630,"int, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tGetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatr",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:2290,Safety,safe,safe,2290,"estNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:2572,Safety,safe,safe,2572,"obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); static voidDistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObje",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:13909,Safety,safe,safe,13909,"cifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius an",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:14041,Safety,safe,safe,14041,"acity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, co",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:14126,Safety,safe,safe,14126,"acity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, co",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:14347,Safety,safe,safe,14347,"tructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns poi",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:14511,Safety,safe,safe,14511,"uble_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was d",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:14596,Safety,safe,safe,14596,"uble_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was d",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:1291,Testability,test,testNo,1291," TGeoCone(); TGeoCone(Double_t* params); TGeoCone(const TGeoCone&); TGeoCone(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual~TGeoCone(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox:",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoCone.html:13662,Testability,test,test,13662,"mum and maximum radius. TGeoCone(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Default constructor specifying minimum and maximum radius. TGeoCone(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Computes capacity of the shape in [length^3]. ~TGeoCone(); destructor. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this cone. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from inside point to surface of the cone (static); Boundary safe algorithm. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the cone; Boundary safe algorithm. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Compute distance from outside point to surface of the tube; Boundary safe algorithm.; compute distance to Z planes. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. void DistToCone(Double_t* point, Double_t* dir, Do",MatchSource.WIKI,root/html530/TGeoCone.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCone.html
https://root.cern/root/html530/TGeoConeEditor.html:4623,Availability,error,error,4623,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeEditor.html
https://root.cern/root/html530/TGeoConeEditor.html:4707,Availability,error,error,4707,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeEditor.html
https://root.cern/root/html530/TGeoConeEditor.html:18035,Availability,mask,mask,18035,,MatchSource.WIKI,root/html530/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeEditor.html
https://root.cern/root/html530/TGeoConeEditor.html:21579,Usability,undo,undoing,21579,"ol_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoConeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifing current parameters. void DoUndo(); Slot for undoing current operation. void DoRmin1(); Slot for Rmin1. void DoRmax1(); Slot for Rmax1. void DoRmin2(); Slot for Rmin2. void DoRmax2(); Slot for Rmax2. void DoDz(); Slot for Dz.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoConeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeEditor.html
https://root.cern/root/html530/TGeoConeSeg.html:4055,Availability,error,error,4055,", Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:4139,Availability,error,error,4139,"le_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoCone::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoCone::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:2462,Safety,safe,safe,2462,"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Doub",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:2837,Safety,safe,safe,2837,"e_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tDistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static voidTGeoCone::DistToCone(Double_t* point, Double_t* dir, Double_t dz, Double_t r1, Double_t r2, Double_t& b, Double_t& delta); static Double_tDistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voi",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:15546,Safety,safe,safe,15546," Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to create",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:16042,Safety,safe,safe,16042,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:16127,Safety,safe,safe,16127,"nd Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from outside point to surface of arbitrary tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube; compute safe radius. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); --- Divide this cone segment shape belonging to volume ""voldiv"" into ndiv volumes; called divname, from start position with the given step. Returns pointer; to created division cell volume in case of Z divisions. For Z division; creates all volumes with different shapes and returns pointer to volume that; was divided. In case a wrong division axis is supplied, returns pointer to; volume that was divided. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rma",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:1411,Testability,test,testNo,1411," TGeoConeSeg(); TGeoConeSeg(Double_t* params); TGeoConeSeg(const TGeoConeSeg&); TGeoConeSeg(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoConeSeg(const char* name, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); virtual~TGeoConeSeg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; static Double_tCapacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2,",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSeg.html:14777,Testability,test,test,14777,"Default constructor specifying minimum and maximum radius. TGeoConeSeg(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = dz; param[1] = Rmin1; param[2] = Rmax1; param[3] = Rmin2; param[4] = Rmax2; param[5] = phi1; param[6] = phi2. ~TGeoConeSeg(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. Double_t Capacity(Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube segment. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. void ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this sphere. Double_t DistToCons(Double_t* point, Double_t* dir, Double_t r1, Double_t z1, Double_t r2, Double_t z2, Double_t phi1, Double_t phi2); Static method to compute distance to a conical surface with :; - r1, z1 - radius and Z position of lower base; - r2, z2 - radius and Z position of upper base; - phi1, phi2 - phi limits. Double_t DistFromInsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); compute distance from inside point to surface of the tube segment. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube segment. Double_t DistFromOutsideS(Double_t* point, Double_t* dir, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t c",MatchSource.WIKI,root/html530/TGeoConeSeg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSeg.html
https://root.cern/root/html530/TGeoConeSegEditor.html:4796,Availability,error,error,4796,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSegEditor.html
https://root.cern/root/html530/TGeoConeSegEditor.html:4880,Availability,error,error,4880,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSegEditor.html
https://root.cern/root/html530/TGeoConeSegEditor.html:18471,Availability,mask,mask,18471,"t changes; Bool_tTGedFrame::fAvoidSignalflag for executing slots; TGCompositeFrame*TGeoConeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoConeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoConeEditor::fDelayedCheck button for delayed draw; Double_tTGeoConeEditor::fDziInitial box dz; TGNumberEntry*TGeoConeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhi1Number entry for phi1; TGNumberEntry*fEPhi2Number entry for phi2 ; TGNumberEntry*TGeoConeEditor::fERmax1Number entry for rmax1; TGNumberEntry*TGeoConeEditor::fERmax2Number entry for rmax2; TGNumberEntry*TGeoConeEditor::fERmin1Number entry for rmin1; TGNumberEntry*TGeoConeEditor::fERmin2Number entry for rmin2; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoConeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoConeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UIn",MatchSource.WIKI,root/html530/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSegEditor.html
https://root.cern/root/html530/TGeoConeSegEditor.html:22243,Usability,undo,undoing,22243,"TabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoConeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoConeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cone segment editor. ~TGeoConeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for Phi1. void DoPhi2(); Slot for Phi2. void DoPhi(); Slot for Phi. void DoApply(); Slot for applying current parameters. void DoUndo(); Slot for undoing last operation.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoConeEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoConeSegEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoConeSegEditor.html
https://root.cern/root/html530/TGeoCtub.html:4175,Availability,error,error,4175,"FromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tT",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:4259,Availability,error,error,4259,"dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoTubeSeg::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(c",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:2775,Safety,safe,safe,2775,"ion = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); v",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:3129,Safety,safe,safe,3129,"* point, Double_t* dir, Double_t* norm); static voidTGeoTubeSeg::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoTubeSeg::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTubeSeg::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cm, Double_t sm, Double_t cdfi); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(cons",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:15024,Safety,safe,safe,15024," char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); constructor. TGeoCtub(Double_t* params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz,",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:15221,Safety,safe,safe,15221,"params); ctor with parameters. ~TGeoCtub(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute minimum bounding box of the ctub. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; check if point is contained in the cut tube; check the lower cut plane. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. Double_t GetZcoord(Double_t xc, Double_t yc, Double_t zc) const; compute real Z coordinate of a point belonging to either lower or; higher caps (z should be either +fDz or -fDz). Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the cut tube. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the cut tube. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the tube along one axis. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SetCtubDimensions(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); set dimensions of a cut tube. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void S",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtub.html:1732,Testability,test,testNo,1732," TGeoCtub(); TGeoCtub(Double_t* params); TGeoCtub(const TGeoCtub&); TGeoCtub(Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoCtub(const char* name, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); virtual~TGeoCtub(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(c",MatchSource.WIKI,root/html530/TGeoCtub.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtub.html
https://root.cern/root/html530/TGeoCtubEditor.html:4830,Availability,error,error,4830,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtubEditor.html
https://root.cern/root/html530/TGeoCtubEditor.html:4914,Availability,error,error,4914,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtubEditor.html
https://root.cern/root/html530/TGeoCtubEditor.html:18608,Availability,mask,mask,18608,"GeoTubeEditor::fBFrameFrame containing Apply/Undo; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTubeEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTubeEditor::fDelayedCheck button for delayed draw; Double_tTGeoTubeEditor::fDziInitial box dz; TGNumberEntry*TGeoTubeEditor::fEDzNumber entry for DZ; TGNumberEntry*fEPhhiNumber entry for phhi; TGNumberEntry*TGeoTubeSegEditor::fEPhi1Number entry for phi1; TGNumberEntry*TGeoTubeSegEditor::fEPhi2Number entry for phi2 ; TGNumberEntry*fEPhloNumber entry for phlo; TGNumberEntry*TGeoTubeEditor::fERmaxNumber entry for rmax; TGNumberEntry*TGeoTubeEditor::fERminNumber entry for rmin; TGNumberEntry*fEThhiNumber entry for thhi; TGNumberEntry*fEThloNumber entry for thlo; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTubeEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTubeEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGeoTubeSegEditor::fLockPhi lock; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminima",MatchSource.WIKI,root/html530/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtubEditor.html
https://root.cern/root/html530/TGeoCtubEditor.html:22528,Usability,undo,undoing,22528," plane (0, 90); Double_tfThloTheta angle of the normal to the lower plane (90, 180); TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCtubEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for cut tube editor. ~TGeoCtubEditor(); Destructor. void SetModel(TObject* obj); Connect to the selected object. void DoThlo(); Slot for phi1. void DoPhlo(); Slot for phi1. void DoThhi(); Slot for phi1. void DoPhhi(); Slot for phi1. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoTubeEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoCtubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoCtubEditor.html
https://root.cern/root/html530/TGeoDecayChannel.html:1895,Availability,error,error,1895,"nst; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html530/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoDecayChannel.html
https://root.cern/root/html530/TGeoDecayChannel.html:1979,Availability,error,error,1979,"char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TGeoElementRN*Daughter() const; UInt_tDecay() const; static voidDecayName(UInt_t decay, TString& name); virtual voidDecayShift(Int_t& dA, Int_t& dZ, Int_t& dI) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeltaIso() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtu",MatchSource.WIKI,root/html530/TGeoDecayChannel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoDecayChannel.html
https://root.cern/root/html530/TGeoElement.html:1852,Availability,error,error,1852,"bstractMethod(const char* method) const; voidAddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root/html530/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElement.html
https://root.cern/root/html530/TGeoElement.html:1936,Availability,error,error,1936,"_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_tHasIsotopes() c",MatchSource.WIKI,root/html530/TGeoElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElement.html
https://root.cern/root/html530/TGeoElementRN.html:2202,Availability,error,error,2202,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html530/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElementRN.html
https://root.cern/root/html530/TGeoElementRN.html:2286,Availability,error,error,2286,"s); public:. TGeoElementRN(); TGeoElementRN(Int_t A, Int_t Z, Int_t iso, Double_t level, Double_t deltaM, Double_t halfLife, const char* JP, Double_t natAbun, Double_t th_f, Double_t tg_f, Double_t th_s, Double_t tg_s, Int_t status); virtual~TGeoElementRN(); Double_tTGeoElement::A() const; voidTObject::AbstractMethod(const char* method) const; voidAddDecay(TGeoDecayChannel* dc); voidAddDecay(Int_t decay, Int_t diso, Double_t branchingRatio, Double_t qValue); voidTGeoElement::AddIsotope(TGeoIsotope* isotope, Double_t relativeAbundance); voidAddRatio(TGeoBatemanSol& ratio); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAtomicNo() const; virtual voidTObject::Browse(TBrowser* b); Bool_tCheckDecays() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecayResult(TGeoDecayChannel* dc) const; TObjArray*Decays() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Int_tENDF(Int_t a, Int_t z, Int_t iso); virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillPopulation(TObjArray* population, Double_t precision = 0.001, Double_",MatchSource.WIKI,root/html530/TGeoElementRN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElementRN.html
https://root.cern/root/html530/TGeoElementTable.html:1865,Availability,error,error,1865,"le_t a); voidAddElementRN(TGeoElementRN* elem); voidAddIsotope(TGeoIsotope* isotope); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_",MatchSource.WIKI,root/html530/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElementTable.html
https://root.cern/root/html530/TGeoElementTable.html:1949,Availability,error,error,1949,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildDefaultElements(); Bool_tCheckTable() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExportElementsRN(const char* filename = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGeoElement*FindElement(const char* name) const; TGeoIsotope*FindIsotope(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoElement*GetElement(Int_t z); TGeoElementRN*GetElementRN(Int_t ENDFcode) const; TGeoElementRN*GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; TObjArray*GetElementsRN() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNelements() const; Int_tGetNelementsRN() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual cons",MatchSource.WIKI,root/html530/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElementTable.html
https://root.cern/root/html530/TGeoElementTable.html:7680,Performance,optimiz,optimized,7680,"t_t nelements); constructor. TGeoElementTable(const TGeoElementTable& ); copy constructor. TGeoElementTable& operator=(const TGeoElementTable& ); assignment operator. ~TGeoElementTable(); destructor. void AddElement(const char* name, const char* title, Int_t z, Double_t a); Add an element to the table. Obsolete. void AddElement(const char* name, const char* title, Int_t z, Int_t n, Double_t a); Add an element to the table. void AddElementRN(TGeoElementRN* elem); Add a radionuclide to the table and map it. void AddIsotope(TGeoIsotope* isotope); Add isotope to the table. void BuildDefaultElements(); Creates the default element table. void ImportElementsRN(); Creates the list of radionuclides. Bool_t CheckTable() const; Checks status of element table. void ExportElementsRN(const char* filename = """"); Export radionuclides in a file. TGeoElement * FindElement(const char* name) const; Search an element by symbol or full name. TGeoIsotope * FindIsotope(const char* name) const; Find existing isotope by name. Not optimized for a big number of isotopes. TGeoElementRN * GetElementRN(Int_t ENDFcode) const; Retreive a radionuclide by ENDF code. TGeoElementRN * GetElementRN(Int_t a, Int_t z, Int_t iso = 0) const; Retreive a radionuclide by a, z, and isomeric state. TGeoElementRN * GetElement(); {return fElem;}. TObjArray * GetElementsRN() const; {return fListRN;}. Bool_t HasDefaultElements() const; {return TObject::TestBit(kETDefaultElements);}. Bool_t HasRNElements() const; {return TObject::TestBit(kETRNElements);}. Int_t GetNelements() const; {return fNelements;}. Int_t GetNelementsRN() const; {return fNelementsRN;}.  Author: Andrei Gheata 17/06/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoElementTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElementTable.html
https://root.cern/root/html530/TGeoElemIter.html:1974,Availability,down,down,1974,"TGeoElemIter&operator=(const TGeoElemIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}.  Author: Andrei Gheata 17/06/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html530/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElemIter.html
https://root.cern/root/html530/TGeoElemIter.html:2020,Availability,down,downwards,2020,"emIter& iter); virtual voidPrint(Option_t* option = """") const; voidSetLimitRatio(Double_t limit); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoElemIter(); TGeoElementRN*Down(Int_t ibranch); TGeoElementRN*Up(). Data Members; private:. TObjArray*fBranchCurrent branch; const TGeoElementRN*fElemCurrent element; Int_tfLevelCurrent level; Double_tfLimitRatioMinimum cumulative branching ratio; Double_tfRatioCurrent ratio; const TGeoElementRN*fTopTop element of the iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoElemIter(TGeoElementRN* top, Double_t limit = 1.e-4); Default constructor. TGeoElemIter(const TGeoElemIter& iter); Copy ctor. ~TGeoElemIter(); Destructor. TGeoElemIter & operator=(const TGeoElemIter& iter); Assignment. TGeoElementRN * operator()(); () operator. TGeoElementRN * Up(); Go upwards from the current location until the next branching, then down. TGeoElementRN * Down(Int_t ibranch); Go downwards from current level via ibranch as low in the tree as possible.; Return value flags if the operation was successful. TGeoElementRN * Next(); Return next element. void Print(Option_t* option = """") const; Print info about the current decay branch. TGeoElementRN * GetElement() const; {return fElem;}. TGeoElemIter(); {}. TObjArray * GetBranch() const; {return fBranch;}. const TGeoElementRN * GetTop() const; {return fTop;}. Int_t GetLevel() const; {return fLevel;}. Double_t GetRatio() const; {return fRatio;}. void SetLimitRatio(Double_t limit); {fLimitRatio = limit;}.  Author: Andrei Gheata 17/06/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoElement.h 33465 2010-05-11 09:58:19Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoElemIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoElemIter.html
https://root.cern/root/html530/TGeoEltu.html:3242,Availability,error,error,3242,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:3326,Availability,error,error,3326,"ube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacet",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:2034,Safety,safe,safe,2034,"hape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:2292,Safety,safe,safe,2292,"st; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:13209,Safety,safe,safe,13209,"Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The ma",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:13402,Safety,safe,safe,13402,"Eltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, ",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:13482,Safety,safe,safe,13482,"Eltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetEltuDimensions(Double_t a, ",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:1059,Testability,test,testNo,1059," TGeoEltu(); TGeoEltu(Double_t* params); TGeoEltu(const TGeoEltu&); TGeoEltu(Double_t a, Double_t b, Double_t dz); TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); virtual~TGeoEltu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t st",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltu.html:12943,Testability,test,test,12943,"e_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltu(); Dummy constructor. TGeoEltu(Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(const char* name, Double_t a, Double_t b, Double_t dz); Default constructor specifying X and Y semiaxis length. TGeoEltu(Double_t* params); Default constructor specifying minimum and maximum radius; param[0] = A; param[1] = B; param[2] = dz. ~TGeoEltu(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); compute bounding box of the tube. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the elliptical tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each vertex. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the tube. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the tube and safe distance. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has t",MatchSource.WIKI,root/html530/TGeoEltu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltu.html
https://root.cern/root/html530/TGeoEltuEditor.html:4569,Availability,error,error,4569,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltuEditor.html
https://root.cern/root/html530/TGeoEltuEditor.html:4653,Availability,error,error,4653,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltuEditor.html
https://root.cern/root/html530/TGeoEltuEditor.html:17883,Availability,mask,mask,17883,,MatchSource.WIKI,root/html530/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltuEditor.html
https://root.cern/root/html530/TGeoEltuEditor.html:21243,Usability,undo,undoing,21243,"thframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoEltuEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoEltuEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoName(); Slot for name. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoA(); Slot for A. void DoB(); Slot for B. void DoDz(); Slot for Z.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoEltuEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoEltuEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoEltuEditor.html
https://root.cern/root/html530/TGeoGedFrame.html:497,Availability,avail,available,497,". TGeoGedFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOMBUILDER;  TGeoGedFrame. class TGeoGedFrame: public TGedFrame. TGeoGedFrame. Common base class for geombuilder editors. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~TGeoGedFrame(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root/html530/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGedFrame.html
https://root.cern/root/html530/TGeoGedFrame.html:4461,Availability,error,error,4461,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGedFrame.html
https://root.cern/root/html530/TGeoGedFrame.html:4545,Availability,error,error,4545,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGedFrame.html
https://root.cern/root/html530/TGeoGedFrame.html:17336,Availability,mask,mask,17336,,MatchSource.WIKI,root/html530/TGeoGedFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGedFrame.html
https://root.cern/root/html530/TGeoGenTrans.html:6232,Availability,error,error,6232,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:8296,Availability,error,error,8296,"e_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtu",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:8380,Availability,error,error,8380,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; vir",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:3104,Integrability,interface,interface,3104," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:6238,Integrability,message,message,6238,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:6983,Modifiability,variab,variable,6983,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); virtual~TGeoGenTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t p",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:488,Performance,optimiz,optimize,488,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:497,Performance,perform,performance,497,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:982,Performance,perform,performed,982,". TGeoGenTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoGenTrans. class TGeoGenTrans: public TGeoCombiTrans. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scal",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:1708,Performance,perform,performed,1708,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:6215,Performance,perform,performed,6215,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoGenTrans(); TGeoGenTrans(const char* name); TGeoGenTrans(const TGeoGenTrans&); TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); ",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:1721,Usability,simpl,simple,1721,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGenTrans.html:15721,Usability,clear,clear,15721,"; kGeoScale; kGeoReflection; kGeoRegistered; kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TGeoRotation*TGeoCombiTrans::fRotationrotation matrix; Double_tfScale[3]scale (x, y, z); TStringTNamed::fTitleobject title; Double_tTGeoCombiTrans::fTranslation[3]translation vector. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGenTrans(); dummy ctor. TGeoGenTrans(const char* name); constructor. TGeoGenTrans(Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. TGeoGenTrans(const char* name, Double_t dx, Double_t dy, Double_t dz, Double_t sx, Double_t sy, Double_t sz, TGeoRotation* rot); constructor. ~TGeoGenTrans(); destructor. void Clear(Option_t* option = """"); clear the fields of this transformation. void SetScale(Double_t sx, Double_t sy, Double_t sz); set the scale. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Bool_t Normalize(); A scale transformation should be normalized by sx*sy*sz factor. TGeoMatrix& operator=(const TGeoGenTrans& ); Preventing warnings with -Weffc++ in GCC since the behaviour of operator * was chosen so by design. const Double_t * GetScale() const. TGeoMatrix * MakeClone() const. void SetScale(Double_t sx, Double_t sy, Double_t sz). TGeoGenTrans().  Author: Andrei Gheata 25/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoMatrix.h 34744 2010-08-07 06:16:36Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoGenTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGenTrans.html
https://root.cern/root/html530/TGeoGlobalMagField.html:1903,Availability,error,error,1903," TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html530/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html
https://root.cern/root/html530/TGeoGlobalMagField.html:1987,Availability,error,error,1987," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidField(const Double_t* x, Double_t* B); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualMagField*GetField() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html530/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html
https://root.cern/root/html530/TGeoGlobalMagField.html:376,Security,access,access,376,". TGeoGlobalMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoGlobalMagField. class TGeoGlobalMagField: public TObject. TGeoGlobalMagField - Global magnetic field manager. Provides access to; and owns the actual magnetic field set via SetField(). The field is deleted; upon destruction of the field manager at the end of ROOT session or; by calling: TGeoGlobalMagField::Instance()->SetField(0). The previous; global field is deleted upon replacement with notification. The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); One can directly call the Field() method of a field via the global field manager:. TGeoGlobalMagField::Instance()->Field(x,B). Function Members (Methods); public:. TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html530/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html
https://root.cern/root/html530/TGeoGlobalMagField.html:698,Security,access,access,698,". TGeoGlobalMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoGlobalMagField. class TGeoGlobalMagField: public TObject. TGeoGlobalMagField - Global magnetic field manager. Provides access to; and owns the actual magnetic field set via SetField(). The field is deleted; upon destruction of the field manager at the end of ROOT session or; by calling: TGeoGlobalMagField::Instance()->SetField(0). The previous; global field is deleted upon replacement with notification. The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); One can directly call the Field() method of a field via the global field manager:. TGeoGlobalMagField::Instance()->Field(x,B). Function Members (Methods); public:. TGeoGlobalMagField(); virtual~TGeoGlobalMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); vi",MatchSource.WIKI,root/html530/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html
https://root.cern/root/html530/TGeoGlobalMagField.html:6922,Security,access,access,6922," = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoGlobalMagField(const TGeoGlobalMagField&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoGlobalMagField&operator=(const TGeoGlobalMagField&); voidUnlock(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TVirtualMagField*fFieldMagnetic field; Bool_tfLockLock flag for global field.; static TGeoGlobalMagField*fgInstanceStatic pointer to the field manager;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGlobalMagField(); Global field default constructor. ~TGeoGlobalMagField(); Global field destructor. void SetField(TVirtualMagField* field); Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. TGeoGlobalMagField * Instance(); Returns always a valid static pointer to the field manager. void Lock(); Locks the global magnetic field if this is set. Cannot be unlocked. TGeoGlobalMagField(const TGeoGlobalMagField& ). TGeoGlobalMagField& operator=(const TGeoGlobalMagField& ). void Unlock(); {fLock = kFALSE;}. TVirtualMagField * GetField() const; Using SetField() makes a given field global. The field manager owns it from now on. {return fField;}. Bool_t IsLocked(); {return fLock;}. void Field(const Double_t* x, Double_t* B); Inline access to Field() method. {if (fField) fField->Field(x,B);}.  Last changed: root/geom:$Id: TGeoGlobalMagField.h 27191 2009-01-20 08:09:20Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoGlobalMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGlobalMagField.html
https://root.cern/root/html530/TGeoGtra.html:3941,Availability,error,error,3941,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual ",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:4025,Availability,error,error,4025,"FromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:2991,Safety,safe,safe,2991," b); virtual Double_tTGeoArb8::Capacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* met",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:3132,Safety,safe,safe,3132,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTGeoArb8::ComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidTGeoArb8::ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); voidTGeoArb8::ComputeTwist(); virtual Bool_tTGeoArb8::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(c",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:15001,Safety,safe,safe,15001,"gle; TStringTNamed::fTitleobject title; Double_tTGeoTrap::fTl1half length in x at low z and y high edge; Double_tTGeoTrap::fTl2half length in x at high z and y high edge; Double_t*TGeoArb8::fTwist! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. TGeoGtra(); constructor",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:15195,Safety,safe,safe,15195,"st! [4] tangents of twist angles ; Double_tfTwistAngletwist angle in degrees; Double_tTGeoArb8::fXY[8][2]list of vertices. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtra(); Default ctor. TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor. TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); Constructor providing the name of the shape. ~TGeoGtra(); Destructor. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the shape. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; In case shape has some negative parameters, these has to be computed; in order to fit the mother. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Computes the closest distance from given point to this shape. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set all arb8 params in one step.; param[0] = dz; param[1] = theta; param[2] = phi; param[3] = h1; param[4] = bl1; param[5] = tl1; param[6] = alpha1; param[7] = h2; param[8] = bl2; param[9] = tl2; param[10] = alpha2; param[11] = twist. TGeoGtra(); constructors. Double_t GetTwistAngle() const; {return fTwistAngle;}.  Author: Andrei Gheata 24/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoArb8.h",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtra.html:2074,Testability,test,testNo,2074," TGeoGtra(); TGeoGtra(const TGeoGtra&); TGeoGtra(Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoGtra(const char* name, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); virtual~TGeoGtra(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); vir",MatchSource.WIKI,root/html530/TGeoGtra.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtra.html
https://root.cern/root/html530/TGeoGtraEditor.html:4864,Availability,error,error,4864,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtraEditor.html
https://root.cern/root/html530/TGeoGtraEditor.html:4948,Availability,error,error,4948,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtraEditor.html
https://root.cern/root/html530/TGeoGtraEditor.html:18920,Availability,mask,mask,18920,"Frame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTrapEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTrapEditor::fDelayedCheck button for delayed draw; Double_tTGeoTrapEditor::fDziInitial Dz; TGNumberEntry*TGeoTrapEditor::fEAlpha1Number entry for Alpha1; TGNumberEntry*TGeoTrapEditor::fEBl1Number entry for Bl1; TGNumberEntry*TGeoTrapEditor::fEDzNumber entry for DZ; TGNumberEntry*TGeoTrapEditor::fEH1Number entry for H1 ; TGNumberEntry*TGeoTrapEditor::fEPhiNumber entry for Theta ; TGNumberEntry*TGeoTrapEditor::fESc1Number entry for lower scale; TGNumberEntry*TGeoTrapEditor::fESc2Number entry for upper scale; TGNumberEntry*TGeoTrapEditor::fEThetaNumber entry for Theta ; TGNumberEntry*TGeoTrapEditor::fETl1Number entry for Tl1; TGNumberEntry*fETwistNumber entry for H1 ; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tTGeoTrapEditor::fH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTrapEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTrapEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTG",MatchSource.WIKI,root/html530/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtraEditor.html
https://root.cern/root/html530/TGeoGtraEditor.html:22515,Usability,undo,undoing,22515,"uble_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoTrapEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoGtraEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoGtraEditor.html
https://root.cern/root/html530/TGeoHalfSpace.html:2813,Availability,error,error,2813,"ive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t in",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:2897,Availability,error,error,2897,"ir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t*) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:1964,Safety,safe,safe,1964,"x* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px,",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:2105,Safety,safe,safe,2105,"ape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:12012,Safety,safe,safe,12012,"ouble_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameter",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:12195,Safety,safe,safe,12195," id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetDimensions(Double_t* param); Set half-space parameters as stored in an array. TGeoHalfSpace(); constructors. Double_t Capacity() const; methods. {return 0.;}. void ComputeBBox(); {;}. Double_t * GetPoint(); {return fP;}. Double_t * GetN",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:1117,Testability,test,testNo,1117," TGeoHalfSpace(); TGeoHalfSpace(Double_t* params); TGeoHalfSpace(const TGeoHalfSpace&); TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); virtual~TGeoHalfSpace(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDist",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHalfSpace.html:11764,Testability,test,test,11764,"tMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. Double_tfN[3]; Double_tfP[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHalfSpace(); Dummy constructor. TGeoHalfSpace(const char* name, Double_t* p, Double_t* n); Constructor with name, point on the plane and normal. TGeoHalfSpace(Double_t* params); Default constructor specifying minimum and maximum radius. ~TGeoHalfSpace(); destructor. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside the half-space. Int_t DistancetoPrimitive(Int_t px, Int_t py); A half-space does not have a mesh primitive. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to the plane. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divide the shape along one axis. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. void InspectShape() const; print shape parameters. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matchin",MatchSource.WIKI,root/html530/TGeoHalfSpace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHalfSpace.html
https://root.cern/root/html530/TGeoHelix.html:2478,Availability,error,error,2478,"rge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetCurrentDirection() const; const Double_t*GetCurrentPoint() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStep() const; virtual const char*TObject::GetTitle() const; Double_tGetTotalCurvature() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXYcurvature() const; virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:2562,Availability,error,error,2562,"; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetCurrentDirection() const; const Double_t*GetCurrentPoint() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStep() const; virtual const char*TObject::GetTitle() const; Double_tGetTotalCurvature() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXYcurvature() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:7846,Availability,error,error,7846," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:9126,Deployability,update,update,9126,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}.  Author: Andrei Gheata 28/04/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoHelix.h 21425 ",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:666,Energy Efficiency,charge,charged,666,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(const TGeoHelix&); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:765,Energy Efficiency,charge,charge,765,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(const TGeoHelix&); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:914,Energy Efficiency,charge,charge,914,". TGeoHelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHelix. class TGeoHelix: public TObject. TGeoHelix - class representing a helix curve. A helix is a curve defined by the following equations:; x = (1/c) * COS(q*phi); y = (1/c) * SIN(q*phi); z = s * alfa; where:; c = 1/Rxy - curvature in XY plane; phi - phi angle; S = 2*PI*s - vertical separation between helix loops; q = +/- 1 - (+)=left-handed, (-)=right-handed. In particular, a helix describes the trajectory of a charged particle in magnetic; field. In such case, the helix is right-handed for negative particle charge.; To define a helix, one must define:; - the curvature - positive defined; - the Z step made after one full turn of the helix; - the particle charge sign; - the initial particle position and direction (force normalization to unit); - the magnetic field direction. A helix provides:; - propagation to a given Z position (in global frame); Double_t *point = TGeoHelix::PropagateToZ(Double_t z);; - propagation to an arbitrary plane, returning also the new point; - propagation in a geometry until the next crossed surface; - computation of the total track length along a helix. Function Members (Methods); public:. TGeoHelix(); TGeoHelix(const TGeoHelix&); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:1478,Energy Efficiency,charge,charge,1478," TGeoHelix(); TGeoHelix(const TGeoHelix&); TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); virtual~TGeoHelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeSafeStep(Double_t epsil = 1E-6) const; virtual voidTObject::Copy(TObject& object) const",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:5521,Energy Efficiency,charge,charge,5521,"ovedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TGeoHelix&operator=(const TGeoHelix&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidResetStep(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCharge(Int_t charge); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); voidSetHelixStep(Double_t hstep); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetXYcurvature(Double_t curvature); virtual voidShowMembers(TMemberInspector& insp); voidStep(Double_t step); Double_tStepToPlane(Double_t* point, Double_t* norm); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidUpdateHelix(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t opti",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:7428,Energy Efficiency,charge,charge,7428,"ct::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bo",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:7676,Energy Efficiency,charge,charge,7676,"t; voidTObject::MakeZombie(). Data Members; public:. enum EGeoHelixTypes { kHelixNeedUpdate; kHelixStraigth; kHelixCircle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRU",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:8536,Energy Efficiency,charge,charge,8536,"ncludes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:8554,Energy Efficiency,charge,charge,8554,"ncludes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape b",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:9204,Energy Efficiency,charge,charge,9204,"RUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}.  Author: Andrei Gheata 28/04/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoHelix.h 21425 ",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:7798,Safety,safe,safe,7798," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfB[3]normalized direction for magnetic field; Double_tfCcurvature in XY plane; Double_tfDir[3]direction after a step; Double_tfDirInit[3]normalized initial direction; TGeoHMatrix*fMatrixtransformation of local helix frame to MARS ; Double_tfPhiphi angle; Double_tfPoint[3]point after a step; Double_tfPointInit[3]initial point; Int_tfQright/left-handed (+/- 1) - ""charge""; Double_tfSZ step of the helix / 2*PI; Double_tfStepcurrent step. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHelix(); Dummy constructor. TGeoHelix(Double_t curvature, Double_t step, Int_t charge = 1); Normal constructor. ~TGeoHelix(); Destructor. Double_t ComputeSafeStep(Double_t epsil = 1E-6) const; Compute safe linear step that can be made such that the error; between linear-helix extrapolation is less than EPSIL. void InitPoint(Double_t x0, Double_t y0, Double_t z0); Initialize coordinates of a point on the helix. void InitPoint(Double_t* point); Set initial point on the helix. void InitDirection(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. P",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:9084,Safety,safe,safety,9084,"n(Double_t dirx, Double_t diry, Double_t dirz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void InitDirection(Double_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}.  Author: Andrei Gheata 28/04/04  Copyright (C) 1995-2000, Rene Brun a",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHelix.html:9237,Safety,safe,safety,9237,"ble_t* dir, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). Double_t GetTotalCurvature() const; Compute helix total curvature. void SetXYcurvature(Double_t curvature); Set XY curvature: c = 1/Rxy. void SetCharge(Int_t charge); Positive charge means left-handed helix. void SetField(Double_t bx, Double_t by, Double_t bz, Bool_t is_normalized = kTRUE); Initialize particle direction (tangent on the helix in initial point). void SetHelixStep(Double_t hstep); Set Z step of the helix on a complete turn. Positive or null. void ResetStep(); Reset current point/direction to initial values. void Step(Double_t step); Make a step from current point along the helix and compute new point, direction and angle; To reach a plane/ shape boundary, one has to:; 1. Compute the safety to the plane/boundary; 2. Define / update a helix according local field and particle state (position, direction, charge); 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; 5. Repeat from 1. until the step to be made is small enough.; 6. Add to the total step the distance along a straigth line from the last point; to the plane/shape boundary. Double_t StepToPlane(Double_t* point, Double_t* norm); Propagate initial point up to a given Z position in MARS. void UpdateHelix(); Update the local helix matrix. TGeoHelix(); constructors. const Double_t * GetCurrentPoint() const; {return fPoint;}. const Double_t * GetCurrentDirection() const; {return fDir;}. Double_t GetXYcurvature() const; {return fC;}. Double_t GetStep() const; {return fStep;}. Bool_t IsRightHanded() const; {return (fQ>0)?kFALSE:kTRUE;}.  Author: Andrei Gheata 28/04/04  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoHelix.h 21425 2007-12-17 15:59:27Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically g",MatchSource.WIKI,root/html530/TGeoHelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHelix.html
https://root.cern/root/html530/TGeoHMatrix.html:6225,Availability,error,error,6225,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:8151,Availability,error,error,8151,"virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual Double_t*GetRotationMatrix(); virtual const Double_t*GetScale()",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:8235,Availability,error,error,8235,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual Double_t*GetRotationMatrix(); virtual const Double_t*GetScale() const; virtual Double_t*GetScale(); virtual const char*TNamed::GetTitle() const; vi",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:3097,Integrability,interface,interface,3097," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:6231,Integrability,message,message,6231,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:6976,Modifiability,variab,variable,6976,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyFrom(const TGeoMatrix* other); virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Opti",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:481,Performance,optimiz,optimize,481,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:490,Performance,perform,performance,490,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:975,Performance,perform,performed,975,". TGeoHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHMatrix. class TGeoHMatrix: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inve",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:1701,Performance,perform,performed,1701,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:6208,Performance,perform,performed,6208,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoHMatrix(); TGeoHMatrix(const TGeoMatrix& matrix); TGeoHMatrix(const char* name); TGeoHMatrix(const TGeoHMatrix&); virtual~TGeoHMatrix(); voidTObject::AbstractMethod(const char* method) const",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:1714,Usability,simpl,simple,1714,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHMatrix.html:15375,Usability,clear,clear,15375," kGeoSavePrimitive; kGeoMatrixOwned; kGeoCombiTrans; kGeoGenTrans; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfRotationMatrix[9]rotation matrix; Double_tfScale[3]scale component; Double_tfTranslation[3]translation component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHMatrix(); dummy ctor. TGeoHMatrix(const char* name); constructor. TGeoHMatrix(const TGeoMatrix& matrix); assignment. ~TGeoHMatrix(); destructor. TGeoHMatrix & operator=(const TGeoMatrix* matrix); assignment. TGeoHMatrix & operator=(const TGeoMatrix& matrix); assignment. void CopyFrom(const TGeoMatrix* other); Fast copy method. void Clear(Option_t* option = """"); clear the data for this matrix. TGeoMatrix * MakeClone() const; Make a clone of this matrix. TGeoMatrix& Inverse() const; Return a temporary inverse of this. Double_t Determinant() const; computes determinant of the rotation matrix. void Multiply(const TGeoMatrix* right); multiply to the right with an other transformation; if right is identity matrix, just return. void MultiplyLeft(const TGeoMatrix* left); multiply to the left with an other transformation; if right is identity matrix, just return. void RotateX(Double_t angle); Rotate about X axis with angle expressed in degrees. void RotateY(Double_t angle); Rotate about Y axis with angle expressed in degrees. void RotateZ(Double_t angle); Rotate about Z axis with angle expressed in degrees. void ReflectX(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to YZ. void ReflectY(Bool_t leftside, Bool_t rotonly = kFALSE); Multiply by a reflection respect to ZX. void ReflectZ(Bool_t leftside, Bool_t rotonly = kFAL",MatchSource.WIKI,root/html530/TGeoHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHMatrix.html
https://root.cern/root/html530/TGeoHype.html:4315,Availability,error,error,4315,"FromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetF",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:4399,Availability,error,error,4399,"dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:983,Integrability,rout,rout,983,". TGeoHype. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1039,Integrability,rout,rout,1039,". TGeoHype. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1092,Integrability,rout,rout,1092," function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1100,Integrability,rout,rout,1100," function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1133,Integrability,rout,rout,1133," function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoHype. class TGeoHype: public TGeoTube. TGeoHype - Hyperboloid class defined by 5 parameters. Bounded by:; - Two z planes at z=+/-dz; - Inner and outer lateral surfaces. These represent the surfaces; described by the revolution of 2 hyperbolas about the Z axis:; r^2 - (t*z)^2 = a^2. r = distance between hyperbola and Z axis at coordinate z; t = tangent of the stereo angle (angle made by hyperbola; asimptotic lines and Z axis). t=0 means cylindrical surface.; a = distance between hyperbola and Z axis at z=0. The inner hyperbolic surface is described by:; r^2 - (tin*z)^2 = rin^2; - absence of the inner surface (filled hyperboloid can be forced; by rin=0 and sin=0; The outer hyperbolic surface is described by:; r^2 - (tout*z)^2 = rout^2; TGeoHype parameters: dz[cm], rin[cm], sin[deg], rout[cm], sout[deg].; MANDATORY conditions:; - rin < rout; - rout > 0; - rin^2 + (tin*dz)^2 > rout^2 + (tout*dz)^2; SUPPORTED CASES:; - rin = 0, tin != 0 => inner surface conical; - tin=0 AND/OR tout=0 => corresponding surface(s) cyllindrical; e.g. tin=0 AND tout=0 => shape becomes a tube with: rmin,rmax,dz. Function Members (Methods); public:. TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() const; voidTGeoShape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1500,Integrability,rout,rout,1500," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:1601,Integrability,rout,rout,1601," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:10238,Integrability,rout,rout,10238,"ResetBit(UInt_t f); voidTGeoShape::ResetShapeBit(UInt_t f); virtual Double_tSafety(Double_t* point, Bool_t in = kTRUE) const; static Double_tTGeoShape::SafetyPhi(Double_t* point, Bool_t in, Double_t phi1, Double_t phi2); static Double_tTGeoTube::SafetyS(Double_t* point, Bool_t in, Double_t rmin, Double_t rmax, Double_t dz, Int_t skipz = 0); Double_tSafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidSetSegsAndPols(TBuffer3D& buff) const; voidTGeoShape::SetShapeBit(UInt_t f); voidTGeoShape::SetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTGeoShape::SetTransform(TGeoMatrix* matrix); voidTGeoTube::SetTubeDimensions(Double_t rmin, Double_t rmax, Double_t dz); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tTGeoShape::ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamer",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:13922,Integrability,rout,rout,13922,"; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to s",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:14070,Integrability,rout,rout,14070," Double_tTGeoBBox::fDZZ half-length; Double_tTGeoTube::fDzhalf length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; Double_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Doub",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:14290,Integrability,rout,rout,14290,"e_tTGeoTube::fRmaxouter radius; Double_tTGeoTube::fRmininner radius; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; Double_tfStInStereo angle for inner surface; Double_tfStOutStereo angle for inner surface; TStringTNamed::fTitleobject title. private:. Double_tfTinTangent of stereo angle for inner surface; Double_tfTinsqSquared tangent of stereo angle for inner surface; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bo",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:17085,Integrability,rout,rout,17085,"st; Creates a TBuffer3D describing *this* shape.; Coordinates are in local reference frame. void SetSegsAndPols(TBuffer3D& buff) const; Fill TBuffer3D structure for segments and polygons. Double_t RadiusHypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments();; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4;; painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D bu",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:17311,Integrability,rout,rout,17311,"HypeSq(Double_t z, Bool_t inner) const; Compute r^2 = x^2 + y^2 at a given z coordinate, for either inner or outer hyperbolas. Double_t ZHypeSq(Double_t r, Bool_t inner) const; Compute z^2 at a given r^2, for either inner or outer hyperbolas. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; computes the closest distance from given point to this shape, according; to option. The matching point on the shape is stored in spoint. Double_t SafetyToHype(Double_t* point, Bool_t inner, Bool_t in) const; Compute an underestimate of the closest distance from a point to inner or; outer infinite hyperbolas. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void SetHypeDimensions(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Set dimensions of the hyperboloid. void SetDimensions(Double_t* param); Set dimensions of the hyperboloid starting from an array.; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. void SetPoints(Double_t* points) const; create tube mesh points. void SetPoints(Float_t* points) const; create tube mesh points. void GetMeshNumbers(Int_t& nvert, Int_t& nsegs, Int_t& npols) const; Returns numbers of vertices, segments and polygons composing the shape mesh. Int_t GetNmeshVertices() const; Return number of vertices of the mesh representation. void Sizeof3D() const; fill size of this 3-D object; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Int_t n = gGeoManager->GetNsegments();; Int_t numPoints = n*4;; Int_t numSegs = n*8;; Int_t numPolys = n*4;; painter->AddSize3D(numPoints, numSegs, numPolys);. const TBuffer3D & GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; Fills a static 3D buffer and returns a reference. TGeoHype(); constructors. Int_t GetByteCount() const; {return 64;}. Bool_t GetPointsOnSegments(Int_t , Double_t* ) const; {return kFALSE;}. Double_t GetStIn() const; {return",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:3014,Safety,safe,safe,3014,"hape::CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:3272,Safety,safe,safe,3272,"st; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidComputeBBox(); static Double_tTGeoShape::ComputeEpsMch(); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); static voidTGeoTube::ComputeNormalS(Double_t* point, Double_t* dir, Double_t* norm, Double_t rmin, Double_t rmax, Double_t dz); virtual Bool_tContains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tTGeoBBox::CouldBeCrossed(Double_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromInsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); Int_tDistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:14883,Safety,safe,safe,14883,"structor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:15083,Safety,safe,safe,15083,"le_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Get range of shape for a given axis. void GetBoundingCylinder(Double_t* param) const; --- Fill vector param[4] with the bounding cylinder parameters. The order; is the following : Rmin, Rmax, Phi1, Phi2, dZ. TGeoShape * GetMakeRuntimeShape(TGeoShape* mother, TGeoMatrix* mat) const; in case shape has some negative parameters, these has to be computed; in order to fit the mother. void InspectShape() const; print shape parameters. TBuffer",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:2039,Testability,test,testNo,2039," TGeoHype(); TGeoHype(Double_t* params); TGeoHype(const TGeoHype&); TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); virtual~TGeoHype(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTGeoBBox::AreOverlapping(const TGeoBBox* box1, const TGeoMatrix* mat1, const TGeoBBox* box2, const TGeoMatrix* mat2); static Double_tTGeoShape::Big(); virtual voidTObject::Browse(TBrowser* b); virtual Double_tCapacity() c",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHype.html:14627,Testability,test,test,14627,"face; Double_tfToutTangent of stereo angle for outer surface; Double_tfToutsqSquared tangent of stereo angle for outer surface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHype(); Default constructor. TGeoHype(Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying hyperboloid parameters. TGeoHype(const char* name, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Constructor specifying parameters and name. TGeoHype(Double_t* params); Default constructor specifying a list of parameters; param[0] = dz; param[1] = rin; param[2] = stin; param[3] = rout; param[4] = stout. ~TGeoHype(); destructor. Double_t Capacity() const; Computes capacity of the shape in [length^3]. void ComputeBBox(); Compute bounding box of the hyperboloid. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Compute normal to closest surface from POINT. Bool_t Contains(Double_t* point) const; test if point is inside this tube. Int_t DistancetoPrimitive(Int_t px, Int_t py); compute closest distance from point px,py to each corner. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to surface of the hyperboloid. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from outside point to surface of the hyperboloid. Int_t DistToHype(Double_t* point, Double_t* dir, Double_t* s, Bool_t inner, Bool_t in) const; Compute distance from an arbitrary point to inner/outer surface of hyperboloid.; Returns number of positive solutions. S[2] contains the solutions. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Cannot divide hyperboloids. Double_t GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) cons",MatchSource.WIKI,root/html530/TGeoHype.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHype.html
https://root.cern/root/html530/TGeoHypeEditor.html:4603,Availability,error,error,4603,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHypeEditor.html
https://root.cern/root/html530/TGeoHypeEditor.html:4687,Availability,error,error,4687,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHypeEditor.html
https://root.cern/root/html530/TGeoHypeEditor.html:17907,Availability,mask,mask,17907,,MatchSource.WIKI,root/html530/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHypeEditor.html
https://root.cern/root/html530/TGeoHypeEditor.html:21449,Usability,undo,undoing,21449," position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut.  Author: M.Gheata  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoHypeEditor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoHypeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoHypeEditor.html
https://root.cern/root/html530/TGeoIdentity.html:6228,Availability,error,error,6228,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:8060,Availability,error,error,8060,"tity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:8144,Availability,error,error,8144,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslation() const; virtual UInt_tTObject:",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:3100,Integrability,interface,interface,3100," 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving from the same basic abstract class and handling its specific; data and point/vector transformation algorithms. /*. */. The base class TGeoMatrix defines abstract metods for:. - translation, rotation and scale getters. Every derived class stores only; its specific data, e.g. a translation stores an array of 3 doubles and a; rotation an array of 9. However, asking which is the rotation array of a; TGeoTranslation through the base TGeoMatrix interface is a legal operation.; The answer in this case is a pointer to a global constant array representing; an identity rotation.; Double_t *TGeoMatrix::GetTranslation(); Double_t *TGeoMatrix::GetRotation(); Double_t *TGeoMatrix::GetScale(). - MasterToLocal() and LocalToMaster() point and vector transformations :; void TGeoMatrix::MasterToLocal(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local, Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master, Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local, Double_t *master); These allow correct conversion also for reflections.; - Transformation type getters :; Bool_t TGeoMatrix::IsIdentity(); Bool_t TGeoMatrix::IsTranslation(); Bool_t TGeoMatrix::IsRotation(); Bool_t TGeoMatrix::IsScale(); Bool_t TGeoMatrix::IsCombi() (translation + rotation); Bool_t TGeoMatrix::IsGeneral() (translation + rotation + scale). Combinatio",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:6234,Integrability,message,message,6234,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:6979,Modifiability,variab,variable,6979,"th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Er",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:484,Performance,optimiz,optimize,484,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:493,Performance,perform,performance,493,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:978,Performance,perform,performed,978,". TGeoIdentity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoIdentity. class TGeoIdentity: public TGeoMatrix. Geometrical transformation package. All geometrical transformations handled by the modeller are provided as a; built-in package. This was designed to minimize memory requirements and; optimize performance of point/vector master-to-local and local-to-master; computation. We need to have in mind that a transformation in TGeo has 2; major use-cases. The first one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: I",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:1704,Performance,perform,performed,1704,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:6211,Performance,perform,performed,6211,"dy,dz) translation. Data members:; Double_t fTranslation[3]. Translations can be added/subtracted.; TGeoTranslation t1;; t1->SetTranslation(-5,10,4);; TGeoTranslation *t2 = new TGeoTranslation(4,3,10);; t2->Subtract(&t1);. 2. Rotations - represent a pure rotation. Data members: Double_t fRotationMatrix[3*3].; Rotations can be defined either by Euler angles, either, by GEANT3 angles :; TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi, theta, psi); // all angles in degrees; This represent the composition of : first a rotation about Z axis with; angle phi, then a rotation with theta about the rotated X axis, and; finally a rotation with psi about the new Z axis. r1->SetAngles(th1,phi1, th2,phi2, th3,phi3); This is a rotation defined in GEANT3 style. Theta and phi are the spherical; angles of each axis of the rotated coordinate system with respect to the; initial one. This construction allows definition of malformed rotations,; e.g. not orthogonal. A check is performed and an error message is issued; in this case. Specific utilities : determinant, inverse. 3. Scale transformations - represent a scale shrinking/enlargement. Data; members :Double_t fScale[3]. Not fully implemented yet. 4. Combined transformations - represent a rotation folowed by a translation.; Data members: Double_t fTranslation[3], TGeoRotation *fRotation.; TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;. TGeoCombiTrans *c1 = new TGeoCombiTrans(trans, rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). 5. TGeoGenTrans - combined transformations including a scale. Not implemented.; 6. TGeoIdentity - a generic singleton matrix representing a identity transformation; NOTE: identified by the global variable gGeoIdentity. Function Members (Methods); public:. TGeoIdentity(); TGeoIdentity(const char* name); TGeoIdentity(const TGeoIdentity&); virtual~TGeoIdentity(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(O",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIdentity.html:1717,Usability,simpl,simple,1717,"one is for defining the placement of a volume; with respect to its container reference frame. This frame will be called; 'master' and the frame of the positioned volume - 'local'. If T is a; transformation used for positioning volume daughters, then:. MASTER = T * LOCAL. Therefore a local-to-master conversion will be performed by using T, while; a master-to-local by using its inverse. The second use case is the computation; of the global transformation of a given object in the geometry. Since the; geometry is built as 'volumes-inside-volumes', this global transformation; represent the pile-up of all local transformations in the corresponding; branch. The conversion from the global reference frame and the given object; is also called master-to-local, but it is handled by the manager class.; A general homogenous transformation is defined as a 4x4 matrix embeeding; a rotation, a translation and a scale. The advantage of this description; is that each basic transformation can be represented as a homogenous matrix,; composition being performed as simple matrix multiplication.; Rotation: Inverse rotation:; r11 r12 r13 0 r11 r21 r31 0; r21 r22 r23 0 r12 r22 r32 0; r31 r32 r33 0 r13 r23 r33 0; 0 0 0 1 0 0 0 1. Translation: Inverse translation:; 1 0 0 tx 1 0 0 -tx; 0 1 0 ty 0 1 0 -ty; 0 0 1 tz 0 0 1 -tz; 0 0 0 1 0 0 0 1. Scale: Inverse scale:; sx 0 0 0 1/sx 0 0 0; 0 sy 0 0 0 1/sy 0 0; 0 0 sz 0 0 0 1/sz 0; 0 0 0 1 0 0 0 1. where: rij are the 3x3 rotation matrix components,; tx, ty, tz are the translation components; sx, sy, sz are arbitrary scale constants on the eacks axis,. The disadvantage in using this approach is that computation for 4x4 matrices; is expensive. Even combining two translation would become a multiplication; of their corresponding matrices, which is quite an undesired effect. On the; other hand, it is not a good idea to store a translation as a block of 16; numbers. We have therefore chosen to implement each basic transformation type; as a class deriving fr",MatchSource.WIKI,root/html530/TGeoIdentity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIdentity.html
https://root.cern/root/html530/TGeoIntersection.html:2886,Availability,error,error,2886,"uble_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:2970,Availability,error,error,2970,"nt, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoMatrix*TGeoBoolNode::GetRightMatrix() const; TGeoShape*TGeoBoolNode::GetRightShape() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handle",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:2388,Safety,safe,safe,2388,"GeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); virtual~TGeoIntersection(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnl",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:2514,Safety,safe,safe,2514," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); virtual Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:8851,Safety,safe,safe,8851,"; Libraries. Function documentation; void Paint(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const.  Author: Andrei Gheata 30/05/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:9036,Safety,safe,safe,9036,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const.  Author: Andrei Gheata 30/05/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIntersection.html:9281,Safety,safe,safety,9281,"(Option_t* option); Paint method. TGeoIntersection(); Default constructor. TGeoIntersection(const char* expr1, const char* expr2); Constructor. TGeoIntersection(TGeoShape* left, TGeoShape* right, TGeoMatrix* lmat = 0, TGeoMatrix* rmat = 0); Constructor providing pointers to components. ~TGeoIntersection(); Destructor; --- deletion of components handled by TGeoManager class. void ComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); Compute bounding box corresponding to a intersection of two shapes. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Normal computation in POINT. The orientation is chosen so that DIR.dot.NORM>0. Bool_t Contains(Double_t* point) const; Find if a intersection of two shapes contains a given point. Int_t DistanceToPrimitive(Int_t px, Int_t py); Compute minimum distance to shape vertices. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point inside to the shape boundary. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; Compute distance from a given point outside to the shape. Int_t GetNpoints(); Returns number of vertices for the composite shape described by this intersection. Double_t Safety(Double_t* point, Bool_t in = kTRUE) const; Compute safety distance for a union node;. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Sizeof3D() const; Register 3D size of this shape. EGeoBoolType GetBooleanOperator() const.  Author: Andrei Gheata 30/05/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: :$Id: TGeoBoolNode.h 32690 2010-03-21 08:47:56Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoIntersection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIntersection.html
https://root.cern/root/html530/TGeoIsotope.html:1612,Availability,error,error,1612,"GeoIsotope(const char* name, Int_t z, Int_t n, Double_t a); virtual~TGeoIsotope(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TGeoIsotope*FindIsotope(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetA() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNa",MatchSource.WIKI,root/html530/TGeoIsotope.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIsotope.html
https://root.cern/root/html530/TGeoIsotope.html:1696,Availability,error,error,1696,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TGeoIsotope*FindIsotope(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetA() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html530/TGeoIsotope.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIsotope.html
https://root.cern/root/html530/TGeoIterator.html:3929,Modifiability,plugin,plugin,3929,"e *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp); voidSkip(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheri",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:4457,Modifiability,plugin,plugin,4457,tring& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp); voidSkip(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The ,MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:5685,Modifiability,plugin,plugin,5685," finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The iteration of the next node will; behave as if the branch starting from the current node (included) is not existing. void SetUserPlugin(TGeoIteratorPlugin* plugin); Set a plugin. Int_t GetIndex(); {return 0;}. TGeoIterator(); { }. Int_t GetLevel() const; {return fLevel;}. * GetUserPlugin() const; {return fPlugin;}. TGeoVolume * GetTopVolume() const; {return fTop;}. Int_t GetType() const; {return fType;}. void SetPluginAutoexec(Bool_t mode); {fPluginAutoexec = mode;}. void SetType(Int_t type); {fType = type;}.  Author: Andrei Gheata 24/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoNode.h 35859 2010-09-29 13:59:30Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:5700,Modifiability,plugin,plugin,5700," finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const; Returns the path for the current node. void IncreaseArray(); Increase by 30 the size of the array. void Reset(TGeoVolume* top = 0); Resets the iterator for volume TOP. void SetTopName(const char* name); Set the top name for path. void Skip(); Stop iterating the current branch. The iteration of the next node will; behave as if the branch starting from the current node (included) is not existing. void SetUserPlugin(TGeoIteratorPlugin* plugin); Set a plugin. Int_t GetIndex(); {return 0;}. TGeoIterator(); { }. Int_t GetLevel() const; {return fLevel;}. * GetUserPlugin() const; {return fPlugin;}. TGeoVolume * GetTopVolume() const; {return fTop;}. Int_t GetType() const; {return fType;}. void SetPluginAutoexec(Bool_t mode); {fPluginAutoexec = mode;}. void SetType(Int_t type); {fType = type;}.  Author: Andrei Gheata 24/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoNode.h 35859 2010-09-29 13:59:30Z brun $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:2874,Performance,perform,perform,2874,"vel in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::AddNodeOverlap(same arguments);. When closing the geometry, overlapping nodes perform a check of possible; overlaps with their neighbours. These are stored and checked all the time; during navigation, therefore navigation is slower when embedding such nodes; into geometry. Node have visualization attributes as volume have. When undefined by users,; painting a node on a pad will take the corresponding volume attributes. /*. */. Function Members (Methods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:1263,Testability,log,logical,1263," TGeoNode. A node represent a volume positioned inside another.They store links to both; volumes and to the TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:1344,Testability,log,logical,1344," TGeoMatrix representing the relative positioning. Node are; never instanciated directly by users, but created as a result of volume operations.; Adding a volume named A with a given user ID inside a volume B will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a po",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:1504,Testability,log,logical,1504," will create a node; node named A_ID. This will be added to the list of nodes stored by B. Also,; when applying a division operation in N slices to a volume A, a list of nodes; B_1, B_2, ..., B_N is also created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-ov",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:1712,Testability,log,logical,1712," created. A node B_i does not represent a unique; object in the geometry because its container A might be at its turn positioned; as node inside several other volumes. Only when a complete branch of nodes; is fully defined up to the top node in the geometry, a given path like:; /TOP_1/.../A_3/B_7 will represent an unique object. Its global transformation; matrix can be computed as the pile-up of all local transformations in its; branch. We will therefore call ""logical graph"" the hierarchy defined by nodes; and volumes. The expansion of the logical graph by all possible paths defines; a tree sructure where all nodes are unique ""touchable"" objects. We will call; this the ""physical tree"". Unlike the logical graph, the physical tree can; become a huge structure with several milions of nodes in case of complex; geometries, therefore it is not always a good idea to keep it transient; in memory. Since a the logical and physical structures are correlated, the; modeller rather keeps track only of the current branch, updating the current; global matrix at each change of the level in geometry. The current physical node; is not an object that can be asked for at a given moment, but rather represented; by the combination: current node + current global matrix. However, physical nodes; have unique ID's that can be retreived for a given modeler state. These can be; fed back to the modeler in order to force a physical node to become current.; The advantage of this comes from the fact that all navigation queries check; first the current node, therefore knowing the location of a point in the; geometry can be saved as a starting state for later use. Nodes can be declared as ""overlapping"" in case they do overlap with other; nodes inside the same container or extrude this container. Non-overlapping; nodes can be created with:. TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);. The creation of overapping nodes can be done with a similar prototype:. TGeoVolume::Ad",MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIterator.html:4319,Usability,resume,resume,4319,ethods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp); voidSkip(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const;,MatchSource.WIKI,root/html530/TGeoIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIterator.html
https://root.cern/root/html530/TGeoIteratorPlugin.html:2212,Availability,avail,available,2212,"A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=next())); if (name == node->GetVolume()->GetName()) return node->GetVolume();. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TGeoIteratorPlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html530/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIteratorPlugin.html
https://root.cern/root/html530/TGeoIteratorPlugin.html:3188,Availability,error,error,3188,,MatchSource.WIKI,root/html530/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIteratorPlugin.html
https://root.cern/root/html530/TGeoIteratorPlugin.html:3272,Availability,error,error,3272," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIteratorPlugin.html
https://root.cern/root/html530/TGeoIteratorPlugin.html:630,Performance,perform,perform,630,". TGeoIteratorPlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoIteratorPlugin. class TGeoIteratorPlugin: public TObject. TGeoIterator. A geometry iterator that sequentially follows all nodes of the geometrical; hierarchy of a volume. The iterator has to be initiated with a top volume; pointer:. TGeoIterator next(myVolume);. One can use the iterator as any other in ROOT:. TGeoNode *node;; while ((node=next())) {. }. The iterator can perform 2 types of iterations that can be selected via:. next.SetType(Int_t type);. Here TYPE can be:; 0 (default) - 'first daughter next' behavior; 1 - iteration at the current level only. Supposing the tree structure looks like:. TOP ___ A_1 ___ A1_1 ___ A11_1; | | |___ A12_1; | |_____A2_1 ___ A21_1; | |___ A21_2; |___ B_1 ... The order of iteration for TYPE=0 is: A_1, A1_1, A11_1, A12_1, A2_1, A21_1,; A21_2, B_1, ...; The order of iteration for TYPE=1 is: A_1, B_1, ...; At any moment during iteration, TYPE can be changed. If the last iterated node; is for instance A1_1 and the iteration type was 0, one can do:. next.SetType(1);; The next iterated nodes will be the rest of A daughters: A2,A3,... The iterator; will return 0 after finishing all daughters of A. During iteration, the following can be retreived:; - Top volume where iteration started: TGeoIterator::GetTopVolume(); - Node at level I in the current branch: TGeoIterator::GetNode(Int_t i); - Iteration type: TGeoIterator::GetType(); - Global matrix of the current node with respect to the top volume:; TGeoIterator::GetCurrentMatrix(). The iterator can be reset by changing (or not) the top volume:. TGeoIterator::Reset(TGeoVolume *top);. Example:. We want to find out a volume named ""MyVol"" in the hierarchy of TOP volume. TIter next(TOP);; TGeoNode *node;; TString name(""MyVol"");; while ((node=ne",MatchSource.WIKI,root/html530/TGeoIteratorPlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoIteratorPlugin.html
https://root.cern/root/html530/TGeoManager.html:8219,Availability,down,down,8219,"*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt).",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:8485,Availability,down,down,8485,"rting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coo",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:10223,Availability,down,down,10223,"nates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; will shoot rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes will appear as segments; having the color of the touched node. Drawn geometry will be then made invisible; in order to enhance rays. /*. */. Function Members (Methods); public:. TGeoManager(); TGeoManager(const char* name, const char",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:13328,Availability,down,downwards,13328,,MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:14310,Availability,error,error,14310,"dLocate(Bool_t downwards, TGeoNode* skipnode); voidDefaultAngles()MENU ; voidDefaultColors()MENU ; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExport(const char* filename, const char* name = """", Option_t* option = ""v""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoMaterial*FindDuplicateMaterial(const TGeoMaterial* mat) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObjec",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:14394,Availability,error,error,14394,"Colors()MENU ; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExport(const char* filename, const char* name = """", Option_t* option = ""v""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoMaterial*FindDuplicateMaterial(const TGeoMaterial* mat) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNormal(Bool_t forward = kTRUE); Double_t*FindNormalFast(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualGeoTrack*FindTrackWithId(In",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:27601,Availability,down,downwards,27601,"= """"); voidRandomRays(Int_t nrays = 1000, Double_t startx = 0, Double_t starty = 0, Double_t startz = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRefreshPhysicalNodes(Bool_t lock = kTRUE); voidRegisterMatrix(const TGeoMatrix* matrix); voidRemoveMaterial(Int_t index); Int_tReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); voidTObject::ResetBit(UInt_t f); voidResetState(); voidResetUserData(); voidRestoreMasterVolume()MENU ; Double_tSafety(Bool_t inside = kFALSE); TGeoNode*SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil = 1E-5, const char* g3path = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; voidSaveAttributes(const char* filename = ""tgeoatt.C"")MENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TGeoNode*SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); voidSelectTrackingMedia(); TGeoPNEntry*SetAlignableEntry(const char* unique_name, const char* path, Int_t uid = -1); voidSetAllIndex(); voidSetAnimateTracks(Bool_t flag = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3)MENU ; voidSetCheckedNode(TGeoNode* node); voidSetCheckingOverlaps(Bool_t flag = kTRUE); voidSetCldirChecked(Double_t* dir); voidSetClipping(Bool_t flag = kTRUE)MENU ; voidSetClippingShape(TGeoShape* clip); voidSetCurrentDirection(Double_t* dir); voidSetCurrentDirection(Double_t nx, Double_t ny, Double_t nz); Bool_tSetCurrentNavigator(Int_t index); voidSetCurrentPoint(Double_t* point); voidSetCurrentPoint(Double_t x, Double_t y, Double_t z); voidSetCurrentTrack(Int_t i); voidSetCurrentTrack(TVirtualGeoTrack* track); voidSetDrawExtraPaths(Bool_t flag = kTRUE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetExplodedView(Int_t iopt =",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:45392,Availability,down,down,45392," reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTracks(Option_t* option = """"); Draw tracks over the geometry, according to option. By default, only; primaries are drawn. See TGeoTrack::Draw() for additional options. void DrawPath(const char* path); Draw current path. void RandomPoints(const TGeoVolume* vol, Int_t npoints = 10000, Option_t* option = """"); Draw random points in the bounding box of a volume. void Test(Int_t npoints = 1000000, Option_t* option = """"); Check time of finding ""Where am I"" for n points. void TestOverlaps(const char* path = """"); Geometry overlap checker based on sampling. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an arra",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:49063,Availability,down,down,49063," the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expressio",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:49450,Availability,down,down,49450,"rical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attribute",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:49999,Availability,error,error,49999,"el; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (d",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:50487,Availability,down,downwards,50487,"reasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represen",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:50651,Availability,down,downwards,50651,"in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:64158,Availability,error,errors,64158,"""); return;}; Int_t *media = new Int_t[nmat];; memset(media, 0, nmat*sizeof(Int_t));; Int_t imedia = 1;; TGeoMaterial *mat, *matref;; mat = (TGeoMaterial*)fMaterials->At(0);; if (mat->GetMedia()) {; for (Int_t i=0; i<nmat; i++) {; mat = (TGeoMaterial*)fMaterials->At(i);; mat->Print();; }; return;; }; mat->SetMedia(imedia);; media[0] = imedia++;; mat->Print();; for (Int_t i=0; i<nmat; i++) {; mat = (TGeoMaterial*)fMaterials->At(i);; for (Int_t j=0; j<i; j++) {; matref = (TGeoMaterial*)fMaterials->At(j);; if (mat->IsEq(matref)) {; mat->SetMedia(media[j]);; break;; }; if (j==(i-1)) {; // different material; mat->SetMedia(imedia);; media[i] = imedia++;; mat->Print();; }; }; }. void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); Check pushes and pulls needed to cross the next boundary with respect to the; position given by FindNextBoundary. If radius is not mentioned the full bounding; box will be sampled. void CheckBoundaryReference(Int_t icheck = -1); Check the boundary errors reference file created by CheckBoundaryErrors method.; The shape for which the crossing failed is drawn with the starting point in red; and the extrapolated point to boundary (+/- failing push/pull) in yellow. void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); Classify a given point. See TGeoChecker::CheckPoint(). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); Test for shape navigation methods. Summary for test numbers:; 1: DistFromInside/Outside. Sample points inside the shape. Generate; directions randomly in cos(theta). Compute DistFromInside and move the; point with bigger distance. Compute DistFromOutside back from new point.; Plot d-(d1+d2). void CheckGeometryFull(Int_t ntracks = 1000000, Double_t vx = 0., Double_t vy = 0., Double_t vz = 0., Option_t* option = ""ob""); Geometry checking.; - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; - if option contains 'b': Optio",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:9713,Deployability,update,updates,9713,"e will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:41098,Deployability,continuous,continuous,41098,"Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY fl",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:41021,Energy Efficiency,energy,energy,41021,"erial * Mixture(const char* name, Float_t* a, Float_t* z, Double_t dens, Int_t nelem, Float_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:8565,Integrability,depend,depending,8565,"panded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visi",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:22429,Integrability,rout,rout,22429,"TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz); TGeoVolume*MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); TGeoVolume*MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); TGeoVolume*MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); TGeoVolume*MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); TGeoVolume*MakeGtra(const char* name, TGeoMedium* medium, Double_t dz, Double_t theta, Double_t phi, Double_t twist, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2); TGeoVolume*MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); TGeoVolume*MakePara(const char* name, TGeoMedium* medium, Double_t dx, Double_t dy, Double_t dz, Double_t alpha, Double_t theta, Double_t phi); TGeoVolume*MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); TGeoVolume*MakePcon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nz); TGeoVolume*MakePgon(const char* name, TGeoMedium* medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz); TGeoPhysicalNode*MakePhysicalNode(const char* path = 0); TGeoVolume*MakeSphere(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t themin = 0, Double_t themax = 180, Double_t phimin = 0, Double_t phimax = 360); TGeoVolume*MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); TVirtualGeoTrack*MakeTrack(Int_t id, Int_t pdgcode, TObject* particle); TGeoVolume*MakeTrap(const char* name, TGeoMedium* medium,",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:32320,Integrability,message,messages,32320,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Double_t*fDblBuffer! transient dbl buffer; Int_tfDblSize! dbl buffer size; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:57379,Integrability,rout,rout,57379,"hemax = 180, Double_t phimin = 0, Double_t phimax = 360); Make in one step a volume pointing to a sphere shape with given medium. TGeoVolume * MakeTorus(const char* name, TGeoMedium* medium, Double_t r, Double_t rmin, Double_t rmax, Double_t phi1 = 0, Double_t dphi = 360); Make in one step a volume pointing to a torus shape with given medium. TGeoVolume * MakeTube(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeTubs(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeEltu(const char* name, TGeoMedium* medium, Double_t a, Double_t b, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeHype(const char* name, TGeoMedium* medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeParaboloid(const char* name, TGeoMedium* medium, Double_t rlo, Double_t rhi, Double_t dz); Make in one step a volume pointing to a tube shape with given medium. TGeoVolume * MakeCtub(const char* name, TGeoMedium* medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2, Double_t lx, Double_t ly, Double_t lz, Double_t tx, Double_t ty, Double_t tz); Make in one step a volume pointing to a tube segment shape with given medium. TGeoVolume * MakeCone(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2); Make in one step a volume pointing to a cone shape with given medium. TGeoVolume * MakeCons(const char* name, TGeoMedium* medium, Double_t dz, Double_t rmin1, Double_t rmax1, Double_t rmin2, Double_t rmax2, Double_t phi1, Double_t phi2); Make in one step a volume pointing to a cone segment ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:67853,Integrability,message,messages,67853,"tream an object of class TGeoManager. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute mouse actions on this manager. Int_t Export(const char* filename, const char* name = """", Option_t* option = ""v""); Export this geometry to a file. -Case 1: root file or root/xml file; if filename end with "".root"". The key will be named name; By default the geometry is saved without the voxelisation info.; Use option 'v"" to save the voxelisation info.; if filename end with "".xml"" a root/xml file is produced. -Case 2: C++ script; if filename end with "".C"". -Case 3: gdml file; if filename end with "".gdml""; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/geom/gdml. void LockGeometry(); Lock current geometry so that no other geometry can be imported. void UnlockGeometry(); Unlock current geometry. Bool_t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:3985,Modifiability,inherit,inherits,3985," several other volumes),; every volume becoming a branch in this graph. Any volume in the logical graph; can become the actual top volume at run time (see TGeoManager::SetTopVolume()).; All functionalities of the modeler will behave in this case as if only the; corresponding branch starting from this volume is the registered geometry. /*. */. A given volume can be positioned several times in the geometry. A volume; can be divided according default or user-defined patterns, creating automatically; the list of division nodes inside. The elementary volumes created during the; dividing process follow the same scheme as usual volumes, therefore it is possible; to position further geometrical structures inside or to divide them further more; (see TGeoVolume::Divide()). The primitive shapes supported by the package are basically the GEANT3; shapes (see class TGeoShape), arbitrary wedges with eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the sam",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:11103,Modifiability,enhance,enhance,11103,"oManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVolume::RandomRays() (context menu of volumes) and; will shoot rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes will appear as segments; having the color of the touched node. Drawn geometry will be then made invisible; in order to enhance rays. /*. */. Function Members (Methods); public:. TGeoManager(); TGeoManager(const char* name, const char* title); virtual~TGeoManager(); voidTObject::AbstractMethod(const char* method) const; Int_tAddMaterial(const TGeoMaterial* material); Int_tAddNavigator(TGeoNavigator* navigator); Int_tAddOverlap(const TNamed* ovlp); Int_tAddShape(const TGeoShape* shape); Int_tAddTrack(TVirtualGeoTrack* track); Int_tAddTrack(Int_t id, Int_t pdgcode, TObject* particle = 0); Int_tAddTransformation(const TGeoMatrix* matrix); Int_tAddVolume(TGeoVolume* volume); voidAnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*"")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidBrowse(TBrowser* b); voidBuildDefaultMaterials(); virtual Bool_tcd(const char* path = """")MENU ; voidCdDown(Int_t index); voidCdNext(); voidCdNode(Int_t nodeid); voidCdTop(); voidCdU",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:5617,Performance,cache,cache,5617," providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. Ther",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:5758,Performance,load,loaded,5758,"the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:6576,Performance,load,loaded,6576,"mes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will dis",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:32259,Performance,load,loaded,32259,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Double_t*fDblBuffer! transient dbl buffer; Int_tfDblSize! dbl buffer size; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:37905,Performance,cache,cache,37905,"t* particle); Makes a primary track but do not attach it to the list of tracks. The track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. Int_t AddNavigator(TGeoNavigator* navigator); Add a navigator in the list of navigators. If it is the first one make it; current navigator. Bool_t SetCurrentNavigator(Int_t index); Switch to another navigator. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START;",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:37989,Performance,cache,cache,37989," track; can be attached as daughter to another one with TVirtualGeoTrack::AddTrack. Int_t AddVolume(TGeoVolume* volume); Add a volume to the list. Returns index of the volume in list. Int_t AddNavigator(TGeoNavigator* navigator); Add a navigator in the list of navigators. If it is the first one make it; current navigator. Bool_t SetCurrentNavigator(Int_t index); Switch to another navigator. void Browse(TBrowser* b); Describe how to browse this object. void Edit(Option_t* option = """"); Append a pad for this geometry. void SetVisibility(TObject* obj, Bool_t vis); Set visibility for a volume. void BombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'bombed' translation vector according current exploded view mode. void UnbombTranslation(const Double_t* tr, Double_t* bombtr); Get the new 'unbombed' translation vector according current exploded view mode. void DoBackupState(); Backup the current state without affecting the cache stack. void DoRestoreState(); Restore a backed-up state without affecting the cache stack. void RegisterMatrix(const TGeoMatrix* matrix); Register a matrix to the list of matrices. It will be cleaned-up at the; destruction TGeoManager. Int_t ReplaceVolume(TGeoVolume* vorig, TGeoVolume* vnew); Replaces all occurences of VORIG with VNEW in the geometry tree. The volume VORIG; is not replaced from the list of volumes, but all node referencing it will reference; VNEW instead. Returns number of occurences changed. Int_t TransformVolumeToAssembly(const char* vname); Transform all volumes named VNAME to assemblies. The volumes must be virtual. TGeoVolume * Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); Create a new volume by dividing an existing one (GEANT3 like). Divides MOTHER into NDIV divisions called NAME; along axis IAXIS starting at coordinate value START; and having size STEP. The created volumes will have tracking; media ID=NUMED (if N",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:41222,Performance,perform,performed,41222," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:41270,Performance,perform,performed,41270," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:41317,Performance,perform,performed,41317," defined by arrays A,Z and WMAT, having an unique id. TGeoMaterial * Mixture(const char* name, Double_t* a, Double_t* z, Double_t dens, Int_t nelem, Double_t* wmat, Int_t uid); Create mixture OR COMPOUND IMAT as composed by THE BASIC nelem; materials defined by arrays A,Z and WMAT, having an unique id. TGeoMedium * Medium(const char* name, Int_t numed, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); Create tracking medium. numed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm). ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; performed with g3helix; ifield = 3 if tracking performed with g3helx3. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Float_t* upar, Int_t npar = 0); Create a node called <name_nr> pointing to the volume called <name>; as daughter of the volume called <mother> (gspos). The relative matrix is; made of : a translation (x,y,z) and a rotation matrix named <matIROT>.; In case npar>0, create the volume to be positioned in mother, according; its actual parameters (gsposp).; NAME Volume name; NUMBER Copy number of the volume; MOTHER Mother volume name; X X coord. of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. void Node(const char* name, Int_t nr, const char* mother, Double_t x, Double_t y, Double_t z, Int_t irot, Bool_t isOnly, Do",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:43819,Performance,cache,cache,43819,".; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. TGeoVolume * Volume(const char* name, const char* shape, Int_t nmed, Double_t* upar, Int_t npar = 0); Create a volume in GEANT3 style.; NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accord",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:44308,Performance,perform,performance,44308," NAME Volume name; SHAPE Volume type; NMED Tracking medium number; NPAR Number of shape parameters; UPAR Vector containing shape parameters. void SetAllIndex(); Assigns uid's for all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:44465,Performance,cache,cache,44465,"all materials,media and matrices. void ClearAttributes(); Reset all attributes to default ones. Default attributes for visualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCu",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:44584,Performance,cache,cache,44584,"sualization; are those defined before closing the geometry. void CloseGeometry(Option_t* option = ""d""); Closing geometry implies checking the geometry validity, fixing shapes; with negative parameters (run-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:44788,Performance,cache,cache,44788,"n-time shapes)building the cache manager,; voxelizing all volumes, counting the total number of physical nodes and; registring the manager class to the browser. void ClearOverlaps(); Clear the list of overlaps. void ClearShape(const TGeoShape* shape); Remove a shape from the list of shapes. void CleanGarbage(); Clean temporary volumes and shapes from garbage collection. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). Int_t GetCurrentNodeId() const; Get the unique ID of the current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdNext(); Do a cd to the node found next by FindNextBoundary. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from fTopNode according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the current navigator. void ConvertReflections(); Convert all reflections in geometry to normal rotations + reflected shapes. Int_t CountNodes(const TGeoVolume* vol = 0, Int_t nlevels = 10000, Int_t option = 0); Count the total number of nodes starting from a volume, nlevels down. void DefaultAngles(); Set default angles for a given view. void DrawCurrentPoint(Int_t color = 2); Draw current point in the same view. void AnimateTracks(Double_t tmin = 0, Double_t tmax = 5E-8, Int_t nframes = 200, Option_t* option = ""/*""); Draw animation of tracks. void DrawTracks(Option_t* option = """"); Draw tracks over the geometry, according to option. By default, only; primaries are dr",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:49481,Performance,perform,performed,49481,"rical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attribute",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:68765,Performance,load,loaded,68765,"t IsLocked(); Check lock state. Int_t GetVerboseLevel(); Set verbosity level (static function).; 0 - suppress messages related to geom-painter visibility level; 1 - default value. void SetVerboseLevel(Int_t vl); Return current verbosity level (static function). TGeoManager * Import(const char* filename, const char* name = """", Option_t* option = """"); static function; Import a geometry from a gdml or ROOT file. -Case 1: gdml; if filename ends with "".gdml"" the foreign geometry described with gdml; is imported executing some python scripts in $ROOTSYS/gdml.; NOTE that to use this option, the PYTHONPATH must be defined like; export PYTHONPATH=$ROOTSYS/lib:$ROOTSYS/gdml. -Case 2: root file (.root) or root/xml file (.xml); Import in memory from filename the geometry with key=name.; if name="""" (default), the first TGeoManager object in the file is returned. Note that this function deletes the current gGeoManager (if one); before importing the new object. void UpdateElements(); Update element flags when geometry is loaded from a file. Bool_t InitArrayPNE() const; Initialize PNE array for fast access via index and unique-id. Int_t * GetIntBuffer(Int_t length); Get a temporary buffer of Int_t*. Double_t * GetDblBuffer(Int_t length); Get a temporary buffer of Double_t*. Bool_t GetTminTmax(Double_t& tmin, Double_t& tmax) const; Get time cut for drawing tracks. void SetTminTmax(Double_t tmin = 0, Double_t tmax = 999); Set time cut interval for drawing tracks. If called with no arguments, time; cut will be disabled. void MasterToTop(const Double_t* master, Double_t* top) const; Convert coordinates from master volume frame to top. void TopToMaster(const Double_t* top, Double_t* master) const; Convert coordinates from top volume frame to master. Bool_t IsLoopingVolumes() const; --- private methods. {return fLoopVolumes;}. void SetLoopVolumes(Bool_t flag = kTRUE); {fLoopVolumes=flag;}. Int_t GetNmany() const; {return fCurrentNavigator->GetNmany();}. Bool_t IsFolder() const; --- visual",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:77481,Performance,cache,cache,77481,"LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCurrentNavigator->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return fCurrentNavigator->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return fCurrentNavigator->PushPath(startlevel);}. Bool_t PopPath(); {return fCurrentNavigator->PopPath();}. Bool_t PopPath(Int_t index); {return fCurrentNavigator->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return fCurrentNavigator->PushPoint(startlevel);}. Bool_t PopPoint(); {return fCurrentNavigator->PopPoint();}. Bool_t PopPoint(Int_t index); {return fCurrentNavigator->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return fCurrentNavigator->PopDummy(ipop);}.  Author: Andrei Gheata 25/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoManager.h 39018 2011-04-25 09:38:31Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:77514,Performance,cache,cache,77514,"LocalToMaster(const Double_t* local, Double_t* master) const; --- point/vector reference frame conversion. {fCurrentNavigator->LocalToMaster(local, master);}. void LocalToMasterVect(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterVect(local, master);}. void LocalToMasterBomb(const Double_t* local, Double_t* master) const; {fCurrentNavigator->LocalToMasterBomb(local, master);}. void MasterToLocal(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocal(master, local);}. void MasterToLocalVect(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalVect(master, local);}. void MasterToLocalBomb(const Double_t* master, Double_t* local) const; {fCurrentNavigator->MasterToLocalBomb(master, local);}. TGeoVolume * GetVolume(const char* name) const; TGeoShape *GetShape(const char *name) const;. Int_t GetNNodes(); {if (!fNNodes) CountNodes(); return fNNodes;}. TGeoNodeCache * GetCache() const; void SetCache(const TGeoNodeCache *cache) {fCache = (TGeoNodeCache*)cache;}. {return fCurrentNavigator->GetCache();}. void SetAnimateTracks(Bool_t flag = kTRUE); {fIsGeomReading=flag;}. Int_t PushPath(Int_t startlevel = 0); --- stack manipulation. {return fCurrentNavigator->PushPath(startlevel);}. Bool_t PopPath(); {return fCurrentNavigator->PopPath();}. Bool_t PopPath(Int_t index); {return fCurrentNavigator->PopPath(index);}. Int_t PushPoint(Int_t startlevel = 0); {return fCurrentNavigator->PushPoint(startlevel);}. Bool_t PopPoint(); {return fCurrentNavigator->PopPoint();}. Bool_t PopPoint(Int_t index); {return fCurrentNavigator->PopPoint(index);}. void PopDummy(Int_t ipop = 9999); {return fCurrentNavigator->PopDummy(ipop);}.  Author: Andrei Gheata 25/10/01  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id: TGeoManager.h 39018 2011-04-25 09:38:31Z agheata $  Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:416,Safety,detect,detector,416,". TGeoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TGeoManager. class TGeoManager: public TNamed. General architecture. The new ROOT geometry package is a tool designed for building, browsing,; tracking and visualizing a detector geometry. The code is independent from; other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic c",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:1451,Safety,detect,detector,1451," other external MC for simulation, therefore it does not contain any; constraints related to physics. However, the package defines a number of; hooks for tracking, such as media, materials, magnetic field or track state flags,; in order to allow interfacing to tracking MC's. The final goal is to be; able to use the same geometry for several purposes, such as tracking,; reconstruction or visualization, taking advantage of the ROOT features; related to bookkeeping, I/O, histograming, browsing and GUI's. The geometrical modeler is the most important component of the package and; it provides answers to the basic questions like ""Where am I ?"" or ""How far; from the next boundary ?"", but also to more complex ones like ""How far from; the closest surface ?"" or ""Which is the next crossing along a helix ?"". The architecture of the modeler is a combination between a GEANT-like; containment scheme and a normal CSG binary tree at the level of shapes. An; important common feature of all detector geometry descriptions is the; mother-daughter concept. This is the most natural approach when tracking; is concerned and imposes a set of constraints to the way geometry is defined.; Constructive solid geometry composition is used only in order to create more; complex shapes from an existing set of primitives through boolean operations.; This feature is not implemented yet but in future full definition of boolean; expressions will be supported. Practically every geometry defined in GEANT style can be mapped by the modeler.; The basic components used for building the logical hierarchy of the geometry; are called ""volumes"" and ""nodes"". Volumes (sometimes called ""solids"") are fully; defined geometrical objects having a given shape and medium and possibly; containing a list of nodes. Nodes represent just positioned instances of volumes; inside a container volume and they are not directly defined by user. They are; automatically created as a result of adding one volume inside other or dividing;",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:48056,Safety,safe,safe,48056,"nst; Returns current depth to which geometry is drawn. Int_t GetVirtualLevel(); Find level of virtuality of current overlapping node (number of levels; up having the same tracking media. TVirtualGeoTrack * FindTrackWithId(Int_t id) const; Search the track hierarchy to find the track with the; given id. if 'primsFirst' is true, then:; first tries TGeoManager::GetTrackOfId, then does a; recursive search if that fails. this would be faster; if the track is somehow known to be a primary. TVirtualGeoTrack * GetTrackOfId(Int_t id) const; Get track with a given ID. TVirtualGeoTrack * GetParentTrackOfId(Int_t id) const; Get parent track with a given ID. Int_t GetTrackIndex(Int_t id) const; Get index for track id, -1 if not found. Bool_t GotoSafeLevel(); Go upwards the tree until a non-overlaping node. Int_t GetSafeLevel() const; Go upwards the tree until a non-overlaping node. void DefaultColors(); Set default volume colors according to A of material. Double_t Safety(Bool_t inside = kFALSE); Compute safe distance from the current point. This represent the distance; from POINT to the closest boundary. void SetVolumeAttribute(const char* name, const char* att, Int_t val); Set volume attributes in G3 style. void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); Set factors that will ""bomb"" all translations in cartesian and cylindrical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:50226,Safety,avoid,avoid,50226,"et visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attributes in a macro. TGeoNode * SearchNode(Bool_t downwards = kFALSE, const TGeoNode* skipnode = 0); Returns the deepest node containing fPoint, which must be set a priori. TGeoNode * CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); Cross next boundary and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """",",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:51712,Safety,safe,safe,51712,"and locate within current node; The current point must be on the boundary of fCurrentNode. TGeoNode * FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the ",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:51823,Safety,safe,safety,51823,"oundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); Compute distance to next boundary within STEPMAX. If no boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNorma",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:51854,Safety,safe,safety,51854," boundary is found,; propagate current point along current direction with fStep=STEPMAX. Otherwise; propagate with fStep=SNEXT (distance to boundary) and locate/return the next; node. TGeoNode * FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); Find distance to next boundary and store it in fStep. Returns node to which this; boundary belongs. If PATH is specified, compute only distance to the node to which; PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; than this value. STEPMAX represent the step to be made imposed by other reasons than; geometry (usually physics processes). Therefore in this case this method provides the; answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; fStep with a big number.; In case frombdr=kTRUE, the isotropic safety is set to zero.; Note : safety distance for the current point is computed ONLY in case STEPMAX is; specified, otherwise users have to call explicitly TGeoManager::Safety() if; they want this computed for the current point. TGeoNode * FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); Computes as fStep the distance to next daughter of the current volume.; The point and direction must be converted in the coordinate system of the current volume.; The proposed step limit is fStep. void ResetState(); Reset current state flags. TGeoNode * FindNode(Bool_t safe_start = kTRUE); Returns deepest node containing current point. TGeoNode * FindNode(Double_t x, Double_t y, Double_t z); Returns deepest node containing current point. Double_t * FindNormalFast(); Computes fast normal to next crossed boundary, assuming that the current point; is close enough to the boundary. Works only after calling FindNextBoundary. Double_t * FindNormal(Bool_t forward = kTRUE); Computes normal vector to the next surface that will be or was already; crossed when propagating on a strai",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:4939,Security,access,accessible,4939,"th eight vertices on two parallel; planes. All basic primitives inherits from class TGeoBBox since the bounding box; of a solid is essential for the tracking algorithms. They also implement the; virtual methods defined in the virtual class TGeoShape (point and segment; classification). User-defined primitives can be direcly plugged into the modeler; provided that they override these methods. Composite shapes will be soon supported; by the modeler. In order to build a TGeoCompositeShape, one will have to define; first the primitive components. The object that handle boolean; operations among components is called TGeoBoolCombinator and it has to be; constructed providing a string boolean expression between the components names. Example for building a simple geometry :. rootgeom.C //; ; //. /*. */. TGeoManager - the manager class for the geometry package. TGeoManager class is embedding all the API needed for building and tracking; a geometry. It defines a global pointer (gGeoManager) in order to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandat",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:5973,Security,validat,validated,5973,"to be fully; accessible from external code. The mechanism of handling multiple geometries; at the same time will be soon implemented. TGeoManager is the owner of all geometry objects defined in a session,; therefore users must not try to control their deletion. It contains lists of; media, materials, transformations, shapes and volumes. Logical nodes (positioned; volumes) are created and destroyed by the TGeoVolume class. Physical; nodes and their global transformations are subjected to a caching mechanism; due to the sometimes very large memory requirements of logical graph expansion.; The caching mechanism is triggered by the total number of physical instances; of volumes and the cache manager is a client of TGeoManager. The manager class; also controls the painter client. This is linked with ROOT graphical libraries; loaded on demand in order to control visualization actions. Rules for building a valid geometry. A given geometry can be built in various ways, but there are mandatory steps; that have to be followed in order to be validated by the modeler. There are; general rules : volumes needs media and shapes in order to be created,; both container an containee volumes must be created before linking them together,; and the relative transformation matrix must be provided. All branches must; have an upper link point otherwise they will not be considered as part of the; geometry. Visibility or tracking properties of volumes can be provided both; at build time or after geometry is closed, but global visualization settings; (see TGeoPainter class) should not be provided at build time, otherwise the; drawing package will be loaded. There is also a list of specific rules :; positioned daughters should not extrude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference f",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:7686,Security,access,access,7686,"trude their mother or intersect with sisters; unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; (containing all geometry tree) must be specified before closing the geometry; and must not be positioned - it represents the global reference frame. After; building the full geometry tree, the geometry must be closed; (see TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:7977,Security,access,accessed,7977," TGeoManager::CloseGeometry()). Voxelization can be redone per volume after; this process. Below is the general scheme of the manager class. /*. */. An interactive session. Provided that a geometry was successfully built and closed (for instance the; previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; itself to ROOT and the logical/physical structures will become immediately browsable.; The ROOT browser will display starting from the geometry folder : the list of; transformations and media, the top volume and the top logical node. These last; two can be fully expanded, any intermediate volume/node in the browser being subject; of direct access context menu operations (right mouse button click). All user; utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; context menu. /*. */. --- Drawing the geometry. Any logical volume can be drawn via TGeoVolume::Draw() member function.; This can be direcly accessed from the context menu of the volume object; directly from the browser.; There are several drawing options that can be set with; TGeoManager::SetVisOption(Int_t opt) method :; opt=0 - only the content of the volume is drawn, N levels down (default N=3).; This is the default behavior. The number of levels to be drawn can be changed; via TGeoManager::SetVisLevel(Int_t level) method. /*. */. opt=1 - the final leaves (e.g. daughters with no containment) of the branch; starting from volume are drawn down to the current number of levels.; WARNING : This mode is memory consuming; depending of the size of geometry, so drawing from top level within this mode; should be handled with care for expensive geometries. In future there will be; a limitation on the maximum number of nodes to be visualized. /*. */. opt=2 - only the clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *p",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:9802,Security,access,accessible,9802,"he clicked volume is visualized. This is automatically set by; TGeoVolume::DrawOnly() method; opt=3 - only a given path is visualized. This is automatically set by; TGeoVolume::DrawPath(const char *path) method. The current view can be exploded in cartesian, cylindrical or spherical; coordinates :; TGeoManager::SetExplodedView(Int_t opt). Options may be :; - 0 - default (no bombing); - 1 - cartesian coordinates. The bomb factor on each axis can be set with; TGeoManager::SetBombX(Double_t bomb) and corresponding Y and Z.; - 2 - bomb in cylindrical coordinates. Only the bomb factors on Z and R; are considered. /*. */. - 3 - bomb in radial spherical coordinate : TGeoManager::SetBombR(). Volumes themselves support different visualization settings :; - TGeoVolume::SetVisibility() : set volume visibility.; - TGeoVolume::VisibleDaughters() : set daughters visibility.; All these actions automatically updates the current view if any. --- Checking the geometry. Several checking methods are accessible from the volume context menu. They; generally apply only to the visible parts of the drawn geometry in order to; ease geometry checking, and their implementation is in the TGeoChecker class; from the painting package. 1. Checking a given point.; Can be called from TGeoManager::CheckPoint(Double_t x, Double_t y, Double_t z).; This method is drawing the daughters of the volume containing the point one; level down, printing the path to the deepest physical node holding this point.; It also computes the closest distance to any boundary. The point will be drawn; in red. /*. */. 2. Shooting random points.; Can be called from TGeoVolume::RandomPoints() (context menu function) and; it will draw this volume with current visualization settings. Random points; are generated in the bounding box of the top drawn volume. The points are; classified and drawn with the color of their deepest container. Only points; in visible nodes will be drawn. /*. */. 3. Raytracing.; Can be called from TGeoVol",MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
https://root.cern/root/html530/TGeoManager.html:33188,Security,hash,hash,33188,,MatchSource.WIKI,root/html530/TGeoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TGeoManager.html
