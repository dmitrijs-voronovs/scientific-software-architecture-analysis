id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html:107,Usability,Feedback,Feedback,107,﻿. Hail | ; GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cel,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html:317,Usability,Guid,Guides,317, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cel,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Cells_EBV-transformed_lymphocytes_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:187,Deployability,Install,Installation,187, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:255,Deployability,Configurat,Configuration,255, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:9754,Deployability,update,updated,9754,"_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations. View page source. GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:255,Modifiability,Config,Configuration,255, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:8815,Testability,Log,Log,8815,"_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations. View page source. GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:87,Usability,Feedback,Feedback,87,﻿. Hail | ; GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html:297,Usability,Guid,Guides,297, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Sigmoid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:190,Deployability,Install,Installation,190, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:258,Deployability,Configurat,Configuration,258, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:9763,Deployability,update,updated,9763,"riant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Colon_Transverse_all_snp_gene_associations. View page source. GTEx_sQTL_Colon_Transverse_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:258,Modifiability,Config,Configuration,258, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:8818,Testability,Log,Log,8818,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Colon_Transverse_all_snp_gene_associations. View page source. GTEx_sQTL_Colon_Transverse_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:90,Usability,Feedback,Feedback,90,﻿. Hail | ; GTEx_sQTL_Colon_Transverse_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html:300,Usability,Guid,Guides,300, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Colon_Transverse_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:209,Deployability,Install,Installation,209, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_C,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:277,Deployability,Configurat,Configuration,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_C,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:9820,Deployability,update,updated,9820,"ndices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:277,Modifiability,Config,Configuration,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_C,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:8837,Testability,Log,Log,8837,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:109,Usability,Feedback,Feedback,109,﻿. Hail | ; GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_C,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html:319,Usability,Guid,Guides,319, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_C,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Gastroesophageal_Junction_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:190,Deployability,Install,Installation,190, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:258,Deployability,Configurat,Configuration,258, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:9763,Deployability,update,updated,9763,"riant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:258,Modifiability,Config,Configuration,258, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:8818,Testability,Log,Log,8818,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:90,Usability,Feedback,Feedback,90,﻿. Hail | ; GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html:300,Usability,Guid,Guides,300, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibro,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Mucosa_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:194,Deployability,Install,Installation,194, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:262,Deployability,Configurat,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:9775,Deployability,update,updated,9775,"dices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:262,Modifiability,Config,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:8822,Testability,Log,Log,8822,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations. View page source. GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04,",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:94,Usability,Feedback,Feedback,94,﻿. Hail | ; GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html:304,Usability,Guid,Guides,304, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Esophagus_Muscularis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:196,Deployability,Install,Installation,196, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:264,Deployability,Configurat,Configuration,264, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:9781,Deployability,update,updated,9781,"s_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations. View page source. GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:264,Modifiability,Config,Configuration,264, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:8824,Testability,Log,Log,8824,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations. View page source. GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:96,Usability,Feedback,Feedback,96,﻿. Hail | ; GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html:306,Usability,Guid,Guides,306, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Atrial_Appendage_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:194,Deployability,Install,Installation,194, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:262,Deployability,Configurat,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:9775,Deployability,update,updated,9775,"dices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations. View page source. GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:262,Modifiability,Config,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:8822,Testability,Log,Log,8822,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations. View page source. GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04,",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:94,Usability,Feedback,Feedback,94,﻿. Hail | ; GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html:304,Usability,Guid,Guides,304, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Heart_Left_Ventricle_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:187,Deployability,Install,Installation,187, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:255,Deployability,Configurat,Configuration,255, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:9754,Deployability,update,updated,9754,"_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations. View page source. GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:255,Modifiability,Config,Configuration,255, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:8815,Testability,Log,Log,8815,"_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations. View page source. GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:87,Usability,Feedback,Feedback,87,﻿. Hail | ; GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html:297,Usability,Guid,Guides,297, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrobla,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Kidney_Cortex_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:179,Deployability,Install,Installation,179, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:247,Deployability,Configurat,Configuration,247, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:9730,Deployability,update,updated,9730,"ices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Liver_all_snp_gene_associations. View page source. GTEx_sQTL_Liver_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:247,Modifiability,Config,Configuration,247, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:8807,Testability,Log,Log,8807,"ices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Liver_all_snp_gene_associations. View page source. GTEx_sQTL_Liver_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:79,Usability,Feedback,Feedback,79,﻿. Hail | ; GTEx_sQTL_Liver_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html:289,Usability,Guid,Guides,289, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Liver_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:178,Deployability,Install,Installation,178, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_s,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:246,Deployability,Configurat,Configuration,246, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_s,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:9727,Deployability,update,updated,9727,"ndices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Lung_all_snp_gene_associations. View page source. GTEx_sQTL_Lung_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:246,Modifiability,Config,Configuration,246, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_s,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:8806,Testability,Log,Log,8806,"ndices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Lung_all_snp_gene_associations. View page source. GTEx_sQTL_Lung_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:78,Usability,Feedback,Feedback,78,﻿. Hail | ; GTEx_sQTL_Lung_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_s,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html:288,Usability,Guid,Guides,288, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_s,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Lung_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:194,Deployability,Install,Installation,194, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:262,Deployability,Configurat,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:9775,Deployability,update,updated,9775,"dices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations. View page source. GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:262,Modifiability,Config,Configuration,262, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:8822,Testability,Log,Log,8822,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations. View page source. GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04,",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:94,Usability,Feedback,Feedback,94,﻿. Hail | ; GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html:304,Usability,Guid,Guides,304, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_f,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Minor_Salivary_Gland_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:189,Deployability,Install,Installation,189, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrob,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:257,Deployability,Configurat,Configuration,257, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrob,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:9760,Deployability,update,updated,9760,"variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations. View page source. GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:257,Modifiability,Config,Configuration,257, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrob,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:8817,Testability,Log,Log,8817,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations. View page source. GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:89,Usability,Feedback,Feedback,89,﻿. Hail | ; GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrob,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html:299,Usability,Guid,Guides,299, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibrob,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Muscle_Skeletal_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:186,Deployability,Install,Installation,186, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblas,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:254,Deployability,Configurat,Configuration,254, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblas,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:9751,Deployability,update,updated,9751,"ad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations. View page source. GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:254,Modifiability,Config,Configuration,254, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblas,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:8814,Testability,Log,Log,8814,"ad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations. View page source. GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:86,Usability,Feedback,Feedback,86,﻿. Hail | ; GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblas,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html:296,Usability,Guid,Guides,296, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblas,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Nerve_Tibial_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:179,Deployability,Install,Installation,179, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:247,Deployability,Configurat,Configuration,247, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:9730,Deployability,update,updated,9730,"ices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Ovary_all_snp_gene_associations. View page source. GTEx_sQTL_Ovary_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:247,Modifiability,Config,Configuration,247, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:8807,Testability,Log,Log,8807,"ices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Ovary_all_snp_gene_associations. View page source. GTEx_sQTL_Ovary_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:79,Usability,Feedback,Feedback,79,﻿. Hail | ; GTEx_sQTL_Ovary_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html:289,Usability,Guid,Guides,289, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Ovary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:182,Deployability,Install,Installation,182, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:250,Deployability,Configurat,Configuration,250, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:9739,Deployability,update,updated,9739,"st; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Pancreas_all_snp_gene_associations. View page source. GTEx_sQTL_Pancreas_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:250,Modifiability,Config,Configuration,250, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:8810,Testability,Log,Log,8810,"st; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Pancreas_all_snp_gene_associations. View page source. GTEx_sQTL_Pancreas_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:82,Usability,Feedback,Feedback,82,﻿. Hail | ; GTEx_sQTL_Pancreas_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html:292,Usability,Guid,Guides,292, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pancreas_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:183,Deployability,Install,Installation,183, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:251,Deployability,Configurat,Configuration,251, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:9742,Deployability,update,updated,9742,"; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Pituitary_all_snp_gene_associations. View page source. GTEx_sQTL_Pituitary_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:251,Modifiability,Config,Configuration,251, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:8811,Testability,Log,Log,8811,"; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Pituitary_all_snp_gene_associations. View page source. GTEx_sQTL_Pituitary_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:83,Usability,Feedback,Feedback,83,﻿. Hail | ; GTEx_sQTL_Pituitary_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html:293,Usability,Guid,Guides,293, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Pituitary_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:182,Deployability,Install,Installation,182, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:250,Deployability,Configurat,Configuration,250, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:9739,Deployability,update,updated,9739,"st; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Prostate_all_snp_gene_associations. View page source. GTEx_sQTL_Prostate_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:250,Modifiability,Config,Configuration,250, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:8810,Testability,Log,Log,8810,"st; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Prostate_all_snp_gene_associations. View page source. GTEx_sQTL_Prostate_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:82,Usability,Feedback,Feedback,82,﻿. Hail | ; GTEx_sQTL_Prostate_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html:292,Usability,Guid,Guides,292, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_a,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Prostate_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:205,Deployability,Install,Installation,205, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:273,Deployability,Configurat,Configuration,273, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:9808,Deployability,update,updated,9808,"ariant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations. View page source. GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:273,Modifiability,Config,Configuration,273, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:8833,Testability,Log,Log,8833,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations. View page source. GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; L",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:105,Usability,Feedback,Feedback,105,﻿. Hail | ; GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html:315,Usability,Guid,Guides,315, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Not_Sun_Exposed_Suprapubic_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:200,Deployability,Install,Installation,200, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cult,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:268,Deployability,Configurat,Configuration,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cult,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:9793,Deployability,update,updated,9793,"nomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations. View page source. GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:268,Modifiability,Config,Configuration,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cult,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:8828,Testability,Log,Log,8828,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations. View page source. GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last update",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:100,Usability,Feedback,Feedback,100,﻿. Hail | ; GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cult,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html:310,Usability,Guid,Guides,310, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cult,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Skin_Sun_Exposed_Lower_leg_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:204,Deployability,Install,Installation,204, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:272,Deployability,Configurat,Configuration,272, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:9805,Deployability,update,updated,9805,"_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations. View page source. GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:272,Modifiability,Config,Configuration,272, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:8832,Testability,Log,Log,8832,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations. View page source. GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Las",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:104,Usability,Feedback,Feedback,104,﻿. Hail | ; GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html:314,Usability,Guid,Guides,314, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Small_Intestine_Terminal_Ileum_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:180,Deployability,Install,Installation,180, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:248,Deployability,Configurat,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:9733,Deployability,update,updated,9733,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Spleen_all_snp_gene_associations. View page source. GTEx_sQTL_Spleen_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:248,Modifiability,Config,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:8808,Testability,Log,Log,8808,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Spleen_all_snp_gene_associations. View page source. GTEx_sQTL_Spleen_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:80,Usability,Feedback,Feedback,80,﻿. Hail | ; GTEx_sQTL_Spleen_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html:290,Usability,Guid,Guides,290, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Spleen_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:181,Deployability,Install,Installation,181, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:249,Deployability,Configurat,Configuration,249, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:9736,Deployability,update,updated,9736,"_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Stomach_all_snp_gene_associations. View page source. GTEx_sQTL_Stomach_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:249,Modifiability,Config,Configuration,249, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:8809,Testability,Log,Log,8809,"_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Stomach_all_snp_gene_associations. View page source. GTEx_sQTL_Stomach_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:81,Usability,Feedback,Feedback,81,﻿. Hail | ; GTEx_sQTL_Stomach_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html:291,Usability,Guid,Guides,291, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Stomach_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:180,Deployability,Install,Installation,180, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:248,Deployability,Configurat,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:9733,Deployability,update,updated,9733,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Testis_all_snp_gene_associations. View page source. GTEx_sQTL_Testis_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:248,Modifiability,Config,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:8808,Testability,Log,Log,8808,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Testis_all_snp_gene_associations. View page source. GTEx_sQTL_Testis_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:80,Usability,Feedback,Feedback,80,﻿. Hail | ; GTEx_sQTL_Testis_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html:290,Usability,Guid,Guides,290, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Testis_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:181,Deployability,Install,Installation,181, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:249,Deployability,Configurat,Configuration,249, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:9736,Deployability,update,updated,9736,"_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Thyroid_all_snp_gene_associations. View page source. GTEx_sQTL_Thyroid_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:249,Modifiability,Config,Configuration,249, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:8809,Testability,Log,Log,8809,"_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Thyroid_all_snp_gene_associations. View page source. GTEx_sQTL_Thyroid_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:81,Usability,Feedback,Feedback,81,﻿. Hail | ; GTEx_sQTL_Thyroid_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html:291,Usability,Guid,Guides,291, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_al,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Thyroid_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:180,Deployability,Install,Installation,180, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:248,Deployability,Configurat,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:9733,Deployability,update,updated,9733,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Uterus_all_snp_gene_associations. View page source. GTEx_sQTL_Uterus_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:248,Modifiability,Config,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:8808,Testability,Log,Log,8808,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Uterus_all_snp_gene_associations. View page source. GTEx_sQTL_Uterus_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:80,Usability,Feedback,Feedback,80,﻿. Hail | ; GTEx_sQTL_Uterus_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html:290,Usability,Guid,Guides,290, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Uterus_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:180,Deployability,Install,Installation,180, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:248,Deployability,Configurat,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:9733,Deployability,update,updated,9733,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Vagina_all_snp_gene_associations. View page source. GTEx_sQTL_Vagina_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:248,Modifiability,Config,Configuration,248, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:8808,Testability,Log,Log,8808,"es_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Vagina_all_snp_gene_associations. View page source. GTEx_sQTL_Vagina_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:80,Usability,Feedback,Feedback,80,﻿. Hail | ; GTEx_sQTL_Vagina_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html:290,Usability,Guid,Guides,290, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Vagina_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:185,Deployability,Install,Installation,185, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblast,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:253,Deployability,Configurat,Configuration,253, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblast,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:9748,Deployability,update,updated,9748,"omad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Whole_Blood_all_snp_gene_associations. View page source. GTEx_sQTL_Whole_Blood_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:253,Modifiability,Config,Configuration,253, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblast,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:8813,Testability,Log,Log,8813,"omad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; GTEx_sQTL_Whole_Blood_all_snp_gene_associations. View page source. GTEx_sQTL_Whole_Blood_all_snp_gene_associations. Versions: v8; Reference genome builds: GRCh38; Type: hail.Table. Schema (v8, GRCh38); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'locus': locus<GRCh38>; 'alleles': array<str>; 'phenotype_id': struct {; intron: interval<locus<GRCh38>>,; cluster: str,; gene_id: str; }; 'tss_distance': int32; 'ma_samples': int32; 'ma_count': int32; 'maf': float64; 'pval_nominal': float64; 'slope': float64; 'slope_se': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:85,Usability,Feedback,Feedback,85,﻿. Hail | ; GTEx_sQTL_Whole_Blood_all_snp_gene_associations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblast,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html:295,Usability,Guid,Guides,295, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblast,MatchSource.WIKI,docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/GTEx_sQTL_Whole_Blood_all_snp_gene_associations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:165,Deployability,Install,Installation,165, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_assoc,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:233,Deployability,Configurat,Configuration,233, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_assoc,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:12941,Deployability,update,updated,12941,"L2': float64; 'UTR_5_UCSC.flanking.500L2': float64; 'WeakEnhancer_HoffmanL2': float64; 'WeakEnhancer_Hoffman.flanking.500L2': float64; 'GERP.NSL2': float64; 'GERP.RSsup4L2': float64; 'MAFbin1L2': float64; 'MAFbin2L2': float64; 'MAFbin3L2': float64; 'MAFbin4L2': float64; 'MAFbin5L2': float64; 'MAFbin6L2': float64; 'MAFbin7L2': float64; 'MAFbin8L2': float64; 'MAFbin9L2': float64; 'MAFbin10L2': float64; 'MAF_Adj_Predicted_Allele_AgeL2': float64; 'MAF_Adj_LLD_AFRL2': float64; 'Recomb_Rate_10kbL2': float64; 'Nucleotide_Diversity_10kbL2': float64; 'Backgrd_Selection_StatL2': float64; 'CpG_Content_50kbL2': float64; 'MAF_Adj_ASMCL2': float64; 'GTEx_eQTL_MaxCPPL2': float64; 'BLUEPRINT_H3K27acQTL_MaxCPPL2': float64; 'BLUEPRINT_H3K4me1QTL_MaxCPPL2': float64; 'BLUEPRINT_DNA_methylation_MaxCPPL2': float64; 'synonymousL2': float64; 'non_synonymousL2': float64; 'Conserved_Vertebrate_phastCons46wayL2': float64; 'Conserved_Vertebrate_phastCons46way.flanking.500L2': float64; 'Conserved_Mammal_phastCons46wayL2': float64; 'Conserved_Mammal_phastCons46way.flanking.500L2': float64; 'Conserved_Primate_phastCons46wayL2': float64; 'Conserved_Primate_phastCons46way.flanking.500L2': float64; 'BivFlnkL2': float64; 'BivFlnk.flanking.500L2': float64; 'Human_Promoter_VillarL2': float64; 'Human_Promoter_Villar.flanking.500L2': float64; 'Human_Enhancer_VillarL2': float64; 'Human_Enhancer_Villar.flanking.500L2': float64; 'Ancient_Sequence_Age_Human_PromoterL2': float64; 'Ancient_Sequence_Age_Human_Promoter.flanking.500L2': float64; 'Ancient_Sequence_Age_Human_EnhancerL2': float64; 'Ancient_Sequence_Age_Human_Enhancer.flanking.500L2': float64; 'Human_Enhancer_Villar_Species_Enhancer_CountL2': float64; 'Human_Promoter_Villar_ExACL2': float64; 'Human_Promoter_Villar_ExAC.flanking.500L2': float64; 'locus': locus<GRCh37>; ----------------------------------------; Key: ['locus']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:233,Modifiability,Config,Configuration,233, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_assoc,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:8794,Testability,Log,Log,8794,"gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; Schema (2.2, GRCh37). ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; ldsc_baselineLD_annotations. View page source. ldsc_baselineLD_annotations. Versions: 2.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (2.2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; reference_genome: str,; n_rows: int32,; n_partitions: int32; }; ----------------------------------------; Row fields:; 'SNP': str; 'baseL2': float64; 'Coding_UCSCL2': float64; 'Coding_UCSC.flanking.500L2': float64; 'Conserved_LindbladTohL2': float64; 'Conserved_LindbladToh.flanking.500L2': float64; 'CTCF_HoffmanL2': float64; 'CTCF_Hoffman.flanking.500L2': float64; 'DGF_ENCODEL2': float64; 'DGF_ENCODE.flanking.500L2': float64; 'DHS_peaks_TrynkaL2': float64; 'DHS_TrynkaL2': float64; 'DHS_Trynka.flanking.500L2': float64; 'Enhancer_AnderssonL2': float64; 'Enhancer_Andersson.flanking.500L2': float64; 'Enhancer_HoffmanL2': float64; 'Enhancer_Hoffman.flanki",MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:65,Usability,Feedback,Feedback,65,﻿. Hail | ; ldsc_baselineLD_annotations. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_assoc,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html:275,Usability,Guid,Guides,275, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_assoc,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_annotations.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:162,Deployability,Install,Installation,162, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associat,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:230,Deployability,Configurat,Configuration,230, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associat,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:9646,Deployability,update,updated,9646,"_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; Schema (2.2, GRCh37). panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; ldsc_baselineLD_ldscores. View page source. ldsc_baselineLD_ldscores. Versions: 2.2, 1.1; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (2.2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'annotation': str; 'M_5_50': int32; 'M': int32; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'SNP': str; ----------------------------------------; Entry fields:; 'x': float64; ----------------------------------------; Column key: ['annotation']; Row key: ['locus']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:230,Modifiability,Config,Configuration,230, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associat,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:8791,Testability,Log,Log,8791,"_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; Schema (2.2, GRCh37). panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; ldsc_baselineLD_ldscores. View page source. ldsc_baselineLD_ldscores. Versions: 2.2, 1.1; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (2.2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'annotation': str; 'M_5_50': int32; 'M': int32; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'SNP': str; ----------------------------------------; Entry fields:; 'x': float64; ----------------------------------------; Column key: ['annotation']; Row key: ['locus']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:62,Usability,Feedback,Feedback,62,﻿. Hail | ; ldsc_baselineLD_ldscores. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associat,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html:272,Usability,Guid,Guides,272, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associat,MatchSource.WIKI,docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/ldsc_baselineLD_ldscores.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; Schema (0.2, GRCh37). panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_AFR. View page source. panukb_ld_scores_AFR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; Schema (0.2, GRCh37). panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_AFR. View page source. panukb_ld_scores_AFR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_AFR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; Schema (0.2, GRCh37). panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_AMR. View page source. panukb_ld_scores_AMR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; Schema (0.2, GRCh37). panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_AMR. View page source. panukb_ld_scores_AMR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_AMR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; Schema (0.2, GRCh37). panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_CSA. View page source. panukb_ld_scores_CSA. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; Schema (0.2, GRCh37). panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_CSA. View page source. panukb_ld_scores_CSA. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_CSA. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; Schema (0.2, GRCh37). panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_EAS. View page source. panukb_ld_scores_EAS. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; Schema (0.2, GRCh37). panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_EAS. View page source. panukb_ld_scores_EAS. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_EAS. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; Schema (0.2, GRCh37). panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_EUR. View page source. panukb_ld_scores_EUR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; Schema (0.2, GRCh37). panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_EUR. View page source. panukb_ld_scores_EUR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_EUR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:9391,Deployability,update,updated,9391,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; Schema (0.2, GRCh37). panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_MID. View page source. panukb_ld_scores_MID. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:8787,Testability,Log,Log,8787,"omad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; Schema (0.2, GRCh37). panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_scores_MID. View page source. panukb_ld_scores_MID. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'rsid': str; 'varid': str; 'AF': float64; 'ld_score': float64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_ld_scores_MID. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_scores_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_scores_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; Schema (0.2, GRCh37). panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_AFR. View page source. panukb_ld_variant_indices_AFR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; Schema (0.2, GRCh37). panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_AFR. View page source. panukb_ld_variant_indices_AFR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_AFR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AFR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; Schema (0.2, GRCh37). panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_AMR. View page source. panukb_ld_variant_indices_AMR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; Schema (0.2, GRCh37). panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_AMR. View page source. panukb_ld_variant_indices_AMR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_AMR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_AMR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; Schema (0.2, GRCh37). panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_CSA. View page source. panukb_ld_variant_indices_CSA. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; Schema (0.2, GRCh37). panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_CSA. View page source. panukb_ld_variant_indices_CSA. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_CSA. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_CSA.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; Schema (0.2, GRCh37). panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_EAS. View page source. panukb_ld_variant_indices_EAS. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; Schema (0.2, GRCh37). panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_EAS. View page source. panukb_ld_variant_indices_EAS. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_EAS. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EAS.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; Schema (0.2, GRCh37). panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_EUR. View page source. panukb_ld_variant_indices_EUR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; Schema (0.2, GRCh37). panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_EUR. View page source. panukb_ld_variant_indices_EUR. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_EUR. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_EUR.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:167,Deployability,Install,Installation,167, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:235,Deployability,Configurat,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:9395,Deployability,update,updated,9395,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; Schema (0.2, GRCh37). panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_MID. View page source. panukb_ld_variant_indices_MID. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:235,Modifiability,Config,Configuration,235, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:8796,Testability,Log,Log,8796,"r; gnomad_ld_scores_asj; gnomad_ld_scores_eas; gnomad_ld_scores_est; gnomad_ld_scores_fin; gnomad_ld_scores_nfe; gnomad_ld_scores_nwe; gnomad_ld_scores_seu; gnomad_ld_variant_indices_afr; gnomad_ld_variant_indices_amr; gnomad_ld_variant_indices_asj; gnomad_ld_variant_indices_eas; gnomad_ld_variant_indices_est; gnomad_ld_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; Schema (0.2, GRCh37). panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_ld_variant_indices_MID. View page source. panukb_ld_variant_indices_MID. Versions: 0.2; Reference genome builds: GRCh37; Type: hail.Table. Schema (0.2, GRCh37); ----------------------------------------; Global fields:; 'n_samples': int32; 'pop': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'idx': int64; ----------------------------------------; Key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:67,Usability,Feedback,Feedback,67,﻿. Hail | ; panukb_ld_variant_indices_MID. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html:277,Usability,Guid,Guides,277, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_ass,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_ld_variant_indices_MID.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:173,Deployability,Install,Installation,173, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_ge,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:241,Deployability,Configurat,Configuration,241, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_ge,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:14753,Deployability,update,updated,14753,"t32,; biotype: str,; consequence_terms: array<str>,; impact: str,; minimised: int32,; regulatory_feature_id: str,; variant_allele: str; }>,; seq_region_name: str,; start: int32,; strand: int32,; transcript_consequences: array<struct {; allele_num: int32,; amino_acids: str,; biotype: str,; canonical: int32,; ccds: str,; cdna_start: int32,; cdna_end: int32,; cds_end: int32,; cds_start: int32,; codons: str,; consequence_terms: array<str>,; distance: int32,; domains: array<struct {; db: str,; name: str; }>,; exon: str,; gene_id: str,; gene_pheno: int32,; gene_symbol: str,; gene_symbol_source: str,; hgnc_id: str,; hgvsc: str,; hgvsp: str,; hgvs_offset: int32,; impact: str,; intron: str,; lof: str,; lof_flags: str,; lof_filter: str,; lof_info: str,; minimised: int32,; polyphen_prediction: str,; polyphen_score: float64,; protein_end: int32,; protein_start: int32,; protein_id: str,; sift_prediction: str,; sift_score: float64,; strand: int32,; swissprot: str,; transcript_id: str,; trembl: str,; uniparc: str,; variant_allele: str; }>,; variant_class: str; }; 'freq': array<struct {; pop: str,; ac: float64,; af: float64,; an: int64,; gnomad_exomes_ac: int32,; gnomad_exomes_af: float64,; gnomad_exomes_an: int32,; gnomad_genomes_ac: int32,; gnomad_genomes_af: float64,; gnomad_genomes_an: int32; }>; 'pass_gnomad_exomes': bool; 'pass_gnomad_genomes': bool; 'n_passing_populations': int32; 'high_quality': bool; 'nearest_genes': str; 'info': float64; ----------------------------------------; Entry fields:; 'meta_analysis': array<struct {; BETA: float64,; SE: float64,; Pvalue: float64,; Q: float64,; Pvalue_het: float64,; N: int32,; N_pops: int32,; AF_Allele2: float64,; AF_Cases: float64,; AF_Controls: float64; }>; ----------------------------------------; Column key: ['trait_type', 'phenocode', 'pheno_sex', 'coding', 'modifier']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:241,Modifiability,Config,Configuration,241, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_ge,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:8802,Testability,Log,Log,8802,"gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; Schema (0.3, GRCh37). panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_meta_analysis_all_ancestries. View page source. panukb_meta_analysis_all_ancestries. Versions: 0.3; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (0.3, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Column fields:; 'trait_type': str; 'phenocode': str; 'pheno_sex': str; 'coding': str; 'modifier': str; 'pheno_data': array<struct {; n_cases: int32,; n_controls: int32,; heritability: struct {; estimates: struct {; ldsc: struct {; h2_liability: float64,; h2_liability_se: float64,; h2_z: float64,; h2_observed: float64,; h2_observed_se: float64,; intercept: float64,; intercept_se: float64,; ratio: float64,; ratio_se: float64; },; sldsc_25bin: struct {; h2_liability: float64,; h2_liability_se: float64,; h2_z: float64,; h2_observed: float64,; h2_observed_se: float64,; intercept: float64,; intercept_se: float64,; ratio:",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:73,Usability,Feedback,Feedback,73,﻿. Hail | ; panukb_meta_analysis_all_ancestries. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_ge,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html:283,Usability,Guid,Guides,283, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_ge,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_all_ancestries.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:171,Deployability,Install,Installation,171, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:239,Deployability,Configurat,Configuration,239, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:14747,Deployability,update,updated,14747,"t32,; biotype: str,; consequence_terms: array<str>,; impact: str,; minimised: int32,; regulatory_feature_id: str,; variant_allele: str; }>,; seq_region_name: str,; start: int32,; strand: int32,; transcript_consequences: array<struct {; allele_num: int32,; amino_acids: str,; biotype: str,; canonical: int32,; ccds: str,; cdna_start: int32,; cdna_end: int32,; cds_end: int32,; cds_start: int32,; codons: str,; consequence_terms: array<str>,; distance: int32,; domains: array<struct {; db: str,; name: str; }>,; exon: str,; gene_id: str,; gene_pheno: int32,; gene_symbol: str,; gene_symbol_source: str,; hgnc_id: str,; hgvsc: str,; hgvsp: str,; hgvs_offset: int32,; impact: str,; intron: str,; lof: str,; lof_flags: str,; lof_filter: str,; lof_info: str,; minimised: int32,; polyphen_prediction: str,; polyphen_score: float64,; protein_end: int32,; protein_start: int32,; protein_id: str,; sift_prediction: str,; sift_score: float64,; strand: int32,; swissprot: str,; transcript_id: str,; trembl: str,; uniparc: str,; variant_allele: str; }>,; variant_class: str; }; 'freq': array<struct {; pop: str,; ac: float64,; af: float64,; an: int64,; gnomad_exomes_ac: int32,; gnomad_exomes_af: float64,; gnomad_exomes_an: int32,; gnomad_genomes_ac: int32,; gnomad_genomes_af: float64,; gnomad_genomes_an: int32; }>; 'pass_gnomad_exomes': bool; 'pass_gnomad_genomes': bool; 'n_passing_populations': int32; 'high_quality': bool; 'nearest_genes': str; 'info': float64; ----------------------------------------; Entry fields:; 'meta_analysis': array<struct {; BETA: float64,; SE: float64,; Pvalue: float64,; Q: float64,; Pvalue_het: float64,; N: int32,; N_pops: int32,; AF_Allele2: float64,; AF_Cases: float64,; AF_Controls: float64; }>; ----------------------------------------; Column key: ['trait_type', 'phenocode', 'pheno_sex', 'coding', 'modifier']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:239,Modifiability,Config,Configuration,239, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:8800,Testability,Log,Log,8800,"gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; Schema (0.3, GRCh37). panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_meta_analysis_high_quality. View page source. panukb_meta_analysis_high_quality. Versions: 0.3; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (0.3, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Column fields:; 'trait_type': str; 'phenocode': str; 'pheno_sex': str; 'coding': str; 'modifier': str; 'pheno_data': array<struct {; n_cases: int32,; n_controls: int32,; heritability: struct {; estimates: struct {; ldsc: struct {; h2_liability: float64,; h2_liability_se: float64,; h2_z: float64,; h2_observed: float64,; h2_observed_se: float64,; intercept: float64,; intercept_se: float64,; ratio: float64,; ratio_se: float64; },; sldsc_25bin: struct {; h2_liability: float64,; h2_liability_se: float64,; h2_z: float64,; h2_observed: float64,; h2_observed_se: float64,; intercept: float64,; intercept_se: float64,; ratio: flo",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:71,Usability,Feedback,Feedback,71,﻿. Hail | ; panukb_meta_analysis_high_quality. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html:281,Usability,Guid,Guides,281, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_meta_analysis_high_quality.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:158,Deployability,Install,Installation,158, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:226,Deployability,Configurat,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:10227,Deployability,update,updated,10227,"lineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats; Schema (0.3, GRCh37). Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_summary_stats. View page source. panukb_summary_stats. Versions: 0.3; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (0.3, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Column fields:; 'trait_type': str; 'phenocode': str; 'pheno_sex': str; 'coding': str; 'modifier': str; 'pheno_data': array<struct {; n_cases: int32,; n_controls: int32,; heritability: float64,; saige_version: str,; inv_normalized: bool,; pop: str; }>; 'description': str; 'description_more': str; 'coding_description': str; 'category': str; 'n_cases_full_cohort_both_sexes': int64; 'n_cases_full_cohort_females': int64; 'n_cases_full_cohort_males': int64; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'gene': str; 'annotation': str; ----------------------------------------; Entry fields:; 'summary_stats': array<struct {; AF_Allele2: float64,; imputationInfo: float64,; BETA: float64,; SE: float64,; `p.value.NA`: float64,; `AF.Cases`: float64,; `AF.Controls`: float64,; Pvalue: float64,; low_confidence: bool; }>; ----------------------------------------; Column key: ['trait_type', 'phenocode', 'pheno_sex', 'coding', 'modifier']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:226,Modifiability,Config,Configuration,226, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:8787,Testability,Log,Log,8787,"gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats; Schema (0.3, GRCh37). Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; panukb_summary_stats. View page source. panukb_summary_stats. Versions: 0.3; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (0.3, GRCh37); ----------------------------------------; Global fields:; None; ----------------------------------------; Column fields:; 'trait_type': str; 'phenocode': str; 'pheno_sex': str; 'coding': str; 'modifier': str; 'pheno_data': array<struct {; n_cases: int32,; n_controls: int32,; heritability: float64,; saige_version: str,; inv_normalized: bool,; pop: str; }>; 'description': str; 'description_more': str; 'coding_description': str; 'category': str; 'n_cases_full_cohort_both_sexes': int64; 'n_cases_full_cohort_females': int64; 'n_cases_full_cohort_males': int64; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'gene': str; 'annotation': str; ----------------------------------------; Entry fields:; 'summ",MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:58,Usability,Feedback,Feedback,58,﻿. Hail | ; panukb_summary_stats. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html:268,Usability,Guid,Guides,268, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associations,MatchSource.WIKI,docs/0.2/datasets/schemas/panukb_summary_stats.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/panukb_summary_stats.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:170,Deployability,Install,Installation,170, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:238,Deployability,Configurat,Configuration,238, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:10509,Deployability,update,updated,10509,"ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_both_sexes. View page source. UK_Biobank_Rapid_GWAS_both_sexes. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int32; 'AF': float64; 'p_hwe': float64; 'n_called': int32; 'n_not_called': int32; 'n_hom_ref': int32; 'n_het': int32; 'n_hom_var': int32; 'n_non_ref': int32; 'r_heterozygosity': float64; 'r_het_hom_var': float64; 'r_expected_het_frequency': float64; ----------------------------------------; Entry fields:; 'expected_case_minor_AC': float64; 'expected_min_category_minor_AC': float64; 'low_confidence_variant': bool; 'n_complete_samples': int32; 'AC': float64; 'ytx': float64; 'beta': float64; 'se': float64; 'tstat': float64; 'pval': float64; ----------------------------------------; Column key: ['phenotype']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:238,Modifiability,Config,Configuration,238, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:8798,Testability,Log,Log,8798,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_both_sexes. View page source. UK_Biobank_Rapid_GWAS_both_sexes. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:70,Usability,Feedback,Feedback,70,﻿. Hail | ; UK_Biobank_Rapid_GWAS_both_sexes. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html:280,Usability,Guid,Guides,280, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_both_sexes.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:166,Deployability,Install,Installation,166, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_asso,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:234,Deployability,Configurat,Configuration,234, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_asso,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:10497,Deployability,update,updated,10497," panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_female. View page source. UK_Biobank_Rapid_GWAS_female. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int32; 'AF': float64; 'p_hwe': float64; 'n_called': int32; 'n_not_called': int32; 'n_hom_ref': int32; 'n_het': int32; 'n_hom_var': int32; 'n_non_ref': int32; 'r_heterozygosity': float64; 'r_het_hom_var': float64; 'r_expected_het_frequency': float64; ----------------------------------------; Entry fields:; 'expected_case_minor_AC': float64; 'expected_min_category_minor_AC': float64; 'low_confidence_variant': bool; 'n_complete_samples': int32; 'AC': float64; 'ytx': float64; 'beta': float64; 'se': float64; 'tstat': float64; 'pval': float64; ----------------------------------------; Column key: ['phenotype']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:234,Modifiability,Config,Configuration,234, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_asso,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:8794,Testability,Log,Log,8794,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_female. View page source. UK_Biobank_Rapid_GWAS_female. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int32; 'AF'",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:66,Usability,Feedback,Feedback,66,﻿. Hail | ; UK_Biobank_Rapid_GWAS_female. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_asso,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html:276,Usability,Guid,Guides,276, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_asso,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_female.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:164,Deployability,Install,Installation,164, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associ,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:232,Deployability,Configurat,Configuration,232, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associ,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:10491,Deployability,update,updated,10491,"CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_male. View page source. UK_Biobank_Rapid_GWAS_male. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int32; 'AF': float64; 'p_hwe': float64; 'n_called': int32; 'n_not_called': int32; 'n_hom_ref': int32; 'n_het': int32; 'n_hom_var': int32; 'n_non_ref': int32; 'r_heterozygosity': float64; 'r_het_hom_var': float64; 'r_expected_het_frequency': float64; ----------------------------------------; Entry fields:; 'expected_case_minor_AC': float64; 'expected_min_category_minor_AC': float64; 'low_confidence_variant': bool; 'n_complete_samples': int32; 'AC': float64; 'ytx': float64; 'beta': float64; 'se': float64; 'tstat': float64; 'pval': float64; ----------------------------------------; Column key: ['phenotype']; Row key: ['locus', 'alleles']; ----------------------------------------. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:232,Modifiability,Config,Configuration,232, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associ,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:8792,Testability,Log,Log,8792,"_variant_indices_fin; gnomad_ld_variant_indices_nfe; gnomad_ld_variant_indices_nwe; gnomad_ld_variant_indices_seu; gnomad_lof_metrics; gnomad_mnv_genome_d01; gnomad_mnv_genome_d02; gnomad_mnv_genome_d03; gnomad_mnv_genome_d04; gnomad_mnv_genome_d05; gnomad_mnv_genome_d06; gnomad_mnv_genome_d07; gnomad_mnv_genome_d08; gnomad_mnv_genome_d09; gnomad_mnv_genome_d10; gnomad_pca_variant_loadings; gnomad_plof_metrics_gene; gnomad_plof_metrics_transcript; gnomad_variant_co-occurrence; ldsc_baselineLD_annotations; ldsc_baselineLD_ldscores; panukb_ld_scores_AFR; panukb_ld_scores_AMR; panukb_ld_scores_CSA; panukb_ld_scores_EAS; panukb_ld_scores_EUR; panukb_ld_scores_MID; panukb_ld_variant_indices_AFR; panukb_ld_variant_indices_AMR; panukb_ld_variant_indices_CSA; panukb_ld_variant_indices_EAS; panukb_ld_variant_indices_EUR; panukb_ld_variant_indices_MID; panukb_meta_analysis_all_ancestries; panukb_meta_analysis_high_quality; panukb_summary_stats. Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Datasets; Schemas; UK_Biobank_Rapid_GWAS_male. View page source. UK_Biobank_Rapid_GWAS_male. Versions: v2; Reference genome builds: GRCh37; Type: hail.MatrixTable. Schema (v2, GRCh37); ----------------------------------------; Global fields:; 'metadata': struct {; name: str,; version: str,; reference_genome: str,; n_rows: int32,; n_cols: int32,; n_partitions: int32; }; ----------------------------------------; Column fields:; 'phenotype': str; 'description': str; 'variable_type': str; 'source': str; 'n_non_missing': int32; 'n_missing': int32; 'n_controls': int32; 'n_cases': int32; 'PHESANT_transformation': str; 'notes': str; ----------------------------------------; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'variant': str; 'minor_allele': str; 'minor_AF': float64; 'rsid': str; 'varid': str; 'consequence': str; 'consequence_category': str; 'info': float64; 'call_rate': float64; 'alt_AC': int32; 'AF': fl",MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:64,Usability,Feedback,Feedback,64,﻿. Hail | ; UK_Biobank_Rapid_GWAS_male. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associ,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html:274,Usability,Guid,Guides,274, Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Schemas; 1000_Genomes_HighCov_autosomes; 1000_Genomes_HighCov_chrX; 1000_Genomes_HighCov_chrY; 1000_Genomes_Retracted_autosomes; 1000_Genomes_Retracted_chrX; 1000_Genomes_Retracted_chrY; 1000_Genomes_autosomes; 1000_Genomes_chrMT; 1000_Genomes_chrX; 1000_Genomes_chrY; CADD; DANN; Ensembl_homo_sapiens_low_complexity_regions; Ensembl_homo_sapiens_reference_genome; GTEx_RNA_seq_gene_TPMs; GTEx_RNA_seq_gene_read_counts; GTEx_RNA_seq_junction_read_counts; GTEx_eQTL_Adipose_Subcutaneous_all_snp_gene_associations; GTEx_eQTL_Adipose_Visceral_Omentum_all_snp_gene_associations; GTEx_eQTL_Adrenal_Gland_all_snp_gene_associations; GTEx_eQTL_Artery_Aorta_all_snp_gene_associations; GTEx_eQTL_Artery_Coronary_all_snp_gene_associations; GTEx_eQTL_Artery_Tibial_all_snp_gene_associations; GTEx_eQTL_Brain_Amygdala_all_snp_gene_associations; GTEx_eQTL_Brain_Anterior_cingulate_cortex_BA24_all_snp_gene_associations; GTEx_eQTL_Brain_Caudate_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellar_Hemisphere_all_snp_gene_associations; GTEx_eQTL_Brain_Cerebellum_all_snp_gene_associations; GTEx_eQTL_Brain_Cortex_all_snp_gene_associations; GTEx_eQTL_Brain_Frontal_Cortex_BA9_all_snp_gene_associations; GTEx_eQTL_Brain_Hippocampus_all_snp_gene_associations; GTEx_eQTL_Brain_Hypothalamus_all_snp_gene_associations; GTEx_eQTL_Brain_Nucleus_accumbens_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Putamen_basal_ganglia_all_snp_gene_associations; GTEx_eQTL_Brain_Spinal_cord_cervical_c-1_all_snp_gene_associations; GTEx_eQTL_Brain_Substantia_nigra_all_snp_gene_associations; GTEx_eQTL_Breast_Mammary_Tissue_all_snp_gene_associations; GTEx_eQTL_Cells_Cultured_fibroblasts_all_snp_gene_associ,MatchSource.WIKI,docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/datasets/schemas/UK_Biobank_Rapid_GWAS_male.html
https://hail.is/docs/0.2/linalg/utils/index.html:150,Deployability,Install,Installation,150,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:419,Deployability,Configurat,Configuration,419,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:4883,Deployability,update,updated,4883,"hl.linalg.utils.locus_windows(ht.locus, 1); (array([0, 0, 2, 3, 3, 5]), array([2, 2, 3, 5, 5, 6])). Windows with 1cm radius:; >>> hl.linalg.utils.locus_windows(ht.locus, 1.0, coord_expr=ht.cm); (array([0, 1, 1, 3, 3, 5]), array([1, 3, 3, 5, 5, 6])). Notes; This function returns two 1-dimensional ndarrays of integers,; starts and stops, each of size equal to the number of rows.; By default, for all indices i, [starts[i], stops[i]) is the maximal; range of row indices j such that contig[i] == contig[j] and; position[i] - radius <= position[j] <= position[i] + radius.; If the global_position() on locus_expr is not in ascending order,; this method will fail. Ascending order should hold for a matrix table keyed; by locus or variant (and the associated row table), or for a table that has; been ordered by locus_expr.; Set coord_expr to use a value other than position to define the windows.; This row-indexed numeric expression must be non-missing, non-nan, on the; same source as locus_expr, and ascending with respect to locus; position for each contig; otherwise the function will fail.; The last example above uses centimorgan coordinates, so; [starts[i], stops[i]) is the maximal range of row indices j such; that contig[i] == contig[j] and; cm[i] - radius <= cm[j] <= cm[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. locus_expr (LocusExpression) – Row-indexed locus expression on a table or matrix table.; radius (int) – Radius of window for row values.; coord_expr (Float64Expression, optional) – Row-indexed numeric expression for the row value.; Must be on the same table or matrix table as locus_expr.; By default, the row value is given by the locus position. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop indices array. Previous; Next . © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:419,Modifiability,Config,Configuration,419,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:573,Testability,Log,Log,573,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:50,Usability,Feedback,Feedback,50,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/linalg/utils/index.html:461,Usability,Guid,Guides,461,"﻿. Hail | ; linalg/utils. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); hail; Classes; Modules; expressions; types; functions; aggregators; scans; methods; nd; utils; linalg; stats; genetics; plot; ggplot; vds; experimental. Top-Level Functions. hailtop.fs; hailtop.batch. Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Python API; Hail Query Python API; linalg; linalg/utils. View page source. linalg/utils. array_windows(a, radius); Returns start and stop indices for window around each array value. locus_windows(locus_expr, radius[, ...]); Returns start and stop indices for window around each locus. hail.linalg.utils.array_windows(a, radius)[source]; Returns start and stop indices for window around each array value.; Examples; >>> hl.linalg.utils.array_windows(np.array([1, 2, 4, 4, 6, 8]), 2); (array([0, 0, 1, 1, 2, 4]), array([2, 4, 5, 5, 6, 6])). >>> hl.linalg.utils.array_windows(np.array([-10.0, -2.5, 0.0, 0.0, 1.2, 2.3, 3.0]), 2.5); (array([0, 1, 1, 1, 2, 2, 4]), array([1, 4, 6, 6, 7, 7, 7])). Notes; For an array a in ascending order, the resulting starts and stops; arrays have the same length as a and the property that, for all indices; i, [starts[i], stops[i]) is the maximal range of indices j such; that a[i] - radius <= a[j] <= a[i] + radius.; Index ranges are start-inclusive and stop-exclusive. This function is; especially useful in conjunction with; BlockMatrix.sparsify_row_intervals(). Parameters:. a (numpy.ndarray of signed integer or float values) – 1-dimensional array of values, non-decreasing with respect to index.; radius (float) – Non-negative radius of window for values. Returns:; (numpy.ndarray of int, numpy.ndarray of int) – Tuple of start indices array and stop in",MatchSource.WIKI,docs/0.2/linalg/utils/index.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/linalg/utils/index.html
https://hail.is/docs/0.2/_modules/hail/context.html:8825,Availability,avail,available,8825,"sh` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12067,Availability,error,error,12067," of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; dr",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:150,Deployability,Install,Installation,150,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:218,Deployability,Configurat,Configuration,218,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:6629,Deployability,configurat,configuration,6629,"))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(dictof(str, sequenceof(str))),; copy_spark_log_on_error=nullable(bool),; ); def init(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_con",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:6973,Deployability,configurat,configuration,6973,"_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKI",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7160,Deployability,configurat,configuration,7160,"ores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkCo",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:8350,Deployability,pipeline,pipeline,8350," # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:8988,Deployability,configurat,configuration,8988,"hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Sp",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:10003,Deployability,configurat,configuration,10003,"lass:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:10105,Deployability,configurat,configuration,10105,"ogle Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:11610,Deployability,configurat,configuration,11610,"rocess. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; defa",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12206,Deployability,configurat,configuration,12206,"vided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12769,Deployability,release,release,12769,"w_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configur",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:20273,Deployability,install,installed,20273,"'GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return f""https://github.com/hail-is/hail/commit/{sha_prefix}"". [docs]def citation(*, bibtex=False):; """"""Generate a Hail citation. Parameters; ----------; bibtex : bool; Generate a citation in BibTeX form. Returns; -------; str; """"""; if bibtex:; return (; f""@misc{{Hail,""; f"" author = {{Hail Team}},""; f"" title = {{Hail}},""; f"" howpublished = {{\\url{{{_hail_cite_url()}}}}}""; f""}}""; ); return f""Hail Team. Hail {ve",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:20474,Deployability,install,installed,20474," hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return f""https://github.com/hail-is/hail/commit/{sha_prefix}"". [docs]def citation(*, bibtex=False):; """"""Generate a Hail citation. Parameters; ----------; bibtex : bool; Generate a citation in BibTeX form. Returns; -------; str; """"""; if bibtex:; return (; f""@misc{{Hail,""; f"" author = {{Hail Team}},""; f"" title = {{Hail}},""; f"" howpublished = {{\\url{{{_hail_cite_url()}}}}}""; f""}}""; ); return f""Hail Team. Hail {version()}. {_hail_cite_url()}."". def cite_hail():; return citation(bibtex=False). def cite_hail_bibtex():; return citation(bibtex=True). [docs]def stop():; """"""Stop the currently running Hail session.""""""; if ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:20777,Deployability,install,installed,20777,"L_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return f""https://github.com/hail-is/hail/commit/{sha_prefix}"". [docs]def citation(*, bibtex=False):; """"""Generate a Hail citation. Parameters; ----------; bibtex : bool; Generate a citation in BibTeX form. Returns; -------; str; """"""; if bibtex:; return (; f""@misc{{Hail,""; f"" author = {{Hail Team}},""; f"" title = {{Hail}},""; f"" howpublished = {{\\url{{{_hail_cite_url()}}}}}""; f""}}""; ); return f""Hail Team. Hail {version()}. {_hail_cite_url()}."". def cite_hail():; return citation(bibtex=False). def cite_hail_bibtex():; return citation(bibtex=True). [docs]def stop():; """"""Stop the currently running Hail session.""""""; if Env._hc:; Env.hc().stop(). [docs]def spark_context():; """"""Returns the active Spark context. Returns; -------; :class:`pyspark.SparkContext`; """"""; return Env.spark_backend('spark_context').sc. [docs]def tmp_dir() -> str:; """"""Returns the Hail shared temporary directory. Returns; -------; :class:`str`; """"""; return",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:20829,Deployability,release,releases,20829,"; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return f""https://github.com/hail-is/hail/commit/{sha_prefix}"". [docs]def citation(*, bibtex=False):; """"""Generate a Hail citation. Parameters; ----------; bibtex : bool; Generate a citation in BibTeX form. Returns; -------; str; """"""; if bibtex:; return (; f""@misc{{Hail,""; f"" author = {{Hail Team}},""; f"" title = {{Hail}},""; f"" howpublished = {{\\url{{{_hail_cite_url()}}}}}""; f""}}""; ); return f""Hail Team. Hail {version()}. {_hail_cite_url()}."". def cite_hail():; return citation(bibtex=False). def cite_hail_bibtex():; return citation(bibtex=True). [docs]def stop():; """"""Stop the currently running Hail session.""""""; if Env._hc:; Env.hc().stop(). [docs]def spark_context():; """"""Returns the active Spark context. Returns; -------; :class:`pyspark.SparkContext`; """"""; return Env.spark_backend('spark_context').sc. [docs]def tmp_dir() -> str:; """"""Returns the Hail shared temporary directory. Returns; -------; :class:`str`; """"""; return Env.hc()._tmpdir. class _TemporaryFilenameManager:; def __in",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:27839,Deployability,update,updated,27839,"ndle/b37/human_g1k_v37.dict>`__; and `Homo_sapiens_assembly38.dict; <ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/hg38/Homo_sapiens_assembly38.dict>`__. If ``name='default'``, the value of :func:`.default_reference` is returned. Parameters; ----------; name : :class:`str`; Name of a previously loaded reference genome or one of Hail's built-in; references: ``'GRCh37'``, ``'GRCh38'``, ``'GRCm38'``, ``'CanFam3'``, and; ``'default'``. Returns; -------; :class:`.ReferenceGenome`; """"""; Env.hc(); if name == 'default':; return default_reference(); else:; return Env.backend().get_reference(name). [docs]@typecheck(seed=int); def set_global_seed(seed):; """"""Deprecated. Has no effect. To ensure reproducible randomness, use the `global_seed`; argument to :func:`.init` and :func:`.reset_global_randomness`. See the :ref:`random functions <sec-random-functions>` reference docs for more. Parameters; ----------; seed : :obj:`int`; Integer used to seed Hail's random number generator; """""". warning(; 'hl.set_global_seed has no effect. See '; 'https://hail.is/docs/0.2/functions/random.html for details on '; 'ensuring reproducibility of randomness.'; ); pass. [docs]@typecheck(); def reset_global_randomness():; """"""Restore global randomness to initial state for test reproducibility."""""". Env.reset_global_randomness(). def _set_flags(**flags):; Env.backend().set_flags(**flags). def _get_flags(*flags):; return Env.backend().get_flags(*flags). @contextmanager; def _with_flags(**flags):; before = _get_flags(*flags); try:; _set_flags(**flags); yield; finally:; _set_flags(**before). def debug_info():; from hail.backend.backend import local_jar_information; from hail.backend.spark_backend import SparkBackend. spark_conf = None; if isinstance(Env.backend(), SparkBackend):; spark_conf = spark_context()._conf.getAll(); return {'spark_conf': spark_conf, 'local_jar_information': local_jar_information(), 'version': version()}. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:3555,Integrability,Interface,Interfaces,3555,"Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:9179,Integrability,message,messages,9179,"; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`s",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:218,Modifiability,Config,Configuration,218,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:6506,Modifiability,config,configure,6506,"),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=nullable(enumeration(*BUILTIN_REFERENCES)),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; backend=nullable(enumeration(*BackendType.__args__)),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(dictof(str, sequenceof(str))),; copy_spark_log_on_error=nullable(bool),; ); def init(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:6629,Modifiability,config,configuration,6629,"))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(dictof(str, sequenceof(str))),; copy_spark_log_on_error=nullable(bool),; ); def init(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_con",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:6973,Modifiability,config,configuration,6973,"_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKI",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7089,Modifiability,variab,variable,7089,"ion=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buck",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7126,Modifiability,config,config,7126,"None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7160,Modifiability,config,configuration,7160,"ores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkCo",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7240,Modifiability,Config,Configure,7240,"ry=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not speci",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7500,Modifiability,Config,Configure,7500,"ault arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifyin",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7698,Modifiability,Config,Configure,7698,"and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7987,Modifiability,config,config,7987,"is function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local pat",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:8039,Modifiability,config,config,8039,"is function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local pat",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:8988,Modifiability,config,configuration,8988,"hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Sp",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:10003,Modifiability,config,configuration,10003,"lass:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:10105,Modifiability,config,configuration,10105,"ogle Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:11089,Modifiability,config,configure,11089,"obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_d",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:11217,Modifiability,config,configure,11217,"e. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.';",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:11610,Modifiability,config,configuration,11610,"rocess. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; defa",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:11652,Modifiability,config,config,11652,"kend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" back",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12206,Modifiability,config,configuration,12206,"vided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:26173,Performance,load,loaded,26173," reference genome (``'GRCh37'`` by default).; With an argument, sets the default reference genome to the argument. Returns; -------; :class:`.ReferenceGenome`; """"""; if new_default_reference is not None:; Env.hc().default_reference = new_default_reference; return None; return Env.hc().default_reference. [docs]def get_reference(name) -> ReferenceGenome:; """"""Returns the reference genome corresponding to `name`. Notes; -----. Hail's built-in references are ``'GRCh37'``, ``GRCh38'``, ``'GRCm38'``, and; ``'CanFam3'``.; The contig names and lengths come from the GATK resource bundle:; `human_g1k_v37.dict; <ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/b37/human_g1k_v37.dict>`__; and `Homo_sapiens_assembly38.dict; <ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/hg38/Homo_sapiens_assembly38.dict>`__. If ``name='default'``, the value of :func:`.default_reference` is returned. Parameters; ----------; name : :class:`str`; Name of a previously loaded reference genome or one of Hail's built-in; references: ``'GRCh37'``, ``'GRCh38'``, ``'GRCm38'``, ``'CanFam3'``, and; ``'default'``. Returns; -------; :class:`.ReferenceGenome`; """"""; Env.hc(); if name == 'default':; return default_reference(); else:; return Env.backend().get_reference(name). [docs]@typecheck(seed=int); def set_global_seed(seed):; """"""Deprecated. Has no effect. To ensure reproducible randomness, use the `global_seed`; argument to :func:`.init` and :func:`.reset_global_randomness`. See the :ref:`random functions <sec-random-functions>` reference docs for more. Parameters; ----------; seed : :obj:`int`; Integer used to seed Hail's random number generator; """""". warning(; 'hl.set_global_seed has no effect. See '; 'https://hail.is/docs/0.2/functions/random.html for details on '; 'ensuring reproducibility of randomness.'; ); pass. [docs]@typecheck(); def reset_global_randomness():; """"""Restore global randomness to initial state for test reproducibility."""""". Env.reset_global_randomness(). def _set_flags(**f",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7544,Security,access,accessing,7544,"ault arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifyin",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:7742,Security,access,accessing,7742,"and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; these configuration locations:. 1. The ``backend`` parameter of this function.; 2. The ``HAIL_QUERY_BACKEND`` environment variable.; 3. The value of ``hailctl config get query/backend``. If no configuration is found, Hail will select the Spark backend. Examples; --------; Configure Hail to use the Batch backend:. >>> import hail as hl; >>> hl.init(backend='batch') # doctest: +SKIP. If a :class:`pyspark.SparkContext` is already running, then Hail must be; initialized with it as an argument:. >>> hl.init(sc=sc) # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing any Google Cloud Storage bucket that has; requester pays enabled:. >>> hl.init(gcs_requester_pays_configuration='my-project') # doctest: +SKIP. Configure Hail to bill to `my_project` when accessing the Google Cloud Storage buckets named; `bucket_of_fish` and `bucket_of_eels`:. >>> hl.init(; ... gcs_requester_pays_configuration=('my-project', ['bucket_of_fish', 'bucket_of_eels']); ... ) # doctest: +SKIP. You may also use `hailctl config set gcs_requester_pays/project` and `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:372,Testability,Log,Log,372,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:1899,Testability,log,log,1899,", nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:1909,Testability,log,log,1909,", nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2033,Testability,log,log,2033,"fault; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, back",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2119,Testability,log,log,2119,"loud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2133,Testability,log,log,2133,"loud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2468,Testability,log,log,2468,"pdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during th",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2638,Testability,log,log,2638,"pdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during th",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2642,Testability,log,log,2642,"pdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during th",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2845,Testability,log,log,2845,"ion(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_non",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:2975,Testability,log,log,2975,"ion(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_non",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:3041,Testability,assert,assert,3041,"ion(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir is None:; log_dir = os.getcwd(); log = hail.utils.timestamp_path(os.path.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_non",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:3073,Testability,log,log,3073,"h.join(log_dir, 'hail'), suffix=f'-{py_version}.log'); return log. def convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; x: Optional[Union[str, Tuple[str, List[str]]]],; ) -> Tuple[Optional[str], Optional[str]]:; if isinstance(x, str):; return x, None; if isinstance(x, tuple):; return x[0], "","".join(x[1]); return None, None. class HailContext(object):; @staticmethod; def create(; log: str,; quiet: bool,; append: bool,; tmpdir: str,; local_tmpdir: str,; default_reference: str,; global_seed: Optional[int],; backend: Backend,; ):; hc = HailContext(; log=log,; quiet=quiet,; append=append,; tmpdir=tmpdir,; local_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference)",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:3687,Testability,LOG,LOGGING,3687,"l_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:3708,Testability,log,log,3708,"l_tmpdir=local_tmpdir,; global_seed=global_seed,; backend=backend,; ); hc.initialize_references(default_reference); return hc. @typecheck_method(; log=str, quiet=bool, append=bool, tmpdir=str, local_tmpdir=str, global_seed=nullable(int), backend=Backend; ); def __init__(self, log, quiet, append, tmpdir, local_tmpdir, global_seed, backend):; assert not Env._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:4075,Testability,assert,assert,4075,"v._hc. self._log = log. self._tmpdir = tmpdir; self._local_tmpdir = local_tmpdir. self._backend = backend. self._warn_cols_order = True; self._warn_entries_order = True. self._default_ref: Optional[ReferenceGenome] = None. if not quiet:; py_version = version(); sys.stderr.write(; 'Welcome to\n'; ' __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_ref = value. def stop(self):; assert self._backend; self._backend.stop(); self._backend = None; Env._hc = None; Env._dummy_table = None; Env._seed_generator = None; hail.ir.clear_session_functions(). [docs]@typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; mi",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:4377,Testability,assert,assert,4377," __ __ <>__\n'; ' / /_/ /__ __/ /\n'; ' / __ / _ `/ / /\n'; ' /_/ /_/\\_,_/_/_/ version {}\n'.format(py_version); ). if py_version.startswith('devel'):; sys.stderr.write(; 'NOTE: This is a beta version. Interfaces may change\n'; ' during the beta period. We recommend pulling\n'; ' the latest changes weekly.\n'; ); sys.stderr.write(f'LOGGING: writing to {log}\n'). self._user_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_ref = value. def stop(self):; assert self._backend; self._backend.stop(); self._backend = None; Env._hc = None; Env._dummy_table = None; Env._seed_generator = None; hail.ir.clear_session_functions(). [docs]@typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=nullable(enumeration(*BUILTIN_REFERENCES)),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:4728,Testability,assert,assert,4728,"ser_specified_rng_nonce = True; if global_seed is None:; if 'rng_nonce' not in backend.get_flags('rng_nonce'):; backend.set_flags(rng_nonce=hex(Random().randrange(-(2**63), 2**63 - 1))); self._user_specified_rng_nonce = False; else:; backend.set_flags(rng_nonce=hex(global_seed)); Env._hc = self. def initialize_references(self, default_reference):; assert self._backend; self._backend.initialize_references(); if default_reference in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_ref = value. def stop(self):; assert self._backend; self._backend.stop(); self._backend = None; Env._hc = None; Env._dummy_table = None; Env._seed_generator = None; hail.ir.clear_session_functions(). [docs]@typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=nullable(enumeration(*BUILTIN_REFERENCES)),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; backend=nullable(enumeration(*BackendType.__args__)),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullabl",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:5005,Testability,log,log,5005,"ce in BUILTIN_REFERENCES:; self._default_ref = self._backend.get_reference(default_reference); else:; self._default_ref = ReferenceGenome.read(default_reference). @property; def default_reference(self) -> ReferenceGenome:; assert self._default_ref is not None, '_default_ref should have been initialized in HailContext.create'; return self._default_ref. @default_reference.setter; def default_reference(self, value):; if not isinstance(value, ReferenceGenome):; raise TypeError(f'{value} is {type(value)} not a ReferenceGenome'); self._default_ref = value. def stop(self):; assert self._backend; self._backend.stop(); self._backend = None; Env._hc = None; Env._dummy_table = None; Env._seed_generator = None; hail.ir.clear_session_functions(). [docs]@typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=nullable(enumeration(*BUILTIN_REFERENCES)),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; backend=nullable(enumeration(*BackendType.__args__)),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(dictof(str, sequenceof(str))),; copy_spark_log_on_error=nullable(bool),; ); def init(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:5873,Testability,log,log,5873,"),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=nullable(enumeration(*BUILTIN_REFERENCES)),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; backend=nullable(enumeration(*BackendType.__args__)),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(dictof(str, sequenceof(str))),; copy_spark_log_on_error=nullable(bool),; ); def init(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference=None,; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; *,; backend: Optional[BackendType] = None,; driver_cores=None,; driver_memory=None,; worker_cores=None,; worker_memory=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[Dict[str, List[str]]] = None,; copy_spark_log_on_error: bool = False,; ):; """"""Initialize and configure Hail. This function will be called with default arguments if any Hail functionality is used. If you; need custom configuration, you must explicitly call this function before using Hail. For; example, to set the global random seed to 0, import Hail and immediately call; :func:`.init`:. >>> import hail as hl; >>> hl.init(global_seed=0) # doctest: +SKIP. Hail has two backends, ``spark`` and ``batch``. Hail selects a backend by consulting, in order,; ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:9004,Testability,log,log,9004,"nd `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:9044,Testability,log,log,9044,"nd `hailctl config set; gcs_requester_pays/buckets` to achieve the same effect. See Also; --------; :func:`.stop`. Parameters; ----------; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:9175,Testability,log,log,9175,"; sc : pyspark.SparkContext, optional; Spark Backend only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`s",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:9237,Testability,log,log,9237,"only. Spark context. If not specified, the Spark backend will create a new; Spark context.; app_name : :class:`str`; A name for this pipeline. In the Spark backend, this becomes the Spark application name. In; the Batch backend, this is a prefix for the name of every Batch.; master : :class:`str`, optional; Spark Backend only. URL identifying the Spark leader (master) node or `local[N]` for local; clusters.; local : :class:`str`; Spark Backend only. Local-mode core limit indicator. Must either be `local[N]` where N is a; positive integer or `local[*]`. The latter indicates Spark should use all cores; available. `local[*]` does not respect most containerization CPU limits. This option is only; used if `master` is unset and `spark.master` is not set in the Spark configuration.; log : :class:`str`; Local path for Hail log file. Does not currently support distributed file systems like; Google Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on dri",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:10097,Testability,log,logging,10097,"ogle Storage, S3, or HDFS.; quiet : :obj:`bool`; Print fewer log messages.; append : :obj:`bool`; Append to the end of the log file.; min_block_size : :obj:`int`; Minimum file block size in MB.; branching_factor : :obj:`int`; Branching factor for tree aggregation.; tmp_dir : :class:`str`, optional; Networked temporary directory. Must be a network-visible file; path. Defaults to /tmp in the default scheme.; default_reference : :class:`str`; *Deprecated*. Please use :func:`.default_reference` to set the default reference genome. Default reference genome. Either ``'GRCh37'``, ``'GRCh38'``,; ``'GRCm38'``, or ``'CanFam3'``.; idempotent : :obj:`bool`; If ``True``, calling this function is a no-op if Hail has already been initialized.; global_seed : :obj:`int`, optional; Global random seed.; spark_conf : :obj:`dict` of :class:`str` to :class`str`, optional; Spark backend only. Spark configuration parameters.; skip_logging_configuration : :obj:`bool`; Spark Backend only. Skip logging configuration in java and python.; local_tmpdir : :class:`str`, optional; Local temporary directory. Used on driver and executor nodes.; Must use the file scheme. Defaults to TMPDIR, or /tmp.; driver_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the driver process. May be 1, 2, 4, or 8. Default is; 1.; driver_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the driver process. May be standard or; highmem. Default is standard.; worker_cores : :class:`str` or :class:`int`, optional; Batch backend only. Number of cores to use for the worker processes. May be 1, 2, 4, or 8. Default is; 1.; worker_memory : :class:`str`, optional; Batch backend only. Memory tier to use for the worker processes. May be standard or; highmem. Default is standard.; gcs_requester_pays_configuration : either :class:`str` or :class:`tuple` of :class:`str` and :class:`list` of :class:`str`, optional; If a string is provided, configure the Google Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12020,Testability,log,log,12020," of :class:`str`, optional; If a string is provided, configure the Google Cloud Storage file system to bill usage to the; project identified by that string. If a tuple is provided, configure the Google Cloud; Storage file system to bill usage to the specified project for buckets specified in the; list. See examples above.; regions : :obj:`list` of :class:`str`, optional; List of regions to run jobs in when using the Batch backend. Use :data:`.ANY_REGION` to specify any region is allowed; or use `None` to use the underlying default regions from the hailctl environment configuration. For example, use; `hailctl config set batch/regions region1,region2` to set the default regions to use.; gcs_bucket_allow_list:; A list of buckets that Hail should be permitted to read from or write to, even if their default policy is to; use ""cold"" storage. Should look like ``[""bucket1"", ""bucket2""]``.; copy_spark_log_on_error: :class:`bool`, optional; Spark backend only. If `True`, copy the log from the spark driver node to `tmp_dir` on error.; """"""; if Env._hc:; if idempotent:; return; else:; warning(; 'Hail has already been initialized. If this call was intended to change configuration,'; ' close the session with hl.stop() first.'; ). if default_reference is not None:; warnings.warn(; 'Using hl.init with a default_reference argument is deprecated. '; 'To set a default reference genome after initializing hail, '; 'call `hl.default_reference` with an argument to set the '; 'default reference genome.'; ); else:; default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; dr",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12885,Testability,log,log,12885," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:12889,Testability,log,log,12889," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:13551,Testability,log,log,13551," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:13555,Testability,log,log,13555," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:13940,Testability,log,log,13940," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:13944,Testability,log,log,13944," default_reference = 'GRCh37'. backend = choose_backend(backend). if backend == 'service':; warnings.warn(; 'The ""service"" backend is now called the ""batch"" backend. Support for ""service"" will be removed in a '; 'future release.'; ); backend = 'batch'. if backend == 'batch':; return hail_event_loop().run_until_complete(; init_batch(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; global_seed=global_seed,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=app_name,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; regions=regions,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ); ); if backend == 'spark':; return init_spark(; sc=sc,; app_name=app_name,; master=master,; local=local,; min_block_size=min_block_size,; branching_factor=branching_factor,; spark_conf=spark_conf,; _optimizer_iterations=_optimizer_iterations,; log=log,; quiet=quiet,; append=append,; tmp_dir=tmp_dir,; local_tmpdir=local_tmpdir,; default_reference=default_reference,; idempotent=idempotent,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nu",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:14349,Testability,log,log,14349,"n,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; copy_log_on_error=nullable(bool),; ); def init_spark(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference='GRCh37',; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; copy_log_on_error: bool = False,; ):; from hail.backend.py4j_backend import connect_logger; from hail.backend.spark_backend import SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_request",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:14911,Testability,log,log,14911,"n,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; copy_log_on_error=copy_spark_log_on_error,; ); if backend == 'local':; return init_local(; log=log,; quiet=quiet,; append=append,; tmpdir=tmp_dir,; default_reference=default_reference,; global_seed=global_seed,; skip_logging_configuration=skip_logging_configuration,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); raise ValueError(f'unknown Hail Query backend: {backend}'). @typecheck(; sc=nullable(SparkContext),; app_name=nullable(str),; master=nullable(str),; local=str,; log=nullable(str),; quiet=bool,; append=bool,; min_block_size=int,; branching_factor=int,; tmp_dir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; copy_log_on_error=nullable(bool),; ); def init_spark(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference='GRCh37',; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; copy_log_on_error: bool = False,; ):; from hail.backend.py4j_backend import connect_logger; from hail.backend.spark_backend import SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_request",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:15404,Testability,log,log,15404,"_REFERENCES),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; copy_log_on_error=nullable(bool),; ); def init_spark(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference='GRCh37',; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; copy_log_on_error: bool = False,; ):; from hail.backend.py4j_backend import connect_logger; from hail.backend.spark_backend import SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_requester_pays_configuration(; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); ); backend = SparkBackend(; idempotent,; sc,; spark_conf,; app_name,; master,; local,; log,; quiet,; append,; min_block_size,; branching_factor,; tmpdir,; local_tmpdir,; skip_logging_configuration,; optimizer_iterations,; gcs_requester_pays_project=gcs_requester_pays_project,; gcs_requester_pays_buckets=gcs_requester_pays_buckets,; copy_log_on_error=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typechec",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:15419,Testability,log,log,15419,"_REFERENCES),; idempotent=bool,; global_seed=nullable(int),; spark_conf=nullable(dictof(str, str)),; skip_logging_configuration=bool,; local_tmpdir=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; copy_log_on_error=nullable(bool),; ); def init_spark(; sc=None,; app_name=None,; master=None,; local='local[*]',; log=None,; quiet=False,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference='GRCh37',; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; copy_log_on_error: bool = False,; ):; from hail.backend.py4j_backend import connect_logger; from hail.backend.spark_backend import SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_requester_pays_configuration(; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); ); backend = SparkBackend(; idempotent,; sc,; spark_conf,; app_name,; master,; local,; log,; quiet,; append,; min_block_size,; branching_factor,; tmpdir,; local_tmpdir,; skip_logging_configuration,; optimizer_iterations,; gcs_requester_pays_project=gcs_requester_pays_project,; gcs_requester_pays_buckets=gcs_requester_pays_buckets,; copy_log_on_error=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typechec",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:15959,Testability,log,log,15959,"se,; append=False,; min_block_size=0,; branching_factor=50,; tmp_dir=None,; default_reference='GRCh37',; idempotent=False,; global_seed=None,; spark_conf=None,; skip_logging_configuration=False,; local_tmpdir=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; copy_log_on_error: bool = False,; ):; from hail.backend.py4j_backend import connect_logger; from hail.backend.spark_backend import SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_requester_pays_configuration(; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); ); backend = SparkBackend(; idempotent,; sc,; spark_conf,; app_name,; master,; local,; log,; quiet,; append,; min_block_size,; branching_factor,; tmpdir,; local_tmpdir,; skip_logging_configuration,; optimizer_iterations,; gcs_requester_pays_project=gcs_requester_pays_project,; gcs_requester_pays_buckets=gcs_requester_pays_buckets,; copy_log_on_error=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typecheck(; billing_project=nullable(str),; remote_tmpdir=nullable(str),; log=nullable(str),; quiet=bool,; append=bool,; tmpdir=nullable(str),; local_tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; disable_progress_bar=nullable(bool),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; name",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:16327,Testability,log,log,16327,"mport SparkBackend. log = _get_log(log); tmpdir = _get_tmpdir(tmp_dir); local_tmpdir = _get_local_tmpdir(local_tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). app_name = app_name or 'Hail'; (; gcs_requester_pays_project,; gcs_requester_pays_buckets,; ) = convert_gcs_requester_pays_configuration_to_hadoop_conf_style(; get_gcs_requester_pays_configuration(; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; ); ); backend = SparkBackend(; idempotent,; sc,; spark_conf,; app_name,; master,; local,; log,; quiet,; append,; min_block_size,; branching_factor,; tmpdir,; local_tmpdir,; skip_logging_configuration,; optimizer_iterations,; gcs_requester_pays_project=gcs_requester_pays_project,; gcs_requester_pays_buckets=gcs_requester_pays_buckets,; copy_log_on_error=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typecheck(; billing_project=nullable(str),; remote_tmpdir=nullable(str),; log=nullable(str),; quiet=bool,; append=bool,; tmpdir=nullable(str),; local_tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; disable_progress_bar=nullable(bool),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; name_prefix=nullable(str),; token=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(sequenceof(str)),; ); async def init_batch(; *,; billing_project: Optional[str] = None,; remote_tmpdir: Optional[str] = None,; log: Optional[str] = None,; quiet: bool = False,; append: bool = False,; tmpdir: Optional[str] = None,; local_tmpdir: Op",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:16568,Testability,log,log,16568,"or=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typecheck(; billing_project=nullable(str),; remote_tmpdir=nullable(str),; log=nullable(str),; quiet=bool,; append=bool,; tmpdir=nullable(str),; local_tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; disable_progress_bar=nullable(bool),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; name_prefix=nullable(str),; token=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(sequenceof(str)),; ); async def init_batch(; *,; billing_project: Optional[str] = None,; remote_tmpdir: Optional[str] = None,; log: Optional[str] = None,; quiet: bool = False,; append: bool = False,; tmpdir: Optional[str] = None,; local_tmpdir: Optional[str] = None,; default_reference: str = 'GRCh37',; global_seed: Optional[int] = None,; disable_progress_bar: Optional[bool] = None,; driver_cores: Optional[Union[str, int]] = None,; driver_memory: Optional[str] = None,; worker_cores: Optional[Union[str, int]] = None,; worker_memory: Optional[str] = None,; name_prefix: Optional[str] = None,; token: Optional[str] = None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[List[str]] = None,; ):; from hail.backend.service_backend import ServiceBackend. # FIXME: pass local_tmpdir and use on worker and driver; backend = await ServiceBackend.create(; billing_project=billing_project,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:17265,Testability,log,log,17265,"or=copy_log_on_error,; ); if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). @typecheck(; billing_project=nullable(str),; remote_tmpdir=nullable(str),; log=nullable(str),; quiet=bool,; append=bool,; tmpdir=nullable(str),; local_tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; disable_progress_bar=nullable(bool),; driver_cores=nullable(oneof(str, int)),; driver_memory=nullable(str),; worker_cores=nullable(oneof(str, int)),; worker_memory=nullable(str),; name_prefix=nullable(str),; token=nullable(str),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; regions=nullable(sequenceof(str)),; gcs_bucket_allow_list=nullable(sequenceof(str)),; ); async def init_batch(; *,; billing_project: Optional[str] = None,; remote_tmpdir: Optional[str] = None,; log: Optional[str] = None,; quiet: bool = False,; append: bool = False,; tmpdir: Optional[str] = None,; local_tmpdir: Optional[str] = None,; default_reference: str = 'GRCh37',; global_seed: Optional[int] = None,; disable_progress_bar: Optional[bool] = None,; driver_cores: Optional[Union[str, int]] = None,; driver_memory: Optional[str] = None,; worker_cores: Optional[Union[str, int]] = None,; worker_memory: Optional[str] = None,; name_prefix: Optional[str] = None,; token: Optional[str] = None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[List[str]] = None,; ):; from hail.backend.service_backend import ServiceBackend. # FIXME: pass local_tmpdir and use on worker and driver; backend = await ServiceBackend.create(; billing_project=billing_project,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:18506,Testability,log,log,18506,"es: Optional[Union[str, int]] = None,; driver_memory: Optional[str] = None,; worker_cores: Optional[Union[str, int]] = None,; worker_memory: Optional[str] = None,; name_prefix: Optional[str] = None,; token: Optional[str] = None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[List[str]] = None,; ):; from hail.backend.service_backend import ServiceBackend. # FIXME: pass local_tmpdir and use on worker and driver; backend = await ServiceBackend.create(; billing_project=billing_project,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=name_prefix,; credentials_token=token,; regions=regions,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ). log = _get_log(log); if tmpdir is None:; tmpdir = backend.remote_tmpdir + 'tmp/hail/' + secret_alnum_string(); local_tmpdir = _get_local_tmpdir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backen",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:18521,Testability,log,log,18521,"es: Optional[Union[str, int]] = None,; driver_memory: Optional[str] = None,; worker_cores: Optional[Union[str, int]] = None,; worker_memory: Optional[str] = None,; name_prefix: Optional[str] = None,; token: Optional[str] = None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[List[str]] = None,; ):; from hail.backend.service_backend import ServiceBackend. # FIXME: pass local_tmpdir and use on worker and driver; backend = await ServiceBackend.create(; billing_project=billing_project,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=name_prefix,; credentials_token=token,; regions=regions,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ). log = _get_log(log); if tmpdir is None:; tmpdir = backend.remote_tmpdir + 'tmp/hail/' + secret_alnum_string(); local_tmpdir = _get_local_tmpdir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backen",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:18684,Testability,log,log,18684,"r] = None,; token: Optional[str] = None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; regions: Optional[List[str]] = None,; gcs_bucket_allow_list: Optional[List[str]] = None,; ):; from hail.backend.service_backend import ServiceBackend. # FIXME: pass local_tmpdir and use on worker and driver; backend = await ServiceBackend.create(; billing_project=billing_project,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=name_prefix,; credentials_token=token,; regions=regions,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ). log = _get_log(log); if tmpdir is None:; tmpdir = backend.remote_tmpdir + 'tmp/hail/' + secret_alnum_string(); local_tmpdir = _get_local_tmpdir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:18781,Testability,log,log,18781,"oject,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=name_prefix,; credentials_token=token,; regions=regions,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ). log = _get_log(log); if tmpdir is None:; tmpdir = backend.remote_tmpdir + 'tmp/hail/' + secret_alnum_string(); local_tmpdir = _get_local_tmpdir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_refer",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:19170,Testability,log,log,19170,"oject,; remote_tmpdir=remote_tmpdir,; disable_progress_bar=disable_progress_bar,; driver_cores=driver_cores,; driver_memory=driver_memory,; worker_cores=worker_cores,; worker_memory=worker_memory,; name_prefix=name_prefix,; credentials_token=token,; regions=regions,; gcs_requester_pays_configuration=gcs_requester_pays_configuration,; gcs_bucket_allow_list=gcs_bucket_allow_list,; ). log = _get_log(log); if tmpdir is None:; tmpdir = backend.remote_tmpdir + 'tmp/hail/' + secret_alnum_string(); local_tmpdir = _get_local_tmpdir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_refer",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:19573,Testability,log,log,19573,"dir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:19588,Testability,log,log,19588,"dir(local_tmpdir). HailContext.create(log, quiet, append, tmpdir, local_tmpdir, default_reference, global_seed, backend). @typecheck(; log=nullable(str),; quiet=bool,; append=bool,; branching_factor=int,; tmpdir=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:19845,Testability,log,log,19845,"r=nullable(str),; default_reference=enumeration(*BUILTIN_REFERENCES),; global_seed=nullable(int),; skip_logging_configuration=bool,; jvm_heap_size=nullable(str),; _optimizer_iterations=nullable(int),; gcs_requester_pays_configuration=nullable(oneof(str, sized_tupleof(str, sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:20073,Testability,log,log,20073,", sequenceof(str)))),; ); def init_local(; log=None,; quiet=False,; append=False,; branching_factor=50,; tmpdir=None,; default_reference='GRCh37',; global_seed=None,; skip_logging_configuration=False,; jvm_heap_size=None,; _optimizer_iterations=None,; gcs_requester_pays_configuration: Optional[GCSRequesterPaysConfiguration] = None,; ):; from hail.backend.local_backend import LocalBackend; from hail.backend.py4j_backend import connect_logger. log = _get_log(log); tmpdir = _get_tmpdir(tmpdir); optimizer_iterations = get_env_or_default(_optimizer_iterations, 'HAIL_OPTIMIZER_ITERATIONS', 3). jvm_heap_size = get_env_or_default(jvm_heap_size, 'HAIL_LOCAL_BACKEND_HEAP_SIZE', None); backend = LocalBackend(; tmpdir,; log,; quiet,; append,; branching_factor,; skip_logging_configuration,; optimizer_iterations,; jvm_heap_size,; gcs_requester_pays_configuration,; ). if not backend.fs.exists(tmpdir):; backend.fs.mkdir(tmpdir). HailContext.create(log, quiet, append, tmpdir, tmpdir, default_reference, global_seed, backend); if not quiet:; connect_logger(backend._utils_package_object, 'localhost', 12888). [docs]def version() -> str:; """"""Get the installed Hail version. Returns; -------; str; """"""; if hail.__version__ is None:; hail.__version__ = __resource_str('hail_version').strip(). return hail.__version__. def revision() -> str:; """"""Get the installed Hail git revision. Returns; -------; str; """"""; if hail.__revision__ is None:; hail.__revision__ = __resource_str('hail_revision').strip(). return hail.__revision__. def _hail_cite_url():; v = version(); [tag, sha_prefix] = v.split(""-""); if not local_jar_information().development_mode:; # pip installed; return f""https://github.com/hail-is/hail/releases/tag/{tag}""; return f""https://github.com/hail-is/hail/commit/{sha_prefix}"". [docs]def citation(*, bibtex=False):; """"""Generate a Hail citation. Parameters; ----------; bibtex : bool; Generate a citation in BibTeX form. Returns; -------; str; """"""; if bibtex:; return (; f""@misc{{Hail,""; f"" aut",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:27134,Testability,test,test,27134,"ndle/b37/human_g1k_v37.dict>`__; and `Homo_sapiens_assembly38.dict; <ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/hg38/Homo_sapiens_assembly38.dict>`__. If ``name='default'``, the value of :func:`.default_reference` is returned. Parameters; ----------; name : :class:`str`; Name of a previously loaded reference genome or one of Hail's built-in; references: ``'GRCh37'``, ``'GRCh38'``, ``'GRCm38'``, ``'CanFam3'``, and; ``'default'``. Returns; -------; :class:`.ReferenceGenome`; """"""; Env.hc(); if name == 'default':; return default_reference(); else:; return Env.backend().get_reference(name). [docs]@typecheck(seed=int); def set_global_seed(seed):; """"""Deprecated. Has no effect. To ensure reproducible randomness, use the `global_seed`; argument to :func:`.init` and :func:`.reset_global_randomness`. See the :ref:`random functions <sec-random-functions>` reference docs for more. Parameters; ----------; seed : :obj:`int`; Integer used to seed Hail's random number generator; """""". warning(; 'hl.set_global_seed has no effect. See '; 'https://hail.is/docs/0.2/functions/random.html for details on '; 'ensuring reproducibility of randomness.'; ); pass. [docs]@typecheck(); def reset_global_randomness():; """"""Restore global randomness to initial state for test reproducibility."""""". Env.reset_global_randomness(). def _set_flags(**flags):; Env.backend().set_flags(**flags). def _get_flags(*flags):; return Env.backend().get_flags(*flags). @contextmanager; def _with_flags(**flags):; before = _get_flags(*flags); try:; _set_flags(**flags); yield; finally:; _set_flags(**before). def debug_info():; from hail.backend.backend import local_jar_information; from hail.backend.spark_backend import SparkBackend. spark_conf = None; if isinstance(Env.backend(), SparkBackend):; spark_conf = spark_context()._conf.getAll(); return {'spark_conf': spark_conf, 'local_jar_information': local_jar_information(), 'version': version()}. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:50,Usability,Feedback,Feedback,50,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/context.html:260,Usability,Guid,Guides,260,"﻿. Hail | ; hail.context. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.context. Source code for hail.context; import os; import sys; import warnings; from contextlib import contextmanager; from random import Random; from types import TracebackType; from typing import Dict, List, Optional, Tuple, Type, Union; from urllib.parse import urlparse, urlunparse. from pyspark import SparkContext. import hail; from hail.backend import Backend; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typecheck import dictof, enumeration, nullable, oneof, sequenceof, sized_tupleof, typecheck, typecheck_method; from hail.utils import get_env_or_default; from hail.utils.java import BackendType, Env, choose_backend, warning; from hailtop.aiocloud.aiogoogle import GCSRequesterPaysConfiguration, get_gcs_requester_pays_configuration; from hailtop.fs.fs import FS; from hailtop.hail_event_loop import hail_event_loop; from hailtop.utils import secret_alnum_string. from . import __resource_str; from .backend.backend import local_jar_information; from .builtin_references import BUILTIN_REFERENCES. def _get_tmpdir(tmpdir):; if tmpdir is None:; tmpdir = '/tmp'; return tmpdir. def _get_local_tmpdir(local_tmpdir):; local_tmpdir = get_env_or_default(local_tmpdir, 'TMPDIR', 'file:///tmp'); r = urlparse(local_tmpdir); if not r.scheme:; r = r._replace(scheme='file'); elif r.scheme != 'file':; raise ValueError('invalid local_tmpfile: must use scheme file, got scheme {r.scheme}'); return urlunparse(r). def _get_log(log):; if log is None:; py_version = version(); log_dir = os.environ.get('HAIL_LOG_DIR'); if log_dir i",MatchSource.WIKI,docs/0.2/_modules/hail/context.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/context.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:8479,Availability,down,downstream,8479,"on(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedMatrixTable.aggregate` is; the number of partitions in the upstream dataset. If the aggregation greatly; reduces the size of the dataset, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a new column field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.mean(dataset.pheno.height)); ... .result()). Notes; -----; The aggregation scope includes all column fields and global fields. See Also; --------; :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.GroupedMatrixTable`; """"""; if self._row_keys is not None:; raise Not",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:56793,Availability,down,downstream,56793,"ix. Parameters; ----------; expr : bool or :class:`.BooleanExpression`; Filter expression.; keep : bool; Keep entries where `expr` is true. Returns; -------; :class:`.MatrixTable`; Filtered matrix table. Examples; --------. Keep entries where the sum of `AD` is greater than 10 and `GQ` is greater than 20:. >>> dataset_result = dataset.filter_entries((hl.sum(dataset.AD) > 10) & (dataset.GQ > 20)). Warning; -------; When `expr` evaluates to missing, the entry will be removed regardless of; `keep`. Note; ----; This method does not support aggregation. Notes; -----; The expression `expr` will be evaluated for every entry of the table.; If `keep` is ``True``, then entries where `expr` evaluates to ``True``; will be kept (the filter removes the entries where the predicate; evaluates to ``False``). If `keep` is ``False``, then entries where; `expr` evaluates to ``True`` will be removed (the filter keeps the; entries where the predicate evaluates to ``False``). Filtered entries are removed entirely from downstream operations. This; means that the resulting matrix table has sparsity -- that is, that the; number of entries is **smaller** than the product of :meth:`count_rows`; and :meth:`count_cols`. To re-densify a filtered matrix table, use the; :meth:`unfilter_entries` method to restore filtered entries, populated; all fields with missing values. Below are some properties of an; entry-filtered matrix table. 1. Filtered entries are not included in the :meth:`entries` table. >>> mt_range = hl.utils.range_matrix_table(10, 10); >>> mt_range = mt_range.annotate_entries(x = mt_range.row_idx + mt_range.col_idx); >>> mt_range.count(); (10, 10). >>> mt_range.entries().count(); 100. >>> mt_filt = mt_range.filter_entries(mt_range.x % 2 == 0); >>> mt_filt.count(); (10, 10). >>> mt_filt.count_rows() * mt_filt.count_cols(); 100. >>> mt_filt.entries().count(); 50. 2. Filtered entries are not included in aggregation. >>> mt_filt.aggregate_entries(hl.agg.count()); 50. >>> mt_filt = mt_filt",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:58820,Availability,down,downstream,58820,"l_n.take(5); [5, 5, 5, 5, 5]. >>> mt_filt = mt_filt.annotate_rows(row_n = hl.agg.count()); >>> mt_filt.row_n.take(5); [5, 5, 5, 5, 5]. 3. Annotating a new entry field will not annotate filtered entries. >>> mt_filt = mt_filt.annotate_entries(y = 1); >>> mt_filt.aggregate_entries(hl.agg.sum(mt_filt.y)); 50. 4. If all the entries in a row or column of a matrix table are; filtered, the row or column remains. >>> mt_filt.filter_entries(False).count(); (10, 10). See Also; --------; :meth:`unfilter_entries`, :meth:`compute_entry_filter_stats`; """"""; base, cleanup = self._process_joins(expr); analyze('MatrixTable.filter_entries', expr, self._entry_indices). m = MatrixTable(ir.MatrixFilterEntries(base._mir, ir.filter_predicate_with_keep(expr._ir, keep))); return cleanup(m). [docs] def unfilter_entries(self):; """"""Unfilters filtered entries, populating fields with missing values. Returns; -------; :class:`MatrixTable`. Notes; -----; This method is used in the case that a pipeline downstream of :meth:`filter_entries`; requires a fully dense (no filtered entries) matrix table. Generally, if this method is required in a pipeline, the upstream pipeline can; be rewritten to use annotation instead of entry filtering. See Also; --------; :meth:`filter_entries`, :meth:`compute_entry_filter_stats`; """"""; entry_ir = hl.if_else(; hl.is_defined(self.entry), self.entry, hl.struct(**{k: hl.missing(v.dtype) for k, v in self.entry.items()}); )._ir; return MatrixTable(ir.MatrixMapEntries(self._mir, entry_ir)). [docs] @typecheck_method(row_field=str, col_field=str); def compute_entry_filter_stats(self, row_field='entry_stats_row', col_field='entry_stats_col') -> 'MatrixTable':; """"""Compute statistics about the number and fraction of filtered entries. .. include:: _templates/experimental.rst. Parameters; ----------; row_field : :class:`str`; Name for computed row field (default: ``entry_stats_row``.; col_field : :class:`str`; Name for computed column field (default: ``entry_stats_col``. Returns; --",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:80170,Availability,checkpoint,checkpoint,80170,"calize=True) -> int:; """"""Count the number of columns in the matrix. Examples; --------. Count the number of columns:. >>> n_cols = dataset.count_cols(). Returns; -------; :obj:`int`; Number of columns in the matrix.; """"""; count_ir = ir.TableCount(ir.MatrixColsTable(self._mir)); if _localize:; return Env.backend().execute(count_ir); else:; return construct_expr(ir.LiftMeOut(count_ir), hl.tint64). [docs] def count(self) -> Tuple[int, int]:; """"""Count the number of rows and columns in the matrix. Examples; --------. >>> dataset.count(). Returns; -------; :obj:`int`, :obj:`int`; Number of rows, number of cols.; """"""; count_ir = ir.MatrixCount(self._mir); return Env.backend().execute(count_ir). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; _drop_cols=bool,; _drop_rows=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; _drop_cols=False,; _drop_rows=False,; ) -> 'MatrixTable':; """"""Checkpoint the matrix table to disk by writing and reading using a fast, but less space-efficient codec. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`MatrixTable`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_matrix_table`. It is; possible to read the file at this path later with; :func:`.read_matrix_table`. A faster, but less efficient, codec is used; or writing the data so the file will be larger than if one used; :meth:`write`. Examples; --------; >>> dataset = dataset.checkpoint(",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:80434,Availability,Checkpoint,Checkpoint,80434,"calize=True) -> int:; """"""Count the number of columns in the matrix. Examples; --------. Count the number of columns:. >>> n_cols = dataset.count_cols(). Returns; -------; :obj:`int`; Number of columns in the matrix.; """"""; count_ir = ir.TableCount(ir.MatrixColsTable(self._mir)); if _localize:; return Env.backend().execute(count_ir); else:; return construct_expr(ir.LiftMeOut(count_ir), hl.tint64). [docs] def count(self) -> Tuple[int, int]:; """"""Count the number of rows and columns in the matrix. Examples; --------. >>> dataset.count(). Returns; -------; :obj:`int`, :obj:`int`; Number of rows, number of cols.; """"""; count_ir = ir.MatrixCount(self._mir); return Env.backend().execute(count_ir). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; _drop_cols=bool,; _drop_rows=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; _drop_cols=False,; _drop_rows=False,; ) -> 'MatrixTable':; """"""Checkpoint the matrix table to disk by writing and reading using a fast, but less space-efficient codec. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`MatrixTable`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_matrix_table`. It is; possible to read the file at this path later with; :func:`.read_matrix_table`. A faster, but less efficient, codec is used; or writing the data so the file will be larger than if one used; :meth:`write`. Examples; --------; >>> dataset = dataset.checkpoint(",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:81223,Availability,checkpoint,checkpoint,81223,"y: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; _drop_cols=False,; _drop_rows=False,; ) -> 'MatrixTable':; """"""Checkpoint the matrix table to disk by writing and reading using a fast, but less space-efficient codec. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`MatrixTable`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_matrix_table`. It is; possible to read the file at this path later with; :func:`.read_matrix_table`. A faster, but less efficient, codec is used; or writing the data so the file will be larger than if one used; :meth:`write`. Examples; --------; >>> dataset = dataset.checkpoint('output/dataset_checkpoint.mt'); """"""; hl.current_backend().validate_file(output). if not _read_if_exists or not hl.hadoop_exists(f'{output}/_SUCCESS'):; self.write(output=output, overwrite=overwrite, stage_locally=stage_locally, _codec_spec=_codec_spec); _assert_type = self._type; _load_refs = False; else:; _assert_type = None; _load_refs = True; return hl.read_matrix_table(; output,; _intervals=_intervals,; _filter_intervals=_filter_intervals,; _drop_cols=_drop_cols,; _drop_rows=_drop_rows,; _assert_type=_assert_type,; _load_refs=_load_refs,; ). [docs] @typecheck_method(; output=str, overwrite=bool, stage_locally=bool, _codec_spec=nullable(str), _partitions=nullable(expr_any); ); def write(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _partitions=None,; ):; """"""Write to disk. Examples; --------. >>> dataset.write('output/dataset.mt'). .. include:: _templates/write_warning.rst. See Also; --------; :func:`.read_matrix_table`. P",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:106508,Availability,avail,available,106508,". [docs] @typecheck_method(indices=sequenceof(int)); def choose_cols(self, indices: List[int]) -> 'MatrixTable':; """"""Choose a new set of columns from a list of old column indices. Examples; --------. Randomly shuffle column order:. >>> import random; >>> indices = list(range(dataset.count_cols())); >>> random.shuffle(indices); >>> dataset_reordered = dataset.choose_cols(indices). Take the first ten columns:. >>> dataset_result = dataset.choose_cols(list(range(10))). Parameters; ----------; indices : :obj:`list` of :obj:`int`; List of old column indices. Returns; -------; :class:`.MatrixTable`; """"""; n_cols = self.count_cols(); for i in indices:; if not 0 <= i < n_cols:; raise ValueError(f""'choose_cols': expect indices between 0 and {n_cols}, found {i}""); return MatrixTable(ir.MatrixChooseCols(self._mir, indices)). [docs] def n_partitions(self) -> int:; """"""Number of partitions. Notes; -----. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. Partitions are a; core concept of distributed computation in Spark, see `here; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. Returns; -------; int; Number of partitions.; """"""; return Env.backend().execute(ir.MatrixToValueApply(self._mir, {'name': 'NPartitionsMatrixTable'})). [docs] @typecheck_method(n_partitions=int, shuffle=bool); def repartition(self, n_partitions: int, shuffle: bool = True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:106664,Availability,resilien,resilient-distributed-datasets-rdds,106664,"= list(range(dataset.count_cols())); >>> random.shuffle(indices); >>> dataset_reordered = dataset.choose_cols(indices). Take the first ten columns:. >>> dataset_result = dataset.choose_cols(list(range(10))). Parameters; ----------; indices : :obj:`list` of :obj:`int`; List of old column indices. Returns; -------; :class:`.MatrixTable`; """"""; n_cols = self.count_cols(); for i in indices:; if not 0 <= i < n_cols:; raise ValueError(f""'choose_cols': expect indices between 0 and {n_cols}, found {i}""); return MatrixTable(ir.MatrixChooseCols(self._mir, indices)). [docs] def n_partitions(self) -> int:; """"""Number of partitions. Notes; -----. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. Partitions are a; core concept of distributed computation in Spark, see `here; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. Returns; -------; int; Number of partitions.; """"""; return Env.backend().execute(ir.MatrixToValueApply(self._mir, {'name': 'NPartitionsMatrixTable'})). [docs] @typecheck_method(n_partitions=int, shuffle=bool); def repartition(self, n_partitions: int, shuffle: bool = True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:107405,Availability,avail,available,107405,"----. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. Partitions are a; core concept of distributed computation in Spark, see `here; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. Returns; -------; int; Number of partitions.; """"""; return Env.backend().execute(ir.MatrixToValueApply(self._mir, {'name': 'NPartitionsMatrixTable'})). [docs] @typecheck_method(n_partitions=int, shuffle=bool); def repartition(self, n_partitions: int, shuffle: bool = True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:108005,Availability,resilien,resilient-distributed-datasets-rdds,108005," of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write t",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:108811,Availability,checkpoint,checkpoint,108811,"e advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:108901,Availability,checkpoint,checkpoint,108901,"ark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; m",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:108999,Availability,checkpoint,checkpoint,108999,"distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:109052,Availability,checkpoint,checkpoint,109052,"`shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns;",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111092,Availability,redundant,redundant,111092,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:113376,Availability,toler,tolerance,113376,"xed; the values are found in the range; ``[0, N)``, where ``N`` is the total number of rows. Parameters; ----------; name : :class:`str`; Name for row index field. Returns; -------; :class:`.MatrixTable`; Dataset with new field.; """"""; return self.annotate_rows(**{name: hl.scan.count()}). [docs] @typecheck_method(name=str); def add_col_index(self, name: str = 'col_idx') -> 'MatrixTable':; """"""Add the integer index of each column as a new column field. Examples; --------. >>> dataset_result = dataset.add_col_index(). Notes; -----; The field added is type :py:data:`.tint32`. The column index is 0-indexed; the values are found in the range; ``[0, N)``, where ``N`` is the total number of columns. Parameters; ----------; name: :class:`str`; Name for column index field. Returns; -------; :class:`.MatrixTable`; Dataset with new field.; """"""; return self.annotate_cols(**{name: hl.scan.count()}). @typecheck_method(other=matrix_table_type, tolerance=numeric, absolute=bool, reorder_fields=bool); def _same(self, other, tolerance=1e-6, absolute=False, reorder_fields=False) -> bool:; entries_name = Env.get_uid('entries_'); cols_name = Env.get_uid('columns_'). fd_f = set if reorder_fields else list. if fd_f(self.row) != fd_f(other.row):; print(f'Different row fields: \n {list(self.row)}\n {list(other.row)}'); return False; if fd_f(self.globals) != fd_f(other.globals):; print(f'Different globals fields: \n {list(self.globals)}\n {list(other.globals)}'); return False; if fd_f(self.col) != fd_f(other.col):; print(f'Different col fields: \n {list(self.col)}\n {list(other.col)}'); return False; if fd_f(self.entry) != fd_f(other.entry):; print(f'Different row fields: \n {list(self.entry)}\n {list(other.entry)}'); return False. if reorder_fields:; entry_order = list(self.entry); if list(other.entry) != entry_order:; other = other.select_entries(*entry_order). globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). col_order",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:113455,Availability,toler,tolerance,113455,"xed; the values are found in the range; ``[0, N)``, where ``N`` is the total number of rows. Parameters; ----------; name : :class:`str`; Name for row index field. Returns; -------; :class:`.MatrixTable`; Dataset with new field.; """"""; return self.annotate_rows(**{name: hl.scan.count()}). [docs] @typecheck_method(name=str); def add_col_index(self, name: str = 'col_idx') -> 'MatrixTable':; """"""Add the integer index of each column as a new column field. Examples; --------. >>> dataset_result = dataset.add_col_index(). Notes; -----; The field added is type :py:data:`.tint32`. The column index is 0-indexed; the values are found in the range; ``[0, N)``, where ``N`` is the total number of columns. Parameters; ----------; name: :class:`str`; Name for column index field. Returns; -------; :class:`.MatrixTable`; Dataset with new field.; """"""; return self.annotate_cols(**{name: hl.scan.count()}). @typecheck_method(other=matrix_table_type, tolerance=numeric, absolute=bool, reorder_fields=bool); def _same(self, other, tolerance=1e-6, absolute=False, reorder_fields=False) -> bool:; entries_name = Env.get_uid('entries_'); cols_name = Env.get_uid('columns_'). fd_f = set if reorder_fields else list. if fd_f(self.row) != fd_f(other.row):; print(f'Different row fields: \n {list(self.row)}\n {list(other.row)}'); return False; if fd_f(self.globals) != fd_f(other.globals):; print(f'Different globals fields: \n {list(self.globals)}\n {list(other.globals)}'); return False; if fd_f(self.col) != fd_f(other.col):; print(f'Different col fields: \n {list(self.col)}\n {list(other.col)}'); return False; if fd_f(self.entry) != fd_f(other.entry):; print(f'Different row fields: \n {list(self.entry)}\n {list(other.entry)}'); return False. if reorder_fields:; entry_order = list(self.entry); if list(other.entry) != entry_order:; other = other.select_entries(*entry_order). globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). col_order",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:114880,Availability,toler,tolerance,114880,"{list(other.globals)}'); return False; if fd_f(self.col) != fd_f(other.col):; print(f'Different col fields: \n {list(self.col)}\n {list(other.col)}'); return False; if fd_f(self.entry) != fd_f(other.entry):; print(f'Different row fields: \n {list(self.entry)}\n {list(other.entry)}'); return False. if reorder_fields:; entry_order = list(self.entry); if list(other.entry) != entry_order:; other = other.select_entries(*entry_order). globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). col_order = list(self.col); if list(other.col) != col_order:; other = other.select_cols(*col_order). row_order = list(self.row); if list(other.row) != row_order:; other = other.select_rows(*row_order). if list(self.col_key) != list(other.col_key):; print(f'different col keys:\n {list(self.col_key)}\n {list(other.col_key)}'); return False. return self._localize_entries(entries_name, cols_name)._same(; other._localize_entries(entries_name, cols_name), tolerance, absolute; ). @typecheck_method(caller=str, s=expr_struct()); def _select_entries(self, caller, s) -> 'MatrixTable':; base, cleanup = self._process_joins(s); analyze(caller, s, self._entry_indices); return cleanup(MatrixTable(ir.MatrixMapEntries(base._mir, s._ir))). @typecheck_method(caller=str, row=expr_struct()); def _select_rows(self, caller, row) -> 'MatrixTable':; analyze(caller, row, self._row_indices, {self._col_axis}); base, cleanup = self._process_joins(row); return cleanup(MatrixTable(ir.MatrixMapRows(base._mir, row._ir))). @typecheck_method(caller=str, col=expr_struct(), new_key=nullable(sequenceof(str))); def _select_cols(self, caller, col, new_key=None) -> 'MatrixTable':; analyze(caller, col, self._col_indices, {self._row_axis}); base, cleanup = self._process_joins(col); return cleanup(MatrixTable(ir.MatrixMapCols(base._mir, col._ir, new_key))). @typecheck_method(caller=str, s=expr_struct()); def _select_globals(self, caller, s) -> 'MatrixTable':; base,",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:127899,Availability,Down,Downsample,127899,"=Table); def from_rows_table(cls, table: Table) -> 'MatrixTable':; """"""Construct matrix table with no columns from a table. .. include:: _templates/experimental.rst. Examples; --------; Import a text table and construct a rows-only matrix table:. >>> table = hl.import_table('data/variant-lof.tsv'); >>> table = table.transmute(**hl.parse_variant(table['v'])).key_by('locus', 'alleles'); >>> sites_mt = hl.MatrixTable.from_rows_table(table). Notes; -----; All fields in the table become row-indexed fields in the; result. Parameters; ----------; table : :class:`.Table`; The table to be converted. Returns; -------; :class:`.MatrixTable`; """"""; col_values_uid = Env.get_uid(); entries_uid = Env.get_uid(); return (; table.annotate_globals(**{col_values_uid: hl.empty_array(hl.tstruct())}); .annotate(**{entries_uid: hl.empty_array(hl.tstruct())}); ._unlocalize_entries(entries_uid, col_values_uid, []); ). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_rows(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each row with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its rows. >>> small_dataset = dataset.sample_rows(0.01). Notes; -----; Although the :class:`MatrixTable` returned by this method may be; small, it requires a full pass over the rows of the sampled object. Parameters; ----------; p : :obj:`float`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_rows(hl.rand_bool(p, seed)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_cols(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each column with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its columns. >>> small_dat",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:127991,Availability,Down,Downsample,127991," _templates/experimental.rst. Examples; --------; Import a text table and construct a rows-only matrix table:. >>> table = hl.import_table('data/variant-lof.tsv'); >>> table = table.transmute(**hl.parse_variant(table['v'])).key_by('locus', 'alleles'); >>> sites_mt = hl.MatrixTable.from_rows_table(table). Notes; -----; All fields in the table become row-indexed fields in the; result. Parameters; ----------; table : :class:`.Table`; The table to be converted. Returns; -------; :class:`.MatrixTable`; """"""; col_values_uid = Env.get_uid(); entries_uid = Env.get_uid(); return (; table.annotate_globals(**{col_values_uid: hl.empty_array(hl.tstruct())}); .annotate(**{entries_uid: hl.empty_array(hl.tstruct())}); ._unlocalize_entries(entries_uid, col_values_uid, []); ). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_rows(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each row with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its rows. >>> small_dataset = dataset.sample_rows(0.01). Notes; -----; Although the :class:`MatrixTable` returned by this method may be; small, it requires a full pass over the rows of the sampled object. Parameters; ----------; p : :obj:`float`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_rows(hl.rand_bool(p, seed)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_cols(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each column with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its columns. >>> small_dataset = dataset.sample_cols(0.01). Parameters; ----------; p : :obj:`float`; Probability of keeping each column.; seed : :obj:`int`; Ran",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:128706,Availability,Down,Downsample,128706,"_uid: hl.empty_array(hl.tstruct())}); ._unlocalize_entries(entries_uid, col_values_uid, []); ). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_rows(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each row with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its rows. >>> small_dataset = dataset.sample_rows(0.01). Notes; -----; Although the :class:`MatrixTable` returned by this method may be; small, it requires a full pass over the rows of the sampled object. Parameters; ----------; p : :obj:`float`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_rows(hl.rand_bool(p, seed)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_cols(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each column with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its columns. >>> small_dataset = dataset.sample_cols(0.01). Parameters; ----------; p : :obj:`float`; Probability of keeping each column.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_cols`` column.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_cols(hl.rand_bool(p, seed)). [docs] @typecheck_method(fields=dictof(str, str)); def rename(self, fields: Dict[str, str]) -> 'MatrixTable':; """"""Rename fields of a matrix table. Examples; --------. Rename column key `s` to `SampleID`, still keying by `SampleID`. >>> dataset_result = dataset.rename({'s': 'SampleID'}). You can rename a field to a field name that already exists, as long as; that field also gets renamed (no name collisions). Here, we rename t",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:128801,Availability,Down,Downsample,128801,"ullable(int)); def sample_rows(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each row with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its rows. >>> small_dataset = dataset.sample_rows(0.01). Notes; -----; Although the :class:`MatrixTable` returned by this method may be; small, it requires a full pass over the rows of the sampled object. Parameters; ----------; p : :obj:`float`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_rows(hl.rand_bool(p, seed)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample_cols(self, p: float, seed=None) -> 'MatrixTable':; """"""Downsample the matrix table by keeping each column with probability ``p``. Examples; --------; Downsample the dataset to approximately 1% of its columns. >>> small_dataset = dataset.sample_cols(0.01). Parameters; ----------; p : :obj:`float`; Probability of keeping each column.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.MatrixTable`; Matrix table with approximately ``p * n_cols`` column.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter_cols(hl.rand_bool(p, seed)). [docs] @typecheck_method(fields=dictof(str, str)); def rename(self, fields: Dict[str, str]) -> 'MatrixTable':; """"""Rename fields of a matrix table. Examples; --------. Rename column key `s` to `SampleID`, still keying by `SampleID`. >>> dataset_result = dataset.rename({'s': 'SampleID'}). You can rename a field to a field name that already exists, as long as; that field also gets renamed (no name collisions). Here, we rename the; column key `s` to `info`, and the row field `info` to `vcf_info`:. >>> dataset_result = dataset.rename({'s': 'info', 'info': 'vcf_info",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:154,Deployability,Install,Installation,154,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:222,Deployability,Configurat,Configuration,222,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:7871,Deployability,pipeline,pipeline,7871,"s); return self._copy(col_keys=col_key, computed_col_key=computed_key). def _check_bindings(self, caller, new_bindings, indices):; empty = []. def iter_option(o):; return o if o is not None else empty. if indices == self._parent._row_indices:; fixed_fields = [*self._parent.globals, *self._parent.col]; else:; assert indices == self._parent._col_indices; fixed_fields = [*self._parent.globals, *self._parent.row]. bound_fields = set(; itertools.chain(; iter_option(self._row_keys),; iter_option(self._col_keys),; iter_option(self._col_fields),; iter_option(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedMatrixTable.aggregate` is; the number of partitions in the upstream dataset. If the aggregation greatly; reduces the size of the dataset, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:8142,Deployability,pipeline,pipeline,8142," [*self._parent.globals, *self._parent.col]; else:; assert indices == self._parent._col_indices; fixed_fields = [*self._parent.globals, *self._parent.row]. bound_fields = set(; itertools.chain(; iter_option(self._row_keys),; iter_option(self._col_keys),; iter_option(self._col_fields),; iter_option(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedMatrixTable.aggregate` is; the number of partitions in the upstream dataset. If the aggregation greatly; reduces the size of the dataset, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a new column field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.mean(dataset.pheno.height)); ... .result()). Notes; -----;",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:58811,Deployability,pipeline,pipeline,58811,"l_n.take(5); [5, 5, 5, 5, 5]. >>> mt_filt = mt_filt.annotate_rows(row_n = hl.agg.count()); >>> mt_filt.row_n.take(5); [5, 5, 5, 5, 5]. 3. Annotating a new entry field will not annotate filtered entries. >>> mt_filt = mt_filt.annotate_entries(y = 1); >>> mt_filt.aggregate_entries(hl.agg.sum(mt_filt.y)); 50. 4. If all the entries in a row or column of a matrix table are; filtered, the row or column remains. >>> mt_filt.filter_entries(False).count(); (10, 10). See Also; --------; :meth:`unfilter_entries`, :meth:`compute_entry_filter_stats`; """"""; base, cleanup = self._process_joins(expr); analyze('MatrixTable.filter_entries', expr, self._entry_indices). m = MatrixTable(ir.MatrixFilterEntries(base._mir, ir.filter_predicate_with_keep(expr._ir, keep))); return cleanup(m). [docs] def unfilter_entries(self):; """"""Unfilters filtered entries, populating fields with missing values. Returns; -------; :class:`MatrixTable`. Notes; -----; This method is used in the case that a pipeline downstream of :meth:`filter_entries`; requires a fully dense (no filtered entries) matrix table. Generally, if this method is required in a pipeline, the upstream pipeline can; be rewritten to use annotation instead of entry filtering. See Also; --------; :meth:`filter_entries`, :meth:`compute_entry_filter_stats`; """"""; entry_ir = hl.if_else(; hl.is_defined(self.entry), self.entry, hl.struct(**{k: hl.missing(v.dtype) for k, v in self.entry.items()}); )._ir; return MatrixTable(ir.MatrixMapEntries(self._mir, entry_ir)). [docs] @typecheck_method(row_field=str, col_field=str); def compute_entry_filter_stats(self, row_field='entry_stats_row', col_field='entry_stats_col') -> 'MatrixTable':; """"""Compute statistics about the number and fraction of filtered entries. .. include:: _templates/experimental.rst. Parameters; ----------; row_field : :class:`str`; Name for computed row field (default: ``entry_stats_row``.; col_field : :class:`str`; Name for computed column field (default: ``entry_stats_col``. Returns; --",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:58960,Deployability,pipeline,pipeline,58960,"a new entry field will not annotate filtered entries. >>> mt_filt = mt_filt.annotate_entries(y = 1); >>> mt_filt.aggregate_entries(hl.agg.sum(mt_filt.y)); 50. 4. If all the entries in a row or column of a matrix table are; filtered, the row or column remains. >>> mt_filt.filter_entries(False).count(); (10, 10). See Also; --------; :meth:`unfilter_entries`, :meth:`compute_entry_filter_stats`; """"""; base, cleanup = self._process_joins(expr); analyze('MatrixTable.filter_entries', expr, self._entry_indices). m = MatrixTable(ir.MatrixFilterEntries(base._mir, ir.filter_predicate_with_keep(expr._ir, keep))); return cleanup(m). [docs] def unfilter_entries(self):; """"""Unfilters filtered entries, populating fields with missing values. Returns; -------; :class:`MatrixTable`. Notes; -----; This method is used in the case that a pipeline downstream of :meth:`filter_entries`; requires a fully dense (no filtered entries) matrix table. Generally, if this method is required in a pipeline, the upstream pipeline can; be rewritten to use annotation instead of entry filtering. See Also; --------; :meth:`filter_entries`, :meth:`compute_entry_filter_stats`; """"""; entry_ir = hl.if_else(; hl.is_defined(self.entry), self.entry, hl.struct(**{k: hl.missing(v.dtype) for k, v in self.entry.items()}); )._ir; return MatrixTable(ir.MatrixMapEntries(self._mir, entry_ir)). [docs] @typecheck_method(row_field=str, col_field=str); def compute_entry_filter_stats(self, row_field='entry_stats_row', col_field='entry_stats_col') -> 'MatrixTable':; """"""Compute statistics about the number and fraction of filtered entries. .. include:: _templates/experimental.rst. Parameters; ----------; row_field : :class:`str`; Name for computed row field (default: ``entry_stats_row``.; col_field : :class:`str`; Name for computed column field (default: ``entry_stats_col``. Returns; -------; :class:`.MatrixTable`. Notes; -----; Adds a new row field, `row_field`, and a new column field, `col_field`,; each of which are structs with t",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:58983,Deployability,pipeline,pipeline,58983,"a new entry field will not annotate filtered entries. >>> mt_filt = mt_filt.annotate_entries(y = 1); >>> mt_filt.aggregate_entries(hl.agg.sum(mt_filt.y)); 50. 4. If all the entries in a row or column of a matrix table are; filtered, the row or column remains. >>> mt_filt.filter_entries(False).count(); (10, 10). See Also; --------; :meth:`unfilter_entries`, :meth:`compute_entry_filter_stats`; """"""; base, cleanup = self._process_joins(expr); analyze('MatrixTable.filter_entries', expr, self._entry_indices). m = MatrixTable(ir.MatrixFilterEntries(base._mir, ir.filter_predicate_with_keep(expr._ir, keep))); return cleanup(m). [docs] def unfilter_entries(self):; """"""Unfilters filtered entries, populating fields with missing values. Returns; -------; :class:`MatrixTable`. Notes; -----; This method is used in the case that a pipeline downstream of :meth:`filter_entries`; requires a fully dense (no filtered entries) matrix table. Generally, if this method is required in a pipeline, the upstream pipeline can; be rewritten to use annotation instead of entry filtering. See Also; --------; :meth:`filter_entries`, :meth:`compute_entry_filter_stats`; """"""; entry_ir = hl.if_else(; hl.is_defined(self.entry), self.entry, hl.struct(**{k: hl.missing(v.dtype) for k, v in self.entry.items()}); )._ir; return MatrixTable(ir.MatrixMapEntries(self._mir, entry_ir)). [docs] @typecheck_method(row_field=str, col_field=str); def compute_entry_filter_stats(self, row_field='entry_stats_row', col_field='entry_stats_col') -> 'MatrixTable':; """"""Compute statistics about the number and fraction of filtered entries. .. include:: _templates/experimental.rst. Parameters; ----------; row_field : :class:`str`; Name for computed row field (default: ``entry_stats_row``.; col_field : :class:`str`; Name for computed column field (default: ``entry_stats_col``. Returns; -------; :class:`.MatrixTable`. Notes; -----; Adds a new row field, `row_field`, and a new column field, `col_field`,; each of which are structs with t",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:89787,Deployability,pipeline,pipeline,89787,"h more flexibly,; albeit with potentially poorer computational performance. Warning; -------; The table returned by this method should be used for aggregation or queries,; but never exported or written to disk without extensive filtering and field; selection -- the disk footprint of an entries_table could be 100x (or more!); larger than its parent matrix. This means that if you try to export the entries; table of a 10 terabyte matrix, you could write a petabyte of data!. Warning; -------; Matrix table columns are typically sorted by the order at import, and; not necessarily by column key. Since tables are always sorted by key,; the table which results from this command will have its rows sorted by; the compound (row key, column key) which becomes the table key.; To preserve the original row-major entry order as the table row order,; first unkey the columns using :meth:`key_cols_by` with no arguments. Warning; -------; If the matrix table has no row key, but has a column key, this operation; may require a full shuffle to sort by the column key, depending on the; pipeline. Returns; -------; :class:`.Table`; Table with all non-global fields from the matrix, with **one row per entry of the matrix**.; """"""; if Env.hc()._warn_entries_order and len(self.col_key) > 0:; warning(; ""entries(): Resulting entries table is sorted by '(row_key, col_key)'.""; ""\n To preserve row-major matrix table order, ""; ""first unkey columns with 'key_cols_by()'""; ); Env.hc()._warn_entries_order = False. return Table(ir.MatrixEntriesTable(self._mir)). [docs] def index_globals(self) -> Expression:; """"""Return this matrix table's global variables for use in another; expression context. Examples; --------; >>> dataset1 = dataset.annotate_globals(pli={'SCN1A': 0.999, 'SONIC': 0.014}); >>> pli_dict = dataset1.index_globals().pli; >>> dataset_result = dataset2.annotate_rows(gene_pli = dataset2.gene.map(lambda x: pli_dict.get(x))). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(i",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111151,Deployability,pipeline,pipelines,111151,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:135577,Deployability,update,updated,135577,"t())))""; ). duplicates = [k for k, count in counts.items() if count > 1]; if duplicates:; raise ValueError(f""column keys must be unique, found duplicates: {', '.join(duplicates)}""). entries_uid = Env.get_uid(); cols_uid = Env.get_uid(). t = self; t = t._localize_entries(entries_uid, cols_uid). def fmt(f, col_key):; if f:; return col_key + separator + f; else:; return col_key. t = t.annotate(**{; fmt(f, col_keys[i]): t[entries_uid][i][j] for i in range(len(col_keys)) for j, f in enumerate(self.entry); }); t = t.drop(cols_uid, entries_uid). return t. [docs] @typecheck_method(rows=bool, cols=bool, entries=bool, handler=nullable(anyfunc)); def summarize(self, *, rows=True, cols=True, entries=True, handler=None):; """"""Compute and print summary information about the fields in the matrix table. .. include:: _templates/experimental.rst. Parameters; ----------; rows : :obj:`bool`; Compute summary for the row fields.; cols : :obj:`bool`; Compute summary for the column fields.; entries : :obj:`bool`; Compute summary for the entry fields.; """""". if handler is None:; handler = default_handler(); if cols:; handler(self.col._summarize(header='Columns', top=True)); if rows:; handler(self.row._summarize(header='Rows', top=True)); if entries:; handler(self.entry._summarize(header='Entries', top=True)). def _write_block_matrix(self, path, overwrite, entry_field, block_size):; mt = self; mt = mt._select_all(entry_exprs={entry_field: mt[entry_field]}). writer = ir.MatrixBlockMatrixWriter(path, overwrite, entry_field, block_size); Env.backend().execute(ir.MatrixWrite(self._mir, writer)). def _calculate_new_partitions(self, n_partitions):; """"""returns a set of range bounds that can be passed to write""""""; ht = self.rows(); ht = ht.select().select_globals(); return Env.backend().execute(; ir.TableToValueApply(ht._tir, {'name': 'TableCalculateNewPartitions', 'nPartitions': n_partitions}); ). matrix_table_type.set(MatrixTable). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:8377,Energy Efficiency,reduce,reduces,8377,"on(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedMatrixTable.aggregate` is; the number of partitions in the upstream dataset. If the aggregation greatly; reduces the size of the dataset, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a new column field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.mean(dataset.pheno.height)); ... .result()). Notes; -----; The aggregation scope includes all column fields and global fields. See Also; --------; :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.GroupedMatrixTable`; """"""; if self._row_keys is not None:; raise Not",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:80522,Energy Efficiency,efficient,efficient,80522,"calize=True) -> int:; """"""Count the number of columns in the matrix. Examples; --------. Count the number of columns:. >>> n_cols = dataset.count_cols(). Returns; -------; :obj:`int`; Number of columns in the matrix.; """"""; count_ir = ir.TableCount(ir.MatrixColsTable(self._mir)); if _localize:; return Env.backend().execute(count_ir); else:; return construct_expr(ir.LiftMeOut(count_ir), hl.tint64). [docs] def count(self) -> Tuple[int, int]:; """"""Count the number of rows and columns in the matrix. Examples; --------. >>> dataset.count(). Returns; -------; :obj:`int`, :obj:`int`; Number of rows, number of cols.; """"""; count_ir = ir.MatrixCount(self._mir); return Env.backend().execute(count_ir). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; _drop_cols=bool,; _drop_rows=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; _drop_cols=False,; _drop_rows=False,; ) -> 'MatrixTable':; """"""Checkpoint the matrix table to disk by writing and reading using a fast, but less space-efficient codec. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`MatrixTable`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_matrix_table`. It is; possible to read the file at this path later with; :func:`.read_matrix_table`. A faster, but less efficient, codec is used; or writing the data so the file will be larger than if one used; :meth:`write`. Examples; --------; >>> dataset = dataset.checkpoint(",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:81075,Energy Efficiency,efficient,efficient,81075,"ls=bool,; _drop_cols=bool,; _drop_rows=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; _drop_cols=False,; _drop_rows=False,; ) -> 'MatrixTable':; """"""Checkpoint the matrix table to disk by writing and reading using a fast, but less space-efficient codec. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`MatrixTable`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_matrix_table`. It is; possible to read the file at this path later with; :func:`.read_matrix_table`. A faster, but less efficient, codec is used; or writing the data so the file will be larger than if one used; :meth:`write`. Examples; --------; >>> dataset = dataset.checkpoint('output/dataset_checkpoint.mt'); """"""; hl.current_backend().validate_file(output). if not _read_if_exists or not hl.hadoop_exists(f'{output}/_SUCCESS'):; self.write(output=output, overwrite=overwrite, stage_locally=stage_locally, _codec_spec=_codec_spec); _assert_type = self._type; _load_refs = False; else:; _assert_type = None; _load_refs = True; return hl.read_matrix_table(; output,; _intervals=_intervals,; _filter_intervals=_filter_intervals,; _drop_cols=_drop_cols,; _drop_rows=_drop_rows,; _assert_type=_assert_type,; _load_refs=_load_refs,; ). [docs] @typecheck_method(; output=str, overwrite=bool, stage_locally=bool, _codec_spec=nullable(str), _partitions=nullable(expr_any); ); def write(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _partitions=None,; ):; """"""Write to disk. Examples; --------. >>> data",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:66080,Integrability,depend,dependent,66080,"ields_referenced)). [docs] @typecheck_method(expr=expr_any, _localize=bool); def aggregate_rows(self, expr, _localize=True) -> Any:; """"""Aggregate over rows to a local value. Examples; --------; Aggregate over rows:. >>> dataset.aggregate_rows(hl.struct(n_high_quality=hl.agg.count_where(dataset.qual > 40),; ... mean_qual=hl.agg.mean(dataset.qual))); Struct(n_high_quality=9, mean_qual=140054.73333333334). Notes; -----; Unlike most :class:`.MatrixTable` methods, this method does not support; meaningful references to fields that are not global or indexed by row. This method should be thought of as a more convenient alternative to; the following:. >>> rows_table = dataset.rows(); >>> rows_table.aggregate(hl.struct(n_high_quality=hl.agg.count_where(rows_table.qual > 40),; ... mean_qual=hl.agg.mean(rows_table.qual))). Note; ----; This method supports (and expects!) aggregation over rows. Parameters; ----------; expr : :class:`.Expression`; Aggregation expression. Returns; -------; any; Aggregated value dependent on `expr`.; """"""; base, _ = self._process_joins(expr); analyze('MatrixTable.aggregate_rows', expr, self._global_indices, {self._row_axis}); rows_table = ir.MatrixRowsTable(base._mir); subst_query = ir.subst(expr._ir, {}, {'va': ir.Ref('row', rows_table.typ.row_type)}). agg_ir = ir.TableAggregate(rows_table, subst_query); if _localize:; return Env.backend().execute(ir.MakeTuple([agg_ir]))[0]; else:; return construct_expr(ir.LiftMeOut(agg_ir), expr.dtype). [docs] @typecheck_method(expr=expr_any, _localize=bool); def aggregate_cols(self, expr, _localize=True) -> Any:; """"""Aggregate over columns to a local value. Examples; --------; Aggregate over columns:. >>> dataset.aggregate_cols(; ... hl.struct(fraction_female=hl.agg.fraction(dataset.pheno.is_female),; ... case_ratio=hl.agg.count_where(dataset.is_case) / hl.agg.count())); Struct(fraction_female=0.44, case_ratio=1.0). Notes; -----; Unlike most :class:`.MatrixTable` methods, this method does not support; meaningful ref",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:67617,Integrability,depend,dependent,67617,"ef aggregate_cols(self, expr, _localize=True) -> Any:; """"""Aggregate over columns to a local value. Examples; --------; Aggregate over columns:. >>> dataset.aggregate_cols(; ... hl.struct(fraction_female=hl.agg.fraction(dataset.pheno.is_female),; ... case_ratio=hl.agg.count_where(dataset.is_case) / hl.agg.count())); Struct(fraction_female=0.44, case_ratio=1.0). Notes; -----; Unlike most :class:`.MatrixTable` methods, this method does not support; meaningful references to fields that are not global or indexed by column. This method should be thought of as a more convenient alternative to; the following:. >>> cols_table = dataset.cols(); >>> cols_table.aggregate(; ... hl.struct(fraction_female=hl.agg.fraction(cols_table.pheno.is_female),; ... case_ratio=hl.agg.count_where(cols_table.is_case) / hl.agg.count())). Note; ----; This method supports (and expects!) aggregation over columns. Parameters; ----------; expr : :class:`.Expression`; Aggregation expression. Returns; -------; any; Aggregated value dependent on `expr`.; """"""; base, _ = self._process_joins(expr); analyze('MatrixTable.aggregate_cols', expr, self._global_indices, {self._col_axis}). cols_field = Env.get_uid(); globals = base.localize_entries(columns_array_field_name=cols_field).index_globals(); if len(self._col_key) == 0:; cols = globals[cols_field]; else:; if Env.hc()._warn_cols_order:; warning(; ""aggregate_cols(): Aggregates over cols ordered by 'col_key'.""; ""\n To preserve matrix table column order, ""; ""first unkey columns with 'key_cols_by()'""; ); Env.hc()._warn_cols_order = False; cols = hl.sorted(globals[cols_field], key=lambda x: x.select(*self._col_key.keys())). agg_ir = ir.Let('global', globals.drop(cols_field)._ir, ir.StreamAgg(ir.ToStream(cols._ir), 'sa', expr._ir)). if _localize:; return Env.backend().execute(ir.MakeTuple([agg_ir]))[0]; else:; return construct_expr(agg_ir, expr.dtype). [docs] @typecheck_method(expr=expr_any, _localize=bool); def aggregate_entries(self, expr, _localize=True):; """"""",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:69388,Integrability,depend,dependent,69388,"localize:; return Env.backend().execute(ir.MakeTuple([agg_ir]))[0]; else:; return construct_expr(agg_ir, expr.dtype). [docs] @typecheck_method(expr=expr_any, _localize=bool); def aggregate_entries(self, expr, _localize=True):; """"""Aggregate over entries to a local value. Examples; --------; Aggregate over entries:. >>> dataset.aggregate_entries(hl.struct(global_gq_mean=hl.agg.mean(dataset.GQ),; ... call_rate=hl.agg.fraction(hl.is_defined(dataset.GT)))); Struct(global_gq_mean=69.60514541387025, call_rate=0.9933333333333333). Notes; -----; This method should be thought of as a more convenient alternative to; the following:. >>> entries_table = dataset.entries(); >>> entries_table.aggregate(hl.struct(global_gq_mean=hl.agg.mean(entries_table.GQ),; ... call_rate=hl.agg.fraction(hl.is_defined(entries_table.GT)))). Note; ----; This method supports (and expects!) aggregation over entries. Parameters; ----------; expr : :class:`.Expression`; Aggregation expressions. Returns; -------; any; Aggregated value dependent on `expr`.; """""". base, _ = self._process_joins(expr); analyze('MatrixTable.aggregate_entries', expr, self._global_indices, {self._row_axis, self._col_axis}); agg_ir = ir.MatrixAggregate(base._mir, expr._ir); if _localize:; return Env.backend().execute(ir.MakeTuple([agg_ir]))[0]; else:; return construct_expr(ir.LiftMeOut(agg_ir), expr.dtype). [docs] @typecheck_method(field_expr=oneof(str, Expression)); def explode_rows(self, field_expr) -> 'MatrixTable':; """"""Explodes a row field of type array or set, copying the entire row for each element. Examples; --------; Explode rows by annotated genes:. >>> dataset_result = dataset.explode_rows(dataset.gene). Notes; -----; The new matrix table will have `N` copies of each row, where `N` is the number; of elements that row contains for the field denoted by `field_expr`. The field; referenced in `field_expr` is replaced in the sequence of duplicated rows by the; sequence of elements in the array or set. All other fields remain t",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:89769,Integrability,depend,depending,89769,"h more flexibly,; albeit with potentially poorer computational performance. Warning; -------; The table returned by this method should be used for aggregation or queries,; but never exported or written to disk without extensive filtering and field; selection -- the disk footprint of an entries_table could be 100x (or more!); larger than its parent matrix. This means that if you try to export the entries; table of a 10 terabyte matrix, you could write a petabyte of data!. Warning; -------; Matrix table columns are typically sorted by the order at import, and; not necessarily by column key. Since tables are always sorted by key,; the table which results from this command will have its rows sorted by; the compound (row key, column key) which becomes the table key.; To preserve the original row-major entry order as the table row order,; first unkey the columns using :meth:`key_cols_by` with no arguments. Warning; -------; If the matrix table has no row key, but has a column key, this operation; may require a full shuffle to sort by the column key, depending on the; pipeline. Returns; -------; :class:`.Table`; Table with all non-global fields from the matrix, with **one row per entry of the matrix**.; """"""; if Env.hc()._warn_entries_order and len(self.col_key) > 0:; warning(; ""entries(): Resulting entries table is sorted by '(row_key, col_key)'.""; ""\n To preserve row-major matrix table order, ""; ""first unkey columns with 'key_cols_by()'""; ); Env.hc()._warn_entries_order = False. return Table(ir.MatrixEntriesTable(self._mir)). [docs] def index_globals(self) -> Expression:; """"""Return this matrix table's global variables for use in another; expression context. Examples; --------; >>> dataset1 = dataset.annotate_globals(pli={'SCN1A': 0.999, 'SONIC': 0.014}); >>> pli_dict = dataset1.index_globals().pli; >>> dataset_result = dataset2.annotate_rows(gene_pli = dataset2.gene.map(lambda x: pli_dict.get(x))). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(i",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:222,Modifiability,Config,Configuration,222,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:13640,Modifiability,extend,extend,13640,".gene); ... .aggregate_rows(consequences = hl.agg.collect_as_set(dataset.consequence)); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a column field and computing the number of non-reference calls; as an entry field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.stats(dataset.pheno.height).mean); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). See Also; --------; :meth:`.aggregate`. Returns; -------; :class:`.MatrixTable`; Aggregated matrix table.; """"""; assert self._row_keys is not None or self._col_keys is not None. defined_exprs = []; for e in [self._row_fields, self._col_fields, self._entry_fields]:; if e is not None:; defined_exprs.append(e); for e in [self._computed_row_key, self._computed_col_key]:; if e is not None:; defined_exprs.extend(e.values()). def promote_none(e):; return hl.struct() if e is None else e. entry_exprs = promote_none(self._entry_fields); if len(entry_exprs) == 0:; warning(""'GroupedMatrixTable.result': No entry fields were defined.""). base, cleanup = self._parent._process_joins(*defined_exprs). if self._col_keys is not None:; cck = self._computed_col_key or {}; computed_key_uids = {k: Env.get_uid() for k in cck}; modified_keys = [computed_key_uids.get(k, k) for k in self._col_keys]; mt = MatrixTable(; ir.MatrixAggregateColsByKey(; ir.MatrixMapCols(; base._mir,; self._parent.col.annotate(**{computed_key_uids[k]: v for k, v in cck.items()})._ir,; modified_keys,; ),; entry_exprs._ir,; promote_none(self._col_fields)._ir,; ); ); if cck:; mt = mt.rename({v: k for k, v in computed_key_uids.items()}); else:; cck = self._computed_row_key or {}; computed_key_uids = {k: Env.get_uid() for k in cck}; modified_keys = [computed_key_uids.get(k, k) for k in self._row_keys]; mt = MatrixTable(; ir.MatrixAggregateRow",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:37681,Modifiability,variab,variable-length,37681,"o compute them. Returns; -------; :class:`.MatrixTable`; Matrix table with new row-and-column-indexed field(s).; """"""; caller = ""MatrixTable.annotate_entries""; check_annotate_exprs(caller, named_exprs, self._entry_indices, set()); return self._select_entries(caller, s=self.entry.annotate(**named_exprs)). [docs] def select_globals(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing global fields or create new fields by name, dropping the rest. Examples; --------; Select one existing field and compute a new one:. >>> dataset_result = dataset.select_globals(dataset.global_field_1,; ... another_global=['AFR', 'EUR', 'EAS', 'AMR', 'SAS']). Notes; -----; This method creates new global fields. If a created field shares its name; with a differently-indexed field of the table, the method will fail. Note; ----. See :meth:`.Table.select` for more information about using ``select`` methods. Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.MatrixTable`; MatrixTable with specified global fields.; """""". caller = 'MatrixTable.select_globals'; new_global = get_select_exprs(caller, exprs, named_exprs, self._global_indices, self._globals); return self._select_globals(caller, new_global). [docs] def select_rows(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing row fields or create new fields by name, dropping all; other non-key fields. Examples; --------; Select existing fields and compute a new one:. >>> dataset_result = dataset.select_rows(; ... dataset.variant_qc.gq_stats.mean,; ... high_quality_cases = hl.agg.count_where((dataset.GQ > 20) &; ... dataset.is_case)). Notes; -----; This method creates new row fields. If a created field shares its name; with a ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:39184,Modifiability,variab,variable-length,39184,"[docs] def select_rows(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing row fields or create new fields by name, dropping all; other non-key fields. Examples; --------; Select existing fields and compute a new one:. >>> dataset_result = dataset.select_rows(; ... dataset.variant_qc.gq_stats.mean,; ... high_quality_cases = hl.agg.count_where((dataset.GQ > 20) &; ... dataset.is_case)). Notes; -----; This method creates new row fields. If a created field shares its name; with a differently-indexed field of the table, or with a row key, the; method will fail. Row keys are preserved. To drop or change a row key field, use; :meth:`MatrixTable.key_rows_by`. Note; ----. See :meth:`.Table.select` for more information about using ``select`` methods. Note; ----; This method supports aggregation over columns. For instance, the usage:. >>> dataset_result = dataset.select_rows(mean_GQ = hl.agg.mean(dataset.GQ)). will compute the mean per row. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.MatrixTable`; MatrixTable with specified row fields.; """"""; caller = 'MatrixTable.select_rows'; new_row = get_select_exprs(caller, exprs, named_exprs, self._row_indices, self._rvrow); return self._select_rows(caller, new_row). [docs] def select_cols(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing column fields or create new fields by name, dropping the rest. Examples; --------; Select existing fields and compute a new one:. >>> dataset_result = dataset.select_cols(; ... dataset.sample_qc,; ... dataset.pheno.age,; ... isCohort1 = dataset.pheno.cohort_name == 'Cohort1'). Notes; -----; This method creates new column fields. If a created field shares its name; with a differently-indexed field of the table, the method wi",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:40517,Modifiability,variab,variable-length,40517,"able.select_rows'; new_row = get_select_exprs(caller, exprs, named_exprs, self._row_indices, self._rvrow); return self._select_rows(caller, new_row). [docs] def select_cols(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing column fields or create new fields by name, dropping the rest. Examples; --------; Select existing fields and compute a new one:. >>> dataset_result = dataset.select_cols(; ... dataset.sample_qc,; ... dataset.pheno.age,; ... isCohort1 = dataset.pheno.cohort_name == 'Cohort1'). Notes; -----; This method creates new column fields. If a created field shares its name; with a differently-indexed field of the table, the method will fail. Note; ----. See :meth:`.Table.select` for more information about using ``select`` methods. Note; ----; This method supports aggregation over rows. For instance, the usage:. >>> dataset_result = dataset.select_cols(mean_GQ = hl.agg.mean(dataset.GQ)). will compute the mean per column. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.MatrixTable`; MatrixTable with specified column fields.; """"""; caller = 'MatrixTable.select_cols'; new_col = get_select_exprs(caller, exprs, named_exprs, self._col_indices, self._col); return self._select_cols(caller, new_col). [docs] def select_entries(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing entry fields or create new fields by name, dropping the rest. Examples; --------; Drop all entry fields aside from `GT`:. >>> dataset_result = dataset.select_entries(dataset.GT). Notes; -----; This method creates new entry fields. If a created field shares its name; with a differently-indexed field of the table, the method will fail. Note; ----. See :meth:`.Table.select` for more information about using ``select`` metho",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:41615,Modifiability,variab,variable-length,41615," field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.MatrixTable`; MatrixTable with specified column fields.; """"""; caller = 'MatrixTable.select_cols'; new_col = get_select_exprs(caller, exprs, named_exprs, self._col_indices, self._col); return self._select_cols(caller, new_col). [docs] def select_entries(self, *exprs, **named_exprs) -> 'MatrixTable':; """"""Select existing entry fields or create new fields by name, dropping the rest. Examples; --------; Drop all entry fields aside from `GT`:. >>> dataset_result = dataset.select_entries(dataset.GT). Notes; -----; This method creates new entry fields. If a created field shares its name; with a differently-indexed field of the table, the method will fail. Note; ----. See :meth:`.Table.select` for more information about using ``select`` methods. Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.MatrixTable`; MatrixTable with specified entry fields.; """"""; caller = 'MatrixTable.select_entries'; new_entry = get_select_exprs(caller, exprs, named_exprs, self._entry_indices, self._entry); return self._select_entries(caller, new_entry). [docs] @typecheck_method(exprs=oneof(str, Expression)); def drop(self, *exprs) -> 'MatrixTable':; """"""Drop fields. Examples; --------. Drop fields `PL` (an entry field), `info` (a row field), and `pheno` (a column; field): using strings:. >>> dataset_result = dataset.drop('PL', 'info', 'pheno'). Drop fields `PL` (an entry field), `info` (a row field), and `pheno` (a column; field): using field references:. >>> dataset_result = dataset.drop(dataset.PL, dataset.info, dataset.pheno). Drop a list of fie",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:90339,Modifiability,variab,variables,90339," always sorted by key,; the table which results from this command will have its rows sorted by; the compound (row key, column key) which becomes the table key.; To preserve the original row-major entry order as the table row order,; first unkey the columns using :meth:`key_cols_by` with no arguments. Warning; -------; If the matrix table has no row key, but has a column key, this operation; may require a full shuffle to sort by the column key, depending on the; pipeline. Returns; -------; :class:`.Table`; Table with all non-global fields from the matrix, with **one row per entry of the matrix**.; """"""; if Env.hc()._warn_entries_order and len(self.col_key) > 0:; warning(; ""entries(): Resulting entries table is sorted by '(row_key, col_key)'.""; ""\n To preserve row-major matrix table order, ""; ""first unkey columns with 'key_cols_by()'""; ); Env.hc()._warn_entries_order = False. return Table(ir.MatrixEntriesTable(self._mir)). [docs] def index_globals(self) -> Expression:; """"""Return this matrix table's global variables for use in another; expression context. Examples; --------; >>> dataset1 = dataset.annotate_globals(pli={'SCN1A': 0.999, 'SONIC': 0.014}); >>> pli_dict = dataset1.index_globals().pli; >>> dataset_result = dataset2.annotate_rows(gene_pli = dataset2.gene.map(lambda x: pli_dict.get(x))). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(ir.MatrixRowsTable(self._mir)), self.globals.dtype). [docs] def index_rows(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the row values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.locus, dataset.alleles).qual). Or equivalently:. >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.row_key).qual). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:91208,Modifiability,variab,variable-length,91208,"eturn Table(ir.MatrixEntriesTable(self._mir)). [docs] def index_globals(self) -> Expression:; """"""Return this matrix table's global variables for use in another; expression context. Examples; --------; >>> dataset1 = dataset.annotate_globals(pli={'SCN1A': 0.999, 'SONIC': 0.014}); >>> pli_dict = dataset1.index_globals().pli; >>> dataset_result = dataset2.annotate_rows(gene_pli = dataset2.gene.map(lambda x: pli_dict.get(x))). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(ir.MatrixRowsTable(self._mir)), self.globals.dtype). [docs] def index_rows(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the row values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.locus, dataset.alleles).qual). Or equivalently:. >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.row_key).qual). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_rows(exprs)`` is equivalent to ``rows().index(exprs)``; or ``rows()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.row_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.rows()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable row key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). [docs] def index_cols(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the column values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_cols(pheno =",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:92394,Modifiability,variab,variable-length,92394,"xprs)`` is equivalent to ``rows().index(exprs)``; or ``rows()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.row_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.rows()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable row key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). [docs] def index_cols(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the column values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_cols(pheno = dataset2.index_cols(dataset.s).pheno). Or equivalently:. >>> dataset_result = dataset.annotate_cols(pheno = dataset2.index_cols(dataset.col_key).pheno). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_cols(cols)`` is equivalent to ``cols().index(exprs)``; or ``cols()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.col_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.cols()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable col key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). [docs] def index_entries(self, row_exprs, col_exprs):; """"""Expose the entries as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_entries(GQ2 = dataset2.index_entries(",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:132296,Modifiability,inherit,inherits,132296,"). t = t.add_index(index_uid); unique_cols = t.aggregate(; hl.agg.group_by(hl.struct(**{f: t[f] for f in col_key_fields}), hl.agg.take(t[index_uid], 1)); ); unique_cols = sorted([v[0] for _, v in unique_cols.items()]). return self.choose_cols(unique_cols). [docs] @deprecated(version=""0.2.129""); @typecheck_method(separator=str); def make_table(self, separator='.') -> Table:; """"""Make a table from a matrix table with one field per sample. .. deprecated:: 0.2.129; use :meth:`.localize_entries` instead because it supports more; columns. Parameters; ----------; separator : :class:`str`; Separator between sample IDs and entry field names. Returns; -------; :class:`.Table`. See Also; --------; :meth:`.localize_entries`. Notes; -----; The table has one row for each row of the input matrix. The; per sample and entry fields are formed by concatenating the; sample ID with the entry field name using `separator`. If the; entry field name is empty, the separator is omitted. The table inherits the globals from the matrix table. Examples; --------; Consider a matrix table with the following schema:. .. code-block:: text. Global fields:; 'batch': str; Column fields:; 's': str; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; Entry fields:; 'GT': call; 'GQ': int32; Column key:; 's': str; Row key:; 'locus': locus<GRCh37>; 'alleles': array<str>. and three sample IDs: `A`, `B` and `C`. Then the result of; :meth:`.make_table`:. >>> ht = mt.make_table() # doctest: +SKIP. has the original row fields along with 6 additional fields,; one for each sample and entry field:. .. code-block:: text. Global fields:; 'batch': str; Row fields:; 'locus': locus<GRCh37>; 'alleles': array<str>; 'A.GT': call; 'A.GQ': int32; 'B.GT': call; 'B.GQ': int32; 'C.GT': call; 'C.GQ': int32; Key:; 'locus': locus<GRCh37>; 'alleles': array<str>; """"""; if not (len(self.col_key) == 1 and self.col_key[0].dtype == hl.tstr):; raise ValueError(""column key must be a single field of type str""). col_keys = self.col_key",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:8072,Performance,optimiz,optimizer,8072," [*self._parent.globals, *self._parent.col]; else:; assert indices == self._parent._col_indices; fixed_fields = [*self._parent.globals, *self._parent.row]. bound_fields = set(; itertools.chain(; iter_option(self._row_keys),; iter_option(self._col_keys),; iter_option(self._col_fields),; iter_option(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedMatrixTable.aggregate` is; the number of partitions in the upstream dataset. If the aggregation greatly; reduces the size of the dataset, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a new column field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.mean(dataset.pheno.height)); ... .result()). Notes; -----;",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:88772,Performance,perform,performance,88772,"ls_by()'""; ); Env.hc()._warn_cols_order = False. return Table(ir.MatrixColsTable(self._mir)). [docs] def entries(self) -> Table:; """"""Returns a matrix in coordinate table form. Examples; --------; Extract the entry table:. >>> entries_table = dataset.entries(). Notes; -----; The coordinate table representation of the source matrix table contains; one row for each **non-filtered** entry of the matrix -- if a matrix table; has no filtered entries and contains N rows and M columns, the table will contain; ``M * N`` rows, which can be **a very large number**. This representation can be useful for aggregating over both axes of a matrix table; at the same time -- it is not possible to aggregate over a matrix table using; :meth:`group_rows_by` and :meth:`group_cols_by` at the same time (aggregating; by population and chromosome from a variant-by-sample genetics representation,; for instance). After moving to the coordinate representation with :meth:`entries`,; it is possible to group and aggregate the resulting table much more flexibly,; albeit with potentially poorer computational performance. Warning; -------; The table returned by this method should be used for aggregation or queries,; but never exported or written to disk without extensive filtering and field; selection -- the disk footprint of an entries_table could be 100x (or more!); larger than its parent matrix. This means that if you try to export the entries; table of a 10 terabyte matrix, you could write a petabyte of data!. Warning; -------; Matrix table columns are typically sorted by the order at import, and; not necessarily by column key. Since tables are always sorted by key,; the table which results from this command will have its rows sorted by; the compound (row key, column key) which becomes the table key.; To preserve the original row-major entry order as the table row order,; first unkey the columns using :meth:`key_cols_by` with no arguments. Warning; -------; If the matrix table has no row key, but ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:107658,Performance,perform,performance,107658,"org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. Returns; -------; int; Number of partitions.; """"""; return Env.backend().execute(ir.MatrixToValueApply(self._mir, {'name': 'NPartitionsMatrixTable'})). [docs] @typecheck_method(n_partitions=int, shuffle=bool); def repartition(self, n_partitions: int, shuffle: bool = True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Reparti",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:110279,Performance,cache,cache,110279,"ethod(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:110418,Performance,cache,cache,110418," partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:110586,Performance,Cache,Cached,110586,"sce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY,",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111007,Performance,cache,cache,111007,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111130,Performance,perform,performance,111130,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:120046,Performance,perform,performed,120046,"_right_row_fields=bool); def union_cols(; self, other: 'MatrixTable', row_join_type: str = 'inner', drop_right_row_fields: bool = True; ) -> 'MatrixTable':; """"""Take the union of dataset columns. Warning; -------. This method does not preserve the global fields from the other matrix table. Examples; --------. Union the columns of two datasets:. >>> dataset_result = dataset_to_union_1.union_cols(dataset_to_union_2). Notes; -----. In order to combine two datasets, three requirements must be met:. - The row keys must match.; - The column key schemas and column schemas must match.; - The entry schemas must match. The row fields in the resulting dataset are the row fields from the; first dataset; the row schemas do not need to match. This method creates a :class:`.MatrixTable` which contains all columns; from both input datasets. The set of rows included in the result is; determined by the `row_join_type` parameter. - With the default value of ``'inner'``, an inner join is performed; on rows, so that only rows whose row key exists in both input datasets; are included. In this case, the entries for each row are the; concatenation of all entries of the corresponding rows in the input; datasets.; - With `row_join_type` set to ``'outer'``, an outer join is perfomed on; rows, so that row keys which exist in only one input dataset are also; included. For those rows, the entry fields for the columns coming; from the other dataset will be missing. Only distinct row keys from each dataset are included (equivalent to; calling :meth:`.distinct_by_row` on each dataset first). This method does not deduplicate; if a column key exists identically in; two datasets, then it will be duplicated in the result. Parameters; ----------; other : :class:`.MatrixTable`; Dataset to concatenate.; row_join_type : :obj:`.str`; If `outer`, perform an outer join on rows; if 'inner', perform an; inner join. Default `inner`.; drop_right_row_fields : :obj:`.bool`; If true, non-key row fields of `other` are ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:120899,Performance,perform,perform,120899,"d in the result is; determined by the `row_join_type` parameter. - With the default value of ``'inner'``, an inner join is performed; on rows, so that only rows whose row key exists in both input datasets; are included. In this case, the entries for each row are the; concatenation of all entries of the corresponding rows in the input; datasets.; - With `row_join_type` set to ``'outer'``, an outer join is perfomed on; rows, so that row keys which exist in only one input dataset are also; included. For those rows, the entry fields for the columns coming; from the other dataset will be missing. Only distinct row keys from each dataset are included (equivalent to; calling :meth:`.distinct_by_row` on each dataset first). This method does not deduplicate; if a column key exists identically in; two datasets, then it will be duplicated in the result. Parameters; ----------; other : :class:`.MatrixTable`; Dataset to concatenate.; row_join_type : :obj:`.str`; If `outer`, perform an outer join on rows; if 'inner', perform an; inner join. Default `inner`.; drop_right_row_fields : :obj:`.bool`; If true, non-key row fields of `other` are dropped. Otherwise,; non-key row fields in the two datasets must have distinct names,; and the result contains the union of the row fields. Returns; -------; :class:`.MatrixTable`; Dataset with columns from both datasets.; """"""; if self.entry.dtype != other.entry.dtype:; raise ValueError(; f'entry types differ:\n' f' left: {self.entry.dtype}\n' f' right: {other.entry.dtype}'; ); if self.col.dtype != other.col.dtype:; raise ValueError(f'column types differ:\n' f' left: {self.col.dtype}\n' f' right: {other.col.dtype}'); if self.col_key.keys() != other.col_key.keys():; raise ValueError(; f'column key fields differ:\n'; f' left: {"", "".join(self.col_key.keys())}\n'; f' right: {"", "".join(other.col_key.keys())}'; ); if list(self.row_key.dtype.values()) != list(other.row_key.dtype.values()):; raise ValueError(; f'row key types differ:\n'; f' left: {"", "".j",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:120942,Performance,perform,perform,120942,"d in the result is; determined by the `row_join_type` parameter. - With the default value of ``'inner'``, an inner join is performed; on rows, so that only rows whose row key exists in both input datasets; are included. In this case, the entries for each row are the; concatenation of all entries of the corresponding rows in the input; datasets.; - With `row_join_type` set to ``'outer'``, an outer join is perfomed on; rows, so that row keys which exist in only one input dataset are also; included. For those rows, the entry fields for the columns coming; from the other dataset will be missing. Only distinct row keys from each dataset are included (equivalent to; calling :meth:`.distinct_by_row` on each dataset first). This method does not deduplicate; if a column key exists identically in; two datasets, then it will be duplicated in the result. Parameters; ----------; other : :class:`.MatrixTable`; Dataset to concatenate.; row_join_type : :obj:`.str`; If `outer`, perform an outer join on rows; if 'inner', perform an; inner join. Default `inner`.; drop_right_row_fields : :obj:`.bool`; If true, non-key row fields of `other` are dropped. Otherwise,; non-key row fields in the two datasets must have distinct names,; and the result contains the union of the row fields. Returns; -------; :class:`.MatrixTable`; Dataset with columns from both datasets.; """"""; if self.entry.dtype != other.entry.dtype:; raise ValueError(; f'entry types differ:\n' f' left: {self.entry.dtype}\n' f' right: {other.entry.dtype}'; ); if self.col.dtype != other.col.dtype:; raise ValueError(f'column types differ:\n' f' left: {self.col.dtype}\n' f' right: {other.col.dtype}'); if self.col_key.keys() != other.col_key.keys():; raise ValueError(; f'column key fields differ:\n'; f' left: {"", "".join(self.col_key.keys())}\n'; f' right: {"", "".join(other.col_key.keys())}'; ); if list(self.row_key.dtype.values()) != list(other.row_key.dtype.values()):; raise ValueError(; f'row key types differ:\n'; f' left: {"", "".j",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:28681,Safety,unsafe,unsafe,28681,"""Key columns by a new set of fields. See :meth:`.Table.key_by` for more information on defining a key. Parameters; ----------; keys : varargs of :class:`str` or :class:`.Expression`.; Column fields to key by.; named_keys : keyword args of :class:`.Expression`.; Column fields to key by.; Returns; -------; :class:`.MatrixTable`; """"""; key_fields, computed_keys = get_key_by_exprs(""MatrixTable.key_cols_by"", keys, named_keys, self._col_indices). if not computed_keys:; return MatrixTable(ir.MatrixMapCols(self._mir, self._col._ir, key_fields)); else:; new_col = self.col.annotate(**computed_keys); base, cleanup = self._process_joins(new_col). return cleanup(MatrixTable(ir.MatrixMapCols(base._mir, new_col._ir, key_fields))). @typecheck_method(new_key=str); def _key_rows_by_assert_sorted(self, *new_key):; rk_names = list(self.row_key); i = 0; while i < min(len(new_key), len(rk_names)):; if new_key[i] != rk_names[i]:; break; i += 1. if i < 1:; raise ValueError(; f'cannot implement an unsafe sort with no shared key:\n new key: {new_key}\n old key: {rk_names}'; ). return MatrixTable(ir.MatrixKeyRowsBy(self._mir, list(new_key), is_sorted=True)). [docs] @typecheck_method(keys=oneof(str, Expression), named_keys=expr_any); def key_rows_by(self, *keys, **named_keys) -> 'MatrixTable':; """"""Key rows by a new set of fields. Examples; --------. >>> dataset_result = dataset.key_rows_by('locus'); >>> dataset_result = dataset.key_rows_by(dataset['locus']); >>> dataset_result = dataset.key_rows_by(**dataset.row_key.drop('alleles')). All of these expressions key the dataset by the 'locus' field, dropping; the 'alleles' field from the row key. >>> dataset_result = dataset.key_rows_by(contig=dataset['locus'].contig,; ... position=dataset['locus'].position,; ... alleles=dataset['alleles']). This keys the dataset by the newly defined fields, 'contig' and 'position',; and the 'alleles' field. The old row key field, 'locus', is preserved as; a non-key field. Notes; -----; See :meth:`.Table.key_by` fo",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:108218,Safety,avoid,avoid,108218,"with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111086,Safety,avoid,avoid,111086,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111092,Safety,redund,redundant,111092,".MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:122398,Safety,avoid,avoid,122398,"eft: {self.entry.dtype}\n' f' right: {other.entry.dtype}'; ); if self.col.dtype != other.col.dtype:; raise ValueError(f'column types differ:\n' f' left: {self.col.dtype}\n' f' right: {other.col.dtype}'); if self.col_key.keys() != other.col_key.keys():; raise ValueError(; f'column key fields differ:\n'; f' left: {"", "".join(self.col_key.keys())}\n'; f' right: {"", "".join(other.col_key.keys())}'; ); if list(self.row_key.dtype.values()) != list(other.row_key.dtype.values()):; raise ValueError(; f'row key types differ:\n'; f' left: {"", "".join(self.row_key.dtype.values())}\n'; f' right: {"", "".join(other.row_key.dtype.values())}'; ). if drop_right_row_fields:; other = other.select_rows(); else:; left_fields = set(self.row_value); other_fields = set(other.row_value) - set(other.row_key); renames, _ = deduplicate(other_fields, max_attempts=100, already_used=left_fields). if renames:; renames = dict(renames); other = other.rename(renames); info(; 'Table.union_cols: renamed the following fields on the right to avoid name conflicts:'; + ''.join(f'\n {k!r} -> {v!r}' for k, v in renames.items()); ). return MatrixTable(ir.MatrixUnionCols(self._mir, other._mir, row_join_type)). [docs] @typecheck_method(n_rows=nullable(int), n_cols=nullable(int), n=nullable(int)); def head(self, n_rows: Optional[int], n_cols: Optional[int] = None, *, n: Optional[int] = None) -> 'MatrixTable':; """"""Subset matrix to first `n_rows` rows and `n_cols` cols. Examples; --------; >>> mt_range = hl.utils.range_matrix_table(100, 100). Passing only one argument will take the first `n_rows` rows:. >>> mt_range.head(10).count(); (10, 100). Passing two arguments refers to rows and columns, respectively:. >>> mt_range.head(10, 20).count(); (10, 20). Either argument may be ``None`` to indicate no filter. First 10 rows, all columns:. >>> mt_range.head(10, None).count(); (10, 100). All rows, first 10 columns:. >>> mt_range.head(None, 10).count(); (100, 10). Notes; -----; The number of partitions in the new matrix is eq",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:90856,Security,Expose,Expose,90856,"l fields from the matrix, with **one row per entry of the matrix**.; """"""; if Env.hc()._warn_entries_order and len(self.col_key) > 0:; warning(; ""entries(): Resulting entries table is sorted by '(row_key, col_key)'.""; ""\n To preserve row-major matrix table order, ""; ""first unkey columns with 'key_cols_by()'""; ); Env.hc()._warn_entries_order = False. return Table(ir.MatrixEntriesTable(self._mir)). [docs] def index_globals(self) -> Expression:; """"""Return this matrix table's global variables for use in another; expression context. Examples; --------; >>> dataset1 = dataset.annotate_globals(pli={'SCN1A': 0.999, 'SONIC': 0.014}); >>> pli_dict = dataset1.index_globals().pli; >>> dataset_result = dataset2.annotate_rows(gene_pli = dataset2.gene.map(lambda x: pli_dict.get(x))). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(ir.MatrixRowsTable(self._mir)), self.globals.dtype). [docs] def index_rows(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the row values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.locus, dataset.alleles).qual). Or equivalently:. >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.row_key).qual). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_rows(exprs)`` is equivalent to ``rows().index(exprs)``; or ``rows()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.row_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.rows()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable row key: {', '.join(str(t) for t in err.key_ty",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:92056,Security,Expose,Expose,92056,"ual). Or equivalently:. >>> dataset_result = dataset.annotate_rows(qual = dataset2.index_rows(dataset.row_key).qual). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_rows(exprs)`` is equivalent to ``rows().index(exprs)``; or ``rows()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.row_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.rows()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable row key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). [docs] def index_cols(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the column values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_cols(pheno = dataset2.index_cols(dataset.s).pheno). Or equivalently:. >>> dataset_result = dataset.annotate_cols(pheno = dataset2.index_cols(dataset.col_key).pheno). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_cols(cols)`` is equivalent to ``cols().index(exprs)``; or ``cols()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.col_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.cols()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable col key: {', '.join(str(t) for t in err.key_type.values()) or ",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:93223,Security,Expose,Expose,93223,"taset.s).pheno). Or equivalently:. >>> dataset_result = dataset.annotate_cols(pheno = dataset2.index_cols(dataset.col_key).pheno). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Notes; -----; ``index_cols(cols)`` is equivalent to ``cols().index(exprs)``; or ``cols()[exprs]``. The type of the resulting struct is the same as the type of; :meth:`.col_value`. Returns; -------; :class:`.Expression`; """"""; try:; return self.cols()._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable col key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). [docs] def index_entries(self, row_exprs, col_exprs):; """"""Expose the entries as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; >>> dataset_result = dataset.annotate_entries(GQ2 = dataset2.index_entries(dataset.row_key, dataset.col_key).GQ). Or equivalently:. >>> dataset_result = dataset.annotate_entries(GQ2 = dataset2[dataset.row_key, dataset.col_key].GQ). Parameters; ----------; row_exprs : tuple of :class:`.Expression`; Row index expressions.; col_exprs : tuple of :class:`.Expression`; Column index expressions. Notes; -----; The type of the resulting struct is the same as the type of; :meth:`.entry`. Note; ----; There is a shorthand syntax for :meth:`.MatrixTable.index_entries` using; square brackets (the Python ``__getitem__`` syntax). This syntax is; preferred. >>> dataset_result = dataset.annotate_entries(GQ2 = dataset2[dataset.row_key, dataset.col_key].GQ). Returns; -------; :class:`.StructExpression`; """"""; row_exprs = wrap_to_tuple(row_exprs); col_exprs = wrap_to_tuple(col_exprs); if len(row_exprs) == 0 or len(col_ex",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:376,Testability,Log,Log,376,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:7180,Testability,assert,assert,7180," expressions to group by. Returns; -------; :class:`.GroupedMatrixTable`; Grouped matrix, can be used to call :meth:`.GroupedMatrixTable.aggregate`.; """"""; if self._row_keys is not None:; raise NotImplementedError(""GroupedMatrixTable is already grouped by rows; cannot also group by cols.""); if self._col_keys is not None:; raise NotImplementedError(""GroupedMatrixTable is already grouped by cols.""). caller = 'group_cols_by'; col_key, computed_key = get_key_by_exprs(; caller,; exprs,; named_exprs,; self._parent._col_indices,; override_protected_indices={self._parent._global_indices, self._parent._row_indices},; ). self._check_bindings(caller, computed_key, self._parent._col_indices); return self._copy(col_keys=col_key, computed_col_key=computed_key). def _check_bindings(self, caller, new_bindings, indices):; empty = []. def iter_option(o):; return o if o is not None else empty. if indices == self._parent._row_indices:; fixed_fields = [*self._parent.globals, *self._parent.col]; else:; assert indices == self._parent._col_indices; fixed_fields = [*self._parent.globals, *self._parent.row]. bound_fields = set(; itertools.chain(; iter_option(self._row_keys),; iter_option(self._col_keys),; iter_option(self._col_fields),; iter_option(self._row_fields),; iter_option(self._entry_fields),; fixed_fields,; ); ). for k in new_bindings:; if k in bound_fields:; raise ExpressionException(f""{caller!r} cannot assign duplicate field {k!r}""). [docs] def partition_hint(self, n: int) -> 'GroupedMatrixTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.MatrixTable.group_rows_by` /; :meth:`.GroupedMatrixTable.aggregate` pipeline:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .partition_hint(5); ... .aggregate(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref()))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some place",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:9521,Testability,assert,assert,9521," n : int; Number of partitions. Returns; -------; :class:`.GroupedMatrixTable`; Same grouped matrix table with a partition hint.; """""". self._partitions = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate_cols(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate cols by group. Examples; --------; Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a new column field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.mean(dataset.pheno.height)); ... .result()). Notes; -----; The aggregation scope includes all column fields and global fields. See Also; --------; :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.GroupedMatrixTable`; """"""; if self._row_keys is not None:; raise NotImplementedError(""GroupedMatrixTable is already grouped by rows. Cannot aggregate over cols.""); assert self._col_keys is not None. base = self._col_fields if self._col_fields is not None else hl.struct(); for k, e in named_exprs.items():; analyze('GroupedMatrixTable.aggregate_cols', e, self._parent._global_indices, {self._parent._col_axis}). self._check_bindings('aggregate_cols', named_exprs, self._parent._col_indices); return self._copy(col_fields=base.annotate(**named_exprs)). [docs] @typecheck_method(named_exprs=expr_any); def aggregate_rows(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate rows by group. Examples; --------; Aggregate to a matrix with genes as row keys, collecting the functional; consequences per gene as a set as a new row field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_rows(consequences = hl.agg.collect_as_set(dataset.consequence)); ... .result()). Notes; -----; The aggregation scope includes all row fields and global fields. See Also; --------; :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:10753,Testability,assert,assert,10753,"col_axis}). self._check_bindings('aggregate_cols', named_exprs, self._parent._col_indices); return self._copy(col_fields=base.annotate(**named_exprs)). [docs] @typecheck_method(named_exprs=expr_any); def aggregate_rows(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate rows by group. Examples; --------; Aggregate to a matrix with genes as row keys, collecting the functional; consequences per gene as a set as a new row field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_rows(consequences = hl.agg.collect_as_set(dataset.consequence)); ... .result()). Notes; -----; The aggregation scope includes all row fields and global fields. See Also; --------; :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.GroupedMatrixTable`; """"""; if self._col_keys is not None:; raise NotImplementedError(""GroupedMatrixTable is already grouped by cols. Cannot aggregate over rows.""); assert self._row_keys is not None. base = self._row_fields if self._row_fields is not None else hl.struct(); for k, e in named_exprs.items():; analyze('GroupedMatrixTable.aggregate_rows', e, self._parent._global_indices, {self._parent._row_axis}). self._check_bindings('aggregate_rows', named_exprs, self._parent._row_indices); return self._copy(row_fields=base.annotate(**named_exprs)). [docs] @typecheck_method(named_exprs=expr_any); def aggregate_entries(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate entries by group. Examples; --------; Aggregate to a matrix with genes as row keys, computing the number of; non-reference calls as an entry field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). See Also; --------; :meth:`.aggregate`, :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.G",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:11782,Testability,assert,assert,11782,"is not None. base = self._row_fields if self._row_fields is not None else hl.struct(); for k, e in named_exprs.items():; analyze('GroupedMatrixTable.aggregate_rows', e, self._parent._global_indices, {self._parent._row_axis}). self._check_bindings('aggregate_rows', named_exprs, self._parent._row_indices); return self._copy(row_fields=base.annotate(**named_exprs)). [docs] @typecheck_method(named_exprs=expr_any); def aggregate_entries(self, **named_exprs) -> 'GroupedMatrixTable':; """"""Aggregate entries by group. Examples; --------; Aggregate to a matrix with genes as row keys, computing the number of; non-reference calls as an entry field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). See Also; --------; :meth:`.aggregate`, :meth:`.result`. Parameters; ----------; named_exprs : varargs of :class:`.Expression`; Aggregation expressions. Returns; -------; :class:`.GroupedMatrixTable`; """"""; assert self._row_keys is not None or self._col_keys is not None. base = self._entry_fields if self._entry_fields is not None else hl.struct(); for k, e in named_exprs.items():; analyze(; 'GroupedMatrixTable.aggregate_entries',; e,; self._fixed_indices(),; {self._parent._row_axis, self._parent._col_axis},; ). self._check_bindings(; 'aggregate_entries',; named_exprs,; self._parent._col_indices if self._col_keys is not None else self._parent._row_indices,; ); return self._copy(entry_fields=base.annotate(**named_exprs)). [docs] def result(self) -> 'MatrixTable':; """"""Return the result of aggregating by group. Examples; --------; Aggregate to a matrix with genes as row keys, collecting the functional; consequences per gene as a row field and computing the number of; non-reference calls as an entry field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_rows(consequences = hl.agg.collect_as_set(dataset.consequence)); ... .aggregate_entries(n_non_ref = hl.agg.c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:13350,Testability,assert,assert,13350,"eturn the result of aggregating by group. Examples; --------; Aggregate to a matrix with genes as row keys, collecting the functional; consequences per gene as a row field and computing the number of; non-reference calls as an entry field:. >>> dataset_result = (dataset.group_rows_by(dataset.gene); ... .aggregate_rows(consequences = hl.agg.collect_as_set(dataset.consequence)); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). Aggregate to a matrix with cohort as column keys, computing the mean height; per cohort as a column field and computing the number of non-reference calls; as an entry field:. >>> dataset_result = (dataset.group_cols_by(dataset.cohort); ... .aggregate_cols(mean_height = hl.agg.stats(dataset.pheno.height).mean); ... .aggregate_entries(n_non_ref = hl.agg.count_where(dataset.GT.is_non_ref())); ... .result()). See Also; --------; :meth:`.aggregate`. Returns; -------; :class:`.MatrixTable`; Aggregated matrix table.; """"""; assert self._row_keys is not None or self._col_keys is not None. defined_exprs = []; for e in [self._row_fields, self._col_fields, self._entry_fields]:; if e is not None:; defined_exprs.append(e); for e in [self._computed_row_key, self._computed_col_key]:; if e is not None:; defined_exprs.extend(e.values()). def promote_none(e):; return hl.struct() if e is None else e. entry_exprs = promote_none(self._entry_fields); if len(entry_exprs) == 0:; warning(""'GroupedMatrixTable.result': No entry fields were defined.""). base, cleanup = self._parent._process_joins(*defined_exprs). if self._col_keys is not None:; cck = self._computed_col_key or {}; computed_key_uids = {k: Env.get_uid() for k in cck}; modified_keys = [computed_key_uids.get(k, k) for k in self._col_keys]; mt = MatrixTable(; ir.MatrixAggregateColsByKey(; ir.MatrixMapCols(; base._mir,; self._parent.col.annotate(**{computed_key_uids[k]: v for k, v in cck.items()})._ir,; modified_keys,; ),; entry_exprs._ir,; promote_none(self._col_fields",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:21157,Testability,assert,assert,21157,"`_unlocalize_entries`. In; # this form, the column table is bundled with the globals and the entries; # for each row is stored on the row.; def raise_when_mismatched_property_dimensions(kvs: Dict[str, Iterable[Any]]):; def value_len(entry):; return len(entry[1]). kvs = sorted(kvs.items(), key=value_len); dims = itertools.groupby(kvs, value_len); dims = {size: [k for k, _ in group] for size, group in dims}; if len(dims) > 1:; raise ValueError(f""property matrix dimensions do not match: {dims}.""). def transpose(kvs: Dict[str, Iterable[Any]]) -> List[Dict[str, Any]]:; raise_when_mismatched_property_dimensions(kvs); return [dict(zip(kvs, vs)) for vs in zip(*kvs.values())]. def anyval(kvs):; return next(iter(kvs.values())). # In the case rows or cols aren't specified, we need to infer the; # matrix dimensions from *an* entry. Which one isn't important as we; # enforce congruence among input dimensions.; assert not ((rows is None or cols is None) and (entries is None)); cols = transpose(cols) if cols else [{} for _ in anyval(entries)[0]]; for i, _ in enumerate(cols):; cols[i] = hl.struct(col_idx=i, **cols[i]). if globals is None:; globals = {}. cols_field_name = Env.get_uid(); globals[cols_field_name] = cols. rows = transpose(rows) if rows else [{} for _ in anyval(entries)]; entries = [transpose(e) for e in transpose(entries)] if entries else [[{} for _ in cols] for _ in rows]. if len(rows) != len(entries) or len(cols) != len(entries[0]):; raise ValueError(; (""mismatched matrix dimensions: "" ""number of rows and cols does not match entry dimensions.""); ). entries_field_name = Env.get_uid(); for i, (row_props, entry_props) in enumerate(zip(rows, entries)):; row_entries = [hl.struct(**kvs) for kvs in entry_props]; rows[i] = hl.Struct(row_idx=i, **row_props, **{entries_field_name: row_entries}). ht = Table.parallelize(rows, key='row_idx', globals=hl.struct(**globals)); return ht._unlocalize_entries(entries_field_name, cols_field_name, col_key=['col_idx']). def __init__(self, m",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:44107,Testability,assert,assert,44107," :meth:`.key_rows_by`; or :meth:`.key_cols_by` to remove the field from the key before dropping. While many operations exist independently for rows, columns, entries, and; globals, only one is needed for dropping due to the lack of any necessary; contextual information. Parameters; ----------; exprs : varargs of :class:`str` or :class:`.Expression`; Names of fields to drop or field reference expressions. Returns; -------; :class:`.MatrixTable`; Matrix table without specified fields.; """""". def check_key(name, keys):; if name in keys:; raise ValueError(""MatrixTable.drop: cannot drop key field '{}'"".format(name)); return name. all_field_exprs = {e: k for k, e in self._fields.items()}; fields_to_drop = set(); for e in exprs:; if isinstance(e, Expression):; if e in all_field_exprs:; fields_to_drop.add(all_field_exprs[e]); else:; raise ExpressionException(; ""Method 'drop' expects string field names or top-level field expressions""; "" (e.g. 'foo', matrix.foo, or matrix['foo'])""; ); else:; assert isinstance(e, str); if e not in self._fields:; raise IndexError(""MatrixTable has no field '{}'"".format(e)); fields_to_drop.add(e). m = self; global_fields = [field for field in fields_to_drop if self._fields[field]._indices == self._global_indices]; if global_fields:; m = m._select_globals(""MatrixTable.drop"", m.globals.drop(*global_fields)). row_fields = [; check_key(field, list(self.row_key)); for field in fields_to_drop; if self._fields[field]._indices == self._row_indices; ]; if row_fields:; m = m._select_rows(""MatrixTable.drop"", row=m.row.drop(*row_fields)). col_fields = [; check_key(field, list(self.col_key)); for field in fields_to_drop; if self._fields[field]._indices == self._col_indices; ]; if col_fields:; m = m._select_cols(""MatrixTable.drop"", m.col.drop(*col_fields)). entry_fields = [field for field in fields_to_drop if self._fields[field]._indices == self._entry_indices]; if entry_fields:; m = m._select_entries(""MatrixTable.drop"", m.entry.drop(*entry_fields)). return m. [",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:84196,Testability,log,logging,84196,"isplayed_n_cols != self.actual_n_cols:; s += f""showing the first { self.displayed_n_cols } of { self.actual_n_cols } columns""; return s. def __repr__(self):; return self.__str__(). def _repr_html_(self):; s = self.table_show._repr_html_(); if self.displayed_n_cols != self.actual_n_cols:; s += '<p style=""background: #fdd; padding: 0.4em;"">'; s += f""showing the first { self.displayed_n_cols } of { self.actual_n_cols } columns""; s += '</p>\n'; return s. [docs] @typecheck_method(; n_rows=nullable(int),; n_cols=nullable(int),; include_row_fields=bool,; width=nullable(int),; truncate=nullable(int),; types=bool,; handler=nullable(anyfunc),; ); def show(; self, n_rows=None, n_cols=None, include_row_fields=False, width=None, truncate=None, types=True, handler=None; ):; """"""Print the first few rows of the matrix table to the console. .. include:: _templates/experimental.rst. Notes; -----; The output can be passed piped to another output source using the `handler` argument:. >>> mt.show(handler=lambda x: logging.info(x)) # doctest: +SKIP. Parameters; ----------; n_rows : :obj:`int`; Maximum number of rows to show.; n_cols : :obj:`int`; Maximum number of columns to show.; width : :obj:`int`; Horizontal width at which to break fields.; truncate : :obj:`int`, optional; Truncate each field to the given number of characters. If; ``None``, truncate fields to the given `width`.; types : :obj:`bool`; Print an extra header line with the type of each field.; handler : Callable[[str], Any]; Handler function for data string.; """""". def estimate_size(struct_expression):; return sum(max(len(f), len(str(x.dtype))) + 3 for f, x in struct_expression.flatten().items()). if n_cols is None:; import shutil. (characters, _) = shutil.get_terminal_size((80, 10)); characters -= 6 # borders; key_characters = estimate_size(self.row_key); characters -= key_characters; if include_row_fields:; characters -= estimate_size(self.row_value); characters = max(characters, 0); n_cols = characters // (estimate_size(s",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:96923,Testability,assert,assert,96923,"exprs) == 1; and isinstance(col_exprs[0], StructExpression); and types_match(self.col_key.values(), col_exprs[0].values()); ):; return self.index_entries(row_exprs, tuple(col_exprs[0].values())); elif len(col_exprs) != len(self.col_key):; raise ExpressionException(; f'Key mismatch: matrix table has {len(self.col_key)} col key fields, '; f'found {len(col_exprs)} index expressions.'; ); else:; raise ExpressionException(; f""Key type mismatch: cannot index matrix table with given expressions:\n""; f"" MatrixTable col key: {', '.join(str(t) for t in self.col_key.dtype.values())}\n""; f"" Col index expressions: {', '.join(str(e.dtype) for e in col_exprs)}""; ). indices, aggregations = unify_all(*(row_exprs + col_exprs)); src = indices.source; if aggregations:; raise ExpressionException('Cannot join using an aggregated field'). uid = Env.get_uid(); uids = [uid]. if isinstance(src, Table):; # join table with matrix.entries_table(); return self.entries().index(*(row_exprs + col_exprs)); else:; assert isinstance(src, MatrixTable); row_uid = Env.get_uid(); uids.append(row_uid); col_uid = Env.get_uid(); uids.append(col_uid). def joiner(left: MatrixTable):; localized = self._localize_entries(row_uid, col_uid); src_cols_indexed = self.add_col_index(col_uid).cols(); src_cols_indexed = src_cols_indexed.annotate(**{col_uid: hl.int32(src_cols_indexed[col_uid])}); left = left._annotate_all(; row_exprs={row_uid: localized.index(*row_exprs)[row_uid]},; col_exprs={col_uid: src_cols_indexed.index(*col_exprs)[col_uid]},; ); return left.annotate_entries(**{uid: left[row_uid][left[col_uid]]}). join_ir = ir.Join(; ir.ProjectedTopLevelReference('g', uid, self.entry.dtype), uids, [*row_exprs, *col_exprs], joiner; ); return construct_expr(join_ir, self.entry.dtype, indices, aggregations). @typecheck_method(entries_field_name=str, cols_field_name=str); def _localize_entries(self, entries_field_name, cols_field_name) -> 'Table':; assert entries_field_name not in self.row; assert cols_field_name not in s",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:97855,Testability,assert,assert,97855,"ce(src, Table):; # join table with matrix.entries_table(); return self.entries().index(*(row_exprs + col_exprs)); else:; assert isinstance(src, MatrixTable); row_uid = Env.get_uid(); uids.append(row_uid); col_uid = Env.get_uid(); uids.append(col_uid). def joiner(left: MatrixTable):; localized = self._localize_entries(row_uid, col_uid); src_cols_indexed = self.add_col_index(col_uid).cols(); src_cols_indexed = src_cols_indexed.annotate(**{col_uid: hl.int32(src_cols_indexed[col_uid])}); left = left._annotate_all(; row_exprs={row_uid: localized.index(*row_exprs)[row_uid]},; col_exprs={col_uid: src_cols_indexed.index(*col_exprs)[col_uid]},; ); return left.annotate_entries(**{uid: left[row_uid][left[col_uid]]}). join_ir = ir.Join(; ir.ProjectedTopLevelReference('g', uid, self.entry.dtype), uids, [*row_exprs, *col_exprs], joiner; ); return construct_expr(join_ir, self.entry.dtype, indices, aggregations). @typecheck_method(entries_field_name=str, cols_field_name=str); def _localize_entries(self, entries_field_name, cols_field_name) -> 'Table':; assert entries_field_name not in self.row; assert cols_field_name not in self.globals; return Table(ir.CastMatrixToTable(self._mir, entries_field_name, cols_field_name)). [docs] @typecheck_method(entries_array_field_name=nullable(str), columns_array_field_name=nullable(str)); def localize_entries(self, entries_array_field_name=None, columns_array_field_name=None) -> 'Table':; """"""Convert the matrix table to a table with entries localized as an array of structs. Examples; --------; Build a numpy ndarray from a small :class:`.MatrixTable`:. >>> mt = hl.utils.range_matrix_table(3,3); >>> mt = mt.select_entries(x = mt.row_idx * mt.col_idx); >>> mt.show(); +---------+-------+-------+-------+; | row_idx | 0.x | 1.x | 2.x |; +---------+-------+-------+-------+; | int32 | int32 | int32 | int32 |; +---------+-------+-------+-------+; | 0 | 0 | 0 | 0 |; | 1 | 0 | 1 | 2 |; | 2 | 0 | 2 | 4 |; +---------+-------+-------+-------+. >>> t = mt.localiz",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:97898,Testability,assert,assert,97898,"); else:; assert isinstance(src, MatrixTable); row_uid = Env.get_uid(); uids.append(row_uid); col_uid = Env.get_uid(); uids.append(col_uid). def joiner(left: MatrixTable):; localized = self._localize_entries(row_uid, col_uid); src_cols_indexed = self.add_col_index(col_uid).cols(); src_cols_indexed = src_cols_indexed.annotate(**{col_uid: hl.int32(src_cols_indexed[col_uid])}); left = left._annotate_all(; row_exprs={row_uid: localized.index(*row_exprs)[row_uid]},; col_exprs={col_uid: src_cols_indexed.index(*col_exprs)[col_uid]},; ); return left.annotate_entries(**{uid: left[row_uid][left[col_uid]]}). join_ir = ir.Join(; ir.ProjectedTopLevelReference('g', uid, self.entry.dtype), uids, [*row_exprs, *col_exprs], joiner; ); return construct_expr(join_ir, self.entry.dtype, indices, aggregations). @typecheck_method(entries_field_name=str, cols_field_name=str); def _localize_entries(self, entries_field_name, cols_field_name) -> 'Table':; assert entries_field_name not in self.row; assert cols_field_name not in self.globals; return Table(ir.CastMatrixToTable(self._mir, entries_field_name, cols_field_name)). [docs] @typecheck_method(entries_array_field_name=nullable(str), columns_array_field_name=nullable(str)); def localize_entries(self, entries_array_field_name=None, columns_array_field_name=None) -> 'Table':; """"""Convert the matrix table to a table with entries localized as an array of structs. Examples; --------; Build a numpy ndarray from a small :class:`.MatrixTable`:. >>> mt = hl.utils.range_matrix_table(3,3); >>> mt = mt.select_entries(x = mt.row_idx * mt.col_idx); >>> mt.show(); +---------+-------+-------+-------+; | row_idx | 0.x | 1.x | 2.x |; +---------+-------+-------+-------+; | int32 | int32 | int32 | int32 |; +---------+-------+-------+-------+; | 0 | 0 | 0 | 0 |; | 1 | 0 | 1 | 2 |; | 2 | 0 | 2 | 4 |; +---------+-------+-------+-------+. >>> t = mt.localize_entries('entry_structs', 'columns'); >>> t.describe(); ----------------------------------------; Global fiel",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:116216,Testability,test,testsetup,116216,"ws(self, caller, row) -> 'MatrixTable':; analyze(caller, row, self._row_indices, {self._col_axis}); base, cleanup = self._process_joins(row); return cleanup(MatrixTable(ir.MatrixMapRows(base._mir, row._ir))). @typecheck_method(caller=str, col=expr_struct(), new_key=nullable(sequenceof(str))); def _select_cols(self, caller, col, new_key=None) -> 'MatrixTable':; analyze(caller, col, self._col_indices, {self._row_axis}); base, cleanup = self._process_joins(col); return cleanup(MatrixTable(ir.MatrixMapCols(base._mir, col._ir, new_key))). @typecheck_method(caller=str, s=expr_struct()); def _select_globals(self, caller, s) -> 'MatrixTable':; base, cleanup = self._process_joins(s); analyze(caller, s, self._global_indices); return cleanup(MatrixTable(ir.MatrixMapGlobals(base._mir, s._ir))). [docs] @typecheck(datasets=matrix_table_type, _check_cols=bool); def union_rows(*datasets: 'MatrixTable', _check_cols=True) -> 'MatrixTable':; """"""Take the union of dataset rows. Examples; --------. .. testsetup::. dataset_to_union_1 = dataset; dataset_to_union_2 = dataset. Union the rows of two datasets:. >>> dataset_result = dataset_to_union_1.union_rows(dataset_to_union_2). Given a list of datasets, take the union of all rows:. >>> all_datasets = [dataset_to_union_1, dataset_to_union_2]. The following three syntaxes are equivalent:. >>> dataset_result = dataset_to_union_1.union_rows(dataset_to_union_2); >>> dataset_result = all_datasets[0].union_rows(*all_datasets[1:]); >>> dataset_result = hl.MatrixTable.union_rows(*all_datasets). Notes; -----. In order to combine two datasets, three requirements must be met:. - The column keys must be identical, both in type, value, and ordering.; - The row key schemas and row schemas must match.; - The entry schemas must match. The column fields in the resulting dataset are the column fields from; the first dataset; the column schemas do not need to match. This method does not deduplicate; if a row exists identically in two; datasets, then it will be",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:54,Usability,Feedback,Feedback,54,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:264,Usability,Guid,Guides,264,"﻿. Hail | ; hail.matrixtable. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.matrixtable. Source code for hail.matrixtable; import itertools; import warnings; from collections import Counter; from typing import Any, Dict, Iterable, List, Optional, Tuple. from deprecated import deprecated. import hail as hl; from hail import ir; from hail.expr.expressions import (; Expression,; ExpressionException,; Indices,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_bool,; expr_struct,; extract_refs_by_indices,; unify_all,; ); from hail.expr.matrix_type import tmatrix; from hail.expr.types import tarray, tset, types_match; from hail.table import ExprContainer, Table, TableIndexKeyError; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; lazy,; nullable,; numeric,; oneof,; sequenceof,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate, default_handler, storage_level; from hail.utils.java import Env, info, warning; from hail.utils.misc import check_annotate_exprs, get_key_by_exprs, get_select_exprs, process_joins, wrap_to_tuple. [docs]class GroupedMatrixTable(ExprContainer):; """"""Matrix table grouped by row or column that can be aggregated into a new matrix table."""""". def __init__(; self,; parent: 'MatrixTable',; row_keys=None,; computed_row_key=None,; col_keys=None,; computed_col_key=None,; entry_fields=None,; row_fields=None,; col_fields=None,; partitions=None,; ):; super(GroupedMatrixTable, self).__init__(); self._parent = parent; self._copy_fields_from(parent); self._row_keys = row_keys; self._computed_row_key = computed_row_key; self._c",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:106653,Usability,guid,guide,106653,"column order:. >>> import random; >>> indices = list(range(dataset.count_cols())); >>> random.shuffle(indices); >>> dataset_reordered = dataset.choose_cols(indices). Take the first ten columns:. >>> dataset_result = dataset.choose_cols(list(range(10))). Parameters; ----------; indices : :obj:`list` of :obj:`int`; List of old column indices. Returns; -------; :class:`.MatrixTable`; """"""; n_cols = self.count_cols(); for i in indices:; if not 0 <= i < n_cols:; raise ValueError(f""'choose_cols': expect indices between 0 and {n_cols}, found {i}""); return MatrixTable(ir.MatrixChooseCols(self._mir, indices)). [docs] def n_partitions(self) -> int:; """"""Number of partitions. Notes; -----. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. Partitions are a; core concept of distributed computation in Spark, see `here; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. Returns; -------; int; Number of partitions.; """"""; return Env.backend().execute(ir.MatrixToValueApply(self._mir, {'name': 'NPartitionsMatrixTable'})). [docs] @typecheck_method(n_partitions=int, shuffle=bool); def repartition(self, n_partitions: int, shuffle: bool = True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitio",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:107994,Usability,guid,guide,107994," True) -> 'MatrixTable':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> dataset_result = dataset.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a matrix with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full; shuffle. These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n_partitions : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.MatrixTable`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:109591,Usability,simpl,simply,109591,"`; Repartitioned dataset.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.row_key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_matrix_table(tmp2).add_row_index(uid).key_rows_by(uid); ht.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions).drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_matrix_table(tmp, _n_partitions=n_partitions). return MatrixTable(; ir.MatrixRepartition(; self._mir, n_partitions, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'MatrixTable':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> dataset_result = dataset.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.MatrixTable`; Matrix table with at most `max_partitions` partitions.; """"""; return MatrixTable(ir.MatrixRepartition(self._mir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] def cache(self) -> 'MatrixTable':; """"""Persist the dataset in memory. Examples; --------; Persist the dataset in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return se",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/matrixtable.html:111393,Usability,guid,guide,111393,"t in memory:. >>> dataset = dataset.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.MatrixTable.persist>`. Returns; -------; :class:`.MatrixTable`; Cached dataset.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level: str = 'MEMORY_AND_DISK') -> 'MatrixTable':; """"""Persist this table in memory or on disk. Examples; --------; Persist the dataset to both memory and disk:. >>> dataset = dataset.persist() # doctest: +SKIP. Notes; -----. The :meth:`.MatrixTable.persist` and :meth:`.MatrixTable.cache`; methods store the current dataset on disk or in memory temporarily to; avoid redundant computation and improve the performance of Hail; pipelines. This method is not a substitution for :meth:`.Table.write`,; which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.MatrixTable`; Persisted dataset.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'MatrixTable':; """"""; Unpersists this dataset from memory/disk. Notes; -----; This function will have no effect on a dataset that was not previously; persisted. Returns; -------; :class:`.MatrixTable`; Unpersisted dataset.; """"""; return Env.backend().unpersist(self). [docs] @typecheck_method(name=str); def add_row_index(self, name: str = 'row_idx') -> 'MatrixTable':; """"""Add the integer index of each row as a new row field. Examples; --------. >>> dataset_result = dataset.add_row_index(). Notes; -----; The field adde",MatchSource.WIKI,docs/0.2/_modules/hail/matrixtable.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/matrixtable.html
https://hail.is/docs/0.2/_modules/hail/table.html:5682,Availability,down,downstream,5682,"dTable.aggregate`.; """""". def __init__(self, parent: 'Table', key_expr):; super(GroupedTable, self).__init__(); self._key_expr = key_expr; self._parent = parent; self._npartitions = None; self._buffer_size = 50. self._copy_fields_from(parent). [docs] def partition_hint(self, n: int) -> 'GroupedTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.Table.group_by` / :meth:`.GroupedTable.aggregate`; pipeline:. >>> table_result = (table1.group_by(table1.ID); ... .partition_hint(5); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedTable.aggregate` is the; number of partitions in the upstream table. If the aggregation greatly; reduces the size of the table, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedTable`; Same grouped table with a partition hint.; """"""; self._npartitions = n; return self. def _set_buffer_size(self, n: int) -> 'GroupedTable':; """"""Set the map-side combiner buffer size (in rows). Parameters; ----------; n : int; Buffer size. Returns; -------; :class:`.GroupedTable`; Same grouped table with a buffer size.; """"""; if n <= 0:; raise ValueError(n); self._buffer_size = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate(self, **named_exprs) -> 'Table':; """"""Aggregate by group, used after :meth:`.Table.group_by`. Examples; --------; Compute the mean value of `X` and the sum of `Z` per unique `ID`:. >>> table_result = (table1.group_by(table1.ID); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Group by a height bin and compute sex ratio per bin:. >>> table_res",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:12746,Availability,down,down,12746,"e 2: Left distinct join: ht[ht2.key] or ht[ht2.field1, ht2.field2]""; ) from e. @property; def key(self) -> StructExpression:; """"""Row key struct. Examples; --------. List of key field names:. >>> list(table1.key); ['ID']. Number of key fields:. >>> len(table1.key); 1. Returns; -------; :class:`.StructExpression`; """"""; return self._key. @property; def _value(self) -> 'StructExpression':; return self.row.drop(*self.key). [docs] def n_partitions(self):; """"""Returns the number of partitions in the table. Examples; --------. Range tables can be constructed with an explicit number of partitions:. >>> ht = hl.utils.range_table(100, n_partitions=10); >>> ht.n_partitions(); 10. Small files are often imported with one partition:. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True); >>> ht2.n_partitions(); 1. The `min_partitions` argument to :func:`.import_table` forces more partitions, but it can; produce empty partitions. Empty partitions do not affect correctness but introduce; unnecessary extra bookkeeping that slows down the pipeline. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True, min_partitions=10); >>> ht2.n_partitions(); 10. Returns; -------; :obj:`int`; Number of partitions. """"""; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'NPartitionsTable'})). [docs] def count(self):; """"""Count the number of rows in the table. Examples; --------. Count the number of rows in a table loaded from 'data/kt_example1.tsv'. Each line of the TSV; becomes one row in the Hail Table. >>> ht = hl.import_table('data/kt_example1.tsv', impute=True); >>> ht.count(); 4. Returns; -------; :obj:`int`; The number of rows in the table. """"""; return Env.backend().execute(ir.TableCount(self._tir)). async def _async_count(self):; return await Env.backend()._async_execute(ir.TableCount(self._tir)). def _force_count(self):; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'ForceCountTable'})). async def _async_force_count(self)",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:58731,Availability,checkpoint,checkpoint,58731,"gate over rows into a local value. Examples; --------; Aggregate over rows:. >>> table1.aggregate(hl.struct(fraction_male=hl.agg.fraction(table1.SEX == 'M'),; ... mean_x=hl.agg.mean(table1.X))); Struct(fraction_male=0.5, mean_x=6.5). Note; ----; This method supports (and expects!) aggregation over rows. Parameters; ----------; expr : :class:`.Expression`; Aggregation expression. Returns; -------; any; Aggregated value dependent on `expr`.; """"""; expr = to_expr(expr); base, _ = self._process_joins(expr); analyze('Table.aggregate', expr, self._global_indices, {self._row_axis}). agg_ir = ir.TableAggregate(base._tir, expr._ir). if _localize:; return Env.backend().execute(hl.ir.MakeTuple([agg_ir]))[0]. return construct_expr(ir.LiftMeOut(agg_ir), expr.dtype). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; ) -> 'Table':; """"""Checkpoint the table to disk by writing and reading. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`Table`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_table`. It is; possible to read the file at this path later with :func:`.read_table`. Examples; --------; >>> table1 = table1.checkpoint('output/table_checkpoint.ht', overwrite=True). """"""; hl.current_backend().validate_file(output). if not _read_if_exists or not hl.hadoop_exists(f'{output}/_SUCCESS'):; self.write(output=output, overwrite=overwrite, ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:58951,Availability,Checkpoint,Checkpoint,58951,"gate over rows into a local value. Examples; --------; Aggregate over rows:. >>> table1.aggregate(hl.struct(fraction_male=hl.agg.fraction(table1.SEX == 'M'),; ... mean_x=hl.agg.mean(table1.X))); Struct(fraction_male=0.5, mean_x=6.5). Note; ----; This method supports (and expects!) aggregation over rows. Parameters; ----------; expr : :class:`.Expression`; Aggregation expression. Returns; -------; any; Aggregated value dependent on `expr`.; """"""; expr = to_expr(expr); base, _ = self._process_joins(expr); analyze('Table.aggregate', expr, self._global_indices, {self._row_axis}). agg_ir = ir.TableAggregate(base._tir, expr._ir). if _localize:; return Env.backend().execute(hl.ir.MakeTuple([agg_ir]))[0]. return construct_expr(ir.LiftMeOut(agg_ir), expr.dtype). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; ) -> 'Table':; """"""Checkpoint the table to disk by writing and reading. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`Table`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_table`. It is; possible to read the file at this path later with :func:`.read_table`. Examples; --------; >>> table1 = table1.checkpoint('output/table_checkpoint.ht', overwrite=True). """"""; hl.current_backend().validate_file(output). if not _read_if_exists or not hl.hadoop_exists(f'{output}/_SUCCESS'):; self.write(output=output, overwrite=overwrite, ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:59540,Availability,checkpoint,checkpoint,59540,"ut=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; ) -> 'Table':; """"""Checkpoint the table to disk by writing and reading. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copied to ``output``; overwrite : bool; If ``True``, overwrite an existing file at the destination. Returns; -------; :class:`Table`. .. include:: _templates/write_warning.rst. Notes; -----; An alias for :meth:`write` followed by :func:`.read_table`. It is; possible to read the file at this path later with :func:`.read_table`. Examples; --------; >>> table1 = table1.checkpoint('output/table_checkpoint.ht', overwrite=True). """"""; hl.current_backend().validate_file(output). if not _read_if_exists or not hl.hadoop_exists(f'{output}/_SUCCESS'):; self.write(output=output, overwrite=overwrite, stage_locally=stage_locally, _codec_spec=_codec_spec); _assert_type = self._type; _load_refs = False; else:; _assert_type = None; _load_refs = True; return hl.read_table(; output,; _intervals=_intervals,; _filter_intervals=_filter_intervals,; _assert_type=_assert_type,; _load_refs=_load_refs,; ). [docs] @typecheck_method(output=str, overwrite=bool, stage_locally=bool, _codec_spec=nullable(str)); def write(self, output: str, overwrite=False, stage_locally: bool = False, _codec_spec: Optional[str] = None):; """"""Write to disk. Examples; --------. >>> table1.write('output/table1.ht', overwrite=True). .. include:: _templates/write_warning.rst. See Also; --------; :func:`.read_table`. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major out",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:71580,Availability,avail,available,71580,""" |; +-------+----------+. Using `key` as the sole index expression is equivalent to passing all; key fields individually:. >>> table_result = table1.select(B = table2.index(table1.key).B). It is also possible to use non-key fields or expressions as the index; expressions:. >>> table_result = table1.select(B = table2.index(table1.C1 % 4).B); >>> table_result.show(); +-------+---------+; | ID | B |; +-------+---------+; | int32 | str |; +-------+---------+; | 1 | ""dog"" |; | 2 | ""dog"" |; | 3 | ""dog"" |; | 4 | ""mouse"" |; +-------+---------+. Notes; -----; :meth:`.Table.index` is used to expose one table's fields for use in; expressions involving the another table or matrix table's fields. The; result of the method call is a struct expression that is usable in the; same scope as `exprs`, just as if `exprs` were used to look up values of; the table in a dictionary. The type of the struct expression is the same as the indexed table's; :meth:`.row_value` (the key fields are removed, as they are available; in the form of the index expressions). Note; ----; There is a shorthand syntax for :meth:`.Table.index` using square; brackets (the Python ``__getitem__`` syntax). This syntax is preferred. >>> table_result = table1.select(B = table2[table1.ID].B). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Returns; -------; :class:`.Expression`; """"""; try:; return self._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index table with given expressions:\n""; f"" Table key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index Expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). @staticmethod; def _maybe_truncate_for_flexindex(indexer, indexee_dtype):; if not len(indexee_dtype) > 0:; raise ValueError('Must have non-e",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80110,Availability,redundant,redundant,80110,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:81825,Availability,error,errors,81825,"e.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().unpersist(self). @overload; def collect(self) -> List[hl.Struct]: ... @overload; def collect(self, _localize=False) -> ArrayExpression: ... [docs] @typecheck_method(_localize=bool, _timed=bool); def collect(self, _localize=True, *, _timed=False):; """"""Collect the rows of the table into a local list. Examples; --------; Collect a list of all `X` records:. >>> all_xs = [row['X'] for row in table1.select(table1.X).collect()]. Notes; -----; This method returns a list whose elements are of type :class:`.Struct`. Fields; of these structs can be accessed similarly to fields on a table, using dot; methods (``struct.foo``) or string indexing (``struct['foo']``). Warning; -------; Using this method can cause out of memory errors. Only collect small tables. Returns; -------; :obj:`list` of :class:`.Struct`; List of rows.; """"""; if len(self.key) > 0:; t = self.order_by(*self.key); else:; t = self; rows_ir = ir.GetField(ir.TableCollect(t._tir), 'rows'); e = construct_expr(rows_ir, hl.tarray(t.row.dtype)); if _localize:; return Env.backend().execute(e._ir, timed=_timed); else:; return e. [docs] def describe(self, handler=print, *, widget=False):; """"""Print information about the fields in the table. Note; ----; The `widget` argument is **experimental**. Parameters; ----------; handler : Callable[[str], None]; Handler function for returned string.; widget : bool; Create an interactive IPython widget.; """"""; if widget:; from hail.experimental.interact import interact. return interact(self). def format_type(typ):; return typ.pretty(indent=4).lstrip(). if len(self.globals) == 0:; global_fields = '\n None'; else:; global_fields = ''.join(; ""\n '{name}': {type} "".format(name=f, type=format_",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:85654,Availability,error,error,85654,"unique integer index for; rows of a table so that more complex types can be encoded as a simple; number for performance reasons. Parameters; ----------; name : str; Name of index field. Returns; -------; :class:`.Table`; Table with a new index field.; """""". return self.annotate(**{name: hl.scan.count()}). [docs] @typecheck_method(tables=table_type, unify=bool); def union(self, *tables, unify: bool = False) -> 'Table':; """"""Union the rows of multiple tables. Examples; --------. Take the union of rows from two tables:. >>> union_table = table1.union(other_table). Notes; -----; If a row appears in more than one table identically, it is duplicated; in the result. All tables must have the same key names and types. They; must also have the same row types, unless the `unify` parameter is; ``True``, in which case a field appearing in any table will be included; in the result, with missing values for tables that do not contain the; field. If a field appears in multiple tables with incompatible types,; like arrays and strings, then an error will be raised. Parameters; ----------; tables : varargs of :class:`.Table`; Tables to union.; unify : :obj:`bool`; Attempt to unify table field. Returns; -------; :class:`.Table`; Table with all rows from each component table.; """"""; left_key = self.key.dtype; for (; i,; ht,; ) in enumerate(tables):; if left_key != ht.key.dtype:; raise ValueError(; f""'union': table {i} has a different key.""; f"" Expected: {left_key}\n""; f"" Table {i}: {ht.key.dtype}""; ). if not (unify or ht.row.dtype == self.row.dtype):; raise ValueError(; f""'union': table {i} has a different row type.\n""; f"" Expected: {self.row.dtype}\n""; f"" Table {i}: {ht.row.dtype}\n""; f"" If the tables have the same fields in different orders, or some\n""; f"" common and some unique fields, then the 'unify' parameter may be\n""; f"" able to coerce the tables to a common type.""; ); all_tables = [self]; all_tables.extend(tables). if unify and not len(set(ht.row_value.dtype for ht in all_tables)) =",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:89902,Availability,Down,Downsample,89902," ""F"" | 7 | 3 | 10 | 81 | -5 |; +-------+-------+-----+-------+-------+-------+-------+-------+. Notes; -----. The number of partitions in the new table is equal to the number of; partitions containing the first `n` rows. Parameters; ----------; n : int; Number of rows to include. Returns; -------; :class:`.Table`; Table limited to the first `n` rows.; """""". return Table(ir.TableHead(self._tir, n)). [docs] @typecheck_method(n=int); def tail(self, n) -> 'Table':; """"""Subset table to last `n` rows. Examples; --------; Subset to the last three rows:. >>> table_result = table1.tail(3); >>> table_result.count(); 3. Notes; -----. The number of partitions in the new table is equal to the number of; partitions containing the last `n` rows. Parameters; ----------; n : int; Number of rows to include. Returns; -------; :class:`.Table`; Table including the last `n` rows.; """""". return Table(ir.TableTail(self._tir, n)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample(self, p, seed=None) -> 'Table':; """"""Downsample the table by keeping each row with probability ``p``. Examples; --------. Downsample the table to approximately 1% of its rows. >>> table1.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | ""M"" | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | ""F"" | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | ""F"" | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+; >>> small_table1 = table1.sample(0.75, seed=0); >>> small_table1.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | i",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:89987,Availability,Down,Downsample,89987,"ns in the new table is equal to the number of; partitions containing the first `n` rows. Parameters; ----------; n : int; Number of rows to include. Returns; -------; :class:`.Table`; Table limited to the first `n` rows.; """""". return Table(ir.TableHead(self._tir, n)). [docs] @typecheck_method(n=int); def tail(self, n) -> 'Table':; """"""Subset table to last `n` rows. Examples; --------; Subset to the last three rows:. >>> table_result = table1.tail(3); >>> table_result.count(); 3. Notes; -----. The number of partitions in the new table is equal to the number of; partitions containing the last `n` rows. Parameters; ----------; n : int; Number of rows to include. Returns; -------; :class:`.Table`; Table including the last `n` rows.; """""". return Table(ir.TableTail(self._tir, n)). [docs] @typecheck_method(p=numeric, seed=nullable(int)); def sample(self, p, seed=None) -> 'Table':; """"""Downsample the table by keeping each row with probability ``p``. Examples; --------. Downsample the table to approximately 1% of its rows. >>> table1.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | ""M"" | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | ""F"" | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | ""F"" | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+; >>> small_table1 = table1.sample(0.75, seed=0); >>> small_table1.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; | 3 | 70 | ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:92445,Availability,avail,available,92445,"------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; +-------+-------+-----+-------+-------+-------+-------+-------+. Parameters; ----------; p : :obj:`float`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.Table`; Table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter(hl.rand_bool(p, seed)). [docs] @typecheck_method(n=int, shuffle=bool); def repartition(self, n, shuffle=True) -> 'Table':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> table_result = table1.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a table with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark,",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93044,Availability,resilien,resilient-distributed-datasets-rdds,93044,"mber of partitions. Examples; --------. Repartition to 500 partitions:. >>> table_result = table1.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a table with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return h",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93827,Availability,checkpoint,checkpoint,93827,"s; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'Table':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> table_result = table1.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Para",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93901,Availability,checkpoint,checkpoint,93901,"oncept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'Table':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> table_result = table1.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93990,Availability,checkpoint,checkpoint,93990,"rg/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'Table':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> table_result = table1.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Ret",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:94043,Availability,checkpoint,checkpoint,94043,"stributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'Table':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> table_result = table1.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.Table`; Table with at most",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:127809,Availability,toler,tolerance,127809,"columns[fields[0]])):; for field in fields:; cur_val = columns[field][data_idx]. # Can't call isna on a collection or it will implicitly broadcast; if pandas.api.types.is_numeric_dtype(df[field].dtype) and pandas.isna(cur_val):; if isinstance(cur_val, float):; fixed_val = cur_val; elif isinstance(cur_val, np.floating):; fixed_val = cur_val.item(); else:; fixed_val = None; elif isinstance(df[field].dtype, pandas.StringDtype) and pandas.isna(cur_val): # No NaN to worry about; fixed_val = None; elif isinstance(cur_val, np.number):; fixed_val = cur_val.item(); else:; fixed_val = cur_val; data[data_idx][field] = fixed_val. for data_idx, field in enumerate(fields):; type_hint = dtypes_from_pandas(pd_dtypes[field]); if type_hint is not None:; hl_type_hints[field] = type_hint. new_table = hl.Table.parallelize(data, partial_type=hl_type_hints); return new_table if not key else new_table.key_by(*key). @typecheck_method(other=table_type, tolerance=nullable(numeric), absolute=bool, reorder_fields=bool); def _same(self, other, tolerance=1e-6, absolute=False, reorder_fields=False):; from hail.expr.functions import _values_similar. fd_f = set if reorder_fields else list. if fd_f(self.row) != fd_f(other.row):; print(f'Different row fields: \n {list(self.row)}\n {list(other.row)}'); return False; if fd_f(self.globals) != fd_f(other.globals):; print(f'Different globals fields: \n {list(self.globals)}\n {list(other.globals)}'); return False. if reorder_fields:; globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). row_order = list(self.row); if list(other.row) != row_order:; other = other.select(*row_order). if self._type != other._type:; print(f'Table._same: types differ:\n {self._type}\n {other._type}'); return False. left = self; left = left.select_globals(left_globals=left.globals); left = left.group_by(key=left.key).aggregate(left_row=hl.agg.collect(left.row_value)). right = other; right = right.select_globals(",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:127898,Availability,toler,tolerance,127898,"columns[fields[0]])):; for field in fields:; cur_val = columns[field][data_idx]. # Can't call isna on a collection or it will implicitly broadcast; if pandas.api.types.is_numeric_dtype(df[field].dtype) and pandas.isna(cur_val):; if isinstance(cur_val, float):; fixed_val = cur_val; elif isinstance(cur_val, np.floating):; fixed_val = cur_val.item(); else:; fixed_val = None; elif isinstance(df[field].dtype, pandas.StringDtype) and pandas.isna(cur_val): # No NaN to worry about; fixed_val = None; elif isinstance(cur_val, np.number):; fixed_val = cur_val.item(); else:; fixed_val = cur_val; data[data_idx][field] = fixed_val. for data_idx, field in enumerate(fields):; type_hint = dtypes_from_pandas(pd_dtypes[field]); if type_hint is not None:; hl_type_hints[field] = type_hint. new_table = hl.Table.parallelize(data, partial_type=hl_type_hints); return new_table if not key else new_table.key_by(*key). @typecheck_method(other=table_type, tolerance=nullable(numeric), absolute=bool, reorder_fields=bool); def _same(self, other, tolerance=1e-6, absolute=False, reorder_fields=False):; from hail.expr.functions import _values_similar. fd_f = set if reorder_fields else list. if fd_f(self.row) != fd_f(other.row):; print(f'Different row fields: \n {list(self.row)}\n {list(other.row)}'); return False; if fd_f(self.globals) != fd_f(other.globals):; print(f'Different globals fields: \n {list(self.globals)}\n {list(other.globals)}'); return False. if reorder_fields:; globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). row_order = list(self.row); if list(other.row) != row_order:; other = other.select(*row_order). if self._type != other._type:; print(f'Table._same: types differ:\n {self._type}\n {other._type}'); return False. left = self; left = left.select_globals(left_globals=left.globals); left = left.group_by(key=left.key).aggregate(left_row=hl.agg.collect(left.row_value)). right = other; right = right.select_globals(",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:129153,Availability,toler,tolerance,129153,"turn False; if fd_f(self.globals) != fd_f(other.globals):; print(f'Different globals fields: \n {list(self.globals)}\n {list(other.globals)}'); return False. if reorder_fields:; globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). row_order = list(self.row); if list(other.row) != row_order:; other = other.select(*row_order). if self._type != other._type:; print(f'Table._same: types differ:\n {self._type}\n {other._type}'); return False. left = self; left = left.select_globals(left_globals=left.globals); left = left.group_by(key=left.key).aggregate(left_row=hl.agg.collect(left.row_value)). right = other; right = right.select_globals(right_globals=right.globals); right = right.group_by(key=right.key).aggregate(right_row=hl.agg.collect(right.row_value)). t = left.join(right, how='outer'). mismatched_globals, mismatched_rows = t.aggregate(; hl.tuple((; hl.or_missing(~_values_similar(t.left_globals, t.right_globals, tolerance, absolute), t.globals),; hl.agg.filter(; ~hl.all(; hl.is_defined(t.left_row),; hl.is_defined(t.right_row),; _values_similar(t.left_row, t.right_row, tolerance, absolute),; ),; hl.agg.take(t.row, 10),; ),; )); ). columns, _ = shutil.get_terminal_size((80, 10)). def pretty(obj):; pretty_str = pprint.pformat(obj, width=columns); return ''.join(' ' + line for line in pretty_str.splitlines(keepends=True)). is_same = True; if mismatched_globals is not None:; print(f""""""Table._same: globals differ:; Left:; {pretty(mismatched_globals.left_globals)}; Right:; {pretty(mismatched_globals.right_globals)}""""""); is_same = False. if len(mismatched_rows) > 0:; print('Table._same: rows differ:'); for r in mismatched_rows:; print(f"""""" Row mismatch at key={r.key}:; Left:; {pretty(r.left_row)}; Right:; {pretty(r.right_row)}""""""); is_same = False. return is_same. [docs] def collect_by_key(self, name: str = 'values') -> 'Table':; """"""Collect values for each unique key into an array. .. include:: _templates/",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:129312,Availability,toler,tolerance,129312,"rder_fields:; globals_order = list(self.globals); if list(other.globals) != globals_order:; other = other.select_globals(*globals_order). row_order = list(self.row); if list(other.row) != row_order:; other = other.select(*row_order). if self._type != other._type:; print(f'Table._same: types differ:\n {self._type}\n {other._type}'); return False. left = self; left = left.select_globals(left_globals=left.globals); left = left.group_by(key=left.key).aggregate(left_row=hl.agg.collect(left.row_value)). right = other; right = right.select_globals(right_globals=right.globals); right = right.group_by(key=right.key).aggregate(right_row=hl.agg.collect(right.row_value)). t = left.join(right, how='outer'). mismatched_globals, mismatched_rows = t.aggregate(; hl.tuple((; hl.or_missing(~_values_similar(t.left_globals, t.right_globals, tolerance, absolute), t.globals),; hl.agg.filter(; ~hl.all(; hl.is_defined(t.left_row),; hl.is_defined(t.right_row),; _values_similar(t.left_row, t.right_row, tolerance, absolute),; ),; hl.agg.take(t.row, 10),; ),; )); ). columns, _ = shutil.get_terminal_size((80, 10)). def pretty(obj):; pretty_str = pprint.pformat(obj, width=columns); return ''.join(' ' + line for line in pretty_str.splitlines(keepends=True)). is_same = True; if mismatched_globals is not None:; print(f""""""Table._same: globals differ:; Left:; {pretty(mismatched_globals.left_globals)}; Right:; {pretty(mismatched_globals.right_globals)}""""""); is_same = False. if len(mismatched_rows) > 0:; print('Table._same: rows differ:'); for r in mismatched_rows:; print(f"""""" Row mismatch at key={r.key}:; Left:; {pretty(r.left_row)}; Right:; {pretty(r.right_row)}""""""); is_same = False. return is_same. [docs] def collect_by_key(self, name: str = 'values') -> 'Table':; """"""Collect values for each unique key into an array. .. include:: _templates/req_keyed_table.rst. Examples; --------; >>> t1 = hl.Table.parallelize([; ... {'t': 'foo', 'x': 4, 'y': 'A'},; ... {'t': 'bar', 'x': 2, 'y': 'B'},; ... {'t': 'bar',",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:148,Deployability,Install,Installation,148,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:216,Deployability,Configurat,Configuration,216,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:5092,Deployability,pipeline,pipeline,5092," object is not mutable""); self.__dict__[key] = value. def __getattr__(self, item):; if item in self.__dict__:; return self.__dict__[item]. raise AttributeError(get_nice_attr_error(self, item)). def _copy_fields_from(self, other: 'ExprContainer'):; self._fields = other._fields; self._fields_inverse = other._fields_inverse. [docs]class GroupedTable(ExprContainer):; """"""Table grouped by row that can be aggregated into a new table. There are only two operations on a grouped table, :meth:`.GroupedTable.partition_hint`; and :meth:`.GroupedTable.aggregate`.; """""". def __init__(self, parent: 'Table', key_expr):; super(GroupedTable, self).__init__(); self._key_expr = key_expr; self._parent = parent; self._npartitions = None; self._buffer_size = 50. self._copy_fields_from(parent). [docs] def partition_hint(self, n: int) -> 'GroupedTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.Table.group_by` / :meth:`.GroupedTable.aggregate`; pipeline:. >>> table_result = (table1.group_by(table1.ID); ... .partition_hint(5); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedTable.aggregate` is the; number of partitions in the upstream table. If the aggregation greatly; reduces the size of the table, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedTable`; Same grouped table with a partition hint.; """"""; self._npartitions = n; return self. def _set_buffer_size(self, n: int) -> 'GroupedTable':; """"""Set the map-side combiner buffer size (in rows). Parameters; ----------; n : int; Buffer size. Returns; -------; :class:`.GroupedTable`; Same group",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:5355,Deployability,pipeline,pipeline,5355,"lf._fields = other._fields; self._fields_inverse = other._fields_inverse. [docs]class GroupedTable(ExprContainer):; """"""Table grouped by row that can be aggregated into a new table. There are only two operations on a grouped table, :meth:`.GroupedTable.partition_hint`; and :meth:`.GroupedTable.aggregate`.; """""". def __init__(self, parent: 'Table', key_expr):; super(GroupedTable, self).__init__(); self._key_expr = key_expr; self._parent = parent; self._npartitions = None; self._buffer_size = 50. self._copy_fields_from(parent). [docs] def partition_hint(self, n: int) -> 'GroupedTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.Table.group_by` / :meth:`.GroupedTable.aggregate`; pipeline:. >>> table_result = (table1.group_by(table1.ID); ... .partition_hint(5); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedTable.aggregate` is the; number of partitions in the upstream table. If the aggregation greatly; reduces the size of the table, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedTable`; Same grouped table with a partition hint.; """"""; self._npartitions = n; return self. def _set_buffer_size(self, n: int) -> 'GroupedTable':; """"""Set the map-side combiner buffer size (in rows). Parameters; ----------; n : int; Buffer size. Returns; -------; :class:`.GroupedTable`; Same grouped table with a buffer size.; """"""; if n <= 0:; raise ValueError(n); self._buffer_size = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate(self, **named_exprs) -> 'Table':; """"""Aggregate by group, used after :meth:`.Table.gro",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:12755,Deployability,pipeline,pipeline,12755,"e 2: Left distinct join: ht[ht2.key] or ht[ht2.field1, ht2.field2]""; ) from e. @property; def key(self) -> StructExpression:; """"""Row key struct. Examples; --------. List of key field names:. >>> list(table1.key); ['ID']. Number of key fields:. >>> len(table1.key); 1. Returns; -------; :class:`.StructExpression`; """"""; return self._key. @property; def _value(self) -> 'StructExpression':; return self.row.drop(*self.key). [docs] def n_partitions(self):; """"""Returns the number of partitions in the table. Examples; --------. Range tables can be constructed with an explicit number of partitions:. >>> ht = hl.utils.range_table(100, n_partitions=10); >>> ht.n_partitions(); 10. Small files are often imported with one partition:. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True); >>> ht2.n_partitions(); 1. The `min_partitions` argument to :func:`.import_table` forces more partitions, but it can; produce empty partitions. Empty partitions do not affect correctness but introduce; unnecessary extra bookkeeping that slows down the pipeline. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True, min_partitions=10); >>> ht2.n_partitions(); 10. Returns; -------; :obj:`int`; Number of partitions. """"""; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'NPartitionsTable'})). [docs] def count(self):; """"""Count the number of rows in the table. Examples; --------. Count the number of rows in a table loaded from 'data/kt_example1.tsv'. Each line of the TSV; becomes one row in the Hail Table. >>> ht = hl.import_table('data/kt_example1.tsv', impute=True); >>> ht.count(); 4. Returns; -------; :obj:`int`; The number of rows in the table. """"""; return Env.backend().execute(ir.TableCount(self._tir)). async def _async_count(self):; return await Env.backend()._async_execute(ir.TableCount(self._tir)). def _force_count(self):; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'ForceCountTable'})). async def _async_force_count(self)",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:42409,Deployability,pipeline,pipeline,42409," +-------+-------+-----+-------+-------+----------+-------+----------+; +----------------+; | HT_DESCRIPTION |; +----------------+; | str |; +----------------+; | ""sixty-five"" |; | ""seventy-two"" |; | ""seventy"" |; | ""sixty"" |; +----------------+. Parameters; ----------; named_exprs : keyword args of :class:`.Expression`; Expressions for new fields. Returns; -------; :class:`.Table`; Table with new fields. """"""; caller = ""Table.annotate""; check_annotate_exprs(caller, named_exprs, self._row_indices, set()); return self._select(caller, self.row.annotate(**named_exprs)). [docs] @typecheck_method(expr=expr_bool, keep=bool); def filter(self, expr, keep: bool = True) -> 'Table':; """"""Filter rows conditional on the value of each row's fields. Note; ----. Hail will can read much less data if a Table filter condition references the key field and; the Table is stored in Hail native format (i.e. read using :func:`.read_table`, _not_; :func:`.import_table`). In other words: filtering on the key will make a pipeline faster by; reading fewer rows. This optimization is prevented by certain operations appearing between a; :func:`.read_table` and a :meth:`.filter`. For example, a `key_by` and `group_by`, both; force reading all the data. Suppose we previously :meth:`.write` a Hail Table with one million rows keyed by a field; called `idx`. If we filter this table to one value of `idx`, the pipeline will be fast; because we read only the rows that have that value of `idx`:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx == 5) # doctest: +SKIP. This also works with inequality conditions:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx <= 5) # doctest: +SKIP. Examples; --------. Consider this table:. >>> ht = ht.drop('C1', 'C2', 'C3'); >>> ht.show(); +-------+-------+-----+-------+-------+; | ID | HT | SEX | X | Z |; +-------+-------+-----+-------+-------+; | int32 | int32 | str | int32 | int32 |; +-------+-------+-",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:42795,Deployability,pipeline,pipeline,42795,"""""""; caller = ""Table.annotate""; check_annotate_exprs(caller, named_exprs, self._row_indices, set()); return self._select(caller, self.row.annotate(**named_exprs)). [docs] @typecheck_method(expr=expr_bool, keep=bool); def filter(self, expr, keep: bool = True) -> 'Table':; """"""Filter rows conditional on the value of each row's fields. Note; ----. Hail will can read much less data if a Table filter condition references the key field and; the Table is stored in Hail native format (i.e. read using :func:`.read_table`, _not_; :func:`.import_table`). In other words: filtering on the key will make a pipeline faster by; reading fewer rows. This optimization is prevented by certain operations appearing between a; :func:`.read_table` and a :meth:`.filter`. For example, a `key_by` and `group_by`, both; force reading all the data. Suppose we previously :meth:`.write` a Hail Table with one million rows keyed by a field; called `idx`. If we filter this table to one value of `idx`, the pipeline will be fast; because we read only the rows that have that value of `idx`:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx == 5) # doctest: +SKIP. This also works with inequality conditions:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx <= 5) # doctest: +SKIP. Examples; --------. Consider this table:. >>> ht = ht.drop('C1', 'C2', 'C3'); >>> ht.show(); +-------+-------+-----+-------+-------+; | ID | HT | SEX | X | Z |; +-------+-------+-----+-------+-------+; | int32 | int32 | str | int32 | int32 |; +-------+-------+-----+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 |; | 2 | 72 | ""M"" | 6 | 3 |; | 3 | 70 | ""F"" | 7 | 3 |; | 4 | 60 | ""F"" | 8 | 2 |; +-------+-------+-----+-------+-------+. Keep rows where ``Z`` is 3:. >>> filtered_ht = ht.filter(ht.Z == 3); >>> filtered_ht.show(). +-------+-------+-----+-------+-------+; | ID | HT | SEX | X | Z |; +-------+-------+-----+-------+-------+; | int32 | int32 | str | int32 | int32",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:53565,Deployability,pipeline,pipeline,53565,"check_keys('drop', f, protected_key); row_fields = set(table.row); to_drop = [f for f in fields_to_drop if f in row_fields]; table = table._select('drop', table.row.drop(*to_drop)). return table. [docs] @typecheck_method(; output=str, types_file=nullable(str), header=bool, parallel=nullable(ir.ExportType.checker), delimiter=str; ); def export(self, output, types_file=None, header=True, parallel=None, delimiter='\t'):; """"""Export to a text file. Examples; --------; Export to a tab-separated file:. >>> table1.export('output/table1.tsv.bgz'). Note; ----; It is highly recommended to export large files with a ``.bgz`` extension,; which will use a block gzipped compression codec. These files can be; read natively with any Hail method, as well as with Python's ``gzip.open``; and R's ``read.table``. Nested structures will be exported as JSON. In order to export nested struct; fields as separate fields in the resulting table, use :meth:`flatten` first. Warning; -------; Do not export to a path that is being read from in the same pipeline. See Also; --------; :meth:`flatten`, :meth:`write`. Parameters; ----------; output : :class:`str`; URI at which to write exported file.; types_file : :class:`str`, optional; URI at which to write file containing field type information.; header : :obj:`bool`; Include a header in the file.; parallel : :class:`str`, optional; If None, a single file is produced, otherwise a; folder of file shards is produced. If 'separate_header',; the header file is output separately from the file shards. If; 'header_per_shard', each file shard has a header. If set to None; the export will be slower.; delimiter : :class:`str`; Field delimiter.; """"""; hl.current_backend().validate_file(output). parallel = ir.ExportType.default(parallel); Env.backend().execute(; ir.TableWrite(self._tir, ir.TableTextWriter(output, types_file, header, parallel, delimiter)); ). [docs] def group_by(self, *exprs, **named_exprs) -> 'GroupedTable':; """"""Group by a new key for use with :me",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80169,Deployability,pipeline,pipelines,80169,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:136644,Deployability,update,updated,136644,"bles[0]; if any(head.key.dtype != t.key.dtype for t in tables):; raise TypeError(; 'All input tables to multi_way_zip_join must have the same key type:\n '; + '\n '.join(str(t.key.dtype) for t in tables); ); if any(head.row.dtype != t.row.dtype for t in tables):; raise TypeError(; 'All input tables to multi_way_zip_join must have the same row type\n '; + '\n '.join(str(t.row.dtype) for t in tables); ); if any(head.globals.dtype != t.globals.dtype for t in tables):; raise TypeError(; 'All input tables to multi_way_zip_join must have the same global type\n '; + '\n '.join(str(t.globals.dtype) for t in tables); ); return Table(ir.TableMultiWayZipJoin([t._tir for t in tables], data_field_name, global_field_name)). def _group_within_partitions(self, name, n):; def grouping_func(part):; groups = part.grouped(n); key_names = list(self.key); return groups.map(lambda group: group[0].select(*key_names, **{name: group})). return self._map_partitions(grouping_func). @typecheck_method(f=func_spec(1, expr_stream(expr_struct()))); def _map_partitions(self, f):; rows_uid = 'tmp_rows_' + Env.get_uid(); globals_uid = 'tmp_globals_' + Env.get_uid(); expr = construct_expr(; ir.Ref(rows_uid, hl.tstream(self.row.dtype)), hl.tstream(self.row.dtype), self._row_indices; ); body = f(expr); result_t = body.dtype; if any(k not in result_t.element_type for k in self.key):; raise ValueError('Table._map_partitions must preserve key fields'). body_ir = ir.Let('global', ir.Ref(globals_uid, self._global_type), body._ir); return Table(ir.TableMapPartitions(self._tir, globals_uid, rows_uid, body_ir, len(self.key), len(self.key))). def _calculate_new_partitions(self, n_partitions):; """"""returns a set of range bounds that can be passed to write""""""; return Env.backend().execute(; ir.TableToValueApply(; self.select().select_globals()._tir,; {'name': 'TableCalculateNewPartitions', 'nPartitions': n_partitions},; ); ). table_type.set(Table). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:5582,Energy Efficiency,reduce,reduces,5582,"dTable.aggregate`.; """""". def __init__(self, parent: 'Table', key_expr):; super(GroupedTable, self).__init__(); self._key_expr = key_expr; self._parent = parent; self._npartitions = None; self._buffer_size = 50. self._copy_fields_from(parent). [docs] def partition_hint(self, n: int) -> 'GroupedTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.Table.group_by` / :meth:`.GroupedTable.aggregate`; pipeline:. >>> table_result = (table1.group_by(table1.ID); ... .partition_hint(5); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedTable.aggregate` is the; number of partitions in the upstream table. If the aggregation greatly; reduces the size of the table, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedTable`; Same grouped table with a partition hint.; """"""; self._npartitions = n; return self. def _set_buffer_size(self, n: int) -> 'GroupedTable':; """"""Set the map-side combiner buffer size (in rows). Parameters; ----------; n : int; Buffer size. Returns; -------; :class:`.GroupedTable`; Same grouped table with a buffer size.; """"""; if n <= 0:; raise ValueError(n); self._buffer_size = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate(self, **named_exprs) -> 'Table':; """"""Aggregate by group, used after :meth:`.Table.group_by`. Examples; --------; Compute the mean value of `X` and the sum of `Z` per unique `ID`:. >>> table_result = (table1.group_by(table1.ID); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Group by a height bin and compute sex ratio per bin:. >>> table_res",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:58186,Integrability,depend,dependent,58186," reference expressions.; named_exprs : keyword args of type :class:`.Expression`; Field names and expressions to compute them. Returns; -------; :class:`.GroupedTable`; Grouped table; use :meth:`.GroupedTable.aggregate` to complete the aggregation.; """"""; key, computed_key = get_key_by_exprs(; 'Table.group_by', exprs, named_exprs, self._row_indices, override_protected_indices={self._global_indices}; ); return GroupedTable(self, self.row.annotate(**computed_key).select(*key)). [docs] @typecheck_method(expr=expr_any, _localize=bool); def aggregate(self, expr, _localize=True):; """"""Aggregate over rows into a local value. Examples; --------; Aggregate over rows:. >>> table1.aggregate(hl.struct(fraction_male=hl.agg.fraction(table1.SEX == 'M'),; ... mean_x=hl.agg.mean(table1.X))); Struct(fraction_male=0.5, mean_x=6.5). Note; ----; This method supports (and expects!) aggregation over rows. Parameters; ----------; expr : :class:`.Expression`; Aggregation expression. Returns; -------; any; Aggregated value dependent on `expr`.; """"""; expr = to_expr(expr); base, _ = self._process_joins(expr); analyze('Table.aggregate', expr, self._global_indices, {self._row_axis}). agg_ir = ir.TableAggregate(base._tir, expr._ir). if _localize:; return Env.backend().execute(hl.ir.MakeTuple([agg_ir]))[0]. return construct_expr(ir.LiftMeOut(agg_ir), expr.dtype). [docs] @typecheck_method(; output=str,; overwrite=bool,; stage_locally=bool,; _codec_spec=nullable(str),; _read_if_exists=bool,; _intervals=nullable(sequenceof(anytype)),; _filter_intervals=bool,; ); def checkpoint(; self,; output: str,; overwrite: bool = False,; stage_locally: bool = False,; _codec_spec: Optional[str] = None,; _read_if_exists: bool = False,; _intervals=None,; _filter_intervals=False,; ) -> 'Table':; """"""Checkpoint the table to disk by writing and reading. Parameters; ----------; output : str; Path at which to write.; stage_locally: bool; If ``True``, major output will be written to temporary local storage; before being copie",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:100474,Integrability,depend,depends,100474,"ey.values()); ):; raise ValueError(; 'anti_join: cannot join: table must have a key of the same type(s) and be the same length or shorter:'; f'\n Left key: {"", "".join(str(x.dtype) for x in self.key.values())}'; f'\n Right key: {"", "".join(str(x.dtype) for x in other.key.values())}'; ). return self.filter(hl.is_missing(other.index(*(self.key[i] for i in range(len(other.key)))))). [docs] @typecheck_method(; right=table_type, how=enumeration('inner', 'outer', 'left', 'right'), _mangle=anyfunc, _join_key=nullable(int); ); def join(; self,; right: 'Table',; how='inner',; _mangle: Callable[[str, int], str] = lambda s, i: f'{s}_{i}',; _join_key: Optional[int] = None,; ) -> 'Table':; """"""Join two tables together. Examples; --------; Join `table1` to `table2` to produce `table_joined`:. >>> table_joined = table1.key_by('ID').join(table2.key_by('ID')). Notes; -----; Tables are joined at rows whose key fields have equal values. Missing values never match.; The inclusion of a row with no match in the opposite table depends on the; join type:. - **inner** -- Only rows with a matching key in the opposite table are included; in the resulting table.; - **left** -- All rows from the left table are included in the resulting table.; If a row in the left table has no match in the right table, then the fields; derived from the right table will be missing.; - **right** -- All rows from the right table are included in the resulting table.; If a row in the right table has no match in the left table, then the fields; derived from the left table will be missing.; - **outer** -- All rows are included in the resulting table. If a row in the right; table has no match in the left table, then the fields derived from the left; table will be missing. If a row in the right table has no match in the left table,; then the fields derived from the left table will be missing. Both tables must have the same number of keys and the corresponding; types of each key must be the same (order matters), but the key",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:216,Modifiability,Config,Configuration,216,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:31306,Modifiability,variab,variable-length,31306,"---; Key: ['idx']; ----------------------------------------; >>> ht = ht.select_globals(ht.pops, target_date='2025-01-01'); >>> ht.describe(); ----------------------------------------; Global fields:; 'pops': array<str>; 'target_date': str; ----------------------------------------; Row fields:; 'idx': int32; ----------------------------------------; Key: ['idx']; ----------------------------------------. Fields may also be selected by their name:. >>> ht = ht.select_globals('target_date'); >>> ht.globals.show(); +--------------------+; | <expr>.target_date |; +--------------------+; | str |; +--------------------+; | ""2025-01-01"" |; +--------------------+. Notes; -----; This method creates new global fields. If a created field shares its name; with a row-indexed field of the table, the method will fail. Note; ----. See :meth:`.Table.select` for more information about using ``select`` methods. Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.Table`; Table with specified global fields. """"""; caller = 'Table.select_globals'; new_globals = get_select_exprs(caller, exprs, named_exprs, self._global_indices, self._globals). return self._select_globals(caller, new_globals). [docs] @typecheck_method(named_exprs=expr_any); def transmute_globals(self, **named_exprs) -> 'Table':; """"""Similar to :meth:`.Table.annotate_globals`, but drops referenced fields. Notes; -----; Consider a table with global fields `population`, `area`, and `year`:. >>> ht = hl.utils.range_table(1); >>> ht = ht.annotate_globals(population=1000000, area=500, year=2020). Compute a new field, `density` from `population` and `area` and also drop the latter two; fields:. >>> ht = ht.transmute_globals(density=ht.popu",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:48670,Modifiability,variab,variable-length,48670,"-; :class:`.Table`; Filtered table. """"""; analyze('Table.filter', expr, self._row_indices); base, cleanup = self._process_joins(expr). return cleanup(Table(ir.TableFilter(base._tir, ir.filter_predicate_with_keep(expr._ir, keep)))). [docs] @typecheck_method(exprs=oneof(Expression, str), named_exprs=anytype); def select(self, *exprs, **named_exprs) -> 'Table':; """"""Select existing fields or create new fields by name, dropping the rest. Examples; --------; Select a few old fields and compute a new one:. >>> table_result = table1.select(table1.C1, Y=table1.Z - table1.X). Notes; -----; This method creates new row-indexed fields. If a created field shares its name; with a global field of the table, the method will fail. Note; ----. **Using select**. Select and its sibling methods (:meth:`.Table.select_globals`,; :meth:`.MatrixTable.select_globals`, :meth:`.MatrixTable.select_rows`,; :meth:`.MatrixTable.select_cols`, and :meth:`.MatrixTable.select_entries`) accept; both variable-length (``f(x, y, z)``) and keyword (``f(a=x, b=y, c=z)``); arguments. Select methods will always preserve the key along that axis; e.g. for; :meth:`.Table.select`, the table key will aways be kept. To modify the; key, use :meth:`.key_by`. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a new table with; fields `C1` and `C2` of `table1`, and the table key `ID`. First, variable-length string arguments:. >>> table_result = table1.select('C1', 'C2'). Second, field reference variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:48919,Modifiability,Variab,Variable-length,48919,"), named_exprs=anytype); def select(self, *exprs, **named_exprs) -> 'Table':; """"""Select existing fields or create new fields by name, dropping the rest. Examples; --------; Select a few old fields and compute a new one:. >>> table_result = table1.select(table1.C1, Y=table1.Z - table1.X). Notes; -----; This method creates new row-indexed fields. If a created field shares its name; with a global field of the table, the method will fail. Note; ----. **Using select**. Select and its sibling methods (:meth:`.Table.select_globals`,; :meth:`.MatrixTable.select_globals`, :meth:`.MatrixTable.select_rows`,; :meth:`.MatrixTable.select_cols`, and :meth:`.MatrixTable.select_entries`) accept; both variable-length (``f(x, y, z)``) and keyword (``f(a=x, b=y, c=z)``); arguments. Select methods will always preserve the key along that axis; e.g. for; :meth:`.Table.select`, the table key will aways be kept. To modify the; key, use :meth:`.key_by`. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a new table with; fields `C1` and `C2` of `table1`, and the table key `ID`. First, variable-length string arguments:. >>> table_result = table1.select('C1', 'C2'). Second, field reference variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, producing a table with one field, `x`.:. >>> table3_result = table3.select(table3.s.x). >>> table3_result = table3.select(x = table3.s.x). The keyword argument syntax permits arbitrary expressions:. >>> table_result =",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:49231,Modifiability,variab,variable-length,49231,"table1.Z - table1.X). Notes; -----; This method creates new row-indexed fields. If a created field shares its name; with a global field of the table, the method will fail. Note; ----. **Using select**. Select and its sibling methods (:meth:`.Table.select_globals`,; :meth:`.MatrixTable.select_globals`, :meth:`.MatrixTable.select_rows`,; :meth:`.MatrixTable.select_cols`, and :meth:`.MatrixTable.select_entries`) accept; both variable-length (``f(x, y, z)``) and keyword (``f(a=x, b=y, c=z)``); arguments. Select methods will always preserve the key along that axis; e.g. for; :meth:`.Table.select`, the table key will aways be kept. To modify the; key, use :meth:`.key_by`. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a new table with; fields `C1` and `C2` of `table1`, and the table key `ID`. First, variable-length string arguments:. >>> table_result = table1.select('C1', 'C2'). Second, field reference variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, producing a table with one field, `x`.:. >>> table3_result = table3.select(table3.s.x). >>> table3_result = table3.select(x = table3.s.x). The keyword argument syntax permits arbitrary expressions:. >>> table_result = table1.select(foo=table1.X ** 2 + 1). These syntaxes can be mixed together, with the stipulation that all keyword arguments; must come at the end due to Python language restrictions. >>> table_result = table1.select(table1.X, 'Z', bar = [table1.C1, table1.C2]). Not",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:49336,Modifiability,variab,variable-length,49336,"field shares its name; with a global field of the table, the method will fail. Note; ----. **Using select**. Select and its sibling methods (:meth:`.Table.select_globals`,; :meth:`.MatrixTable.select_globals`, :meth:`.MatrixTable.select_rows`,; :meth:`.MatrixTable.select_cols`, and :meth:`.MatrixTable.select_entries`) accept; both variable-length (``f(x, y, z)``) and keyword (``f(a=x, b=y, c=z)``); arguments. Select methods will always preserve the key along that axis; e.g. for; :meth:`.Table.select`, the table key will aways be kept. To modify the; key, use :meth:`.key_by`. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a new table with; fields `C1` and `C2` of `table1`, and the table key `ID`. First, variable-length string arguments:. >>> table_result = table1.select('C1', 'C2'). Second, field reference variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, producing a table with one field, `x`.:. >>> table3_result = table3.select(table3.s.x). >>> table3_result = table3.select(x = table3.s.x). The keyword argument syntax permits arbitrary expressions:. >>> table_result = table1.select(foo=table1.X ** 2 + 1). These syntaxes can be mixed together, with the stipulation that all keyword arguments; must come at the end due to Python language restrictions. >>> table_result = table1.select(table1.X, 'Z', bar = [table1.C1, table1.C2]). Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-l",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:49541,Modifiability,variab,variable-length,49541,".select_rows`,; :meth:`.MatrixTable.select_cols`, and :meth:`.MatrixTable.select_entries`) accept; both variable-length (``f(x, y, z)``) and keyword (``f(a=x, b=y, c=z)``); arguments. Select methods will always preserve the key along that axis; e.g. for; :meth:`.Table.select`, the table key will aways be kept. To modify the; key, use :meth:`.key_by`. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a new table with; fields `C1` and `C2` of `table1`, and the table key `ID`. First, variable-length string arguments:. >>> table_result = table1.select('C1', 'C2'). Second, field reference variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, producing a table with one field, `x`.:. >>> table3_result = table3.select(table3.s.x). >>> table3_result = table3.select(x = table3.s.x). The keyword argument syntax permits arbitrary expressions:. >>> table_result = table1.select(foo=table1.X ** 2 + 1). These syntaxes can be mixed together, with the stipulation that all keyword arguments; must come at the end due to Python language restrictions. >>> table_result = table1.select(table1.X, 'Z', bar = [table1.C1, table1.C2]). Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Re",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:50327,Modifiability,variab,variable-length,50327," variable-length arguments:. >>> table_result = table1.select(table1.C1, table1.C2). Last, expression keyword arguments:. >>> table_result = table1.select(C1 = table1.C1, C2 = table1.C2). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, producing a table with one field, `x`.:. >>> table3_result = table3.select(table3.s.x). >>> table3_result = table3.select(x = table3.s.x). The keyword argument syntax permits arbitrary expressions:. >>> table_result = table1.select(foo=table1.X ** 2 + 1). These syntaxes can be mixed together, with the stipulation that all keyword arguments; must come at the end due to Python language restrictions. >>> table_result = table1.select(table1.X, 'Z', bar = [table1.C1, table1.C2]). Note; ----; This method does not support aggregation. Parameters; ----------; exprs : variable-length args of :class:`str` or :class:`.Expression`; Arguments that specify field names or nested field reference expressions.; named_exprs : keyword args of :class:`.Expression`; Field names and the expressions to compute them. Returns; -------; :class:`.Table`; Table with specified fields.; """"""; row = get_select_exprs('Table.select', exprs, named_exprs, self._row_indices, self._row). return self._select('Table.select', row). [docs] @typecheck_method(exprs=oneof(str, Expression)); def drop(self, *exprs) -> 'Table':; """"""Drop fields from the table. Examples; --------. Drop fields `C1` and `C2` using strings:. >>> table_result = table1.drop('C1', 'C2'). Drop fields `C1` and `C2` using field references:. >>> table_result = table1.drop(table1.C1, table1.C2). Drop a list of fields:. >>> fields_to_drop = ['C1', 'C2']; >>> table_result = table1.drop(*fields_to_drop). Notes; -----. This method can be used to drop global or row-indexed fields. The arguments; can be either strings (``'field'``)",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:55265,Modifiability,variab,variable-length,55265,"parallel); Env.backend().execute(; ir.TableWrite(self._tir, ir.TableTextWriter(output, types_file, header, parallel, delimiter)); ). [docs] def group_by(self, *exprs, **named_exprs) -> 'GroupedTable':; """"""Group by a new key for use with :meth:`.GroupedTable.aggregate`. Examples; --------; Compute the mean value of `X` and the sum of `Z` per unique `ID`:. >>> table_result = (table1.group_by(table1.ID); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Group by a height bin and compute sex ratio per bin:. >>> table_result = (table1.group_by(height_bin = table1.HT // 20); ... .aggregate(fraction_female = hl.agg.fraction(table1.SEX == 'F'))). Notes; -----; This function is always followed by :meth:`.GroupedTable.aggregate`. Follow the; link for documentation on the aggregation step. Note; ----; **Using group_by**. **group_by** and its sibling methods (:meth:`.MatrixTable.group_rows_by` and; :meth:`.MatrixTable.group_cols_by`) accept both variable-length (``f(x, y, z)``); and keyword (``f(a=x, b=y, c=z)``) arguments. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a; :class:`.GroupedTable` grouped by fields `C1` and `C2` of `table1`. First, variable-length string arguments:. >>> table_result = (table1.group_by('C1', 'C2'); ... .aggregate(meanX = hl.agg.mean(table1.X))). Second, field reference variable-length arguments:. >>> table_result = (table1.group_by(table1.C1, table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Last, expression keyword arguments:. >>> table_result = (table1.group_by(C1 = table1.C1, C2 = table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:55345,Modifiability,Variab,Variable-length,55345,"el, delimiter)); ). [docs] def group_by(self, *exprs, **named_exprs) -> 'GroupedTable':; """"""Group by a new key for use with :meth:`.GroupedTable.aggregate`. Examples; --------; Compute the mean value of `X` and the sum of `Z` per unique `ID`:. >>> table_result = (table1.group_by(table1.ID); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Group by a height bin and compute sex ratio per bin:. >>> table_result = (table1.group_by(height_bin = table1.HT // 20); ... .aggregate(fraction_female = hl.agg.fraction(table1.SEX == 'F'))). Notes; -----; This function is always followed by :meth:`.GroupedTable.aggregate`. Follow the; link for documentation on the aggregation step. Note; ----; **Using group_by**. **group_by** and its sibling methods (:meth:`.MatrixTable.group_rows_by` and; :meth:`.MatrixTable.group_cols_by`) accept both variable-length (``f(x, y, z)``); and keyword (``f(a=x, b=y, c=z)``) arguments. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a; :class:`.GroupedTable` grouped by fields `C1` and `C2` of `table1`. First, variable-length string arguments:. >>> table_result = (table1.group_by('C1', 'C2'); ... .aggregate(meanX = hl.agg.mean(table1.X))). Second, field reference variable-length arguments:. >>> table_result = (table1.group_by(table1.C1, table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Last, expression keyword arguments:. >>> table_result = (table1.group_by(C1 = table1.C1, C2 = table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, grouping by one field, `x`:. >>> table_result = (table3.group_by(tabl",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:55652,Modifiability,variab,variable-length,55652," (table1.group_by(table1.ID); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Group by a height bin and compute sex ratio per bin:. >>> table_result = (table1.group_by(height_bin = table1.HT // 20); ... .aggregate(fraction_female = hl.agg.fraction(table1.SEX == 'F'))). Notes; -----; This function is always followed by :meth:`.GroupedTable.aggregate`. Follow the; link for documentation on the aggregation step. Note; ----; **Using group_by**. **group_by** and its sibling methods (:meth:`.MatrixTable.group_rows_by` and; :meth:`.MatrixTable.group_cols_by`) accept both variable-length (``f(x, y, z)``); and keyword (``f(a=x, b=y, c=z)``) arguments. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a; :class:`.GroupedTable` grouped by fields `C1` and `C2` of `table1`. First, variable-length string arguments:. >>> table_result = (table1.group_by('C1', 'C2'); ... .aggregate(meanX = hl.agg.mean(table1.X))). Second, field reference variable-length arguments:. >>> table_result = (table1.group_by(table1.C1, table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Last, expression keyword arguments:. >>> table_result = (table1.group_by(C1 = table1.C1, C2 = table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, grouping by one field, `x`:. >>> table_result = (table3.group_by(table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). >>> table_result = (table3.group_by(x = table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). The keyword argument syntax permits arbitrary expressions:. >>> table_result = (table1.group_by(foo=tab",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:55808,Modifiability,variab,variable-length,55808," ratio per bin:. >>> table_result = (table1.group_by(height_bin = table1.HT // 20); ... .aggregate(fraction_female = hl.agg.fraction(table1.SEX == 'F'))). Notes; -----; This function is always followed by :meth:`.GroupedTable.aggregate`. Follow the; link for documentation on the aggregation step. Note; ----; **Using group_by**. **group_by** and its sibling methods (:meth:`.MatrixTable.group_rows_by` and; :meth:`.MatrixTable.group_cols_by`) accept both variable-length (``f(x, y, z)``); and keyword (``f(a=x, b=y, c=z)``) arguments. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a; :class:`.GroupedTable` grouped by fields `C1` and `C2` of `table1`. First, variable-length string arguments:. >>> table_result = (table1.group_by('C1', 'C2'); ... .aggregate(meanX = hl.agg.mean(table1.X))). Second, field reference variable-length arguments:. >>> table_result = (table1.group_by(table1.C1, table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Last, expression keyword arguments:. >>> table_result = (table1.group_by(C1 = table1.C1, C2 = table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, grouping by one field, `x`:. >>> table_result = (table3.group_by(table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). >>> table_result = (table3.group_by(x = table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). The keyword argument syntax permits arbitrary expressions:. >>> table_result = (table1.group_by(foo=table1.X ** 2 + 1); ... .aggregate(meanZ = hl.agg.mean(table1.Z))). These syntaxes can be mixed together, with the stipulation that all keyword arg",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:56115,Modifiability,variab,variable-length,56115,"*group_by** and its sibling methods (:meth:`.MatrixTable.group_rows_by` and; :meth:`.MatrixTable.group_cols_by`) accept both variable-length (``f(x, y, z)``); and keyword (``f(a=x, b=y, c=z)``) arguments. Variable-length arguments can be either strings or expressions that reference a; (possibly nested) field of the table. Keyword arguments can be arbitrary; expressions. **The following three usages are all equivalent**, producing a; :class:`.GroupedTable` grouped by fields `C1` and `C2` of `table1`. First, variable-length string arguments:. >>> table_result = (table1.group_by('C1', 'C2'); ... .aggregate(meanX = hl.agg.mean(table1.X))). Second, field reference variable-length arguments:. >>> table_result = (table1.group_by(table1.C1, table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Last, expression keyword arguments:. >>> table_result = (table1.group_by(C1 = table1.C1, C2 = table1.C2); ... .aggregate(meanX = hl.agg.mean(table1.X))). Additionally, the variable-length argument syntax also permits nested field; references. Given the following struct field `s`:. >>> table3 = table1.annotate(s = hl.struct(x=table1.X, z=table1.Z)). The following two usages are equivalent, grouping by one field, `x`:. >>> table_result = (table3.group_by(table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). >>> table_result = (table3.group_by(x = table3.s.x); ... .aggregate(meanX = hl.agg.mean(table3.X))). The keyword argument syntax permits arbitrary expressions:. >>> table_result = (table1.group_by(foo=table1.X ** 2 + 1); ... .aggregate(meanZ = hl.agg.mean(table1.Z))). These syntaxes can be mixed together, with the stipulation that all keyword arguments; must come at the end due to Python language restrictions. >>> table_result = (table1.group_by(table1.C1, 'C2', height_bin = table1.HT // 20); ... .aggregate(meanX = hl.agg.mean(table1.X))). Note; ----; This method does not support aggregation in key expressions. Arguments; ---------; exprs : varargs of type str or :class:`",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:71872,Modifiability,variab,variable-length,71872,"table1.select(B = table2.index(table1.C1 % 4).B); >>> table_result.show(); +-------+---------+; | ID | B |; +-------+---------+; | int32 | str |; +-------+---------+; | 1 | ""dog"" |; | 2 | ""dog"" |; | 3 | ""dog"" |; | 4 | ""mouse"" |; +-------+---------+. Notes; -----; :meth:`.Table.index` is used to expose one table's fields for use in; expressions involving the another table or matrix table's fields. The; result of the method call is a struct expression that is usable in the; same scope as `exprs`, just as if `exprs` were used to look up values of; the table in a dictionary. The type of the struct expression is the same as the indexed table's; :meth:`.row_value` (the key fields are removed, as they are available; in the form of the index expressions). Note; ----; There is a shorthand syntax for :meth:`.Table.index` using square; brackets (the Python ``__getitem__`` syntax). This syntax is preferred. >>> table_result = table1.select(B = table2[table1.ID].B). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Returns; -------; :class:`.Expression`; """"""; try:; return self._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index table with given expressions:\n""; f"" Table key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" Index Expressions: {', '.join(str(e.dtype) for e in err.index_expressions)}""; ). @staticmethod; def _maybe_truncate_for_flexindex(indexer, indexee_dtype):; if not len(indexee_dtype) > 0:; raise ValueError('Must have non-empty key to index'). if not isinstance(indexer.dtype, (hl.tstruct, hl.ttuple)):; indexer = hl.tuple([indexer]). matching_prefix = 0; for x, y in zip(indexer.dtype.types, indexee_dtype.types):; if x != y:; break; matching_prefix += 1; prefix_match = matching_prefix == len(indexee_dtype); direc",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:78155,Modifiability,extend,extend,78155,"e(; ir.MatrixMapRows(; mart,; ir.InsertFields(; ir.Ref('va', mart.typ.row_type),; [; (; uid,; ir.Apply(; 'get',; join_table._row_type[uid].value_type,; ir.GetField(ir.GetField(ir.Ref('va', mart.typ.row_type), uid), uid),; ir.MakeTuple([e._ir for e in exprs]),; ),; ); ],; None,; ),; ); ). else:. def joiner(left: MatrixTable):; return MatrixTable(ir.MatrixAnnotateRowsTable(left._mir, right._tir, uid, all_matches)). ast = ir.Join(ir.ProjectedTopLevelReference('va', uid, new_schema), [uid], exprs, joiner); return construct_expr(ast, new_schema, indices, aggregations); elif indices == src._col_indices and not (is_interval and all_matches):; all_uids = [uid]; if len(exprs) == len(src.col_key) and all([exprs[i] is src.col_key[i] for i in range(len(exprs))]):; # key is already correct; def joiner(left):; return MatrixTable(ir.MatrixAnnotateColsTable(left._mir, right._tir, uid)). else:; index_uid = Env.get_uid(); uids = [Env.get_uid() for _ in exprs]. all_uids.append(index_uid); all_uids.extend(uids). def joiner(left: MatrixTable):; prev_key = list(src.col_key); joined = (; src.annotate_cols(**dict(zip(uids, exprs))); .add_col_index(index_uid); .key_cols_by(*uids); .cols(); .select(index_uid); .join(self, 'inner'); .key_by(index_uid); .drop(*uids); ); result = MatrixTable(; ir.MatrixAnnotateColsTable(; (left.add_col_index(index_uid).key_cols_by(index_uid)._mir), joined._tir, uid; ); ).key_cols_by(*prev_key); return result. join_ir = ir.Join(ir.ProjectedTopLevelReference('sa', uid, new_schema), all_uids, exprs, joiner); return construct_expr(join_ir, new_schema, indices, aggregations); else:; raise NotImplementedError(); else:; raise TypeError(""Cannot join with expressions derived from '{}'"".format(src.__class__)). [docs] def index_globals(self) -> 'StructExpression':; """"""Return this table's global variables for use in another; expression context. Examples; --------; >>> table_result = table2.annotate(C = table2.A * table1.index_globals().global_field_1). Returns; -------; :cl",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:78981,Modifiability,variab,variables,78981,"eft):; return MatrixTable(ir.MatrixAnnotateColsTable(left._mir, right._tir, uid)). else:; index_uid = Env.get_uid(); uids = [Env.get_uid() for _ in exprs]. all_uids.append(index_uid); all_uids.extend(uids). def joiner(left: MatrixTable):; prev_key = list(src.col_key); joined = (; src.annotate_cols(**dict(zip(uids, exprs))); .add_col_index(index_uid); .key_cols_by(*uids); .cols(); .select(index_uid); .join(self, 'inner'); .key_by(index_uid); .drop(*uids); ); result = MatrixTable(; ir.MatrixAnnotateColsTable(; (left.add_col_index(index_uid).key_cols_by(index_uid)._mir), joined._tir, uid; ); ).key_cols_by(*prev_key); return result. join_ir = ir.Join(ir.ProjectedTopLevelReference('sa', uid, new_schema), all_uids, exprs, joiner); return construct_expr(join_ir, new_schema, indices, aggregations); else:; raise NotImplementedError(); else:; raise TypeError(""Cannot join with expressions derived from '{}'"".format(src.__class__)). [docs] def index_globals(self) -> 'StructExpression':; """"""Return this table's global variables for use in another; expression context. Examples; --------; >>> table_result = table2.annotate(C = table2.A * table1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:86532,Modifiability,extend,extend,86532,"ntain the; field. If a field appears in multiple tables with incompatible types,; like arrays and strings, then an error will be raised. Parameters; ----------; tables : varargs of :class:`.Table`; Tables to union.; unify : :obj:`bool`; Attempt to unify table field. Returns; -------; :class:`.Table`; Table with all rows from each component table.; """"""; left_key = self.key.dtype; for (; i,; ht,; ) in enumerate(tables):; if left_key != ht.key.dtype:; raise ValueError(; f""'union': table {i} has a different key.""; f"" Expected: {left_key}\n""; f"" Table {i}: {ht.key.dtype}""; ). if not (unify or ht.row.dtype == self.row.dtype):; raise ValueError(; f""'union': table {i} has a different row type.\n""; f"" Expected: {self.row.dtype}\n""; f"" Table {i}: {ht.row.dtype}\n""; f"" If the tables have the same fields in different orders, or some\n""; f"" common and some unique fields, then the 'unify' parameter may be\n""; f"" able to coerce the tables to a common type.""; ); all_tables = [self]; all_tables.extend(tables). if unify and not len(set(ht.row_value.dtype for ht in all_tables)) == 1:; discovered = collections.defaultdict(dict); for i, ht in enumerate(all_tables):; for field_name in ht.row_value:; discovered[field_name][i] = ht[field_name]; all_fields = [{} for _ in all_tables]; for field_name, expr_dict in discovered.items():; *unified, can_unify = hl.expr.expressions.unify_exprs(*expr_dict.values()); if not can_unify:; raise ValueError(; f""cannot unify field {field_name!r}: found fields of types ""; f""{[str(t) for t in {e.dtype for e in expr_dict.values()}]}""; ); unified_map = dict(zip(expr_dict.keys(), unified)); default = hl.missing(unified[0].dtype); for i in range(len(all_tables)):; all_fields[i][field_name] = unified_map.get(i, default). for i, t in enumerate(all_tables):; all_tables[i] = t.select(**all_fields[i]). return Table(ir.TableUnion([table._tir for table in all_tables])). [docs] @typecheck_method(n=int, _localize=bool); def take(self, n, _localize=True):; """"""Collect the f",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:5285,Performance,optimiz,optimizer,5285,"lf._fields = other._fields; self._fields_inverse = other._fields_inverse. [docs]class GroupedTable(ExprContainer):; """"""Table grouped by row that can be aggregated into a new table. There are only two operations on a grouped table, :meth:`.GroupedTable.partition_hint`; and :meth:`.GroupedTable.aggregate`.; """""". def __init__(self, parent: 'Table', key_expr):; super(GroupedTable, self).__init__(); self._key_expr = key_expr; self._parent = parent; self._npartitions = None; self._buffer_size = 50. self._copy_fields_from(parent). [docs] def partition_hint(self, n: int) -> 'GroupedTable':; """"""Set the target number of partitions for aggregation. Examples; --------. Use `partition_hint` in a :meth:`.Table.group_by` / :meth:`.GroupedTable.aggregate`; pipeline:. >>> table_result = (table1.group_by(table1.ID); ... .partition_hint(5); ... .aggregate(meanX = hl.agg.mean(table1.X), sumZ = hl.agg.sum(table1.Z))). Notes; -----; Until Hail's query optimizer is intelligent enough to sample records at all; stages of a pipeline, it can be necessary in some places to provide some; explicit hints. The default number of partitions for :meth:`.GroupedTable.aggregate` is the; number of partitions in the upstream table. If the aggregation greatly; reduces the size of the table, providing a hint for the target number of; partitions can accelerate downstream operations. Parameters; ----------; n : int; Number of partitions. Returns; -------; :class:`.GroupedTable`; Same grouped table with a partition hint.; """"""; self._npartitions = n; return self. def _set_buffer_size(self, n: int) -> 'GroupedTable':; """"""Set the map-side combiner buffer size (in rows). Parameters; ----------; n : int; Buffer size. Returns; -------; :class:`.GroupedTable`; Same grouped table with a buffer size.; """"""; if n <= 0:; raise ValueError(n); self._buffer_size = n; return self. [docs] @typecheck_method(named_exprs=expr_any); def aggregate(self, **named_exprs) -> 'Table':; """"""Aggregate by group, used after :meth:`.Table.gro",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:13155,Performance,load,loaded,13155,"self):; """"""Returns the number of partitions in the table. Examples; --------. Range tables can be constructed with an explicit number of partitions:. >>> ht = hl.utils.range_table(100, n_partitions=10); >>> ht.n_partitions(); 10. Small files are often imported with one partition:. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True); >>> ht2.n_partitions(); 1. The `min_partitions` argument to :func:`.import_table` forces more partitions, but it can; produce empty partitions. Empty partitions do not affect correctness but introduce; unnecessary extra bookkeeping that slows down the pipeline. >>> ht2 = hl.import_table('data/coordinate_matrix.tsv', impute=True, min_partitions=10); >>> ht2.n_partitions(); 10. Returns; -------; :obj:`int`; Number of partitions. """"""; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'NPartitionsTable'})). [docs] def count(self):; """"""Count the number of rows in the table. Examples; --------. Count the number of rows in a table loaded from 'data/kt_example1.tsv'. Each line of the TSV; becomes one row in the Hail Table. >>> ht = hl.import_table('data/kt_example1.tsv', impute=True); >>> ht.count(); 4. Returns; -------; :obj:`int`; The number of rows in the table. """"""; return Env.backend().execute(ir.TableCount(self._tir)). async def _async_count(self):; return await Env.backend()._async_execute(ir.TableCount(self._tir)). def _force_count(self):; return Env.backend().execute(ir.TableToValueApply(self._tir, {'name': 'ForceCountTable'})). async def _async_force_count(self):; return await Env.backend()._async_execute(ir.TableToValueApply(self._tir, {'name': 'ForceCountTable'})). @typecheck_method(caller=str, row=expr_struct()); def _select(self, caller, row) -> 'Table':; analyze(caller, row, self._row_indices); base, cleanup = self._process_joins(row); return cleanup(Table(ir.TableMapRows(base._tir, row._ir))). @typecheck_method(caller=str, s=expr_struct()); def _select_globals(self, caller, s) -> 'Table':; base",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:42454,Performance,optimiz,optimization,42454,"---+; | HT_DESCRIPTION |; +----------------+; | str |; +----------------+; | ""sixty-five"" |; | ""seventy-two"" |; | ""seventy"" |; | ""sixty"" |; +----------------+. Parameters; ----------; named_exprs : keyword args of :class:`.Expression`; Expressions for new fields. Returns; -------; :class:`.Table`; Table with new fields. """"""; caller = ""Table.annotate""; check_annotate_exprs(caller, named_exprs, self._row_indices, set()); return self._select(caller, self.row.annotate(**named_exprs)). [docs] @typecheck_method(expr=expr_bool, keep=bool); def filter(self, expr, keep: bool = True) -> 'Table':; """"""Filter rows conditional on the value of each row's fields. Note; ----. Hail will can read much less data if a Table filter condition references the key field and; the Table is stored in Hail native format (i.e. read using :func:`.read_table`, _not_; :func:`.import_table`). In other words: filtering on the key will make a pipeline faster by; reading fewer rows. This optimization is prevented by certain operations appearing between a; :func:`.read_table` and a :meth:`.filter`. For example, a `key_by` and `group_by`, both; force reading all the data. Suppose we previously :meth:`.write` a Hail Table with one million rows keyed by a field; called `idx`. If we filter this table to one value of `idx`, the pipeline will be fast; because we read only the rows that have that value of `idx`:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx == 5) # doctest: +SKIP. This also works with inequality conditions:. >>> ht = hl.read_table('large-table.ht') # doctest: +SKIP; >>> ht = ht.filter(ht.idx <= 5) # doctest: +SKIP. Examples; --------. Consider this table:. >>> ht = ht.drop('C1', 'C2', 'C3'); >>> ht.show(); +-------+-------+-----+-------+-------+; | ID | HT | SEX | X | Z |; +-------+-------+-----+-------+-------+; | int32 | int32 | str | int32 | int32 |; +-------+-------+-----+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 |; | 2 | 72 | ""M"" | 6 | 3 |; | 3 | 70 | ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:79358,Performance,cache,cache,79358,"ner'); .key_by(index_uid); .drop(*uids); ); result = MatrixTable(; ir.MatrixAnnotateColsTable(; (left.add_col_index(index_uid).key_cols_by(index_uid)._mir), joined._tir, uid; ); ).key_cols_by(*prev_key); return result. join_ir = ir.Join(ir.ProjectedTopLevelReference('sa', uid, new_schema), all_uids, exprs, joiner); return construct_expr(join_ir, new_schema, indices, aggregations); else:; raise NotImplementedError(); else:; raise TypeError(""Cannot join with expressions derived from '{}'"".format(src.__class__)). [docs] def index_globals(self) -> 'StructExpression':; """"""Return this table's global variables for use in another; expression context. Examples; --------; >>> table_result = table2.annotate(C = table2.A * table1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apach",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:79484,Performance,cache,cache,79484,"index_uid).key_cols_by(index_uid)._mir), joined._tir, uid; ); ).key_cols_by(*prev_key); return result. join_ir = ir.Join(ir.ProjectedTopLevelReference('sa', uid, new_schema), all_uids, exprs, joiner); return construct_expr(join_ir, new_schema, indices, aggregations); else:; raise NotImplementedError(); else:; raise TypeError(""Cannot join with expressions derived from '{}'"".format(src.__class__)). [docs] def index_globals(self) -> 'StructExpression':; """"""Return this table's global variables for use in another; expression context. Examples; --------; >>> table_result = table2.annotate(C = table2.A * table1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Par",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:79640,Performance,Cache,Cached,79640,"ence('sa', uid, new_schema), all_uids, exprs, joiner); return construct_expr(join_ir, new_schema, indices, aggregations); else:; raise NotImplementedError(); else:; raise TypeError(""Cannot join with expressions derived from '{}'"".format(src.__class__)). [docs] def index_globals(self) -> 'StructExpression':; """"""Return this table's global variables for use in another; expression context. Examples; --------; >>> table_result = table2.annotate(C = table2.A * table1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMO",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80028,Performance,cache,cache,80028,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80149,Performance,perform,performance,80149,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:84723,Performance,perform,performance,84723,"PUT_CHECK; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 | idx |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 | int64 |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | 1 | 65 | M | 5 | 4 | 2 | 50 | 5 | 0 |; | 2 | 72 | M | 6 | 3 | 2 | 61 | 1 | 1 |; | 3 | 70 | F | 7 | 3 | 10 | 81 | -5 | 2 |; | 4 | 60 | F | 8 | 2 | 11 | 90 | -10 | 3 |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+. Notes; -----. This method returns a table with a new field whose name is given by; the `name` parameter, with type :py:data:`.tint64`. The value of this field; is the integer index of each row, starting from 0. Methods that respect; ordering (like :meth:`.Table.take` or :meth:`.Table.export`) will; return rows in order. This method is also helpful for creating a unique integer index for; rows of a table so that more complex types can be encoded as a simple; number for performance reasons. Parameters; ----------; name : str; Name of index field. Returns; -------; :class:`.Table`; Table with a new index field.; """""". return self.annotate(**{name: hl.scan.count()}). [docs] @typecheck_method(tables=table_type, unify=bool); def union(self, *tables, unify: bool = False) -> 'Table':; """"""Union the rows of multiple tables. Examples; --------. Take the union of rows from two tables:. >>> union_table = table1.union(other_table). Notes; -----; If a row appears in more than one table identically, it is duplicated; in the result. All tables must have the same key names and types. They; must also have the same row types, unless the `unify` parameter is; ``True``, in which case a field appearing in any table will be included; in the result, with missing values for tables that do not contain the; field. If a field appears in multiple tables with incompatible types,; like arrays and strings, then an err",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:92697,Performance,perform,performance,92697,"loat`; Probability of keeping each row.; seed : :obj:`int`; Random seed. Returns; -------; :class:`.Table`; Table with approximately ``p * n_rows`` rows.; """""". if not 0 <= p <= 1:; raise ValueError(""Requires 'p' in [0,1]. Found p={}"".format(p)). return self.filter(hl.rand_bool(p, seed)). [docs] @typecheck_method(n=int, shuffle=bool); def repartition(self, n, shuffle=True) -> 'Table':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> table_result = table1.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a table with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80104,Safety,avoid,avoid,80104,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80110,Safety,redund,redundant,80110,"ble1.index_globals().global_field_1). Returns; -------; :class:`.StructExpression`; """"""; return construct_expr(ir.TableGetGlobals(self._tir), self.globals.dtype). def _process_joins(self, *exprs) -> 'Table':; return process_joins(self, exprs). [docs] def cache(self) -> 'Table':; """"""Persist this table in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93257,Safety,avoid,avoid,93257," with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a table with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; )",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:103081,Safety,avoid,avoid,103081,"esulting table can be larger than; the number of records on the left or right if duplicate keys are; present. Parameters; ----------; right : :class:`.Table`; Table to join.; how : :class:`str`; Join type. One of ""inner"", ""left"", ""right"", ""outer"". Returns; -------; :class:`.Table`; Joined table. """"""; if _join_key is None:; _join_key = max(len(self.key), len(right.key)). left_key_types = list(self.key.dtype.values())[:_join_key]; right_key_types = list(right.key.dtype.values())[:_join_key]; if not left_key_types == right_key_types:; raise ValueError(; f""'join': key mismatch:\n ""; f"" left: [{', '.join(str(t) for t in left_key_types)}]\n ""; f"" right: [{', '.join(str(t) for t in right_key_types)}]""; ); left_fields = set(self._fields); right_fields = set(right._fields) - set(right.key). renames, _ = deduplicate(right_fields, max_attempts=100, already_used=left_fields). if renames:; renames = dict(renames); right = right.rename(renames); info(; 'Table.join: renamed the following fields on the right to avoid name conflicts:'; + ''.join(f'\n {k!r} -> {v!r}' for k, v in renames.items()); ). return Table(ir.TableJoin(self._tir, right._tir, how, _join_key)). [docs] @typecheck_method(expr=BooleanExpression); def all(self, expr):; """"""Evaluate whether a boolean expression is true for all rows. Examples; --------; Test whether `C1` is greater than 5 in all rows of the table:. >>> if table1.all(table1.C1 == 5):; ... print(""All rows have C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Expression to test. Returns; -------; :obj:`bool`; """"""; return self.aggregate(hl.agg.all(expr)). [docs] @typecheck_method(expr=BooleanExpression); def any(self, expr):; """"""Evaluate whether a Boolean expression is true for at least one row. Examples; --------. Test whether `C1` is equal to 5 any row in any row of the table:. >>> if table1.any(table1.C1 == 5):; ... print(""At least one row has C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Boolean exp",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:70137,Security,Expose,Expose,70137,"-+-------+. Notes; -----; The output can be passed piped to another output source using the `handler` argument:. >>> ht.show(handler=lambda x: logging.info(x)) # doctest: +SKIP. Parameters; ----------; n or n_rows : :obj:`int`; Maximum number of rows to show, or negative to show all rows.; width : :obj:`int`; Horizontal width at which to break fields.; truncate : :obj:`int`, optional; Truncate each field to the given number of characters. If; ``None``, truncate fields to the given `width`.; types : :obj:`bool`; Print an extra header line with the type of each field.; handler : Callable[[str], Any]; Handler function for data string.; """"""; if n_rows is not None and n is not None:; raise ValueError(f'specify one of n_rows or n, received {n_rows} and {n}'); if n_rows is not None:; n = n_rows; del n_rows; if handler is None:; handler = hl.utils.default_handler(); return handler(self._show(n, width, truncate, types)). [docs] def index(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the row values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; In the example below, both `table1` and `table2` are keyed by one; field `ID` of type ``int``. >>> table_result = table1.select(B = table2.index(table1.ID).B); >>> table_result.B.show(); +-------+----------+; | ID | B |; +-------+----------+; | int32 | str |; +-------+----------+; | 1 | ""cat"" |; | 2 | ""dog"" |; | 3 | ""mouse"" |; | 4 | ""rabbit"" |; +-------+----------+. Using `key` as the sole index expression is equivalent to passing all; key fields individually:. >>> table_result = table1.select(B = table2.index(table1.key).B). It is also possible to use non-key fields or expressions as the index; expressions:. >>> table_result = table1.select(B = table2.index(table1.C1 % 4).B); >>> table_result.show(); +-------+---------+; | ID | B |; +-------+---------+; | int32 | str |; +-------+---------+; | 1 | ""dog"" |; | 2 | ""dog"" |; | 3 | ""dog"" |; | 4 | ""mouse"" |; +-------+---------+. Notes; -----; :met",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:71168,Security,expose,expose,71168,"prs`. Examples; --------; In the example below, both `table1` and `table2` are keyed by one; field `ID` of type ``int``. >>> table_result = table1.select(B = table2.index(table1.ID).B); >>> table_result.B.show(); +-------+----------+; | ID | B |; +-------+----------+; | int32 | str |; +-------+----------+; | 1 | ""cat"" |; | 2 | ""dog"" |; | 3 | ""mouse"" |; | 4 | ""rabbit"" |; +-------+----------+. Using `key` as the sole index expression is equivalent to passing all; key fields individually:. >>> table_result = table1.select(B = table2.index(table1.key).B). It is also possible to use non-key fields or expressions as the index; expressions:. >>> table_result = table1.select(B = table2.index(table1.C1 % 4).B); >>> table_result.show(); +-------+---------+; | ID | B |; +-------+---------+; | int32 | str |; +-------+---------+; | 1 | ""dog"" |; | 2 | ""dog"" |; | 3 | ""dog"" |; | 4 | ""mouse"" |; +-------+---------+. Notes; -----; :meth:`.Table.index` is used to expose one table's fields for use in; expressions involving the another table or matrix table's fields. The; result of the method call is a struct expression that is usable in the; same scope as `exprs`, just as if `exprs` were used to look up values of; the table in a dictionary. The type of the struct expression is the same as the indexed table's; :meth:`.row_value` (the key fields are removed, as they are available; in the form of the index expressions). Note; ----; There is a shorthand syntax for :meth:`.Table.index` using square; brackets (the Python ``__getitem__`` syntax). This syntax is preferred. >>> table_result = table1.select(B = table2[table1.ID].B). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Returns; -------; :class:`.Expression`; """"""; try:; return self._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mis",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:81648,Security,access,accessed,81648,"ND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().unpersist(self). @overload; def collect(self) -> List[hl.Struct]: ... @overload; def collect(self, _localize=False) -> ArrayExpression: ... [docs] @typecheck_method(_localize=bool, _timed=bool); def collect(self, _localize=True, *, _timed=False):; """"""Collect the rows of the table into a local list. Examples; --------; Collect a list of all `X` records:. >>> all_xs = [row['X'] for row in table1.select(table1.X).collect()]. Notes; -----; This method returns a list whose elements are of type :class:`.Struct`. Fields; of these structs can be accessed similarly to fields on a table, using dot; methods (``struct.foo``) or string indexing (``struct['foo']``). Warning; -------; Using this method can cause out of memory errors. Only collect small tables. Returns; -------; :obj:`list` of :class:`.Struct`; List of rows.; """"""; if len(self.key) > 0:; t = self.order_by(*self.key); else:; t = self; rows_ir = ir.GetField(ir.TableCollect(t._tir), 'rows'); e = construct_expr(rows_ir, hl.tarray(t.row.dtype)); if _localize:; return Env.backend().execute(e._ir, timed=_timed); else:; return e. [docs] def describe(self, handler=print, *, widget=False):; """"""Print information about the fields in the table. Note; ----; The `widget` argument is **experimental**. Parameters; ----------; handler : Callable[[str], None]; Handler function for returned string.; widget : bool; Create an interactive IPython widget.; """"""; if widget:; from hail.experimental.interact import interact. return interact(self). def format_type(typ):; return typ.pretty(indent=4).lstrip(). if len(",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:370,Testability,Log,Log,370,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:3105,Testability,assert,assert,3105,"xpressions. class Ascending:; def __init__(self, col):; self.col = col. def __eq__(self, other):; return isinstance(other, Ascending) and self.col == other.col. def __ne__(self, other):; return not self == other. class Descending:; def __init__(self, col):; self.col = col. def __eq__(self, other):; return isinstance(other, Descending) and self.col == other.col. def __ne__(self, other):; return not self == other. [docs]@typecheck(col=oneof(Expression, str)); def asc(col):; """"""Sort by `col` ascending."""""". return Ascending(col). [docs]@typecheck(col=oneof(Expression, str)); def desc(col):; """"""Sort by `col` descending."""""". return Descending(col). class ExprContainer:; # this can only grow as big as the object dir, so no need to worry about memory leak; _warned_about: ClassVar = set(). def __init__(self):; self._fields: Dict[str, Expression] = {}; self._fields_inverse: Dict[Expression, str] = {}; self._dir = set(dir(self)); super(ExprContainer, self).__init__(). def _set_field(self, key, value):; assert key not in self._fields_inverse, key; self._fields[key] = value; self._fields_inverse[value] = key. # key is in __dir for methods; # key is in __dict__ for private class fields; if key in self._dir or key in self.__dict__:; if key not in ExprContainer._warned_about:; ExprContainer._warned_about.add(key); warning(; f""Name collision: field {key!r} already in object dict. ""; f""\n This field must be referenced with __getitem__ syntax: obj[{key!r}]""; ); else:; self.__dict__[key] = value. def _get_field(self, item) -> Expression:; if item in self._fields:; return self._fields[item]. raise LookupError(get_nice_field_error(self, item)). def __iter__(self):; raise TypeError(f""'{self.__class__.__name__}' object is not iterable""). def __delattr__(self, item):; if not item[0] == '_':; raise NotImplementedError(f""'{self.__class__.__name__}' object is not mutable""). def __setattr__(self, key, value):; if not key[0] == '_':; raise NotImplementedError(f""'{self.__class__.__name__}' object ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:16377,Testability,log,login,16377,"5, 'b': 10}, {'a': 0, 'b': 200}],; ... schema=hl.tstruct(a=hl.tint, b=hl.tint),; ... key='a'; ... ); >>> t.show(); +-------+-------+; | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also elide schema entirely and let Hail guess the type. The list elements must; either be Hail :class:`.Struct` or :class:`.dict` s. >>> t = hl.Table.parallelize(; ... [{'a': 5, 'b': 10}, {'a': 0, 'b': 200}],; ... key='a'; ... ); >>> t.show(); +-------+-------+; | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also specify only a handful of types in `partial_type`. Hail will automatically; deduce the types of the other fields. Hail _cannot_ deduce the type of a field which only; contains empty arrays (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+------------",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:16506,Testability,log,login,16506," | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also elide schema entirely and let Hail guess the type. The list elements must; either be Hail :class:`.Struct` or :class:`.dict` s. >>> t = hl.Table.parallelize(; ... [{'a': 5, 'b': 10}, {'a': 0, 'b': 200}],; ... key='a'; ... ); >>> t.show(); +-------+-------+; | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also specify only a handful of types in `partial_type`. Hail will automatically; deduce the types of the other fields. Hail _cannot_ deduce the type of a field which only; contains empty arrays (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+--------------------+-----------------+----------+; | 10038 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10037 | ""open"" | ""daniel-goldstein"" | ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:16642,Testability,log,login,16642,"e schema entirely and let Hail guess the type. The list elements must; either be Hail :class:`.Struct` or :class:`.dict` s. >>> t = hl.Table.parallelize(; ... [{'a': 5, 'b': 10}, {'a': 0, 'b': 200}],; ... key='a'; ... ); >>> t.show(); +-------+-------+; | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also specify only a handful of types in `partial_type`. Hail will automatically; deduce the types of the other fields. Hail _cannot_ deduce the type of a field which only; contains empty arrays (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+--------------------+-----------------+----------+; | 10038 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10037 | ""open"" | ""daniel-goldstein"" | False | 24440116 |; | 10036 | ""open"" | ""jigold"" | False | 1693348 |; | 10035 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10033 | ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:16767,Testability,log,login,16767," t = hl.Table.parallelize(; ... [{'a': 5, 'b': 10}, {'a': 0, 'b': 200}],; ... key='a'; ... ); >>> t.show(); +-------+-------+; | a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also specify only a handful of types in `partial_type`. Hail will automatically; deduce the types of the other fields. Hail _cannot_ deduce the type of a field which only; contains empty arrays (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+--------------------+-----------------+----------+; | 10038 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10037 | ""open"" | ""daniel-goldstein"" | False | 24440116 |; | 10036 | ""open"" | ""jigold"" | False | 1693348 |; | 10035 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10033 | ""open"" | ""tpoterba"" | False | 10562794 |; +--------+--------+--------------------+-----------------+----------+; +-----------+",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:16895,Testability,log,login,16895," a | b |; +-------+-------+; | int32 | int32 |; +-------+-------+; | 0 | 200 |; | 5 | 10 |; +-------+-------+. You may also specify only a handful of types in `partial_type`. Hail will automatically; deduce the types of the other fields. Hail _cannot_ deduce the type of a field which only; contains empty arrays (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+--------------------+-----------------+----------+; | 10038 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10037 | ""open"" | ""daniel-goldstein"" | False | 24440116 |; | 10036 | ""open"" | ""jigold"" | False | 1693348 |; | 10035 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10033 | ""open"" | ""tpoterba"" | False | 10562794 |; +--------+--------+--------------------+-----------------+----------+; +-----------+------------+; | milestone | labels |; +-----------+------------+; | str | array<str> |; +-----------+------------+; | NA | [] |",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:17223,Testability,log,login,17223," (the element type is unspecified), so we specify the type of labels; explicitly. >>> dictionaries = [; ... {""number"":10038,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794}, ""milestone"":None,""labels"":[]},; ... {""number"":10037,""state"":""open"",""user"":{""login"":""daniel-goldstein"",""site_admin"":False,""id"":24440116},""milestone"":None,""labels"":[]},; ... {""number"":10036,""state"":""open"",""user"":{""login"":""jigold"",""site_admin"":False,""id"":1693348},""milestone"":None,""labels"":[]},; ... {""number"":10035,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... {""number"":10033,""state"":""open"",""user"":{""login"":""tpoterba"",""site_admin"":False,""id"":10562794},""milestone"":None,""labels"":[]},; ... ]; >>> t = hl.Table.parallelize(; ... dictionaries,; ... partial_type={""milestone"": hl.tstr, ""labels"": hl.tarray(hl.tstr)}; ... ); >>> t.show(); +--------+--------+--------------------+-----------------+----------+; | number | state | user.login | user.site_admin | user.id |; +--------+--------+--------------------+-----------------+----------+; | int32 | str | str | bool | int32 |; +--------+--------+--------------------+-----------------+----------+; | 10038 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10037 | ""open"" | ""daniel-goldstein"" | False | 24440116 |; | 10036 | ""open"" | ""jigold"" | False | 1693348 |; | 10035 | ""open"" | ""tpoterba"" | False | 10562794 |; | 10033 | ""open"" | ""tpoterba"" | False | 10562794 |; +--------+--------+--------------------+-----------------+----------+; +-----------+------------+; | milestone | labels |; +-----------+------------+; | str | array<str> |; +-----------+------------+; | NA | [] |; | NA | [] |; | NA | [] |; | NA | [] |; | NA | [] |; +-----------+------------+. Parallelizing with a specified number of partitions:. >>> rows = [ {'a': i} for i in range(100) ]; >>> ht = hl.Table.parallelize(rows, n_partitions=10); >>> ht.n_partitions(); 10; >>> ht.count(); 100. Parallelizing with some global",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:51959,Testability,assert,assert,51959,"t = table1.drop('C1', 'C2'). Drop fields `C1` and `C2` using field references:. >>> table_result = table1.drop(table1.C1, table1.C2). Drop a list of fields:. >>> fields_to_drop = ['C1', 'C2']; >>> table_result = table1.drop(*fields_to_drop). Notes; -----. This method can be used to drop global or row-indexed fields. The arguments; can be either strings (``'field'``), or top-level field references; (``table.field`` or ``table['field']``). Parameters; ----------; exprs : varargs of :class:`str` or :class:`.Expression`; Names of fields to drop or field reference expressions. Returns; -------; :class:`.Table`; Table without specified fields.; """"""; all_field_exprs = {e: k for k, e in self._fields.items()}; fields_to_drop = set(); for e in exprs:; if isinstance(e, Expression):; if e in all_field_exprs:; fields_to_drop.add(all_field_exprs[e]); else:; raise ExpressionException(; ""method 'drop' expects string field names or top-level field expressions"" "" (e.g. table['foo'])""; ); else:; assert isinstance(e, str); if e not in self._fields:; raise IndexError(""table has no field '{}'"".format(e)); fields_to_drop.add(e). table = self; if any(self._fields[field]._indices == self._global_indices for field in fields_to_drop):; # need to drop globals; table = table._select_globals(; 'drop', self._globals.drop(*[f for f in table.globals if f in fields_to_drop]); ). if any(self._fields[field]._indices == self._row_indices for field in fields_to_drop):; # need to drop row fields; protected_key = set(self._row_indices.protected_key); for f in fields_to_drop:; check_keys('drop', f, protected_key); row_fields = set(table.row); to_drop = [f for f in fields_to_drop if f in row_fields]; table = table._select('drop', table.row.drop(*to_drop)). return table. [docs] @typecheck_method(; output=str, types_file=nullable(str), header=bool, parallel=nullable(ir.ExportType.checker), delimiter=str; ); def export(self, output, types_file=None, header=True, parallel=None, delimiter='\t'):; """"""Export to a t",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:69283,Testability,log,logging,69283,"able(int),; width=nullable(int),; truncate=nullable(int),; types=bool,; handler=nullable(anyfunc),; n_rows=nullable(int),; ); def show(self, n=None, width=None, truncate=None, types=True, handler=None, n_rows=None):; """"""Print the first few rows of the table to the console. Examples; --------; Show the first lines of the table:. >>> table1.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | ""M"" | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | ""F"" | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | ""F"" | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+. Notes; -----; The output can be passed piped to another output source using the `handler` argument:. >>> ht.show(handler=lambda x: logging.info(x)) # doctest: +SKIP. Parameters; ----------; n or n_rows : :obj:`int`; Maximum number of rows to show, or negative to show all rows.; width : :obj:`int`; Horizontal width at which to break fields.; truncate : :obj:`int`, optional; Truncate each field to the given number of characters. If; ``None``, truncate fields to the given `width`.; types : :obj:`bool`; Print an extra header line with the type of each field.; handler : Callable[[str], Any]; Handler function for data string.; """"""; if n_rows is not None and n is not None:; raise ValueError(f'specify one of n_rows or n, received {n_rows} and {n}'); if n_rows is not None:; n = n_rows; del n_rows; if handler is None:; handler = hl.utils.default_handler(); return handler(self._show(n, width, truncate, types)). [docs] def index(self, *exprs, all_matches=False) -> 'Expression':; """"""Expose the row values as if looked up in a dictionary, indexing; with `exprs`. Examples; --------; In the example below, both `table1` and ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:103391,Testability,Test,Test,103391,"len(self.key), len(right.key)). left_key_types = list(self.key.dtype.values())[:_join_key]; right_key_types = list(right.key.dtype.values())[:_join_key]; if not left_key_types == right_key_types:; raise ValueError(; f""'join': key mismatch:\n ""; f"" left: [{', '.join(str(t) for t in left_key_types)}]\n ""; f"" right: [{', '.join(str(t) for t in right_key_types)}]""; ); left_fields = set(self._fields); right_fields = set(right._fields) - set(right.key). renames, _ = deduplicate(right_fields, max_attempts=100, already_used=left_fields). if renames:; renames = dict(renames); right = right.rename(renames); info(; 'Table.join: renamed the following fields on the right to avoid name conflicts:'; + ''.join(f'\n {k!r} -> {v!r}' for k, v in renames.items()); ). return Table(ir.TableJoin(self._tir, right._tir, how, _join_key)). [docs] @typecheck_method(expr=BooleanExpression); def all(self, expr):; """"""Evaluate whether a boolean expression is true for all rows. Examples; --------; Test whether `C1` is greater than 5 in all rows of the table:. >>> if table1.all(table1.C1 == 5):; ... print(""All rows have C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Expression to test. Returns; -------; :obj:`bool`; """"""; return self.aggregate(hl.agg.all(expr)). [docs] @typecheck_method(expr=BooleanExpression); def any(self, expr):; """"""Evaluate whether a Boolean expression is true for at least one row. Examples; --------. Test whether `C1` is equal to 5 any row in any row of the table:. >>> if table1.any(table1.C1 == 5):; ... print(""At least one row has C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Boolean expression. Returns; -------; :obj:`bool`; ``True`` if the predicate evaluated for ``True`` for any row, otherwise ``False``.; """"""; return self.aggregate(hl.agg.any(expr)). [docs] @typecheck_method(mapping=dictof(str, str)); def rename(self, mapping) -> 'Table':; """"""Rename fields of the table. Examples; --------; Rename `C1` to `col1` and `C2`",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:103604,Testability,test,test,103604," right_key_types:; raise ValueError(; f""'join': key mismatch:\n ""; f"" left: [{', '.join(str(t) for t in left_key_types)}]\n ""; f"" right: [{', '.join(str(t) for t in right_key_types)}]""; ); left_fields = set(self._fields); right_fields = set(right._fields) - set(right.key). renames, _ = deduplicate(right_fields, max_attempts=100, already_used=left_fields). if renames:; renames = dict(renames); right = right.rename(renames); info(; 'Table.join: renamed the following fields on the right to avoid name conflicts:'; + ''.join(f'\n {k!r} -> {v!r}' for k, v in renames.items()); ). return Table(ir.TableJoin(self._tir, right._tir, how, _join_key)). [docs] @typecheck_method(expr=BooleanExpression); def all(self, expr):; """"""Evaluate whether a boolean expression is true for all rows. Examples; --------; Test whether `C1` is greater than 5 in all rows of the table:. >>> if table1.all(table1.C1 == 5):; ... print(""All rows have C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Expression to test. Returns; -------; :obj:`bool`; """"""; return self.aggregate(hl.agg.all(expr)). [docs] @typecheck_method(expr=BooleanExpression); def any(self, expr):; """"""Evaluate whether a Boolean expression is true for at least one row. Examples; --------. Test whether `C1` is equal to 5 any row in any row of the table:. >>> if table1.any(table1.C1 == 5):; ... print(""At least one row has C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Boolean expression. Returns; -------; :obj:`bool`; ``True`` if the predicate evaluated for ``True`` for any row, otherwise ``False``.; """"""; return self.aggregate(hl.agg.any(expr)). [docs] @typecheck_method(mapping=dictof(str, str)); def rename(self, mapping) -> 'Table':; """"""Rename fields of the table. Examples; --------; Rename `C1` to `col1` and `C2` to `col2`:. >>> table_result = table1.rename({'C1' : 'col1', 'C2' : 'col2'}). Parameters; ----------; mapping : :obj:`dict` of :class:`str`, :obj:`str`; Mapping from old field n",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:103850,Testability,Test,Test,103850,"icate(right_fields, max_attempts=100, already_used=left_fields). if renames:; renames = dict(renames); right = right.rename(renames); info(; 'Table.join: renamed the following fields on the right to avoid name conflicts:'; + ''.join(f'\n {k!r} -> {v!r}' for k, v in renames.items()); ). return Table(ir.TableJoin(self._tir, right._tir, how, _join_key)). [docs] @typecheck_method(expr=BooleanExpression); def all(self, expr):; """"""Evaluate whether a boolean expression is true for all rows. Examples; --------; Test whether `C1` is greater than 5 in all rows of the table:. >>> if table1.all(table1.C1 == 5):; ... print(""All rows have C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Expression to test. Returns; -------; :obj:`bool`; """"""; return self.aggregate(hl.agg.all(expr)). [docs] @typecheck_method(expr=BooleanExpression); def any(self, expr):; """"""Evaluate whether a Boolean expression is true for at least one row. Examples; --------. Test whether `C1` is equal to 5 any row in any row of the table:. >>> if table1.any(table1.C1 == 5):; ... print(""At least one row has C1 equal 5.""). Parameters; ----------; expr : :class:`.BooleanExpression`; Boolean expression. Returns; -------; :obj:`bool`; ``True`` if the predicate evaluated for ``True`` for any row, otherwise ``False``.; """"""; return self.aggregate(hl.agg.any(expr)). [docs] @typecheck_method(mapping=dictof(str, str)); def rename(self, mapping) -> 'Table':; """"""Rename fields of the table. Examples; --------; Rename `C1` to `col1` and `C2` to `col2`:. >>> table_result = table1.rename({'C1' : 'col1', 'C2' : 'col2'}). Parameters; ----------; mapping : :obj:`dict` of :class:`str`, :obj:`str`; Mapping from old field names to new field names. Notes; -----; Any field that does not appear as a key in `mapping` will not be; renamed. Returns; -------; :class:`.Table`; Table with renamed fields.; """"""; seen = {}. row_map = {}; global_map = {}. for k, v in mapping.items():; if v in seen:; raise ValueError(; ""Can",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:105227,Testability,assert,assert,105227,"egate(hl.agg.any(expr)). [docs] @typecheck_method(mapping=dictof(str, str)); def rename(self, mapping) -> 'Table':; """"""Rename fields of the table. Examples; --------; Rename `C1` to `col1` and `C2` to `col2`:. >>> table_result = table1.rename({'C1' : 'col1', 'C2' : 'col2'}). Parameters; ----------; mapping : :obj:`dict` of :class:`str`, :obj:`str`; Mapping from old field names to new field names. Notes; -----; Any field that does not appear as a key in `mapping` will not be; renamed. Returns; -------; :class:`.Table`; Table with renamed fields.; """"""; seen = {}. row_map = {}; global_map = {}. for k, v in mapping.items():; if v in seen:; raise ValueError(; ""Cannot rename two fields to the same name: attempted to rename {} and {} both to {}"".format(; repr(seen[v]), repr(k), repr(v); ); ); if v in self._fields and v not in mapping:; raise ValueError(""Cannot rename {} to {}: field already exists."".format(repr(k), repr(v))); seen[v] = k; if self[k]._indices == self._row_indices:; row_map[k] = v; else:; assert self[k]._indices == self._global_indices; global_map[k] = v. stray = set(mapping.keys()) - set(seen.values()); if stray:; raise ValueError(f""found rename rules for fields not present in table: {list(stray)}""). return Table(ir.TableRename(self._tir, row_map, global_map)). [docs] def expand_types(self) -> 'Table':; """"""Expand complex types into structs and arrays. Examples; --------. >>> table_result = table1.expand_types(). Notes; -----; Expands the following types: :class:`.tlocus`, :class:`.tinterval`,; :class:`.tset`, :class:`.tdict`, :class:`.ttuple`. The only types that will remain after this method are:; :py:data:`.tbool`, :py:data:`.tint32`, :py:data:`.tint64`,; :py:data:`.tfloat64`, :py:data:`.tfloat32`, :class:`.tarray`,; :class:`.tstruct`. Note, expand_types always returns an unkeyed table. Returns; -------; :class:`.Table`; Expanded table.; """""". t = self; if len(t.key) > 0:; t = t.order_by(*t.key). def _expand(e):; if isinstance(e, (CollectionExpression, Dict",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:106957,Testability,assert,assert,106957,"`. Note, expand_types always returns an unkeyed table. Returns; -------; :class:`.Table`; Expanded table.; """""". t = self; if len(t.key) > 0:; t = t.order_by(*t.key). def _expand(e):; if isinstance(e, (CollectionExpression, DictExpression)):; return hl.map(lambda x: _expand(x), hl.array(e)); elif isinstance(e, StructExpression):; return hl.struct(**{k: _expand(v) for (k, v) in e.items()}); elif isinstance(e, TupleExpression):; return hl.struct(**{f'_{i}': x for (i, x) in enumerate(e)}); elif isinstance(e, IntervalExpression):; return hl.struct(start=e.start, end=e.end, includesStart=e.includes_start, includesEnd=e.includes_end); elif isinstance(e, LocusExpression):; return hl.struct(contig=e.contig, position=e.position); elif isinstance(e, CallExpression):; return hl.struct(alleles=hl.map(lambda i: e[i], hl.range(0, e.ploidy)), phased=e.phased); elif isinstance(e, NDArrayExpression):; return hl.struct(shape=e.shape, data=_expand(e._data_array())); else:; assert isinstance(e, (NumericExpression, BooleanExpression, StringExpression)); return e. t = t.select(**_expand(t.row)); t = t.select_globals(**_expand(t.globals)); return t. [docs] def flatten(self) -> 'Table':; """"""Flatten nested structs. Examples; --------; Flatten table:. >>> table_result = table1.flatten(). Notes; -----; Consider a table with signature. .. code-block:: text. a: struct{; p: int32,; q: str; },; b: int32,; c: struct{; x: str,; y: array<struct{; y: str,; z: str; }>; }. and key ``a``. The result of flatten is. .. code-block:: text. a.p: int32; a.q: str; b: int32; c.x: str; c.y: array<struct{; y: str,; z: str; }>. with key ``a.p, a.q``. Note, structures inside collections like arrays or sets will not be; flattened. Note, the result of flatten is always unkeyed. Warning; -------; Flattening a table will produces fields that cannot be referenced using; the ``table.<field>`` syntax, e.g. ""a.b"". Reference these fields using; square bracket lookups: ``table['a.b']``. Returns; -------; :class:`.Table`; Table",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:48,Usability,Feedback,Feedback,48,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:258,Usability,Guid,Guides,258,"﻿. Hail | ; hail.table. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.table. Source code for hail.table; import collections; import itertools; import pprint; import shutil; from typing import Callable, ClassVar, Dict, List, Optional, Sequence, Union, overload. import numpy as np; import pandas; import pyspark. import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; BooleanExpression,; CallExpression,; CollectionExpression,; DictExpression,; Expression,; ExpressionException,; Indices,; IntervalExpression,; LocusExpression,; NDArrayExpression,; NumericExpression,; StringExpression,; StructExpression,; TupleExpression,; analyze,; construct_expr,; construct_reference,; expr_any,; expr_array,; expr_bool,; expr_stream,; expr_struct,; extract_refs_by_indices,; to_expr,; unify_all,; ); from hail.expr.table_type import ttable; from hail.expr.types import dtypes_from_pandas, hail_type, tarray, tset, tstruct, types_match; from hail.typecheck import (; anyfunc,; anytype,; dictof,; enumeration,; func_spec,; lazy,; nullable,; numeric,; oneof,; sequenceof,; table_key_type,; typecheck,; typecheck_method,; ); from hail.utils import deduplicate; from hail.utils.interval import Interval; from hail.utils.java import Env, info, warning; from hail.utils.misc import (; check_annotate_exprs,; check_collisions,; check_keys,; get_key_by_exprs,; get_nice_attr_error,; get_nice_field_error,; get_select_exprs,; plural,; process_joins,; storage_level,; wrap_to_tuple,; ); from hail.utils.placement_tree import PlacementTree. table_type = lazy(). class TableIndexKeyError(Exception):; def __init__(self, key_type, in",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:8171,Usability,guid,guide,8171,"amed_exprs.items():; analyze(f'{caller}: ({name!r})', expr, self._parent._global_indices, {self._parent._row_axis}); check_collisions(caller, list(named_exprs), self._parent._row_indices); if not named_exprs.keys().isdisjoint(set(self._key_expr)):; intersection = set(named_exprs.keys()) & set(self._key_expr); raise ValueError(; f'GroupedTable.aggregate: Group names and aggregration expression names overlap: {intersection}'; ). base, _ = self._parent._process_joins(self._key_expr, *named_exprs.values()). key_struct = self._key_expr; return Table(; ir.TableKeyByAndAggregate(; base._tir, hl.struct(**named_exprs)._ir, key_struct._ir, self._npartitions, self._buffer_size; ); ). [docs]class Table(ExprContainer):; """"""Hail's distributed implementation of a dataframe or SQL table. Use :func:`.read_table` to read a table that was written with; :meth:`.Table.write`. Use :meth:`.to_spark` and :meth:`.Table.from_spark`; to inter-operate with PySpark's; `SQL <https://spark.apache.org/docs/latest/sql-programming-guide.html>`__ and; `machine learning <https://spark.apache.org/docs/latest/ml-guide.html>`__; functionality. Examples; --------. The examples below use ``table1`` and ``table2``, which are imported; from text files using :func:`.import_table`. >>> table1 = hl.import_table('data/kt_example1.tsv', impute=True, key='ID'); >>> table1.show(). .. code-block:: text. +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | M | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | M | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | F | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | F | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+. >>> table2 = hl.import_table('data/kt_example2.tsv', impute=True, key='ID'); >>> table2.show(). .. code-",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:8200,Usability,learn,learning,8200,"{name!r})', expr, self._parent._global_indices, {self._parent._row_axis}); check_collisions(caller, list(named_exprs), self._parent._row_indices); if not named_exprs.keys().isdisjoint(set(self._key_expr)):; intersection = set(named_exprs.keys()) & set(self._key_expr); raise ValueError(; f'GroupedTable.aggregate: Group names and aggregration expression names overlap: {intersection}'; ). base, _ = self._parent._process_joins(self._key_expr, *named_exprs.values()). key_struct = self._key_expr; return Table(; ir.TableKeyByAndAggregate(; base._tir, hl.struct(**named_exprs)._ir, key_struct._ir, self._npartitions, self._buffer_size; ); ). [docs]class Table(ExprContainer):; """"""Hail's distributed implementation of a dataframe or SQL table. Use :func:`.read_table` to read a table that was written with; :meth:`.Table.write`. Use :meth:`.to_spark` and :meth:`.Table.from_spark`; to inter-operate with PySpark's; `SQL <https://spark.apache.org/docs/latest/sql-programming-guide.html>`__ and; `machine learning <https://spark.apache.org/docs/latest/ml-guide.html>`__; functionality. Examples; --------. The examples below use ``table1`` and ``table2``, which are imported; from text files using :func:`.import_table`. >>> table1 = hl.import_table('data/kt_example1.tsv', impute=True, key='ID'); >>> table1.show(). .. code-block:: text. +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | M | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | M | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | F | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | F | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+. >>> table2 = hl.import_table('data/kt_example2.tsv', impute=True, key='ID'); >>> table2.show(). .. code-block:: text. +-------+-------+--------+; |",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:8250,Usability,guid,guide,8250,"ces, {self._parent._row_axis}); check_collisions(caller, list(named_exprs), self._parent._row_indices); if not named_exprs.keys().isdisjoint(set(self._key_expr)):; intersection = set(named_exprs.keys()) & set(self._key_expr); raise ValueError(; f'GroupedTable.aggregate: Group names and aggregration expression names overlap: {intersection}'; ). base, _ = self._parent._process_joins(self._key_expr, *named_exprs.values()). key_struct = self._key_expr; return Table(; ir.TableKeyByAndAggregate(; base._tir, hl.struct(**named_exprs)._ir, key_struct._ir, self._npartitions, self._buffer_size; ); ). [docs]class Table(ExprContainer):; """"""Hail's distributed implementation of a dataframe or SQL table. Use :func:`.read_table` to read a table that was written with; :meth:`.Table.write`. Use :meth:`.to_spark` and :meth:`.Table.from_spark`; to inter-operate with PySpark's; `SQL <https://spark.apache.org/docs/latest/sql-programming-guide.html>`__ and; `machine learning <https://spark.apache.org/docs/latest/ml-guide.html>`__; functionality. Examples; --------. The examples below use ``table1`` and ``table2``, which are imported; from text files using :func:`.import_table`. >>> table1 = hl.import_table('data/kt_example1.tsv', impute=True, key='ID'); >>> table1.show(). .. code-block:: text. +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | M | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | M | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | F | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | F | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+. >>> table2 = hl.import_table('data/kt_example2.tsv', impute=True, key='ID'); >>> table2.show(). .. code-block:: text. +-------+-------+--------+; | ID | A | B |; +-------+-------+--------+; ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:21498,Usability,simpl,simple,21498,"ou mind.; """"""; context_name = f""context_{Env.get_uid()}""; ctype = contexts.dtype.element_type; cexpr = construct_expr(ir.Ref(context_name, ctype), ctype). globals_name = f""globals_{Env.get_uid()}""; globals = globals or hl.struct(); gexpr = construct_expr(ir.Ref(globals_name, globals.dtype), globals.dtype). body = ir.toStream(rowfn(cexpr, gexpr)._ir). if isinstance(partitions, int):; partitions = [Interval(hl.Struct(), hl.Struct(), True, True) for _ in range(partitions)]. partitioner = ir.Partitioner(partitions[0].point_type, partitions). return Table(ir.TableGen(ir.toStream(contexts._ir), globals._ir, context_name, globals_name, body, partitioner)). [docs] @typecheck_method(keys=oneof(str, expr_any), named_keys=expr_any); def key_by(self, *keys, **named_keys) -> 'Table':; """"""Key table by a new set of fields. Table keys control both the order of the rows in the table and the ability to join or; annotate one table with the information in another table. Examples; --------. Consider a simple unkeyed table. Its rows appear are guaranteed to appear in the same order; as they were in the source text file. >>> ht = hl.import_table('data/kt_example1.tsv', impute=True); >>> ht.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 |; +-------+-------+-----+-------+-------+-------+-------+-------+; | 1 | 65 | ""M"" | 5 | 4 | 2 | 50 | 5 |; | 2 | 72 | ""M"" | 6 | 3 | 2 | 61 | 1 |; | 3 | 70 | ""F"" | 7 | 3 | 10 | 81 | -5 |; | 4 | 60 | ""F"" | 8 | 2 | 11 | 90 | -10 |; +-------+-------+-----+-------+-------+-------+-------+-------+. Changing the key forces the rows to appear in ascending order. For this reason,; :meth:`.key_by` is a relatively expensive operation. It must sort the entire dataset. >>> ht = ht.key_by('HT'); >>> ht.show(); +-------+-------+-----+-------+-------+-------+-------+-------+; | ID |",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:71334,Usability,usab,usable,71334,"ect(B = table2.index(table1.ID).B); >>> table_result.B.show(); +-------+----------+; | ID | B |; +-------+----------+; | int32 | str |; +-------+----------+; | 1 | ""cat"" |; | 2 | ""dog"" |; | 3 | ""mouse"" |; | 4 | ""rabbit"" |; +-------+----------+. Using `key` as the sole index expression is equivalent to passing all; key fields individually:. >>> table_result = table1.select(B = table2.index(table1.key).B). It is also possible to use non-key fields or expressions as the index; expressions:. >>> table_result = table1.select(B = table2.index(table1.C1 % 4).B); >>> table_result.show(); +-------+---------+; | ID | B |; +-------+---------+; | int32 | str |; +-------+---------+; | 1 | ""dog"" |; | 2 | ""dog"" |; | 3 | ""dog"" |; | 4 | ""mouse"" |; +-------+---------+. Notes; -----; :meth:`.Table.index` is used to expose one table's fields for use in; expressions involving the another table or matrix table's fields. The; result of the method call is a struct expression that is usable in the; same scope as `exprs`, just as if `exprs` were used to look up values of; the table in a dictionary. The type of the struct expression is the same as the indexed table's; :meth:`.row_value` (the key fields are removed, as they are available; in the form of the index expressions). Note; ----; There is a shorthand syntax for :meth:`.Table.index` using square; brackets (the Python ``__getitem__`` syntax). This syntax is preferred. >>> table_result = table1.select(B = table2[table1.ID].B). Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Index expressions.; all_matches : bool; Experimental. If ``True``, value of expression is array of all matches. Returns; -------; :class:`.Expression`; """"""; try:; return self._index(*exprs, all_matches=all_matches); except TableIndexKeyError as err:; raise ExpressionException(; f""Key type mismatch: cannot index table with given expressions:\n""; f"" Table key: {', '.join(str(t) for t in err.key_type.values()) or '<<<empty key>>>'}\n""; f"" In",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:80411,Usability,guid,guide,80411,"able in memory. Examples; --------; Persist the table in memory:. >>> table = table.cache() # doctest: +SKIP. Notes; -----. This method is an alias for :func:`persist(""MEMORY_ONLY"") <hail.Table.persist>`. Returns; -------; :class:`.Table`; Cached table.; """"""; return self.persist('MEMORY_ONLY'). [docs] @typecheck_method(storage_level=storage_level); def persist(self, storage_level='MEMORY_AND_DISK') -> 'Table':; """"""Persist this table in memory or on disk. Examples; --------; Persist the table to both memory and disk:. >>> table = table.persist() # doctest: +SKIP. Notes; -----. The :meth:`.Table.persist` and :meth:`.Table.cache` methods store the; current table on disk or in memory temporarily to avoid redundant computation; and improve the performance of Hail pipelines. This method is not a substitution; for :meth:`.Table.write`, which stores a permanent file. Most users should use the ""MEMORY_AND_DISK"" storage level. See the `Spark; documentation; <http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence>`__; for a more in-depth discussion of persisting data. Parameters; ----------; storage_level : str; Storage level. One of: NONE, DISK_ONLY,; DISK_ONLY_2, MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_ONLY_SER,; MEMORY_ONLY_SER_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2,; MEMORY_AND_DISK_SER, MEMORY_AND_DISK_SER_2, OFF_HEAP. Returns; -------; :class:`.Table`; Persisted table.; """"""; return Env.backend().persist(self). [docs] def unpersist(self) -> 'Table':; """"""; Unpersists this table from memory/disk. Notes; -----; This function will have no effect on a table that was not previously; persisted. Returns; -------; :class:`.Table`; Unpersisted table.; """"""; return Env.backend().unpersist(self). @overload; def collect(self) -> List[hl.Struct]: ... @overload; def collect(self, _localize=False) -> ArrayExpression: ... [docs] @typecheck_method(_localize=bool, _timed=bool); def collect(self, _localize=True, *, _timed=False):; """"""Collect the rows of the table into a local li",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:84704,Usability,simpl,simple,84704,"PUT_CHECK; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | ID | HT | SEX | X | Z | C1 | C2 | C3 | idx |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | int32 | int32 | str | int32 | int32 | int32 | int32 | int32 | int64 |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+; | 1 | 65 | M | 5 | 4 | 2 | 50 | 5 | 0 |; | 2 | 72 | M | 6 | 3 | 2 | 61 | 1 | 1 |; | 3 | 70 | F | 7 | 3 | 10 | 81 | -5 | 2 |; | 4 | 60 | F | 8 | 2 | 11 | 90 | -10 | 3 |; +-------+-------+-----+-------+-------+-------+-------+-------+-------+. Notes; -----. This method returns a table with a new field whose name is given by; the `name` parameter, with type :py:data:`.tint64`. The value of this field; is the integer index of each row, starting from 0. Methods that respect; ordering (like :meth:`.Table.take` or :meth:`.Table.export`) will; return rows in order. This method is also helpful for creating a unique integer index for; rows of a table so that more complex types can be encoded as a simple; number for performance reasons. Parameters; ----------; name : str; Name of index field. Returns; -------; :class:`.Table`; Table with a new index field.; """""". return self.annotate(**{name: hl.scan.count()}). [docs] @typecheck_method(tables=table_type, unify=bool); def union(self, *tables, unify: bool = False) -> 'Table':; """"""Union the rows of multiple tables. Examples; --------. Take the union of rows from two tables:. >>> union_table = table1.union(other_table). Notes; -----; If a row appears in more than one table identically, it is duplicated; in the result. All tables must have the same key names and types. They; must also have the same row types, unless the `unify` parameter is; ``True``, in which case a field appearing in any table will be included; in the result, with missing values for tables that do not contain the; field. If a field appears in multiple tables with incompatible types,; like arrays and strings, then an err",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:93033,Usability,guid,guide,93033,"n, shuffle=True) -> 'Table':; """"""Change the number of partitions. Examples; --------. Repartition to 500 partitions:. >>> table_result = table1.repartition(500). Notes; -----. Check the current number of partitions with :meth:`.n_partitions`. The data in a dataset is divided into chunks called partitions, which; may be stored together or across a network, so that each partition may; be read and processed in parallel by available cores. When a table with; :math:`M` rows is first imported, each of the :math:`k` partitions will; contain about :math:`M/k` of the rows. Since each partition has some; computational overhead, decreasing the number of partitions can improve; performance after significant filtering. Since it's recommended to have; at least 2 - 4 partitions per core, increasing the number of partitions; can allow one to take advantage of more cores. Partitions are a core; concept of distributed computation in Spark, see `their documentation; <http://spark.apache.org/docs/latest/programming-guide.html#resilient-distributed-datasets-rdds>`__; for details. When ``shuffle=True``, Hail does a full shuffle of the data; and creates equal sized partitions. When ``shuffle=False``,; Hail combines existing partitions to avoid a full shuffle.; These algorithms correspond to the `repartition` and; `coalesce` commands in Spark, respectively. In particular,; when ``shuffle=False``, ``n_partitions`` cannot exceed current; number of partitions. Parameters; ----------; n : int; Desired number of partitions.; shuffle : bool; If ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hail/table.html:94537,Usability,simpl,simply,94537," ``True``, use full shuffle to repartition. Returns; -------; :class:`.Table`; Repartitioned table.; """"""; if hl.current_backend().requires_lowering:; tmp = hl.utils.new_temp_file(). if len(self.key) == 0:; uid = Env.get_uid(); tmp2 = hl.utils.new_temp_file(); self.checkpoint(tmp2); ht = hl.read_table(tmp2).add_index(uid).key_by(uid); ht.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n).key_by().drop(uid); else:; # checkpoint rather than write to use fast codec; self.checkpoint(tmp); return hl.read_table(tmp, _n_partitions=n). return Table(; ir.TableRepartition(; self._tir, n, ir.RepartitionStrategy.SHUFFLE if shuffle else ir.RepartitionStrategy.COALESCE; ); ). [docs] @typecheck_method(max_partitions=int); def naive_coalesce(self, max_partitions: int) -> 'Table':; """"""Naively decrease the number of partitions. Example; -------; Naively repartition to 10 partitions:. >>> table_result = table1.naive_coalesce(10). Warning; -------; :meth:`.naive_coalesce` simply combines adjacent partitions to achieve; the desired number. It does not attempt to rebalance, unlike; :meth:`.repartition`, so it can produce a heavily unbalanced dataset. An; unbalanced dataset can be inefficient to operate on because the work is; not evenly distributed across partitions. Parameters; ----------; max_partitions : int; Desired number of partitions. If the current number of partitions is; less than or equal to `max_partitions`, do nothing. Returns; -------; :class:`.Table`; Table with at most `max_partitions` partitions.; """"""; return Table(ir.TableRepartition(self._tir, max_partitions, ir.RepartitionStrategy.NAIVE_COALESCE)). [docs] @typecheck_method(other=table_type); def semi_join(self, other: 'Table') -> 'Table':; """"""Filters the table to rows whose key appears in `other`. Parameters; ----------; other : :class:`.Table`; Table with compatible key field(s). Returns; -------; :class:`.Table`. Notes; -----; The key type of the table must match the key type of `other`. This method does not ",MatchSource.WIKI,docs/0.2/_modules/hail/table.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/table.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:156,Deployability,Install,Installation,156,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:224,Deployability,Configurat,Configuration,224,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:1631,Deployability,update,updated,1631,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:224,Modifiability,Config,Configuration,224,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:1416,Security,hash,hash,1416,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:378,Testability,Log,Log,378,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:56,Usability,Feedback,Feedback,56,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hailtop/frozendict.html:266,Usability,Guid,Guides,266,"﻿. Hail | ; hailtop.frozendict. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hailtop.frozendict. Source code for hailtop.frozendict; from collections.abc import Mapping; from typing import Dict, Generic, TypeVar. T = TypeVar(""T""); U = TypeVar(""U""). [docs]class frozendict(Mapping, Generic[T, U]):; """"""; An object representing an immutable dictionary. >>> my_frozen_dict = hl.utils.frozendict({1:2, 7:5}). To get a normal python dictionary with the same elements from a `frozendict`:. >>> dict(frozendict({'a': 1, 'b': 2})). Note; ----; This object refers to the Python value returned by taking or collecting; Hail expressions, e.g. ``mt.my_dict.take(5)``. This is rare; it is much; more common to manipulate the :class:`.DictExpression` object, which is; constructed using :func:`.dict`. This class is necessary because hail; supports using dicts as keys to other dicts or as elements in sets, while; python does not. """""". def __init__(self, d: Dict[T, U]):; self.d = d.copy(). def __getitem__(self, k: T) -> U:; return self.d[k]. def __hash__(self) -> int:; return hash(frozenset(self.items())). def __len__(self) -> int:; return len(self.d). def __iter__(self):; return iter(self.d). def __repr__(self):; return f'frozendict({self.d!r})'. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hailtop/frozendict.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hailtop/frozendict.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1738,Availability,avail,available,1738,"> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:2281,Availability,avail,available,2281,"netic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes =",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:2984,Availability,avail,available,2984,"one``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; r",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3172,Availability,avail,available,3172,"ify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region];",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3213,Availability,Avail,Available,3213," ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] ==",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3467,Availability,avail,available,3467,"e`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.ja",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3505,Availability,Avail,Available,3505,"region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Te",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3734,Availability,avail,available,3734,"={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:3967,Availability,avail,available,3967,"={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:4038,Availability,Avail,Available,4038,"={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:164,Deployability,Install,Installation,164,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:232,Deployability,Configurat,Configuration,232,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:4542,Deployability,update,updated,4542,"={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:232,Modifiability,Config,Configuration,232,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1007,Performance,load,load,1007,"hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, `",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1259,Performance,Load,Load,1259," Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is current",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1330,Performance,Load,Load,1330,"ers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :cla",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1655,Performance,load,load,1655,"ort Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_reg",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:1728,Performance,load,load,1728,"> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ``'us'``, ``'us-central1'``, or ``'europe-west1'``, (default is; ``'us-central1'``).; cloud : :class:`str`; Specify if using Google Cloud Platform or Amazon Web Services,; ``'gcp'`` or ``'aws'`` (default is ``'gcp'``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Returns; -------; :class:`.Table`, :class:`.MatrixTable`, or :class:`.BlockMatrix`; """""". valid_regions = {'us', 'us-central1', 'europe-west1'}; if region not in valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:386,Testability,Log,Log,386,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:4250,Testability,assert,assert,4250,"={region!r}.\n'; f'Valid region values are {valid_regions}.'; ). valid_clouds = {'gcp', 'aws'}; if cloud not in valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {valid_clouds}.'; ). datasets = get_datasets_metadata(); names = set([dataset for dataset in datasets]); if name not in names:; raise ValueError(f'{name} is not a dataset available in the' f' repository.'). versions = set(dataset['version'] for dataset in datasets[name]['versions']); if version not in versions:; raise ValueError(; f'Version {version!r} not available for dataset' f' {name!r}.\n' f'Available versions: {versions}.'; ). reference_genomes = set(dataset['reference_genome'] for dataset in datasets[name]['versions']); if reference_genome not in reference_genomes:; raise ValueError(; f'Reference genome build {reference_genome!r} not'; f' available for dataset {name!r}.\n'; f'Available reference genome builds:'; f' {reference_genomes}.'; ). clouds = set(k for dataset in datasets[name]['versions'] for k in dataset['url'].keys()); if cloud not in clouds:; raise ValueError(f'Cloud platform {cloud!r} not available for dataset {name}.\nAvailable platforms: {clouds}.'). regions = set(k for dataset in datasets[name]['versions'] for k in dataset['url'][cloud].keys()); if region not in regions:; raise ValueError(; f'Region {region!r} not available for dataset'; f' {name!r} on cloud platform {cloud!r}.\n'; f'Available regions: {regions}.'; ). path = [; dataset['url'][cloud][region]; for dataset in datasets[name]['versions']; if all([dataset['version'] == version, dataset['reference_genome'] == reference_genome]); ]; assert len(path) == 1; path = path[0]; if path.startswith('s3://'):; try:; dataset = _read_dataset(path); except hl.utils.java.FatalError:; dataset = _read_dataset(path.replace('s3://', 's3a://')); else:; dataset = _read_dataset(path); return dataset. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:64,Usability,Feedback,Feedback,64,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html:274,Usability,Guid,Guides,274,"﻿. Hail | ; hail.experimental.datasets. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.datasets. Source code for hail.experimental.datasets; from typing import Optional, Union. import hail as hl; from hail.matrixtable import MatrixTable; from hail.table import Table. from .datasets_metadata import get_datasets_metadata. def _read_dataset(path: str) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; if path.endswith('.ht'):; return hl.read_table(path); elif path.endswith('.mt'):; return hl.read_matrix_table(path); elif path.endswith('.bm'):; return hl.linalg.BlockMatrix.read(path); raise ValueError(f'Invalid path: {path}. Can only load datasets with .ht, .mt, or .bm extensions.'). [docs]def load_dataset(; name: str, version: Optional[str], reference_genome: Optional[str], region: str = 'us-central1', cloud: str = 'gcp'; ) -> Union[Table, MatrixTable, hl.linalg.BlockMatrix]:; """"""Load a genetic dataset from Hail's repository. Example; -------; >>> # Load the gnomAD ""HGDP + 1000 Genomes"" dense MatrixTable with GRCh38 coordinates.; >>> mt = hl.experimental.load_dataset(name='gnomad_hgdp_1kg_subset_dense',; ... version='3.1.2',; ... reference_genome='GRCh38',; ... region='us-central1',; ... cloud='gcp'). Parameters; ----------; name : :class:`str`; Name of the dataset to load.; version : :class:`str`, optional; Version of the named dataset to load (see available versions in; documentation). Possibly ``None`` for some datasets.; reference_genome : :class:`str`, optional; Reference genome build, ``'GRCh37'`` or ``'GRCh38'``. Possibly ``None``; for some datasets.; region : :class:`str`; Specify region for bucket, ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/datasets.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/datasets.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2040,Availability,avail,available,2040,"rsion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_version",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2813,Availability,avail,available,2813,"sion keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset e",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2976,Availability,avail,available,2976," or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:3658,Availability,avail,available,3658,"jects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameter",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:4094,Availability,avail,available,4094,".; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of ex",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:4167,Availability,avail,available,4167,"_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_ta",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6261,Availability,avail,available,6261,"s). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: Li",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:8699,Availability,avail,available,8699,"ression) -> StructExpression:; """"""Get index from compatible version of annotation dataset. Checks for compatible indexed values from each :class:`.DatasetVersion`; in :attr:`.Dataset.versions`, where `key_expr` is the row key struct; from the dataset to be annotated. Parameters; ----------; key_expr : :class:`.StructExpression`; Row key struct from relational object to be annotated. Returns; -------; :class:`.StructExpression`; Struct of compatible indexed values.; """"""; all_matches = 'unique' not in self.key_properties; compatible_indexed_values = [; (version.maybe_index(key_expr, all_matches), version.version); for version in self.versions; if version.maybe_index(key_expr, all_matches) is not None; ]; if len(compatible_indexed_values) == 0:; versions = [f'{(v.version, v.reference_genome)}' for v in self.versions]; raise ValueError(; f'Could not find compatible version of {self.name} for user'; f' dataset with key {key_expr.dtype}.\n'; f'This annotation dataset is available for the following'; f' versions and reference genome builds: {"", "".join(versions)}.'; ); else:; indexed_values = sorted(compatible_indexed_values, key=lambda x: x[1])[-1]. if len(compatible_indexed_values) > 1:; info(; f'index_compatible_version: More than one compatible version'; f' exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Reg",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10269,Availability,avail,available,10269," annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._val",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11325,Availability,avail,available,11325,"es; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12393,Availability,avail,available,12393,"rm. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; raise ValueError('annotation database can only annotate Hail' ' MatrixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :obj:`str`; Name of dataset. Returns; -------; :class:`Dataset`; """"""; if name not in self.__by_name:; raise ValueError(; f'{name} not found in annotation database,'; f' you may list all known dataset names'; f' with available_da",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12463,Availability,avail,available,12463,"fig is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; raise ValueError('annotation database can only annotate Hail' ' MatrixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :obj:`str`; Name of dataset. Returns; -------; :class:`Dataset`; """"""; if name not in self.__by_name:; raise ValueError(; f'{name} not found in annotation database,'; f' you may list all known dataset names'; f' with available_datasets'; ); return self.__by_name[name]. def _annotate_gene_name(self, rel: Union[TableR",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:14021,Availability,avail,available,14021,"rixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :obj:`str`; Name of dataset. Returns; -------; :class:`Dataset`; """"""; if name not in self.__by_name:; raise ValueError(; f'{name} not found in annotation database,'; f' you may list all known dataset names'; f' with available_datasets'; ); return self.__by_name[name]. def _annotate_gene_name(self, rel: Union[TableRows, MatrixRows]) -> Tuple[str, Union[TableRows, MatrixRows]]:; """"""Annotate row lens with gene name if annotation dataset is gene; keyed. Parameters; ----------; rel : :class:`TableRows` or :class:`MatrixRows`; Row lens of relational object to be annotated. Returns; -------; :class:`tuple`; """"""; gene_field = Env.get_uid(); gencode = self.__by_name['gencode'].index_compatible_version(rel.key); return gene_field, rel.annotate(**{gene_field: gencode.gene_name}). def _check_availability(self, names: Iterable) -> None:; """"""Check if datasets given in `names` are available in the annotation; database instance. Parameters; ----------; names : :obj:`iterable`; Names to check.; """"""; unavailable = [x for x in names if x not in self.__by_name.keys()]; if unavailable:; raise ValueError(f'datasets: {unavailable} not available' f' in the {self.region} region.'). [docs] @typecheck_method(rel=oneof(table_type, matrix_table_type), names=str); def annotate_rows_db(self, rel: Union[Table, MatrixTable], *names: str) -> Union[Table, MatrixTable]:; """"""Add annotations from datasets specified by name to a relational; object. List datasets with :attr:`~.available_datasets`. An interactive query builder is available in the; `Hail Annotation Database documentation; </docs/0.2/annotation_database_ui.html>`_. Examples; --------; Annotate a :class:`.MatrixTable` with ``gnomad_lof_metrics``:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); >>> mt = db.annotate_rows_db(mt, 'gnomad_lof_metrics') # doctest: +SKIP. Annotate a :clas",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:14272,Availability,avail,available,14272," ValueError(; f'{name} not found in annotation database,'; f' you may list all known dataset names'; f' with available_datasets'; ); return self.__by_name[name]. def _annotate_gene_name(self, rel: Union[TableRows, MatrixRows]) -> Tuple[str, Union[TableRows, MatrixRows]]:; """"""Annotate row lens with gene name if annotation dataset is gene; keyed. Parameters; ----------; rel : :class:`TableRows` or :class:`MatrixRows`; Row lens of relational object to be annotated. Returns; -------; :class:`tuple`; """"""; gene_field = Env.get_uid(); gencode = self.__by_name['gencode'].index_compatible_version(rel.key); return gene_field, rel.annotate(**{gene_field: gencode.gene_name}). def _check_availability(self, names: Iterable) -> None:; """"""Check if datasets given in `names` are available in the annotation; database instance. Parameters; ----------; names : :obj:`iterable`; Names to check.; """"""; unavailable = [x for x in names if x not in self.__by_name.keys()]; if unavailable:; raise ValueError(f'datasets: {unavailable} not available' f' in the {self.region} region.'). [docs] @typecheck_method(rel=oneof(table_type, matrix_table_type), names=str); def annotate_rows_db(self, rel: Union[Table, MatrixTable], *names: str) -> Union[Table, MatrixTable]:; """"""Add annotations from datasets specified by name to a relational; object. List datasets with :attr:`~.available_datasets`. An interactive query builder is available in the; `Hail Annotation Database documentation; </docs/0.2/annotation_database_ui.html>`_. Examples; --------; Annotate a :class:`.MatrixTable` with ``gnomad_lof_metrics``:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); >>> mt = db.annotate_rows_db(mt, 'gnomad_lof_metrics') # doctest: +SKIP. Annotate a :class:`.Table` with ``clinvar_gene_summary``, ``CADD``,; and ``DANN``:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); >>> ht = db.annotate_rows_db(ht, 'clinvar_gene_summary', 'CADD', 'DANN') # doctest: +SKIP. Notes; -----. If a dataset is g",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:14657,Availability,avail,available,14657,"ens of relational object to be annotated. Returns; -------; :class:`tuple`; """"""; gene_field = Env.get_uid(); gencode = self.__by_name['gencode'].index_compatible_version(rel.key); return gene_field, rel.annotate(**{gene_field: gencode.gene_name}). def _check_availability(self, names: Iterable) -> None:; """"""Check if datasets given in `names` are available in the annotation; database instance. Parameters; ----------; names : :obj:`iterable`; Names to check.; """"""; unavailable = [x for x in names if x not in self.__by_name.keys()]; if unavailable:; raise ValueError(f'datasets: {unavailable} not available' f' in the {self.region} region.'). [docs] @typecheck_method(rel=oneof(table_type, matrix_table_type), names=str); def annotate_rows_db(self, rel: Union[Table, MatrixTable], *names: str) -> Union[Table, MatrixTable]:; """"""Add annotations from datasets specified by name to a relational; object. List datasets with :attr:`~.available_datasets`. An interactive query builder is available in the; `Hail Annotation Database documentation; </docs/0.2/annotation_database_ui.html>`_. Examples; --------; Annotate a :class:`.MatrixTable` with ``gnomad_lof_metrics``:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); >>> mt = db.annotate_rows_db(mt, 'gnomad_lof_metrics') # doctest: +SKIP. Annotate a :class:`.Table` with ``clinvar_gene_summary``, ``CADD``,; and ``DANN``:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); >>> ht = db.annotate_rows_db(ht, 'clinvar_gene_summary', 'CADD', 'DANN') # doctest: +SKIP. Notes; -----. If a dataset is gene-keyed, the annotation will be a dictionary mapping; from gene name to the annotation value. There will be one entry for each; gene overlapping the given locus. If a dataset does not have unique rows for each key (consider the; ``gencode`` genes, which may overlap; and ``clinvar_variant_summary``,; which contains many overlapping multiple nucleotide variants), then the; result will be an array of annotation values, one ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:158,Deployability,Install,Installation,158,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:226,Deployability,Configurat,Configuration,226,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:5379,Deployability,configurat,configuration,5379,"rn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:5450,Deployability,configurat,configurations,5450,"rn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9324,Deployability,configurat,configuration,9324,"); for version in self.versions; if version.maybe_index(key_expr, all_matches) is not None; ]; if len(compatible_indexed_values) == 0:; versions = [f'{(v.version, v.reference_genome)}' for v in self.versions]; raise ValueError(; f'Could not find compatible version of {self.name} for user'; f' dataset with key {key_expr.dtype}.\n'; f'This annotation dataset is available for the following'; f' versions and reference genome builds: {"", "".join(versions)}.'; ); else:; indexed_values = sorted(compatible_indexed_values, key=lambda x: x[1])[-1]. if len(compatible_indexed_values) > 1:; info(; f'index_compatible_version: More than one compatible version'; f' exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9391,Deployability,configurat,configuration,9391,"); for version in self.versions; if version.maybe_index(key_expr, all_matches) is not None; ]; if len(compatible_indexed_values) == 0:; versions = [f'{(v.version, v.reference_genome)}' for v in self.versions]; raise ValueError(; f'Could not find compatible version of {self.name} for user'; f' dataset with key {key_expr.dtype}.\n'; f'This annotation dataset is available for the following'; f' versions and reference genome builds: {"", "".join(versions)}.'; ); else:; indexed_values = sorted(compatible_indexed_values, key=lambda x: x[1])[-1]. if len(compatible_indexed_values) > 1:; info(; f'index_compatible_version: More than one compatible version'; f' exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9989,Deployability,configurat,configuration,9989," exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10020,Deployability,configurat,configuration,10020," exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10139,Deployability,configurat,configuration,10139," [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud paramete",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10171,Deployability,configurat,configuration,10171," [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud paramete",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11965,Deployability,configurat,configurations,11965,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:17249,Deployability,update,updated,17249,"ll be a dictionary mapping; from gene name to the annotation value. There will be one entry for each; gene overlapping the given locus. If a dataset does not have unique rows for each key (consider the; ``gencode`` genes, which may overlap; and ``clinvar_variant_summary``,; which contains many overlapping multiple nucleotide variants), then the; result will be an array of annotation values, one for each row. Parameters; ----------; rel : :class:`.MatrixTable` or :class:`.Table`; The relational object to which to add annotations.; names : varargs of :class:`str`; The names of the datasets with which to annotate `rel`. Returns; -------; :class:`.MatrixTable` or :class:`.Table`; The relational object `rel`, with the annotations from `names`; added.; """"""; rel = self._row_lens(rel); if len(set(names)) != len(names):; raise ValueError(f'cannot annotate same dataset twice,' f' please remove duplicates from: {names}'); self._check_availability(names); datasets = [self._dataset_by_name(name) for name in names]; if any(dataset.is_gene_keyed for dataset in datasets):; gene_field, rel = self._annotate_gene_name(rel); else:; gene_field = None; for dataset in datasets:; if dataset.is_gene_keyed:; genes = rel.select(gene_field).explode(gene_field); genes = genes.annotate(**{dataset.name: dataset.index_compatible_version(genes[gene_field])}); genes = genes.group_by(*genes.key).aggregate(**{; dataset.name: hl.dict(; hl.agg.filter(; hl.is_defined(genes[dataset.name]),; hl.agg.collect((genes[gene_field], genes[dataset.name])),; ); ); }); rel = rel.annotate(**{dataset.name: genes.index(rel.key)[dataset.name]}); else:; indexed_value = dataset.index_compatible_version(rel.key); if isinstance(indexed_value.dtype, hl.tstruct) and len(indexed_value.dtype) == 0:; indexed_value = hl.is_defined(indexed_value); rel = rel.annotate(**{dataset.name: indexed_value}); if gene_field:; rel = rel.drop(gene_field); return rel.unlens(). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:3990,Integrability,message,message,3990,".; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of ex",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:4363,Integrability,message,message,4363,"erence_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configurat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:226,Modifiability,Config,Configuration,226,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:5379,Modifiability,config,configuration,5379,"rn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:5450,Modifiability,config,configurations,5450,"rn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9324,Modifiability,config,configuration,9324,"); for version in self.versions; if version.maybe_index(key_expr, all_matches) is not None; ]; if len(compatible_indexed_values) == 0:; versions = [f'{(v.version, v.reference_genome)}' for v in self.versions]; raise ValueError(; f'Could not find compatible version of {self.name} for user'; f' dataset with key {key_expr.dtype}.\n'; f'This annotation dataset is available for the following'; f' versions and reference genome builds: {"", "".join(versions)}.'; ); else:; indexed_values = sorted(compatible_indexed_values, key=lambda x: x[1])[-1]. if len(compatible_indexed_values) > 1:; info(; f'index_compatible_version: More than one compatible version'; f' exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9391,Modifiability,config,configuration,9391,"); for version in self.versions; if version.maybe_index(key_expr, all_matches) is not None; ]; if len(compatible_indexed_values) == 0:; versions = [f'{(v.version, v.reference_genome)}' for v in self.versions]; raise ValueError(; f'Could not find compatible version of {self.name} for user'; f' dataset with key {key_expr.dtype}.\n'; f'This annotation dataset is available for the following'; f' versions and reference genome builds: {"", "".join(versions)}.'; ); else:; indexed_values = sorted(compatible_indexed_values, key=lambda x: x[1])[-1]. if len(compatible_indexed_values) > 1:; info(; f'index_compatible_version: More than one compatible version'; f' exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:9989,Modifiability,config,configuration,9989," exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10020,Modifiability,config,configuration,10020," exists for annotation dataset: {self.name}. Rows have been'; f' annotated with version {indexed_values[1]}.'; ); return indexed_values[0]. [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10059,Modifiability,config,config,10059," [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud paramete",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10139,Modifiability,config,configuration,10139," [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud paramete",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10171,Modifiability,config,configuration,10171," [docs]class DB:; """"""An annotation database instance. This class facilitates the annotation of genetic datasets with variant annotations. It accepts; either an HTTP(S) URL to an Annotation DB configuration or a Python :obj:`dict` describing an; Annotation DB configuration. User must specify the `region` (aws: ``'us'``, gcp:; ``'us-central1'`` or ``'europe-west1'``) in which the cluster is running if connecting to the; default Hail Annotation DB. User must also specify the `cloud` platform that they are using; (``'gcp'`` or ``'aws'``). Parameters; ----------; region : :obj:`str`; Region cluster is running in, either ``'us'``, ``'us-central1'``, or ``'europe-west1'``; (default is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud paramete",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:10838,Modifiability,config,config,10838,"lt is ``'us-central1'``).; cloud : :obj:`str`; Cloud platform, either ``'gcp'`` or ``'aws'`` (default is ``'gcp'``).; url : :obj:`str`, optional; Optional URL to annotation DB configuration, if using custom configuration; (default is ``None``).; config : :obj:`str`, optional; Optional :obj:`dict` describing an annotation DB configuration, if using; custom configuration (default is ``None``). Note; ----; The ``'aws'`` `cloud` platform is currently only available for the ``'us'``; `region`. Examples; --------; Create an annotation database connecting to the default Hail Annotation DB:. >>> db = hl.experimental.DB(region='us-central1', cloud='gcp'); """""". _valid_key_properties: ClassVar = {'gene', 'unique'}; _valid_regions: ClassVar = {'us', 'us-central1', 'europe-west1'}; _valid_clouds: ClassVar = {'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11455,Modifiability,config,config,11455,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11564,Modifiability,config,config,11564,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11596,Modifiability,config,config,11596,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11604,Modifiability,config,config,11604,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11620,Modifiability,config,config,11620,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11654,Modifiability,config,config,11654,"'gcp', 'aws'}; _valid_combinations: ClassVar = {('us', 'aws'), ('us-central1', 'gcp'), ('europe-west1', 'gcp')}. def __init__(; self,; *,; region: str = 'us-central1',; cloud: str = 'gcp',; url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, Ma",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11806,Modifiability,config,config,11806," url: Optional[str] = None,; config: Optional[dict] = None,; ):; if region not in DB._valid_regions:; raise ValueError(; f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; i",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11850,Modifiability,config,config,11850,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11885,Modifiability,config,config,11885,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11965,Modifiability,config,configurations,11965,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11992,Modifiability,config,config,11992,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12003,Modifiability,config,config,12003,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12030,Modifiability,config,config,12030,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12134,Modifiability,config,config,12134,"ved: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; raise ValueError('annotation database can only annotate Hail' ' MatrixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :ob",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12143,Modifiability,config,config,12143,"ved: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; raise ValueError('annotation database can only annotate Hail' ' MatrixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :ob",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:12235,Modifiability,config,config,12235,"ouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; raise ValueError('annotation database can only annotate Hail' ' MatrixTable or Table'). def _dataset_by_name(self, name: str) -> Dataset:; """"""Retrieve :class:`Dataset` object by name. Parameters; ----------; name : :obj:`str`; Name of dataset. Returns; -------; :class:`Dataset`; """"""; ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:1947,Security,access,access,1947,"atasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2800,Security,access,access,2800,"sion keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset e",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:3507,Security,access,accessible,3507,"rameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[S",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:3645,Security,access,access,3645,"jects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); return available_versions. def __init__(self, url: Union[dict, str], version: Optional[str], reference_genome: Optional[str]):; self.url = url; self.version = version; self.reference_genome = reference_genome. def in_region(self, name: str, region: str) -> bool:; """"""Check if a :class:`.DatasetVersion` object is accessible in the; desired region. Parameters; ----------; name : :obj:`str`; Name of dataset.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`. Returns; -------; valid_region : :obj:`bool`; Whether or not the dataset exists in the specified region.; """"""; current_version = self.version; available_regions = [k for k in self.url.keys()]; valid_region = region in available_regions; if not valid_region:; message = (; f'\nName: {name}\n'; f'Version: {current_version}\n'; f'This dataset exists but is not yet available in the'; f' {region} region bucket.\n'; f'Dataset is currently available in the'; f' {"", "".join(available_regions)} region bucket(s).\n'; f'Reach out to the Hail team at https://discuss.hail.is/'; f' to request this dataset in your region.'; ); warnings.warn(message, UserWarning, stacklevel=1); return valid_region. def maybe_index(self, indexer_key_expr: StructExpression, all_matches: bool) -> Optional[StructExpression]:; """"""Find the prefix of the given indexer expression that can index the; :class:`.DatasetVersion`, if it exists. Parameter",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:5615,Security,access,access,5615,"s:`.DatasetVersion`, if it exists. Parameters; ----------; indexer_key_expr : :class:`StructExpression`; Row key struct from relational object to be annotated.; all_matches : :obj:`bool`; ``True`` if `indexer_key_expr` key is not unique, indicated in; :attr:`.Dataset.key_properties` for each dataset. If ``True``, value; of `indexer_key_expr` is array of all matches. If ``False``, there; will only be single value of expression. Returns; -------; :class:`StructExpression`, optional; Struct of compatible indexed values, if they exist.; """"""; return hl.read_table(self.url)._maybe_flexindex_table_by_expr(indexer_key_expr, all_matches=all_matches). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_prope",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6248,Security,access,access,6248,"s). class Dataset:; """"""Dataset object constructed from name, description, url, key_properties,; and versions specified in JSON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: Li",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6373,Security,access,access,6373,"ON configuration file or a provided :obj:`dict`; mapping dataset names to configurations. Parameters; ----------; name : :obj:`str`; Name of dataset.; description : :obj:`str`; Brief description of dataset.; url : :obj:`str`; Cloud URL to access dataset.; key_properties : :class:`set` of :obj:`str`; Set containing key property strings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = d",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:380,Testability,Log,Log,380,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2090,Testability,assert,assert,2090,"ary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); retu",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2116,Testability,assert,assert,2116,"ary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); retu",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:2146,Testability,assert,assert,2146,"ary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`.DatasetVersion` if available on cloud platform, else ``None``.; """"""; assert 'url' in doc, doc; assert 'version' in doc, doc; assert 'reference_genome' in doc, doc; if cloud in doc['url']:; return DatasetVersion(doc['url'][cloud], doc['version'], doc['reference_genome']); else:; return None. @staticmethod; def get_region(name: str, versions: List['DatasetVersion'], region: str) -> List['DatasetVersion']:; """"""Get versions of a :class:`.Dataset` in the specified region, if they; exist. Parameters; ----------; name : :obj:`str`; Name of dataset.; versions : :class:`list` of :class:`.DatasetVersion`; List of DatasetVersion objects where the value for :attr:`.url`; is a :obj:`dict` containing key: value pairs, like ``region: url``.; region : :obj:`str`; Region from which to access data, available regions given in; :attr:`hail.experimental.DB._valid_regions`. Returns; -------; available_versions : :class:`list` of :class:`.DatasetVersion`; List of available versions of a class:`.Dataset` for region.; """"""; available_versions = []; for version in versions:; if version.in_region(name, region):; version.url = version.url[region]; available_versions.append(version); retu",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6553,Testability,assert,assert,6553,"ings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_exp",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6589,Testability,assert,assert,6589,"ings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_exp",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6660,Testability,assert,assert,6660,"ings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_exp",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6694,Testability,assert,assert,6694,"ings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_exp",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:6720,Testability,assert,assert,6720,"ings, if present. Valid properties; include ``'gene'`` and ``'unique'``.; versions : :class:`list` of :class:`.DatasetVersion`; List of :class:`.DatasetVersion` objects.; """""". @staticmethod; def from_name_and_json(name: str, doc: dict, region: str, cloud: str) -> Optional['Dataset']:; """"""Create :class:`.Dataset` object from dictionary. Parameters; ----------; name : :obj:`str`; Name of dataset.; doc : :obj:`dict`; Dictionary containing dataset description, url, key_properties, and; versions.; region : :obj:`str`; Region from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_exp",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:7275,Testability,assert,assert,7275,"gion from which to access data, available regions given in; :func:`hail.experimental.DB._valid_regions`.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns; -------; :class:`Dataset`, optional; If versions exist for region returns a :class:`.Dataset` object,; else ``None``.; """"""; assert 'annotation_db' in doc, doc; assert 'key_properties' in doc['annotation_db'], doc['annotation_db']; assert 'description' in doc, doc; assert 'url' in doc, doc; assert 'versions' in doc, doc; key_properties = set(x for x in doc['annotation_db']['key_properties'] if x is not None); versions = [; DatasetVersion.from_json(x, cloud); for x in doc['versions']; if DatasetVersion.from_json(x, cloud) is not None; ]; versions_in_region = DatasetVersion.get_region(name, versions, region); if versions_in_region:; return Dataset(name, doc['description'], doc['url'], key_properties, versions_in_region). def __init__(self, name: str, description: str, url: str, key_properties: Set[str], versions: List[DatasetVersion]):; assert set(key_properties).issubset(DB._valid_key_properties); self.name = name; self.description = description; self.url = url; self.key_properties = key_properties; self.versions = versions. @property; def is_gene_keyed(self) -> bool:; """"""If a :class:`Dataset` is gene keyed. Returns; -------; :obj:`bool`; Whether or not dataset is gene keyed.; """"""; return 'gene' in self.key_properties. def index_compatible_version(self, key_expr: StructExpression) -> StructExpression:; """"""Get index from compatible version of annotation dataset. Checks for compatible indexed values from each :class:`.DatasetVersion`; in :attr:`.Dataset.versions`, where `key_expr` is the row key struct; from the dataset to be annotated. Parameters; ----------; key_expr : :class:`.StructExpression`; Row key struct from relational object to be annotated. Returns; -------; :class:`.StructExpression`; Struct of compatible indexed values.; """"""; all_matches = 'unique' not in self",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:11832,Testability,assert,assert,11832,"f'Specify valid region parameter,'; f' received: region={region!r}.\n'; f'Valid regions are {DB._valid_regions}.'; ); if cloud not in DB._valid_clouds:; raise ValueError(; f'Specify valid cloud parameter,'; f' received: cloud={cloud!r}.\n'; f'Valid cloud platforms are {DB._valid_clouds}.'; ); if (region, cloud) not in DB._valid_combinations:; raise ValueError(; f'The {region!r} region is not available for'; f' the {cloud!r} cloud platform. '; f'Valid region, cloud combinations are'; f' {DB._valid_combinations}.'; ); if config is not None and url is not None:; raise ValueError(; f'Only specify one of the parameters url and' f' config, received: url={url} and config={config}'; ); if config is None:; if url is None:; config = get_datasets_metadata(); else:; session = external_requests_client_session(); response = retry_response_returning_functions(session.get, url); config = response.json(); assert isinstance(config, dict); elif not isinstance(config, dict):; raise ValueError(f'expected a dict mapping dataset names to ' f'configurations, but found {config}'); config = {k: v for k, v in config.items() if 'annotation_db' in v}; self.region = region; self.cloud = cloud; self.url = url; self.config = config; self.__by_name = {; k: Dataset.from_name_and_json(k, v, region, cloud); for k, v in config.items(); if Dataset.from_name_and_json(k, v, region, cloud) is not None; }. @property; def available_datasets(self) -> List[str]:; """"""List of names of available annotation datasets. Returns; -------; :obj:`list`; List of available annotation datasets.; """"""; return sorted(self.__by_name.keys()). @staticmethod; def _row_lens(rel: Union[Table, MatrixTable]) -> Union[TableRows, MatrixRows]:; """"""Get row lens from relational object. Parameters; ----------; rel : :class:`Table` or :class:`MatrixTable`. Returns; -------; :class:`TableRows` or :class:`MatrixRows`; """"""; if isinstance(rel, MatrixTable):; return MatrixRows(rel); elif isinstance(rel, Table):; return TableRows(rel); else:; rais",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:58,Usability,Feedback,Feedback,58,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/db.html:268,Usability,Guid,Guides,268,"﻿. Hail | ; hail.experimental.db. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.db. Source code for hail.experimental.db; import warnings; from typing import ClassVar, Iterable, List, Optional, Set, Tuple, Union. import hail as hl; from hailtop.utils import external_requests_client_session, retry_response_returning_functions. from ..expr import StructExpression; from ..matrixtable import MatrixTable, matrix_table_type; from ..table import Table, table_type; from ..typecheck import oneof, typecheck_method; from ..utils.java import Env, info; from .datasets_metadata import get_datasets_metadata; from .lens import MatrixRows, TableRows. class DatasetVersion:; """""":class:`DatasetVersion` has two constructors: :func:`.from_json` and; :func:`.get_region`. Parameters; ----------; url : :obj:`dict` or :obj:`str`; Nested dictionary of URLs containing key: value pairs, like; ``cloud: {region: url}`` if using :func:`.from_json` constructor,; or a string with the URL from appropriate region if using the; :func:`.get_region` constructor.; version : :obj:`str`, optional; String of dataset version, if not ``None``.; reference_genome : :obj:`str`, optional; String of dataset reference genome, if not ``None``.; """""". @staticmethod; def from_json(doc: dict, cloud: str) -> Optional['DatasetVersion']:; """"""Create :class:`.DatasetVersion` object from dictionary. Parameters; ----------; doc : :obj:`dict`; Dictionary containing url and version keys.; Value for url is a :obj:`dict` containing key: value pairs, like; ``cloud: {region: url}``.; cloud : :obj:`str`; Cloud platform to access dataset, either ``'gcp'`` or ``'aws'``. Returns",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/db.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/db.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:177,Deployability,Install,Installation,177,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:245,Deployability,Configurat,Configuration,245,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:3668,Deployability,update,updated,3668," wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-04.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-05.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-06.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-07.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-08.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-09.tsv.bgz. $ zcat output/cols_files/part-00.tsv.bgz; #{""col_idx"":0}; row_idx x; 0 6.2501e-02; 1 7.0083e-01; 2 3.6452e-01; 3 4.4170e-01; 4 7.9177e-02; 5 6.2392e-01; 6 5.9920e-01; 7 9.7540e-01; 8 8.4848e-01; 9 3.7423e-01. Due to overhead and file system limits related to having large numbers; of open files, this function will iteratively export groups of columns.; The `batch_size` parameter can control the size of these groups. Parameters; ----------; mt : :class:`.MatrixTable`; path : :obj:`int`; Path (directory to write to.; batch_size : :obj:`int`; Number of columns to write per iteration.; bgzip : :obj:`bool`; BGZip output files.; header_json_in_file : :obj:`bool`; Include JSON header in each component file (if False, only written to index.tsv); """"""; if use_string_key_as_file_name and not (len(mt.col_key) == 1 and mt.col_key[0].dtype == hl.tstr):; raise ValueError(; f'parameter ""use_string_key_as_file_name"" requires a single string column key, found {list(mt.col_key.dtype.values())}'; ); hl.utils.java.Env.backend().execute(; hl.ir.MatrixToValueApply(; mt._mir,; {; 'name': 'MatrixExportEntriesByCol',; 'parallelism': batch_size,; 'path': path,; 'bgzip': bgzip,; 'headerJsonInFile': header_json_in_file,; 'useStringKeyAsFileName': use_string_key_as_file_name,; },; ); ). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:245,Modifiability,Config,Configuration,245,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:399,Testability,Log,Log,399,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:77,Usability,Feedback,Feedback,77,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html:287,Usability,Guid,Guides,287,"﻿. Hail | ; hail.experimental.export_entries_by_col. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.export_entries_by_col. Source code for hail.experimental.export_entries_by_col; import hail as hl; from hail.matrixtable import MatrixTable; from hail.typecheck import typecheck. [docs]@typecheck(; mt=MatrixTable, path=str, batch_size=int, bgzip=bool, header_json_in_file=bool, use_string_key_as_file_name=bool; ); def export_entries_by_col(; mt: MatrixTable,; path: str,; batch_size: int = 256,; bgzip: bool = True,; header_json_in_file: bool = True,; use_string_key_as_file_name: bool = False,; ):; """"""Export entries of the `mt` by column as separate text files. Examples; --------; >>> range_mt = hl.utils.range_matrix_table(10, 10); >>> range_mt = range_mt.annotate_entries(x = hl.rand_unif(0, 1)); >>> hl.experimental.export_entries_by_col(range_mt, 'output/cols_files'). Notes; -----; This function writes a directory with one file per column in `mt`. The; files contain one tab-separated field (with header) for each row field; and entry field in `mt`. The column fields of `mt` are written as JSON; in the first line of each file, prefixed with a ``#``. The above will produce a directory at ``output/cols_files`` with the; following files:. .. code-block:: text. $ ls -l output/cols_files; total 80; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 index.tsv; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-00.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-01.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-02.tsv.bgz; -rw-r--r-- 1 hail-dev wheel 712 Jan 25 17:19 part-03.tsv.bgz; -rw-r--r-- 1 hail-dev ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/export_entries_by_col.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/export_entries_by_col.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:167,Deployability,Install,Installation,167,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:235,Deployability,Configurat,Configuration,235,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:2719,Deployability,update,updated,2719," path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""Read an :class:`~.Expression` written with :func:`.experimental.write_expression`. Example; -------; >>> hl.experimental.write_expression(hl.array([1, 2]), 'output/test_expression.he'); >>> expression = hl.experimental.read_expression('output/test_expression.he'); >>> hl.eval(expression). Parameters; ----------. path : :class:`str`; File to read. Returns; -------; :class:`~.Expression`; """"""; _assert_table_type = None; _load_refs = True; if _assert_type:; _assert_table_type = ttable(hl.tstruct(expr=_assert_type), row_type=hl.tstruct(), row_key=[]); _load_refs = False; return hl.read_table(path, _assert_type=_assert_table_type, _load_refs=_load_refs).index_globals().expr. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:235,Modifiability,Config,Configuration,235,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:389,Testability,Log,Log,389,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:67,Usability,Feedback,Feedback,67,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html:277,Usability,Guid,Guides,277,"﻿. Hail | ; hail.experimental.expressions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.expressions. Source code for hail.experimental.expressions; import hail as hl; from hail.expr.expressions import analyze, expr_any; from hail.expr.table_type import ttable; from hail.expr.types import hail_type; from hail.typecheck import nullable, typecheck. [docs]@typecheck(expr=expr_any, path=str, overwrite=bool); def write_expression(expr, path, overwrite=False):; """"""Write an Expression. In the same vein as Python's pickle, write out an expression; that does not have a source (such as one that comes from; Table.aggregate with _localize=False). Example; -------; >>> ht = hl.utils.range_table(100).annotate(x=hl.rand_norm()); >>> mean_norm = ht.aggregate(hl.agg.mean(ht.x), _localize=False); >>> mean_norm; >>> hl.eval(mean_norm); >>> hl.experimental.write_expression(mean_norm, 'output/expression.he'). Parameters; ----------. expr : :class:`~.Expression`; Expression to write.; path : :class:`str`; Path to which to write expression.; Suggested extension: .he (hail expression).; overwrite : :obj:`bool`; If ``True``, overwrite an existing file at the destination. Returns; -------; None; """"""; source = expr._indices.source; if source is not None:; analyze('write_expression.expr', expr, source._global_indices); source = source.select_globals(__expr=expr); expr = source.index_globals().__expr; hl.utils.range_table(1).filter(False).key_by().drop('idx').annotate_globals(expr=expr).write(; path, overwrite=overwrite; ). [docs]@typecheck(path=str, _assert_type=nullable(hail_type)); def read_expression(path, _assert_type=None):; """"""R",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/expressions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/expressions.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:182,Deployability,Install,Installation,182,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:250,Deployability,Configurat,Configuration,250,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:2325,Deployability,update,updated,2325,"; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :py:data:`.tint32`; an : int or :class:`.Expression` of type :py:data:`.tint32`; ci : float or :class:`.Expression` of type :py:data:`.tfloat64`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""filtering_allele_frequency"", tfloat64, ac, an, ci). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:250,Modifiability,Config,Configuration,250,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:404,Testability,Log,Log,404,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:82,Usability,Feedback,Feedback,82,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html:292,Usability,Guid,Guides,292,"﻿. Hail | ; hail.experimental.filtering_allele_frequency. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.filtering_allele_frequency. Source code for hail.experimental.filtering_allele_frequency; from hail.expr.expressions import Float64Expression, expr_float64, expr_int32; from hail.expr.functions import _func; from hail.expr.types import tfloat64; from hail.typecheck import typecheck. [docs]@typecheck(ac=expr_int32, an=expr_int32, ci=expr_float64); def filtering_allele_frequency(ac, an, ci) -> Float64Expression:; """"""; Computes a filtering allele frequency (described below); for `ac` and `an` with confidence `ci`. The filtering allele frequency is the highest true population allele frequency; for which the upper bound of the `ci` (confidence interval) of allele count; under a Poisson distribution is still less than the variant's observed; `ac` (allele count) in the reference sample, given an `an` (allele number). This function defines a ""filtering AF"" that represents; the threshold disease-specific ""maximum credible AF"" at or below which; the disease could not plausibly be caused by that variant. A variant with; a filtering AF >= the maximum credible AF for the disease under consideration; should be filtered, while a variant with a filtering AF below the maximum; credible remains a candidate. This filtering AF is not disease-specific:; it can be applied to any disease of interest by comparing with a; user-defined disease-specific maximum credible AF. For more details, see: `Whiffin et al., 2017 <https://www.nature.com/articles/gim201726>`__. Parameters; ----------; ac : int or :class:`.Expression` of type :p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/filtering_allele_frequency.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:5391,Availability,error,error,5391," = right.localize_entries('right_entries', 'right_cols'). ht = left_t.join(right_t, how='outer'); ht = ht.annotate_globals(; left_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.left_cols.map(lambda x: hl.tuple([x[f] for f in left.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; right_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.right_cols.map(lambda x: hl.tuple([x[f] for f in right.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; ); ht = ht.annotate_globals(; key_indices=hl.array(ht.left_keys.key_set().union(ht.right_keys.key_set())); .map(lambda k: hl.struct(k=k, left_indices=ht.left_keys.get(k), right_indices=ht.right_keys.get(k))); .flatmap(; lambda s: hl.case(); .when(; hl.is_defined(s.left_indices) & hl.is_defined(s.right_indices),; hl.range(0, s.left_indices.length()).flatmap(; lambda i: hl.range(0, s.right_indices.length()).map(; lambda j: hl.struct(k=s.k, left_index=s.left_indices[i], right_index=s.right_indices[j]); ); ),; ); .when(; hl.is_defined(s.left_indices),; s.left_indices.map(lambda elt: hl.struct(k=s.k, left_index=elt, right_index=hl.missing('int32'))),; ); .when(; hl.is_defined(s.right_indices),; s.right_indices.map(lambda elt: hl.struct(k=s.k, left_index=hl.missing('int32'), right_index=elt)),; ); .or_error('assertion error'); ); ); ht = ht.annotate(; __entries=ht.key_indices.map(; lambda s: hl.struct(left_entry=ht.left_entries[s.left_index], right_entry=ht.right_entries[s.right_index]); ); ); ht = ht.annotate_globals(; __cols=ht.key_indices.map(; lambda s: hl.struct(; **{f: s.k[i] for i, f in enumerate(left.col_key)},; left_col=ht.left_cols[s.left_index],; right_col=ht.right_cols[s.right_index],; ); ); ); ht = ht.drop('left_entries', 'left_cols', 'left_keys', 'right_entries', 'right_cols', 'right_keys', 'key_indices'); return ht._unlocalize_entries('__entries', '__cols', list(left.col_key)). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:174,Deployability,Install,Installation,174,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:242,Deployability,Configurat,Configuration,242,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:6017,Deployability,update,updated,6017," = right.localize_entries('right_entries', 'right_cols'). ht = left_t.join(right_t, how='outer'); ht = ht.annotate_globals(; left_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.left_cols.map(lambda x: hl.tuple([x[f] for f in left.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; right_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.right_cols.map(lambda x: hl.tuple([x[f] for f in right.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; ); ht = ht.annotate_globals(; key_indices=hl.array(ht.left_keys.key_set().union(ht.right_keys.key_set())); .map(lambda k: hl.struct(k=k, left_indices=ht.left_keys.get(k), right_indices=ht.right_keys.get(k))); .flatmap(; lambda s: hl.case(); .when(; hl.is_defined(s.left_indices) & hl.is_defined(s.right_indices),; hl.range(0, s.left_indices.length()).flatmap(; lambda i: hl.range(0, s.right_indices.length()).map(; lambda j: hl.struct(k=s.k, left_index=s.left_indices[i], right_index=s.right_indices[j]); ); ),; ); .when(; hl.is_defined(s.left_indices),; s.left_indices.map(lambda elt: hl.struct(k=s.k, left_index=elt, right_index=hl.missing('int32'))),; ); .when(; hl.is_defined(s.right_indices),; s.right_indices.map(lambda elt: hl.struct(k=s.k, left_index=hl.missing('int32'), right_index=elt)),; ); .or_error('assertion error'); ); ); ht = ht.annotate(; __entries=ht.key_indices.map(; lambda s: hl.struct(left_entry=ht.left_entries[s.left_index], right_entry=ht.right_entries[s.right_index]); ); ); ht = ht.annotate_globals(; __cols=ht.key_indices.map(; lambda s: hl.struct(; **{f: s.k[i] for i, f in enumerate(left.col_key)},; left_col=ht.left_cols[s.left_index],; right_col=ht.right_cols[s.right_index],; ); ); ); ht = ht.drop('left_entries', 'left_cols', 'left_keys', 'right_entries', 'right_cols', 'right_keys', 'key_indices'); return ht._unlocalize_entries('__entries', '__cols', list(left.col_key)). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:242,Modifiability,Config,Configuration,242,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:686,Performance,Perform,Performs,686,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:396,Testability,Log,Log,396,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:5381,Testability,assert,assertion,5381," = right.localize_entries('right_entries', 'right_cols'). ht = left_t.join(right_t, how='outer'); ht = ht.annotate_globals(; left_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.left_cols.map(lambda x: hl.tuple([x[f] for f in left.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; right_keys=hl.group_by(; lambda t: t[0],; hl.enumerate(ht.right_cols.map(lambda x: hl.tuple([x[f] for f in right.col_key])), index_first=False),; ).map_values(lambda elts: elts.map(lambda t: t[1])),; ); ht = ht.annotate_globals(; key_indices=hl.array(ht.left_keys.key_set().union(ht.right_keys.key_set())); .map(lambda k: hl.struct(k=k, left_indices=ht.left_keys.get(k), right_indices=ht.right_keys.get(k))); .flatmap(; lambda s: hl.case(); .when(; hl.is_defined(s.left_indices) & hl.is_defined(s.right_indices),; hl.range(0, s.left_indices.length()).flatmap(; lambda i: hl.range(0, s.right_indices.length()).map(; lambda j: hl.struct(k=s.k, left_index=s.left_indices[i], right_index=s.right_indices[j]); ); ),; ); .when(; hl.is_defined(s.left_indices),; s.left_indices.map(lambda elt: hl.struct(k=s.k, left_index=elt, right_index=hl.missing('int32'))),; ); .when(; hl.is_defined(s.right_indices),; s.right_indices.map(lambda elt: hl.struct(k=s.k, left_index=hl.missing('int32'), right_index=elt)),; ); .or_error('assertion error'); ); ); ht = ht.annotate(; __entries=ht.key_indices.map(; lambda s: hl.struct(left_entry=ht.left_entries[s.left_index], right_entry=ht.right_entries[s.right_index]); ); ); ht = ht.annotate_globals(; __cols=ht.key_indices.map(; lambda s: hl.struct(; **{f: s.k[i] for i, f in enumerate(left.col_key)},; left_col=ht.left_cols[s.left_index],; right_col=ht.right_cols[s.right_index],; ); ); ); ht = ht.drop('left_entries', 'left_cols', 'left_keys', 'right_entries', 'right_cols', 'right_keys', 'key_indices'); return ht._unlocalize_entries('__entries', '__cols', list(left.col_key)). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:74,Usability,Feedback,Feedback,74,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html:284,Usability,Guid,Guides,284,"﻿. Hail | ; hail.experimental.full_outer_join_mt. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.full_outer_join_mt. Source code for hail.experimental.full_outer_join_mt; import hail as hl; from hail.matrixtable import MatrixTable. [docs]def full_outer_join_mt(left: MatrixTable, right: MatrixTable) -> MatrixTable:; """"""Performs a full outer join on `left` and `right`. Replaces row, column, and entry fields with the following:. - `left_row` / `right_row`: structs of row fields from left and right.; - `left_col` / `right_col`: structs of column fields from left and right.; - `left_entry` / `right_entry`: structs of entry fields from left and right. Examples; --------. The following creates and joins two random datasets with disjoint sample ids; but non-disjoint variant sets. We use :func:`.or_else` to attempt to find a; non-missing genotype. If neither genotype is non-missing, then the genotype; is set to missing. In particular, note that Samples `2` and `3` have missing; genotypes for loci 1:1 and 1:2 because those loci are not present in `mt2`; and these samples are not present in `mt1`. >>> hl.reset_global_randomness(); >>> mt1 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = hl.balding_nichols_model(1, 2, 3); >>> mt2 = mt2.key_rows_by(locus=hl.locus(mt2.locus.contig,; ... mt2.locus.position+2),; ... alleles=mt2.alleles); >>> mt2 = mt2.key_cols_by(sample_idx=mt2.sample_idx+2); >>> mt1.show(); +---------------+------------+------+------+; | locus | alleles | 0.GT | 1.GT |; +---------------+------------+------+------+; | locus<GRCh37> | array<str> | call | call |; +---------------+------------+------+------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/full_outer_join_mt.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/full_outer_join_mt.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:5057,Availability,checkpoint,checkpoint,5057," : :obj:`bool`; If ``True``, load gzipped files serially on one core. This should; be used only when absolutely necessary, as processing time will be; increased due to lack of parallelism. Returns; -------; :class:`.Table`; """""". ht = hl.import_table(; path,; min_partitions=min_partitions,; comment='#',; no_header=True,; types={'f3': hl.tint, 'f4': hl.tint, 'f5': hl.tfloat, 'f7': hl.tint},; missing='.',; delimiter='\t',; force_bgz=force_bgz,; force=force,; ). ht = ht.rename({; 'f0': 'seqname',; 'f1': 'source',; 'f2': 'feature',; 'f3': 'start',; 'f4': 'end',; 'f5': 'score',; 'f6': 'strand',; 'f7': 'frame',; 'f8': 'attribute',; }). def parse_attributes(unparsed_attributes):; def parse_attribute(attribute):; key_and_value = attribute.split(' '); key = key_and_value[0]; value = key_and_value[1]; return (key, value.replace('""|;\\$', '')). return hl.dict(unparsed_attributes.split('; ').map(parse_attribute)). ht = ht.annotate(attribute=parse_attributes(ht['attribute'])). ht = ht.checkpoint(new_temp_file()). attributes = ht.aggregate(hl.agg.explode(lambda x: hl.agg.collect_as_set(x), ht['attribute'].keys())). ht = ht.transmute(**{x: hl.or_missing(ht['attribute'].contains(x), ht['attribute'][x]) for x in attributes if x}). if reference_genome:; if reference_genome.name == 'GRCh37':; ht = ht.annotate(; seqname=hl.case(); .when((ht['seqname'] == 'M') | (ht['seqname'] == 'chrM'), 'MT'); .when(ht['seqname'].startswith('chr'), ht['seqname'].replace('^chr', '')); .default(ht['seqname']); ); else:; ht = ht.annotate(; seqname=hl.case(); .when(ht['seqname'].startswith('HLA'), ht['seqname']); .when(ht['seqname'].startswith('chrHLA'), ht['seqname'].replace('^chr', '')); .when(ht['seqname'].startswith('chr'), ht['seqname']); .default('chr' + ht['seqname']); ); if skip_invalid_contigs:; valid_contigs = hl.literal(set(reference_genome.contigs)); ht = ht.filter(valid_contigs.contains(ht['seqname'])); ht = ht.transmute(; interval=hl.locus_interval(; ht['seqname'],; ht['start'],; ht['end'],; ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:6975,Availability,avail,available,6975,"); ht = ht.transmute(; interval=hl.locus_interval(; ht['seqname'],; ht['start'],; ht['end'],; includes_start=True,; includes_end=True,; reference_genome=reference_genome,; ); ); else:; ht = ht.transmute(; interval=hl.interval(; hl.struct(seqname=ht['seqname'], position=ht['start']),; hl.struct(seqname=ht['seqname'], position=ht['end']),; includes_start=True,; includes_end=True,; ); ). ht = ht.key_by('interval'). return ht. [docs]@typecheck(; gene_symbols=nullable(sequenceof(str)),; gene_ids=nullable(sequenceof(str)),; transcript_ids=nullable(sequenceof(str)),; verbose=bool,; reference_genome=nullable(reference_genome_type),; gtf_file=nullable(str),; ); def get_gene_intervals(; gene_symbols=None, gene_ids=None, transcript_ids=None, verbose=True, reference_genome=None, gtf_file=None; ):; """"""Get intervals of genes or transcripts. Get the boundaries of genes or transcripts from a GTF file, for quick filtering of a Table or MatrixTable. On Google Cloud platform:; Gencode v19 (GRCh37) GTF available at: gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz; Gencode v29 (GRCh38) GTF available at: gs://hail-common/references/gencode/gencode.v29.annotation.gtf.bgz. Example; -------; >>> hl.filter_intervals(ht, get_gene_intervals(gene_symbols=['PCSK9'], reference_genome='GRCh37')) # doctest: +SKIP. Parameters; ----------. gene_symbols : :obj:`list` of :class:`str`, optional; Gene symbols (e.g. PCSK9).; gene_ids : :obj:`list` of :class:`str`, optional; Gene IDs (e.g. ENSG00000223972).; transcript_ids : :obj:`list` of :class:`str`, optional; Transcript IDs (e.g. ENSG00000223972).; verbose : :obj:`bool`; If ``True``, print which genes and transcripts were matched in the GTF file.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platf",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:7082,Availability,avail,available,7082,"ludes_end=True,; reference_genome=reference_genome,; ); ); else:; ht = ht.transmute(; interval=hl.interval(; hl.struct(seqname=ht['seqname'], position=ht['start']),; hl.struct(seqname=ht['seqname'], position=ht['end']),; includes_start=True,; includes_end=True,; ); ). ht = ht.key_by('interval'). return ht. [docs]@typecheck(; gene_symbols=nullable(sequenceof(str)),; gene_ids=nullable(sequenceof(str)),; transcript_ids=nullable(sequenceof(str)),; verbose=bool,; reference_genome=nullable(reference_genome_type),; gtf_file=nullable(str),; ); def get_gene_intervals(; gene_symbols=None, gene_ids=None, transcript_ids=None, verbose=True, reference_genome=None, gtf_file=None; ):; """"""Get intervals of genes or transcripts. Get the boundaries of genes or transcripts from a GTF file, for quick filtering of a Table or MatrixTable. On Google Cloud platform:; Gencode v19 (GRCh37) GTF available at: gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz; Gencode v29 (GRCh38) GTF available at: gs://hail-common/references/gencode/gencode.v29.annotation.gtf.bgz. Example; -------; >>> hl.filter_intervals(ht, get_gene_intervals(gene_symbols=['PCSK9'], reference_genome='GRCh37')) # doctest: +SKIP. Parameters; ----------. gene_symbols : :obj:`list` of :class:`str`, optional; Gene symbols (e.g. PCSK9).; gene_ids : :obj:`list` of :class:`str`, optional; Gene IDs (e.g. ENSG00000223972).; transcript_ids : :obj:`list` of :class:`str`, optional; Transcript IDs (e.g. ENSG00000223972).; verbose : :obj:`bool`; If ``True``, print which genes and transcripts were matched in the GTF file.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :obj:`list` of :class:`.Interval`; """"""; if gene_symbols is None and gene_ids is None and trans",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:166,Deployability,Install,Installation,166,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:234,Deployability,Configurat,Configuration,234,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:10360,Deployability,update,updated,10360,"ene_symbols)); if gene_ids:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_id == y.split('\\.')[0]), gene_ids)); if transcript_ids:; criteria.append(; hl.any(lambda y: (ht.feature == 'transcript') & (ht.transcript_id == y.split('\\.')[0]), transcript_ids); ). ht = ht.filter(functools.reduce(operator.ior, criteria)); gene_info = ht.aggregate(hl.agg.collect((ht.feature, ht.gene_name, ht.gene_id, ht.transcript_id, ht.interval))); if verbose:; info(; f'get_gene_intervals found {len(gene_info)} entries:\n'; + ""\n"".join(map(lambda x: f'{x[0]}: {x[1]} ({x[2] if x[0] == ""gene"" else x[3]})', gene_info)); ); intervals = list(map(lambda x: x[-1], gene_info)); return intervals. def _load_gencode_gtf(gtf_file=None, reference_genome=None):; """"""; Get Gencode GTF (from file or reference genome). Parameters; ----------; reference_genome : :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :class:`.Table`; """"""; GTFS = {; 'GRCh37': 'gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz',; 'GRCh38': 'gs://hail-common/references/gencode/gencode.v29.annotation.gtf.bgz',; }; if reference_genome is None:; reference_genome = hl.default_reference().name; else:; reference_genome = reference_genome.name; if gtf_file is None:; gtf_file = GTFS.get(reference_genome); if gtf_file is None:; raise ValueError(; 'get_gene_intervals requires a GTF file, or the reference genome be one of GRCh37 or GRCh38 (when on Google Cloud Platform)'; ); ht = hl.experimental.import_gtf(; gtf_file, reference_genome=reference_genome, skip_invalid_contigs=True, min_partitions=12; ); ht = ht.annotate(gene_id=ht.gene_id.split('\\.')[0], transcript_id=ht.transcript_id.split('\\.')[0]); return ht. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:8694,Energy Efficiency,reduce,reduce,8694," : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :obj:`list` of :class:`.Interval`; """"""; if gene_symbols is None and gene_ids is None and transcript_ids is None:; raise ValueError('get_gene_intervals requires at least one of gene_symbols, gene_ids, or transcript_ids'); ht = _load_gencode_gtf(gtf_file, reference_genome); criteria = []; if gene_symbols:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_name == y), gene_symbols)); if gene_ids:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_id == y.split('\\.')[0]), gene_ids)); if transcript_ids:; criteria.append(; hl.any(lambda y: (ht.feature == 'transcript') & (ht.transcript_id == y.split('\\.')[0]), transcript_ids); ). ht = ht.filter(functools.reduce(operator.ior, criteria)); gene_info = ht.aggregate(hl.agg.collect((ht.feature, ht.gene_name, ht.gene_id, ht.transcript_id, ht.interval))); if verbose:; info(; f'get_gene_intervals found {len(gene_info)} entries:\n'; + ""\n"".join(map(lambda x: f'{x[0]}: {x[1]} ({x[2] if x[0] == ""gene"" else x[3]})', gene_info)); ); intervals = list(map(lambda x: x[-1], gene_info)); return intervals. def _load_gencode_gtf(gtf_file=None, reference_genome=None):; """"""; Get Gencode GTF (from file or reference genome). Parameters; ----------; reference_genome : :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :class:`.Table`; """"""; GTFS = {; 'GRCh37': 'gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz',; 'GRCh38': 'gs://hail-common/references/gencode/gencode.v29.annota",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:234,Modifiability,Config,Configuration,234,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:3800,Performance,load,load,3800,"Row fields:; 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'gene_type': str; 'exon_id': str; 'havana_transcript': str; 'level': str; 'transcript_name': str; 'gene_status': str; 'gene_id': str; 'transcript_type': str; 'tag': str; 'transcript_status': str; 'gene_name': str; 'transcript_id': str; 'exon_number': str; 'havana_gene': str; 'interval': interval<locus<GRCh37>>; ----------------------------------------; Key: ['interval']; ----------------------------------------. Parameters; ----------. path : :class:`str`; File to import.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use.; skip_invalid_contigs : :obj:`bool`; If ``True`` and `reference_genome` is not ``None``, skip lines where; ``seqname`` is not consistent with the reference genome.; min_partitions : :obj:`int` or :obj:`None`; Minimum number of partitions (passed to import_table).; force_bgz : :obj:`bool`; If ``True``, load files as blocked gzip files, assuming; that they were actually compressed using the BGZ codec. This option is; useful when the file extension is not ``'.bgz'``, but the file is; blocked gzip, so that the file can be read in parallel and not on a; single node.; force : :obj:`bool`; If ``True``, load gzipped files serially on one core. This should; be used only when absolutely necessary, as processing time will be; increased due to lack of parallelism. Returns; -------; :class:`.Table`; """""". ht = hl.import_table(; path,; min_partitions=min_partitions,; comment='#',; no_header=True,; types={'f3': hl.tint, 'f4': hl.tint, 'f5': hl.tfloat, 'f7': hl.tint},; missing='.',; delimiter='\t',; force_bgz=force_bgz,; force=force,; ). ht = ht.rename({; 'f0': 'seqname',; 'f1': 'source',; 'f2': 'feature',; 'f3': 'start',; 'f4': 'end',; 'f5': 'score',; 'f6': 'strand',; 'f7': 'frame',; 'f8': 'attribute',; }). def parse_attributes(unparsed_attributes):; def parse_attribute(attribute):; key_and_value = attribute.split(' '); key = k",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:4100,Performance,load,load,4100,"t_status': str; 'gene_name': str; 'transcript_id': str; 'exon_number': str; 'havana_gene': str; 'interval': interval<locus<GRCh37>>; ----------------------------------------; Key: ['interval']; ----------------------------------------. Parameters; ----------. path : :class:`str`; File to import.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use.; skip_invalid_contigs : :obj:`bool`; If ``True`` and `reference_genome` is not ``None``, skip lines where; ``seqname`` is not consistent with the reference genome.; min_partitions : :obj:`int` or :obj:`None`; Minimum number of partitions (passed to import_table).; force_bgz : :obj:`bool`; If ``True``, load files as blocked gzip files, assuming; that they were actually compressed using the BGZ codec. This option is; useful when the file extension is not ``'.bgz'``, but the file is; blocked gzip, so that the file can be read in parallel and not on a; single node.; force : :obj:`bool`; If ``True``, load gzipped files serially on one core. This should; be used only when absolutely necessary, as processing time will be; increased due to lack of parallelism. Returns; -------; :class:`.Table`; """""". ht = hl.import_table(; path,; min_partitions=min_partitions,; comment='#',; no_header=True,; types={'f3': hl.tint, 'f4': hl.tint, 'f5': hl.tfloat, 'f7': hl.tint},; missing='.',; delimiter='\t',; force_bgz=force_bgz,; force=force,; ). ht = ht.rename({; 'f0': 'seqname',; 'f1': 'source',; 'f2': 'feature',; 'f3': 'start',; 'f4': 'end',; 'f5': 'score',; 'f6': 'strand',; 'f7': 'frame',; 'f8': 'attribute',; }). def parse_attributes(unparsed_attributes):; def parse_attribute(attribute):; key_and_value = attribute.split(' '); key = key_and_value[0]; value = key_and_value[1]; return (key, value.replace('""|;\\$', '')). return hl.dict(unparsed_attributes.split('; ').map(parse_attribute)). ht = ht.annotate(attribute=parse_attributes(ht['attribute'])). ht = ht.checkpoint(new_temp_file()). attributes = ht.",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:7850,Performance,load,load,7850,"s of genes or transcripts from a GTF file, for quick filtering of a Table or MatrixTable. On Google Cloud platform:; Gencode v19 (GRCh37) GTF available at: gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz; Gencode v29 (GRCh38) GTF available at: gs://hail-common/references/gencode/gencode.v29.annotation.gtf.bgz. Example; -------; >>> hl.filter_intervals(ht, get_gene_intervals(gene_symbols=['PCSK9'], reference_genome='GRCh37')) # doctest: +SKIP. Parameters; ----------. gene_symbols : :obj:`list` of :class:`str`, optional; Gene symbols (e.g. PCSK9).; gene_ids : :obj:`list` of :class:`str`, optional; Gene IDs (e.g. ENSG00000223972).; transcript_ids : :obj:`list` of :class:`str`, optional; Transcript IDs (e.g. ENSG00000223972).; verbose : :obj:`bool`; If ``True``, print which genes and transcripts were matched in the GTF file.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :obj:`list` of :class:`.Interval`; """"""; if gene_symbols is None and gene_ids is None and transcript_ids is None:; raise ValueError('get_gene_intervals requires at least one of gene_symbols, gene_ids, or transcript_ids'); ht = _load_gencode_gtf(gtf_file, reference_genome); criteria = []; if gene_symbols:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_name == y), gene_symbols)); if gene_ids:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_id == y.split('\\.')[0]), gene_ids)); if transcript_ids:; criteria.append(; hl.any(lambda y: (ht.feature == 'transcript') & (ht.transcript_id == y.split('\\.')[0]), transcript_ids); ). ht = ht.filter(functools.reduce(operator.ior, criteria)); gene_info = ht.aggregate(hl.agg.collect((ht.feature, ht.gene_name, ht.gene_id, ht.transcript_id, ht.interv",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:9372,Performance,load,load,9372," 'gene') & (ht.gene_name == y), gene_symbols)); if gene_ids:; criteria.append(hl.any(lambda y: (ht.feature == 'gene') & (ht.gene_id == y.split('\\.')[0]), gene_ids)); if transcript_ids:; criteria.append(; hl.any(lambda y: (ht.feature == 'transcript') & (ht.transcript_id == y.split('\\.')[0]), transcript_ids); ). ht = ht.filter(functools.reduce(operator.ior, criteria)); gene_info = ht.aggregate(hl.agg.collect((ht.feature, ht.gene_name, ht.gene_id, ht.transcript_id, ht.interval))); if verbose:; info(; f'get_gene_intervals found {len(gene_info)} entries:\n'; + ""\n"".join(map(lambda x: f'{x[0]}: {x[1]} ({x[2] if x[0] == ""gene"" else x[3]})', gene_info)); ); intervals = list(map(lambda x: x[-1], gene_info)); return intervals. def _load_gencode_gtf(gtf_file=None, reference_genome=None):; """"""; Get Gencode GTF (from file or reference genome). Parameters; ----------; reference_genome : :class:`.ReferenceGenome`, optional; Reference genome to use (passed along to import_gtf).; gtf_file : :class:`str`; GTF file to load. If none is provided, but `reference_genome` is one of; `GRCh37` or `GRCh38`, a default will be used (on Google Cloud Platform). Returns; -------; :class:`.Table`; """"""; GTFS = {; 'GRCh37': 'gs://hail-common/references/gencode/gencode.v19.annotation.gtf.bgz',; 'GRCh38': 'gs://hail-common/references/gencode/gencode.v29.annotation.gtf.bgz',; }; if reference_genome is None:; reference_genome = hl.default_reference().name; else:; reference_genome = reference_genome.name; if gtf_file is None:; gtf_file = GTFS.get(reference_genome); if gtf_file is None:; raise ValueError(; 'get_gene_intervals requires a GTF file, or the reference genome be one of GRCh37 or GRCh38 (when on Google Cloud Platform)'; ); ht = hl.experimental.import_gtf(; gtf_file, reference_genome=reference_genome, skip_invalid_contigs=True, min_partitions=12; ); ht = ht.annotate(gene_id=ht.gene_id.split('\\.')[0], transcript_id=ht.transcript_id.split('\\.')[0]); return ht. © Copyright 2015-2024, Hail Team.; ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:388,Testability,Log,Log,388,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:2598,Testability,test,test,2598,"; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``reference_genome`` parameter is specified, the start and end; points of the ``interval`` field will be of type :class:`.tlocus`.; Otherwise, the start and end points of the ``interval`` field will be of; type :class:`.tstruct` with fields ``seqname`` (type :class:`str`) and; ``position`` (type :obj:`.tint32`). Furthermore, if the ``reference_genome`` parameter is specified and; ``skip_invalid_contigs`` is ``True``, this import function will skip; lines in the GTF where ``seqname`` is not consistent with the reference; genome specified. Example; -------. >>> ht = hl.experimental.import_gtf('data/test.gtf',; ... reference_genome='GRCh37',; ... skip_invalid_contigs=True). >>> ht.describe() # doctest: +SKIP_OUTPUT_CHECK; ----------------------------------------; Global fields:; None; ----------------------------------------; Row fields:; 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'gene_type': str; 'exon_id': str; 'havana_transcript': str; 'level': str; 'transcript_name': str; 'gene_status': str; 'gene_id': str; 'transcript_type': str; 'tag': str; 'transcript_status': str; 'gene_name': str; 'transcript_id': str; 'exon_number': str; 'havana_gene': str; 'interval': interval<locus<GRCh37>>; ----------------------------------------; Key: ['interval']; ----------------------------------------. Parameters; ----------. path : :class:`str`; File to import.; reference_genome : :class:`str` or :class:`.ReferenceGenome`, optional; Reference genome to use.; skip_invalid_contigs : :obj:`bool`; If ``True`` and `reference_genome` is not ``None``, skip l",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:66,Usability,Feedback,Feedback,66,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html:276,Usability,Guid,Guides,276,"﻿. Hail | ; hail.experimental.import_gtf. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.import_gtf. Source code for hail.experimental.import_gtf; import functools; import operator. import hail as hl; from hail.genetics.reference_genome import reference_genome_type; from hail.table import Table; from hail.typecheck import nullable, sequenceof, typecheck; from hail.utils import new_temp_file; from hail.utils.java import info. [docs]@typecheck(; path=str,; reference_genome=nullable(reference_genome_type),; skip_invalid_contigs=bool,; min_partitions=nullable(int),; force_bgz=bool,; force=bool,; ); def import_gtf(; path, reference_genome=None, skip_invalid_contigs=False, min_partitions=None, force_bgz=False, force=False; ) -> Table:; """"""Import a GTF file. The GTF file format is identical to the GFF version 2 file format,; and so this function can be used to import GFF version 2 files as; well. See https://www.ensembl.org/info/website/upload/gff.html for more; details on the GTF/GFF2 file format. The :class:`.Table` returned by this function will be keyed by the; ``interval`` row field and will include the following row fields:. .. code-block:: text. 'source': str; 'feature': str; 'score': float64; 'strand': str; 'frame': int32; 'interval': interval<>. There will also be corresponding fields for every tag found in the; attribute field of the GTF file. Note; ----. This function will return an ``interval`` field of type :class:`.tinterval`; constructed from the ``seqname``, ``start``, and ``end`` fields in the; GTF file. This interval is inclusive of both the start and end positions; in the GTF file. If the ``refer",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/import_gtf.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/import_gtf.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:163,Deployability,Install,Installation,163,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:231,Deployability,Configurat,Configuration,231,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:1486,Deployability,continuous,continuous,1486,"l.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.binary_annotation,; ... mt.continuous_annotation]). >>> # Show results; >>> ht_scores.show(3). .. code-block:: text. +---------------+-------------------+-----------------------+-------------+; | locus | binary_annotation | continuous_annotation | univariate |; +---------------+-------------------+-----------------------+-------------+; | locus<GRCh37> | float64 | float64 | float64 |; +---------------+-------------------+-----------------------+-------------+; | 20:82079 | 1.15183e+00 | 7.",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:1753,Deployability,continuous,continuous,1753,"emp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.binary_annotation,; ... mt.continuous_annotation]). >>> # Show results; >>> ht_scores.show(3). .. code-block:: text. +---------------+-------------------+-----------------------+-------------+; | locus | binary_annotation | continuous_annotation | univariate |; +---------------+-------------------+-----------------------+-------------+; | locus<GRCh37> | float64 | float64 | float64 |; +---------------+-------------------+-----------------------+-------------+; | 20:82079 | 1.15183e+00 | 7.30145e+01 | 1.60117e+00 |; | 20:103517 | 2.04604e+00 | 2.75392e+02 | 4.69239e+00 |; | 20:108286 | 2.06585e+00 | 2.86453e+02 | 5.00124e+00 |; +---------------+-------------------+-----------------------+-------------+. Warning; -------; :func:`.ld_score` will fail if",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:6967,Deployability,update,updated,6967,"e ValueError(""""""ld_score: entry_expr, locus_expr, coord_expr; (if specified), and annotation_exprs (if; specified) must come from same MatrixTable.""""""). n = mt.count_cols(); r2 = hl.row_correlation(entry_expr, block_size) ** 2; r2_adj = ((n - 1.0) / (n - 2.0)) * r2 - (1.0 / (n - 2.0)). starts, stops = hl.linalg.utils.locus_windows(locus_expr, radius, coord_expr); r2_adj_sparse = r2_adj.sparsify_row_intervals(starts, stops). r2_adj_sparse_tmp = new_temp_file(); r2_adj_sparse.write(r2_adj_sparse_tmp); r2_adj_sparse = BlockMatrix.read(r2_adj_sparse_tmp). if not annotation_exprs:; cols = ['univariate']; col_idxs = {0: 'univariate'}; l2 = r2_adj_sparse.sum(axis=1); else:; ht = mt.select_rows(*wrap_to_list(annotation_exprs)).rows(); ht = ht.annotate(univariate=hl.literal(1.0)); names = [name for name in ht.row if name not in ht.key]. ht_union = Table.union(*[; (ht.annotate(name=hl.str(x), value=hl.float(ht[x])).select('name', 'value')) for x in names; ]); mt_annotations = ht_union.to_matrix_table(row_key=list(ht_union.key), col_key=['name']). cols = mt_annotations.key_cols_by()['name'].collect(); col_idxs = {i: cols[i] for i in range(len(cols))}. a_tmp = new_temp_file(); BlockMatrix.write_from_entry_expr(mt_annotations.value, a_tmp). a = BlockMatrix.read(a_tmp); l2 = r2_adj_sparse @ a. l2_bm_tmp = new_temp_file(); l2_tsv_tmp = new_temp_file(); l2.write(l2_bm_tmp, force_row_major=True); BlockMatrix.export(l2_bm_tmp, l2_tsv_tmp). ht_scores = hl.import_table(l2_tsv_tmp, no_header=True, impute=True); ht_scores = ht_scores.add_index(); ht_scores = ht_scores.key_by('idx'); ht_scores = ht_scores.rename({'f{:}'.format(i): col_idxs[i] for i in range(len(cols))}). ht = mt.select_rows(__locus=locus_expr).rows(); ht = ht.add_index(); ht = ht.annotate(**ht_scores[ht.idx]); ht = ht.key_by('__locus'); ht = ht.select(*[x for x in ht_scores.row if x not in ht_scores.key]); ht = ht.rename({'__locus': 'locus'}). return ht. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:231,Modifiability,Config,Configuration,231,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:1183,Performance,Load,Load,1183,"ls; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.binary_annotation,; ... mt.continuous_annotation]). >>> # Show results; >>> ht_scores.show(3). .. code-block:: text. +---------------+-------------------+-----------------------+-------------+; | locus | b",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:385,Testability,Log,Log,385,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:63,Usability,Feedback,Feedback,63,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html:273,Usability,Guid,Guides,273,"﻿. Hail | ; hail.experimental.ldscore. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscore. Source code for hail.experimental.ldscore; import hail as hl; from hail.expr.expressions import expr_float64, expr_locus, expr_numeric; from hail.linalg import BlockMatrix; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; entry_expr=expr_float64,; locus_expr=expr_locus(),; radius=oneof(int, float),; coord_expr=nullable(expr_float64),; annotation_exprs=nullable(oneof(expr_numeric, sequenceof(expr_numeric))),; block_size=nullable(int),; ); def ld_score(entry_expr, locus_expr, radius, coord_expr=None, annotation_exprs=None, block_size=None) -> Table:; """"""Calculate LD scores. Example; -------. >>> # Load genetic data into MatrixTable; >>> mt = hl.import_plink(bed='data/ldsc.bed',; ... bim='data/ldsc.bim',; ... fam='data/ldsc.fam'). >>> # Create locus-keyed Table with numeric variant annotations; >>> ht = hl.import_table('data/ldsc.annot',; ... types={'BP': hl.tint,; ... 'binary': hl.tfloat,; ... 'continuous': hl.tfloat}); >>> ht = ht.annotate(locus=hl.locus(ht.CHR, ht.BP)); >>> ht = ht.key_by('locus'). >>> # Annotate MatrixTable with external annotations; >>> mt = mt.annotate_rows(binary_annotation=ht[mt.locus].binary,; ... continuous_annotation=ht[mt.locus].continuous). >>> # Calculate LD scores using centimorgan coordinates; >>> ht_scores = hl.experimental.ld_score(entry_expr=mt.GT.n_alt_alleles(),; ... locus_expr=mt.locus,; ... radius=1.0,; ... coord_expr=mt.cm_position,; ... annotation_exprs=[mt.bi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscore.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscore.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:30907,Availability,error,error,30907,"`dict`; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; """"""; assert str_expr is not None or ref_coef_dict is not None, ""str_expr and ref_coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; fields_to_search = tb.row if axis == 'rows' or isinstance(tb, Table) else tb.col; # when axis='rows' we're searching for annotations, axis='cols' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_coef_dict = set(fields).intersection(set(ref_coef_dict.keys())) # fields in ref_coef_dict; # if >0 fields returned by search are not in ref_coef_dict; if in_ref_coef_dict != set(fields):; # if none of the fields returned by search are in ref_coef_dict; assert len(in_ref_coef_dict) > 0, f'None of the {axis_field} fields in ref_coef_dict match search results'; fields_to_ignore = set(fields).difference(in_ref_coef_dict); print(f'Ignored fields from {axis_field} search: {fields_to_ignore}'); print('To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:163,Deployability,Install,Installation,163,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:231,Deployability,Configurat,Configuration,231,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:35369,Deployability,update,updated,35369,"((1 - K) * P); cas = mt.filter_cols(mt.y_w_asc_bias == 1); con = mt.filter_cols(mt.y_w_asc_bias == 0).add_col_index(name='col_idx_' + uid); keep = round(p * n * (1 - K)) * [1] + round((1 - p) * n * (1 - K)) * [0]; con = con.annotate_cols(**{'keep_' + uid: hl.literal(keep)[hl.int32(con['col_idx_' + uid])]}); con = con.filter_cols(con['keep_' + uid] == 1); con = _clean_fields(con, uid); mt = con.union_cols(cas); return mt. [docs]@typecheck(mt=MatrixTable, y=oneof(expr_int32, expr_float64), K=oneof(int, float), exact=bool); def binarize(mt, y, K, exact=False):; r""""""Binarize phenotype `y` such that it has prevalence `K` = cases/(cases+controls); Uses inverse CDF of Gaussian to set binarization threshold when `exact` = False,; otherwise uses ranking to determine threshold. Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing phenotype to be binarized.; y : :class:`.Expression`; Column field of phenotype.; K : :obj:`int` or :obj:`float`; Desired ""population prevalence"" of phenotype.; exact : :obj:`bool`; Whether to get prevalence as close as possible to `K` (does not use inverse CDF). Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype with prevalence of approx. `K`; """"""; if exact:; key = list(mt.col_key); uid = Env.get_uid(base=100); mt = mt.annotate_cols(**{'y_' + uid: y}); tb = mt.cols().order_by('y_' + uid); tb = tb.add_index('idx_' + uid); n = tb.count(); # ""+ 1"" because of zero indexing; tb = tb.annotate(y_binarized=tb['idx_' + uid] + 1 <= round(n * K)); tb, mt = tb.key_by('y_' + uid), mt.key_cols_by('y_' + uid); mt = mt.annotate_cols(y_binarized=tb[mt['y_' + uid]].y_binarized); mt = mt.key_cols_by(*map(lambda x: mt[x], key)); else: # use inverse CDF; y_stats = mt.aggregate_cols(hl.agg.stats(y)); threshold = stats.norm.ppf(1 - K, loc=y_stats.mean, scale=y_stats.stdev); mt = mt.annotate_cols(y_binarized=y > threshold); return mt. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:2174,Integrability,depend,depending,2174," @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact_h2=False; ):; r""""""Simulate phenotypes for testing LD score regression. Simulates betas (SNP effects) under the infinitesimal, spike & slab, or; annotation-informed models, depending on parameters passed. Optionally adds; population stratification. Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing genotypes to be used. Also should contain; variant annotations as row fields if running the annotation-informed; model or covariates as column fields if adding population stratification.; genotype : :class:`.Expression` or :class:`.CallExpression`; Entry field containing genotypes of individuals to be used for the; simulation.; h2 : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`; SNP-based heritability of simulated trait.; pi : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`, optional; Probability of SNP being causal when simulating under the spike & slab; model.; rg : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`, optional; Genetic correlation between traits.; annot : :class:`.Expression`, optional; Row field to use as our aggrega",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:5385,Integrability,depend,depending,5385,"a'],; h2=h2,; popstrat=None if popstrat is None else mt['popstrat_' + uid],; popstrat_var=popstrat_var,; exact_h2=exact_h2,; ); mt = annotate_all(; mt=mt,; global_exprs={; 'ldscsim': hl.struct(**{; 'h2': h2[0] if len(h2) == 1 else h2,; **({} if pi == [None] else {'pi': pi}),; **({} if rg == [None] else {'rg': rg[0] if len(rg) == 1 else rg}),; **({} if annot is None else {'is_annot_inf': True}),; **({} if popstrat is None else {'is_popstrat_inf': True}),; **({} if popstrat_var is None else {'popstrat_var': popstrat_var}),; 'exact_h2': exact_h2,; }); },; ); mt = _clean_fields(mt, uid); return mt. [docs]@typecheck(; mt=MatrixTable,; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; rg=nullable(oneof(float, int, list, np.ndarray)),; ); def make_betas(mt, h2, pi=None, annot=None, rg=None):; r""""""Generates betas under different models. Simulates betas (SNP effects) under the infinitesimal, spike & slab, or; annotation-informed models, depending on parameters passed. Parameters; ----------; mt : :class:`.MatrixTable`; MatrixTable containing genotypes to be used. Also should contain; variant annotations as row fields if running the annotation-informed; model or covariates as column fields if adding population stratification.; h2 : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`; SNP-based heritability of simulated trait(s).; pi : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`, optional; Probability of SNP being causal when simulating under the spike & slab; model. If doing two-trait spike & slab `pi` is a list of probabilities for; overlapping causal SNPs (see docstring of :func:`.multitrait_ss`); annot : :class:`.Expression`, optional; Row field of aggregated annotations for annotation-informed model.; rg : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`, optional; Genetic correlation between traits. Returns; -------; mt :",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:231,Modifiability,Config,Configuration,231,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:385,Testability,Log,Log,385,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:583,Testability,test,testing,583,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:2044,Testability,test,testing,2044,"stment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact_h2=False; ):; r""""""Simulate phenotypes for testing LD score regression. Simulates betas (SNP effects) under the infinitesimal, spike & slab, or; annotation-informed models, depending on parameters passed. Optionally adds; population stratification. Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing genotypes to be used. Also should contain; variant annotations as row fields if running the annotation-informed; model or covariates as column fields if adding population stratification.; genotype : :class:`.Expression` or :class:`.CallExpression`; Entry field containing genotypes of individuals to be used for the; simulation.; h2 : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`; SNP-based heritability of simulated trait.; pi : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`, optional; Probability of SNP being ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:7113,Testability,assert,assert,7113,"-----; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with betas as a row field, simulated according to specified model.; pi : :obj:`list`; Probability of a SNP being causal for different traits, possibly altered; from input `pi` if covariance matrix for multitrait simulation was not; positive semi-definite.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix for multitrait simulation was not positive semi-definite. """"""; h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); pi = pi.tolist() if isinstance(pi, np.ndarray) else ([pi] if not isinstance(pi, list) else pi); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert (pi is not [None]) or all(; x >= 0 and x <= 1 for x in pi; ), 'pi values for spike & slab must be between 0 and 1'; assert rg == [None] or all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1 or None'; if annot is not None: # multi-trait annotation-informed; assert rg == [None], 'Correlated traits not supported for annotation-informed model'; h2 = h2 if isinstance(h2, list) else [h2]; annot_sum = mt.aggregate_rows(hl.agg.sum(annot)); mt = mt.annotate_rows(beta=hl.literal(h2).map(lambda x: hl.rand_norm(0, hl.sqrt(annot * x / (annot_sum * M))))); elif len(h2) > 1 and (pi in ([None], [1])): # multi-trait correlated infinitesimal; mt, rg = multitrait_inf(mt=mt, h2=h2, rg=rg); elif len(h2) == 2 and len(pi) > 1 and len(rg) == 1: # two trait correlated spike & slab; print('multitrait ss'); mt, pi, rg = multitrait_ss(mt=mt, h2=h2, rg=0 if rg is [None] else rg[0], pi=pi); elif len(h2) == 1 and len(pi) == 1: # single trait infinitesimal/spike & slab; M = mt.count_rows(); pi_temp = 1 if pi == [None] else pi[0]; mt = mt.annotate_rows(beta=hl.rand_bool(pi_temp) * hl.rand_norm(0, hl.sqrt(h2[0] / (M * pi_temp)))); el",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:7193,Testability,assert,assert,7193,"-----; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with betas as a row field, simulated according to specified model.; pi : :obj:`list`; Probability of a SNP being causal for different traits, possibly altered; from input `pi` if covariance matrix for multitrait simulation was not; positive semi-definite.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix for multitrait simulation was not positive semi-definite. """"""; h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); pi = pi.tolist() if isinstance(pi, np.ndarray) else ([pi] if not isinstance(pi, list) else pi); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert (pi is not [None]) or all(; x >= 0 and x <= 1 for x in pi; ), 'pi values for spike & slab must be between 0 and 1'; assert rg == [None] or all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1 or None'; if annot is not None: # multi-trait annotation-informed; assert rg == [None], 'Correlated traits not supported for annotation-informed model'; h2 = h2 if isinstance(h2, list) else [h2]; annot_sum = mt.aggregate_rows(hl.agg.sum(annot)); mt = mt.annotate_rows(beta=hl.literal(h2).map(lambda x: hl.rand_norm(0, hl.sqrt(annot * x / (annot_sum * M))))); elif len(h2) > 1 and (pi in ([None], [1])): # multi-trait correlated infinitesimal; mt, rg = multitrait_inf(mt=mt, h2=h2, rg=rg); elif len(h2) == 2 and len(pi) > 1 and len(rg) == 1: # two trait correlated spike & slab; print('multitrait ss'); mt, pi, rg = multitrait_ss(mt=mt, h2=h2, rg=0 if rg is [None] else rg[0], pi=pi); elif len(h2) == 1 and len(pi) == 1: # single trait infinitesimal/spike & slab; M = mt.count_rows(); pi_temp = 1 if pi == [None] else pi[0]; mt = mt.annotate_rows(beta=hl.rand_bool(pi_temp) * hl.rand_norm(0, hl.sqrt(h2[0] / (M * pi_temp)))); el",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:7316,Testability,assert,assert,7316,"-----; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with betas as a row field, simulated according to specified model.; pi : :obj:`list`; Probability of a SNP being causal for different traits, possibly altered; from input `pi` if covariance matrix for multitrait simulation was not; positive semi-definite.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix for multitrait simulation was not positive semi-definite. """"""; h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); pi = pi.tolist() if isinstance(pi, np.ndarray) else ([pi] if not isinstance(pi, list) else pi); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert (pi is not [None]) or all(; x >= 0 and x <= 1 for x in pi; ), 'pi values for spike & slab must be between 0 and 1'; assert rg == [None] or all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1 or None'; if annot is not None: # multi-trait annotation-informed; assert rg == [None], 'Correlated traits not supported for annotation-informed model'; h2 = h2 if isinstance(h2, list) else [h2]; annot_sum = mt.aggregate_rows(hl.agg.sum(annot)); mt = mt.annotate_rows(beta=hl.literal(h2).map(lambda x: hl.rand_norm(0, hl.sqrt(annot * x / (annot_sum * M))))); elif len(h2) > 1 and (pi in ([None], [1])): # multi-trait correlated infinitesimal; mt, rg = multitrait_inf(mt=mt, h2=h2, rg=rg); elif len(h2) == 2 and len(pi) > 1 and len(rg) == 1: # two trait correlated spike & slab; print('multitrait ss'); mt, pi, rg = multitrait_ss(mt=mt, h2=h2, rg=0 if rg is [None] else rg[0], pi=pi); elif len(h2) == 1 and len(pi) == 1: # single trait infinitesimal/spike & slab; M = mt.count_rows(); pi_temp = 1 if pi == [None] else pi[0]; mt = mt.annotate_rows(beta=hl.rand_bool(pi_temp) * hl.rand_norm(0, hl.sqrt(h2[0] / (M * pi_temp)))); el",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:7479,Testability,assert,assert,7479,"-----; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with betas as a row field, simulated according to specified model.; pi : :obj:`list`; Probability of a SNP being causal for different traits, possibly altered; from input `pi` if covariance matrix for multitrait simulation was not; positive semi-definite.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix for multitrait simulation was not positive semi-definite. """"""; h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); pi = pi.tolist() if isinstance(pi, np.ndarray) else ([pi] if not isinstance(pi, list) else pi); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert (pi is not [None]) or all(; x >= 0 and x <= 1 for x in pi; ), 'pi values for spike & slab must be between 0 and 1'; assert rg == [None] or all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1 or None'; if annot is not None: # multi-trait annotation-informed; assert rg == [None], 'Correlated traits not supported for annotation-informed model'; h2 = h2 if isinstance(h2, list) else [h2]; annot_sum = mt.aggregate_rows(hl.agg.sum(annot)); mt = mt.annotate_rows(beta=hl.literal(h2).map(lambda x: hl.rand_norm(0, hl.sqrt(annot * x / (annot_sum * M))))); elif len(h2) > 1 and (pi in ([None], [1])): # multi-trait correlated infinitesimal; mt, rg = multitrait_inf(mt=mt, h2=h2, rg=rg); elif len(h2) == 2 and len(pi) > 1 and len(rg) == 1: # two trait correlated spike & slab; print('multitrait ss'); mt, pi, rg = multitrait_ss(mt=mt, h2=h2, rg=0 if rg is [None] else rg[0], pi=pi); elif len(h2) == 1 and len(pi) == 1: # single trait infinitesimal/spike & slab; M = mt.count_rows(); pi_temp = 1 if pi == [None] else pi[0]; mt = mt.annotate_rows(beta=hl.rand_bool(pi_temp) * hl.rand_norm(0, hl.sqrt(h2[0] / (M * pi_temp)))); el",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:10401,Testability,assert,assert,10401," :math:`r_g`; is assumed to be 0 between traits. If `rg` and `cov_matrix` are both; not None, :math:`r_g` values from `cov_matrix` take precedence.; cov_matrix : :class:`numpy.ndarray`, optional; Covariance matrix for traits, **unscaled by :math:`M`**, the number of SNPs.; Overrides `h2` and `rg` even when `h2` or `rg` are not ``None``.; seed : :obj:`int`, optional; Seed for random number generator. If `seed` is ``None``, `seed` is set randomly. Returns; -------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with simulated SNP effects as a row field of arrays.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; uid = Env.get_uid(base=100); h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert h2 is not [None] or cov_matrix is not None, 'h2 and cov_matrix cannot both be None'; M = mt.count_rows(); if cov_matrix is not None:; n_phens = cov_matrix.shape[0]; else:; n_phens = len(h2); if rg == [None]:; print(f'Assuming rg=0 for all {n_phens} traits'); rg = [0] * int((n_phens**2 - n_phens) / 2); assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between 0 and 1'; cov, rg = get_cov_matrix(h2, rg); cov = (1 / M) * cov; # seed random state for replicability; randstate = np.random.RandomState(int(seed)); betas = randstate.multivariate_normal(; mean=np.zeros(n_phens),; cov=cov,; size=[; M,; ],; ); df = pd.DataFrame([0] * M, columns=['beta']); tb = hl.Table.from_pandas(df); tb = tb.add_index().key_by('idx'); tb = tb.annotate(beta=hl.literal(betas.tolist())[hl.int32(tb.idx)]); mt = mt.add_row_index(name='row_idx' + uid); mt = mt.annotate_rows(beta=tb[mt['row_idx' + uid]]['beta']); mt = _clean_fields(mt, uid); return mt, rg. [docs]@typecheck(; mt=Mat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:10481,Testability,assert,assert,10481," :math:`r_g`; is assumed to be 0 between traits. If `rg` and `cov_matrix` are both; not None, :math:`r_g` values from `cov_matrix` take precedence.; cov_matrix : :class:`numpy.ndarray`, optional; Covariance matrix for traits, **unscaled by :math:`M`**, the number of SNPs.; Overrides `h2` and `rg` even when `h2` or `rg` are not ``None``.; seed : :obj:`int`, optional; Seed for random number generator. If `seed` is ``None``, `seed` is set randomly. Returns; -------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with simulated SNP effects as a row field of arrays.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; uid = Env.get_uid(base=100); h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert h2 is not [None] or cov_matrix is not None, 'h2 and cov_matrix cannot both be None'; M = mt.count_rows(); if cov_matrix is not None:; n_phens = cov_matrix.shape[0]; else:; n_phens = len(h2); if rg == [None]:; print(f'Assuming rg=0 for all {n_phens} traits'); rg = [0] * int((n_phens**2 - n_phens) / 2); assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between 0 and 1'; cov, rg = get_cov_matrix(h2, rg); cov = (1 / M) * cov; # seed random state for replicability; randstate = np.random.RandomState(int(seed)); betas = randstate.multivariate_normal(; mean=np.zeros(n_phens),; cov=cov,; size=[; M,; ],; ); df = pd.DataFrame([0] * M, columns=['beta']); tb = hl.Table.from_pandas(df); tb = tb.add_index().key_by('idx'); tb = tb.annotate(beta=hl.literal(betas.tolist())[hl.int32(tb.idx)]); mt = mt.add_row_index(name='row_idx' + uid); mt = mt.annotate_rows(beta=tb[mt['row_idx' + uid]]['beta']); mt = _clean_fields(mt, uid); return mt, rg. [docs]@typecheck(; mt=Mat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:10791,Testability,assert,assert,10791,":`int`, optional; Seed for random number generator. If `seed` is ``None``, `seed` is set randomly. Returns; -------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with simulated SNP effects as a row field of arrays.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; uid = Env.get_uid(base=100); h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); rg = rg.tolist() if isinstance(rg, np.ndarray) else ([rg] if not isinstance(rg, list) else rg); assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert h2 is not [None] or cov_matrix is not None, 'h2 and cov_matrix cannot both be None'; M = mt.count_rows(); if cov_matrix is not None:; n_phens = cov_matrix.shape[0]; else:; n_phens = len(h2); if rg == [None]:; print(f'Assuming rg=0 for all {n_phens} traits'); rg = [0] * int((n_phens**2 - n_phens) / 2); assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between 0 and 1'; cov, rg = get_cov_matrix(h2, rg); cov = (1 / M) * cov; # seed random state for replicability; randstate = np.random.RandomState(int(seed)); betas = randstate.multivariate_normal(; mean=np.zeros(n_phens),; cov=cov,; size=[; M,; ],; ); df = pd.DataFrame([0] * M, columns=['beta']); tb = hl.Table.from_pandas(df); tb = tb.add_index().key_by('idx'); tb = tb.annotate(beta=hl.literal(betas.tolist())[hl.int32(tb.idx)]); mt = mt.add_row_index(name='row_idx' + uid); mt = mt.annotate_rows(beta=tb[mt['row_idx' + uid]]['beta']); mt = _clean_fields(mt, uid); return mt, rg. [docs]@typecheck(; mt=MatrixTable, h2=oneof(list, np.ndarray), pi=oneof(list, np.ndarray), rg=oneof(float, int), seed=nullable(int); ); def multitrait_ss(mt, h2, pi, rg=0, seed=None):; r""""""Generates spike & slab betas for simulation of two correlated phenotypes. Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` for simulated phenotype.; h2 : :obj:`l",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:13148,Testability,assert,assert,13148,"that are causal for trait 2 but not trait 1.; rg : :obj:`float` or :obj:`int`; Genetic correlation between traits.; seed : :obj:`int`, optional; Seed for random number generator. If `seed` is ``None``, `seed` is set randomly. Warning; -------; May give inaccurate results if chosen parameters make the covariance matrix; not positive semi-definite. Covariance matrix is likely to not be positive; semi-definite when :math:`p_{TT}` is small and rg is large. Returns; -------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with simulated SNP effects as a row field of arrays.; pi : :obj:`list` or :class:`numpy.ndarray`; List of proportion of SNPs: :math:`p_{TT}`, :math:`p_{TF}`, :math:`p_{FT}`.; Possibly altered if covariance matrix of traits was not positive semi-definite.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; assert sum(pi) <= 1, ""probabilities of being causal must sum to be less than 1""; ptt, ptf, pft, pff = pi[0], pi[1], pi[2], 1 - sum(pi); cov_matrix = np.asarray([[1 / (ptt + ptf), rg / ptt], [rg / ptt, 1 / (ptt + pft)]]); M = mt.count_rows(); # seed random state for replicability; randstate = np.random.RandomState(int(seed)); if np.any(np.linalg.eigvals(cov_matrix) < 0):; print('adjusting parameters to make covariance matrix positive semidefinite'); rg0, ptt0 = rg, ptt; while np.any(np.linalg.eigvals(cov_matrix) < 0): # check positive semidefinite; rg = round(0.99 * rg, 6); ptt = round(ptt + (pff) * 0.001, 6); cov_matrix = np.asarray([[1 / (ptt + ptf), rg / ptt], [rg / ptt, 1 / (ptt + pft)]]); pff0, pff = pff, 1 - sum([ptt, ptf, pft]); print(f'rg: {rg0} -> {rg}\nptt: {ptt0} -> {ptt}\npff: {pff0} -> {pff}'); pi = [ptt, ptf, pft, pff]; beta = randstate.multivariate_normal(; mean=np.zeros(2),; cov=cov_matrix,; size=[; int(M),; ],; ); zeros = np.zeros(shape=int(M)).T; beta_matrix = np.stack(; (beta, np.asarray([beta[:, 0], zeros]).T, np.asarray([zeros, zeros]).T",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:19359,Testability,assert,assert,19359,":`h^2` values in list should be; ordered by their order in the diagonal of the covariance array, reading; from top left to bottom right.; rg : :obj:`list` or :class:`numpy.ndarray`; :math:`r_g` values for traits. :math:`r_g` values should be ordered in; the order they appear in the upper triangle of the covariance matrix,; from left to right, top to bottom.; psd_rg : :obj:`bool`; Whether to automatically adjust rg values to get a positive semi-definite; covariance matrix, which ensures that SNP effects simulated with that; covariance matrix have the desired variance and correlation properties; specified by the h2 and rg parameters. Returns; -------; cov_matrix : :class:`numpy.ndarray`; Covariance matrix calculated using `h2` and (possibly altered) `rg` values.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1'; rg = np.asarray(rg) if isinstance(rg, list) else rg; n_rg = len(rg); n_h2 = len(h2); # expected number of rg values, given number of traits; exp_n_rg = int((n_h2**2 - n_h2) / 2); assert n_rg == exp_n_rg, f'The number of rg values given is {n_rg}, expected {exp_n_rg}'; cor = np.zeros(shape=(n_h2, n_h2)); # set upper triangle of correlation matrix to be rg; cor[np.triu_indices(n=n_h2, k=1)] = rg; cor += cor.T; cor[np.diag_indices(n=n_h2)] = 1; if psd_rg:; cor0 = cor; cor = _nearpsd(cor); idx = np.triu_indices(n=n_h2, k=1); maxlines = 50; msg = ['Adjusting rg values to make covariance matrix positive semidefinite']; msg += (; [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(n_rg)]; if n_rg <= maxlines; else [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(maxlines)]; + [f'[ printed first {maxlines} rg changes -- omitted {n_rg - maxlines} ]']; ); print",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:19439,Testability,assert,assert,19439,":`h^2` values in list should be; ordered by their order in the diagonal of the covariance array, reading; from top left to bottom right.; rg : :obj:`list` or :class:`numpy.ndarray`; :math:`r_g` values for traits. :math:`r_g` values should be ordered in; the order they appear in the upper triangle of the covariance matrix,; from left to right, top to bottom.; psd_rg : :obj:`bool`; Whether to automatically adjust rg values to get a positive semi-definite; covariance matrix, which ensures that SNP effects simulated with that; covariance matrix have the desired variance and correlation properties; specified by the h2 and rg parameters. Returns; -------; cov_matrix : :class:`numpy.ndarray`; Covariance matrix calculated using `h2` and (possibly altered) `rg` values.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1'; rg = np.asarray(rg) if isinstance(rg, list) else rg; n_rg = len(rg); n_h2 = len(h2); # expected number of rg values, given number of traits; exp_n_rg = int((n_h2**2 - n_h2) / 2); assert n_rg == exp_n_rg, f'The number of rg values given is {n_rg}, expected {exp_n_rg}'; cor = np.zeros(shape=(n_h2, n_h2)); # set upper triangle of correlation matrix to be rg; cor[np.triu_indices(n=n_h2, k=1)] = rg; cor += cor.T; cor[np.diag_indices(n=n_h2)] = 1; if psd_rg:; cor0 = cor; cor = _nearpsd(cor); idx = np.triu_indices(n=n_h2, k=1); maxlines = 50; msg = ['Adjusting rg values to make covariance matrix positive semidefinite']; msg += (; [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(n_rg)]; if n_rg <= maxlines; else [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(maxlines)]; + [f'[ printed first {maxlines} rg changes -- omitted {n_rg - maxlines} ]']; ); print",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:19700,Testability,assert,assert,19700," values should be ordered in; the order they appear in the upper triangle of the covariance matrix,; from left to right, top to bottom.; psd_rg : :obj:`bool`; Whether to automatically adjust rg values to get a positive semi-definite; covariance matrix, which ensures that SNP effects simulated with that; covariance matrix have the desired variance and correlation properties; specified by the h2 and rg parameters. Returns; -------; cov_matrix : :class:`numpy.ndarray`; Covariance matrix calculated using `h2` and (possibly altered) `rg` values.; rg : :obj:`list`; Genetic correlation between traits, possibly altered from input `rg` if; covariance matrix was not positive semi-definite.; """"""; assert all(x >= 0 and x <= 1 for x in h2), 'h2 values must be between 0 and 1'; assert all(x >= -1 and x <= 1 for x in rg), 'rg values must be between -1 and 1'; rg = np.asarray(rg) if isinstance(rg, list) else rg; n_rg = len(rg); n_h2 = len(h2); # expected number of rg values, given number of traits; exp_n_rg = int((n_h2**2 - n_h2) / 2); assert n_rg == exp_n_rg, f'The number of rg values given is {n_rg}, expected {exp_n_rg}'; cor = np.zeros(shape=(n_h2, n_h2)); # set upper triangle of correlation matrix to be rg; cor[np.triu_indices(n=n_h2, k=1)] = rg; cor += cor.T; cor[np.diag_indices(n=n_h2)] = 1; if psd_rg:; cor0 = cor; cor = _nearpsd(cor); idx = np.triu_indices(n=n_h2, k=1); maxlines = 50; msg = ['Adjusting rg values to make covariance matrix positive semidefinite']; msg += (; [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(n_rg)]; if n_rg <= maxlines; else [(f'{cor0[idx[0][i],idx[1][i]]} -> {cor[idx[0][i],idx[1][i]]}') for i in range(maxlines)]; + [f'[ printed first {maxlines} rg changes -- omitted {n_rg - maxlines} ]']; ); print('\n'.join(msg)); rg = np.ravel(cor[idx]); S = np.diag(h2) ** (1 / 2); cov_matrix = S @ cor @ S # covariance matrix decomposition. # check positive semidefinite; if not np.all(np.linalg.eigvals(cov_matrix) >= 0) and not psd",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:23086,Testability,assert,assert,23086,"n`; Entry field of genotypes.; beta : :class:`.Expression`; Row field of SNP effects.; h2 : :obj:`float` or :obj:`int` or :obj:`list` or :class:`numpy.ndarray`; SNP-based heritability (:math:`h^2`) of simulated trait. Can only be; ``None`` if running annotation-informed model.; popstrat : :class:`.Expression`, optional; Column field containing population stratification term.; popstrat_var : :obj:`float` or :obj:`int`; Variance of population stratification term.; exact_h2: :obj:`bool`; Whether to exactly simulate ratio of variance of genetic component of; phenotype to variance of phenotype to be h2. If `False`, ratio will be; h2 in expectation. Observed h2 in the simulation will be close to; expected h2 for large-scale simulations. Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` with simulated phenotype as column field.; """"""; print('calculating phenotype'); h2 = h2.tolist() if isinstance(h2, np.ndarray) else ([h2] if not isinstance(h2, list) else h2); assert popstrat_var is None or (popstrat_var >= 0), 'popstrat_var must be non-negative'; uid = Env.get_uid(base=100); mt = annotate_all(; mt=mt,; row_exprs={'beta_' + uid: beta},; col_exprs={} if popstrat is None else {'popstrat_' + uid: popstrat},; entry_exprs={'gt_' + uid: genotype.n_alt_alleles() if genotype.dtype is hl.dtype('call') else genotype},; ); mt = mt.filter_rows(hl.agg.stats(mt['gt_' + uid]).stdev > 0); mt = normalize_genotypes(mt['gt_' + uid]); if mt['beta_' + uid].dtype == hl.dtype('array<float64>'): # if >1 traits; if exact_h2:; raise ValueError('exact_h2=True not supported for multitrait simulations'); else:; mt = mt.annotate_cols(; y_no_noise=hl.agg.array_agg(lambda beta: hl.agg.sum(beta * mt['norm_gt']), mt['beta_' + uid]); ); mt = mt.annotate_cols(y=mt.y_no_noise + hl.literal(h2).map(lambda x: hl.rand_norm(0, hl.sqrt(1 - x)))); elif exact_h2 and min([h2[0], 1 - h2[0]]) != 0:; print('exact h2'); mt = mt.annotate_cols(**{'y_no_noise_' + uid: hl.agg.sum(mt['beta_' + uid] * mt['norm_gt'])}",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:26992,Testability,assert,assert,26992,"dev); mt = _clean_fields(mt, uid); return mt. @typecheck(mt=MatrixTable, str_expr=str); def _clean_fields(mt, str_expr):; r""""""Removes fields with names that have `str_expr` in them. Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` with fields to be removed.; str_expr : :class:`str`; string to filter names of fields to remove. Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` with specified fields removed.; """"""; all_fields = list(mt.col) + list(mt.row) + list(mt.entry) + list(mt.globals); return mt.drop(*(x for x in all_fields if str_expr in x)). [docs]@typecheck(mt=MatrixTable, row_exprs=dict, col_exprs=dict, entry_exprs=dict, global_exprs=dict); def annotate_all(mt, row_exprs={}, col_exprs={}, entry_exprs={}, global_exprs={}):; r""""""Equivalent of _annotate_all, but checks source MatrixTable of exprs""""""; exprs = {**row_exprs, **col_exprs, **entry_exprs, **global_exprs}; for key, value in exprs.items():; if value.dtype in (hl.tfloat64, hl.tint32):; assert value._indices.source == mt, 'Cannot combine expressions from different source objects.'; return mt._annotate_all(row_exprs, col_exprs, entry_exprs, global_exprs). [docs]@typecheck(tb=oneof(MatrixTable, Table), coef_dict=nullable(dict), str_expr=nullable(str), axis=str); def agg_fields(tb, coef_dict=None, str_expr=None, axis='rows'):; r""""""Aggregates by linear combination fields matching either keys in `coef_dict`; or `str_expr`. Outputs the aggregation in a :class:`.MatrixTable` or :class:`.Table`; as a new row field ""agg_annot"" or a new column field ""agg_cov"". Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing fields to be aggregated.; coef_dict : :obj:`dict`, optional; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; If not included, coefficients are assumed to be 1.; str_expr : :class:`str`, optional; Str",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:28362,Testability,assert,assert,28362,"_annot"" or a new column field ""agg_cov"". Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing fields to be aggregated.; coef_dict : :obj:`dict`, optional; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; If not included, coefficients are assumed to be 1.; str_expr : :class:`str`, optional; String expression to match against row (or col) field names.; axis : :class:`str`; Either 'rows' or 'cols'. If 'rows', this aggregates across row fields.; If 'cols', this aggregates across col fields. If tb is a Table, axis = 'rows'. Returns; -------; :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing aggregation field.; """"""; assert str_expr is not None or coef_dict is not None, ""str_expr and coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; coef_dict = get_coef_dict(tb=tb, str_expr=str_expr, ref_coef_dict=coef_dict, axis=axis); axis_field = 'annot' if axis == 'rows' else 'cov'; annotate_fn = (; (MatrixTable.annotate_rows if axis == 'rows' else MatrixTable.annotate_cols); if isinstance(tb, MatrixTable); else Table.annotate; ); tb = annotate_fn(self=tb, **{'agg_' + axis_field: 0}); print(f'Fields and associated coefficients used in {axis_field} aggregation: {coef_dict}'); for field, coef in coef_dict.items():; tb = annotate_fn(self=tb, **{'agg_' + axis_field: tb['agg_' + axis_field] + coef * tb[field]}); return tb. [docs]@typecheck(tb=oneof(MatrixTable, Table), str_expr=nullable(str), ref_coef_dict=nullable(dict), axis=str); def get_coef_dict(tb, str_expr=None, ref_coef_dict=None, axis='rows'):; r""""""Gets either col or row fields matching `str_expr` and take intersection; with keys in coefficient reference dict. Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:28462,Testability,assert,assert,28462,"_annot"" or a new column field ""agg_cov"". Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing fields to be aggregated.; coef_dict : :obj:`dict`, optional; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; If not included, coefficients are assumed to be 1.; str_expr : :class:`str`, optional; String expression to match against row (or col) field names.; axis : :class:`str`; Either 'rows' or 'cols'. If 'rows', this aggregates across row fields.; If 'cols', this aggregates across col fields. If tb is a Table, axis = 'rows'. Returns; -------; :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing aggregation field.; """"""; assert str_expr is not None or coef_dict is not None, ""str_expr and coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; coef_dict = get_coef_dict(tb=tb, str_expr=str_expr, ref_coef_dict=coef_dict, axis=axis); axis_field = 'annot' if axis == 'rows' else 'cov'; annotate_fn = (; (MatrixTable.annotate_rows if axis == 'rows' else MatrixTable.annotate_cols); if isinstance(tb, MatrixTable); else Table.annotate; ); tb = annotate_fn(self=tb, **{'agg_' + axis_field: 0}); print(f'Fields and associated coefficients used in {axis_field} aggregation: {coef_dict}'); for field, coef in coef_dict.items():; tb = annotate_fn(self=tb, **{'agg_' + axis_field: tb['agg_' + axis_field] + coef * tb[field]}); return tb. [docs]@typecheck(tb=oneof(MatrixTable, Table), str_expr=nullable(str), ref_coef_dict=nullable(dict), axis=str); def get_coef_dict(tb, str_expr=None, ref_coef_dict=None, axis='rows'):; r""""""Gets either col or row fields matching `str_expr` and take intersection; with keys in coefficient reference dict. Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:30290,Testability,assert,assert,30290,"n coefficient reference dict. Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing row (or col) for `coef_dict`.; str_expr : :class:`str`, optional; String expression pattern to match against row (or col) fields. If left; unspecified, the intersection of field names is only between existing; row (or col) fields in `mt` and keys of `ref_coef_dict`.; ref_coef_dict : :obj:`dict`, optional; Reference coefficient dictionary with keys that are row (or col) field; names from which to subset. If not included, coefficients are assumed to be 1.; axis : :class:`str`; Field type in which to search for field names. Options: 'rows', 'cols'. Returns; -------; coef_dict : :obj:`dict`; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; """"""; assert str_expr is not None or ref_coef_dict is not None, ""str_expr and ref_coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; fields_to_search = tb.row if axis == 'rows' or isinstance(tb, Table) else tb.col; # when axis='rows' we're searching for annotations, axis='cols' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:30398,Testability,assert,assert,30398,"n coefficient reference dict. Parameters; ----------; tb : :class:`.MatrixTable` or :class:`.Table`; :class:`.MatrixTable` or :class:`.Table` containing row (or col) for `coef_dict`.; str_expr : :class:`str`, optional; String expression pattern to match against row (or col) fields. If left; unspecified, the intersection of field names is only between existing; row (or col) fields in `mt` and keys of `ref_coef_dict`.; ref_coef_dict : :obj:`dict`, optional; Reference coefficient dictionary with keys that are row (or col) field; names from which to subset. If not included, coefficients are assumed to be 1.; axis : :class:`str`; Field type in which to search for field names. Options: 'rows', 'cols'. Returns; -------; coef_dict : :obj:`dict`; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; """"""; assert str_expr is not None or ref_coef_dict is not None, ""str_expr and ref_coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; fields_to_search = tb.row if axis == 'rows' or isinstance(tb, Table) else tb.col; # when axis='rows' we're searching for annotations, axis='cols' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:30914,Testability,assert,assert,30914,"`dict`; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; """"""; assert str_expr is not None or ref_coef_dict is not None, ""str_expr and ref_coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; fields_to_search = tb.row if axis == 'rows' or isinstance(tb, Table) else tb.col; # when axis='rows' we're searching for annotations, axis='cols' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_coef_dict = set(fields).intersection(set(ref_coef_dict.keys())) # fields in ref_coef_dict; # if >0 fields returned by search are not in ref_coef_dict; if in_ref_coef_dict != set(fields):; # if none of the fields returned by search are in ref_coef_dict; assert len(in_ref_coef_dict) > 0, f'None of the {axis_field} fields in ref_coef_dict match search results'; fields_to_ignore = set(fields).difference(in_ref_coef_dict); print(f'Ignored fields from {axis_field} search: {fields_to_ignore}'); print('To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:31182,Testability,assert,assert,31182,"`dict`; Coefficients to multiply each field. The coefficients are specified by; `coef_dict` value, the row (or col) field name is specified by `coef_dict` key.; """"""; assert str_expr is not None or ref_coef_dict is not None, ""str_expr and ref_coef_dict cannot both be None""; assert axis in {'rows', 'cols'}, ""axis must be 'rows' or 'cols'""; fields_to_search = tb.row if axis == 'rows' or isinstance(tb, Table) else tb.col; # when axis='rows' we're searching for annotations, axis='cols' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_coef_dict = set(fields).intersection(set(ref_coef_dict.keys())) # fields in ref_coef_dict; # if >0 fields returned by search are not in ref_coef_dict; if in_ref_coef_dict != set(fields):; # if none of the fields returned by search are in ref_coef_dict; assert len(in_ref_coef_dict) > 0, f'None of the {axis_field} fields in ref_coef_dict match search results'; fields_to_ignore = set(fields).difference(in_ref_coef_dict); print(f'Ignored fields from {axis_field} search: {fields_to_ignore}'); print('To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:31637,Testability,assert,assert,31637,"s' searching for covariates; axis_field = 'annotation' if axis == 'rows' else 'covariate'; if str_expr is None:; # take all row (or col) fields in mt matching keys in coef_dict; coef_dict = {k: ref_coef_dict[k] for k in ref_coef_dict.keys() if k in fields_to_search}; # if intersect is empty: return error; assert len(coef_dict) > 0, f'None of the keys in ref_coef_dict match any {axis[:-1]} fields'; return coef_dict # return subset of ref_coef_dict; else:; # str_expr search in list of row (or col) fields; fields = [rf for rf in list(fields_to_search) if str_expr in rf]; assert len(fields) > 0, f'No {axis[:-1]} fields matched str_expr search: {str_expr}'; if ref_coef_dict is None:; print(f'Assuming coef = 1 for all {axis_field}s'); return {k: 1 for k in fields}; in_ref_coef_dict = set(fields).intersection(set(ref_coef_dict.keys())) # fields in ref_coef_dict; # if >0 fields returned by search are not in ref_coef_dict; if in_ref_coef_dict != set(fields):; # if none of the fields returned by search are in ref_coef_dict; assert len(in_ref_coef_dict) > 0, f'None of the {axis_field} fields in ref_coef_dict match search results'; fields_to_ignore = set(fields).difference(in_ref_coef_dict); print(f'Ignored fields from {axis_field} search: {fields_to_ignore}'); print('To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(mt, y, P):; r""""""Adds ascertainment bias to a binary phenotype to give it a sample; prevalence of `P` = cases/(cases+controls). Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype to be used.; y : :class:`.Expression`; Column field of binary phenotype.; P : :obj:`int` or :obj:`float`; Desired ""sample prevalence"" of phenotype. Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype with prevalence",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:32628,Testability,assert,assert,32628,"ef_coef_dict) > 0, f'None of the {axis_field} fields in ref_coef_dict match search results'; fields_to_ignore = set(fields).difference(in_ref_coef_dict); print(f'Ignored fields from {axis_field} search: {fields_to_ignore}'); print('To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(mt, y, P):; r""""""Adds ascertainment bias to a binary phenotype to give it a sample; prevalence of `P` = cases/(cases+controls). Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype to be used.; y : :class:`.Expression`; Column field of binary phenotype.; P : :obj:`int` or :obj:`float`; Desired ""sample prevalence"" of phenotype. Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype with prevalence of approx. P; """"""; assert P >= 0 and P <= 1, 'P must be in [0,1]'; uid = Env.get_uid(base=100); mt = mt.annotate_cols(y_w_asc_bias=y); y_stats = mt.aggregate_cols(hl.agg.stats(mt.y_w_asc_bias)); K = y_stats.mean; n = y_stats.n; assert abs(P - K) < 1, 'Specified sample prevalence is incompatible with population prevalence.'; if P < K:; p = (1 - K) * P / (K * (1 - P)); con = mt.filter_cols(mt.y_w_asc_bias == 0); cas = mt.filter_cols(mt.y_w_asc_bias == 1).add_col_index(name='col_idx_' + uid); keep = round(p * n * K) * [1] + round((1 - p) * n * K) * [0]; cas = cas.annotate_cols(**{'keep_' + uid: hl.literal(keep)[hl.int32(cas['col_idx_' + uid])]}); cas = cas.filter_cols(cas['keep_' + uid] == 1); cas = _clean_fields(cas, uid); mt = cas.union_cols(con); elif P > K:; p = K * (1 - P) / ((1 - K) * P); cas = mt.filter_cols(mt.y_w_asc_bias == 1); con = mt.filter_cols(mt.y_w_asc_bias == 0).add_col_index(name='col_idx_' + uid); keep = round(p * n * (1 - K)) * [1] + round((1 - p) * n * (1 - K)) * [0]; con = con.annotate_cols(**{'keep_' + uid: ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:32837,Testability,assert,assert,32837,"'To include ignored fields, change str_expr to match desired fields'); fields = list(in_ref_coef_dict); return {k: ref_coef_dict[k] for k in fields}. [docs]@typecheck(mt=MatrixTable, y=expr_int32, P=oneof(int, float)); def ascertainment_bias(mt, y, P):; r""""""Adds ascertainment bias to a binary phenotype to give it a sample; prevalence of `P` = cases/(cases+controls). Parameters; ----------; mt : :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype to be used.; y : :class:`.Expression`; Column field of binary phenotype.; P : :obj:`int` or :obj:`float`; Desired ""sample prevalence"" of phenotype. Returns; -------; :class:`.MatrixTable`; :class:`.MatrixTable` containing binary phenotype with prevalence of approx. P; """"""; assert P >= 0 and P <= 1, 'P must be in [0,1]'; uid = Env.get_uid(base=100); mt = mt.annotate_cols(y_w_asc_bias=y); y_stats = mt.aggregate_cols(hl.agg.stats(mt.y_w_asc_bias)); K = y_stats.mean; n = y_stats.n; assert abs(P - K) < 1, 'Specified sample prevalence is incompatible with population prevalence.'; if P < K:; p = (1 - K) * P / (K * (1 - P)); con = mt.filter_cols(mt.y_w_asc_bias == 0); cas = mt.filter_cols(mt.y_w_asc_bias == 1).add_col_index(name='col_idx_' + uid); keep = round(p * n * K) * [1] + round((1 - p) * n * K) * [0]; cas = cas.annotate_cols(**{'keep_' + uid: hl.literal(keep)[hl.int32(cas['col_idx_' + uid])]}); cas = cas.filter_cols(cas['keep_' + uid] == 1); cas = _clean_fields(cas, uid); mt = cas.union_cols(con); elif P > K:; p = K * (1 - P) / ((1 - K) * P); cas = mt.filter_cols(mt.y_w_asc_bias == 1); con = mt.filter_cols(mt.y_w_asc_bias == 0).add_col_index(name='col_idx_' + uid); keep = round(p * n * (1 - K)) * [1] + round((1 - p) * n * (1 - K)) * [0]; con = con.annotate_cols(**{'keep_' + uid: hl.literal(keep)[hl.int32(con['col_idx_' + uid])]}); con = con.filter_cols(con['keep_' + uid] == 1); con = _clean_fields(con, uid); mt = con.union_cols(cas); return mt. [docs]@typecheck(mt=MatrixTable, y=oneof(expr_int32, expr_flo",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:63,Usability,Feedback,Feedback,63,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html:273,Usability,Guid,Guides,273,"﻿. Hail | ; hail.experimental.ldscsim. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ldscsim. Source code for hail.experimental.ldscsim; #!/usr/bin/env python3; # -*- coding: utf-8 -*-; """"""; Simulation framework for testing LDSC. Models for SNP effects:; - Infinitesimal (can simulate n correlated traits); - Spike & slab (can simulate up to 2 correlated traits); - Annotation-informed. Features:; - Field aggregation tools for annotation-informed model and; population stratification with many covariates.; - Automatic adjustment of genetic correlation parameters; to allow for the joint simulation of up to 100 randomly; correlated phenotypes.; - Methods for binarizing phenotypes to have a certain prevalence; and for adding ascertainment bias to binarized phenotypes. @author: nbaya; """""". import numpy as np; import pandas as pd; from scipy import stats. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_float64, expr_int32; from hail.matrixtable import MatrixTable; from hail.table import Table; from hail.typecheck import nullable, oneof, typecheck; from hail.utils.java import Env. [docs]@typecheck(; mt=MatrixTable,; genotype=oneof(expr_int32, expr_float64, expr_call),; h2=(oneof(float, int, list, np.ndarray)),; pi=nullable(oneof(float, int, list, np.ndarray)),; rg=nullable(oneof(float, int, list, np.ndarray)),; annot=nullable(oneof(expr_float64, expr_int32)),; popstrat=nullable(oneof(expr_int32, expr_float64)),; popstrat_var=nullable(oneof(float, int)),; exact_h2=bool,; ); def simulate_phenotypes(; mt, genotype, h2, pi=None, rg=None, annot=None, popstrat=None, popstrat_var=None, exact",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ldscsim.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ldscsim.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:6747,Availability,error,error,6747,must be a single entry-indexed field; (not a list of fields).; * ``n_samples_exprs`` must be a single entry-indexed field; (not a list of fields).; * The ``phenotype`` field that keys the table returned by; :func:`.ld_score_regression` will have values corresponding to the; column keys of the input matrix table. This function returns a :class:`~.Table` with one row per set of summary; statistics passed to the ``chi_sq_exprs`` argument. The following; row-indexed fields are included in the table:. * **phenotype** (:py:data:`.tstr`) -- The name of the phenotype. The; returned table is keyed by this field. See the notes below for; details on the possible values of this field.; * **mean_chi_sq** (:py:data:`.tfloat64`) -- The mean chi-squared; test statistic for the given phenotype.; * **intercept** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; intercept :math:`1 + Na`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. * **snp_heritability** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; SNP-heritability :math:`h_g^2`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. Warning; -------; :func:`.ld_score_regression` considers only the rows for which both row; fields ``weight_expr`` and ``ld_score_expr`` are defined. Rows with missing; values in either field are removed prior to fitting the LD score; regression model. Parameters; ----------; weight_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used to derive; variant weights in the model.; ld_score_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used as covariates; in the model.; chi_sq_exprs : :class:`.Float64Expression` or :obj:`list` of; :class:`.Float64Expression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions f,MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:7007,Availability,error,error,7007,onding to the; column keys of the input matrix table. This function returns a :class:`~.Table` with one row per set of summary; statistics passed to the ``chi_sq_exprs`` argument. The following; row-indexed fields are included in the table:. * **phenotype** (:py:data:`.tstr`) -- The name of the phenotype. The; returned table is keyed by this field. See the notes below for; details on the possible values of this field.; * **mean_chi_sq** (:py:data:`.tfloat64`) -- The mean chi-squared; test statistic for the given phenotype.; * **intercept** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; intercept :math:`1 + Na`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. * **snp_heritability** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; SNP-heritability :math:`h_g^2`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. Warning; -------; :func:`.ld_score_regression` considers only the rows for which both row; fields ``weight_expr`` and ``ld_score_expr`` are defined. Rows with missing; values in either field are removed prior to fitting the LD score; regression model. Parameters; ----------; weight_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used to derive; variant weights in the model.; ld_score_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used as covariates; in the model.; chi_sq_exprs : :class:`.Float64Expression` or :obj:`list` of; :class:`.Float64Expression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions for chi-squared; statistics resulting from genome-wide association; studies (GWAS).; n_samples_exprs: :class:`.NumericExpression` or :obj:`list` of; :class:`.NumericExpression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions ,MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:8220,Availability,error,errors,8220,"are defined. Rows with missing; values in either field are removed prior to fitting the LD score; regression model. Parameters; ----------; weight_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used to derive; variant weights in the model.; ld_score_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used as covariates; in the model.; chi_sq_exprs : :class:`.Float64Expression` or :obj:`list` of; :class:`.Float64Expression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions for chi-squared; statistics resulting from genome-wide association; studies (GWAS).; n_samples_exprs: :class:`.NumericExpression` or :obj:`list` of; :class:`.NumericExpression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions indicating the number of; samples used in the studies that generated the test; statistics supplied to ``chi_sq_exprs``.; n_blocks : :obj:`int`; The number of blocks used in the jackknife approach to; estimating standard errors.; two_step_threshold : :obj:`int`; Variants with chi-squared statistics greater than this; value are excluded in the first step of the two-step; procedure used to fit the model.; n_reference_panel_variants : :obj:`int`, optional; Number of variants used to estimate the; SNP-heritability :math:`h_g^2`. Returns; -------; :class:`~.Table`; Table keyed by ``phenotype`` with intercept and heritability estimates; for each phenotype passed to the function."""""". chi_sq_exprs = wrap_to_list(chi_sq_exprs); n_samples_exprs = wrap_to_list(n_samples_exprs). assert (len(chi_sq_exprs) == len(n_samples_exprs)) or (len(n_samples_exprs) == 1); __k = 2 # number of covariates, including intercept. ds = chi_sq_exprs[0]._indices.source. analyze('ld_score_regression/weight_expr', weight_expr, ds._row_indices); analyze('ld_score_regression/ld_score_expr', ld_score_expr, ds._row_indices). # format input dataset; if isinstance(ds, hl.MatrixTable):; if len(chi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:175,Deployability,Install,Installation,175,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:243,Deployability,Configurat,Configuration,243,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:18103,Deployability,update,updated,18103,"as_bias_corrected),; __step2_jackknife_variance=(; hl.sum(mt.__step2_block_betas_bias_corrected**2); - hl.sum(mt.__step2_block_betas_bias_corrected) ** 2 / n_blocks; ); / (n_blocks - 1); / n_blocks,; ). # combine step 1 and step 2 block jackknifes; mt = mt.annotate_entries(; __step2_initial_w=1.0; / (mt.__w_initial_floor * 2.0 * (mt.__initial_betas[0] + +mt.__initial_betas[1] * mt.__x_floor) ** 2); ). mt = mt.annotate_cols(; __final_betas=[mt.__step1_betas[0], mt.__step2_betas[1]],; __c=(hl.agg.sum(mt.__step2_initial_w * mt.__x) / hl.agg.sum(mt.__step2_initial_w * mt.__x**2)),; ). mt = mt.annotate_cols(; __final_block_betas=hl.map(; lambda i: (mt.__step2_block_betas[i] - mt.__c * (mt.__step1_block_betas[i][0] - mt.__final_betas[0])),; hl.range(0, n_blocks),; ); ). mt = mt.annotate_cols(; __final_block_betas_bias_corrected=(n_blocks * mt.__final_betas[1] - (n_blocks - 1) * mt.__final_block_betas); ). mt = mt.annotate_cols(; __final_jackknife_mean=[mt.__step1_jackknife_mean[0], hl.mean(mt.__final_block_betas_bias_corrected)],; __final_jackknife_variance=[; mt.__step1_jackknife_variance[0],; (; hl.sum(mt.__final_block_betas_bias_corrected**2); - hl.sum(mt.__final_block_betas_bias_corrected) ** 2 / n_blocks; ); / (n_blocks - 1); / n_blocks,; ],; ). # convert coefficient to heritability estimate; mt = mt.annotate_cols(; phenotype=mt.__y_name,; mean_chi_sq=hl.agg.mean(mt.__y),; intercept=hl.struct(estimate=mt.__final_betas[0], standard_error=hl.sqrt(mt.__final_jackknife_variance[0])),; snp_heritability=hl.struct(; estimate=(M / hl.agg.mean(mt.__n)) * mt.__final_betas[1],; standard_error=hl.sqrt((M / hl.agg.mean(mt.__n)) ** 2 * mt.__final_jackknife_variance[1]),; ),; ). # format and return results; ht = mt.cols(); ht = ht.key_by(ht.phenotype); ht = ht.select(ht.mean_chi_sq, ht.intercept, ht.snp_heritability). ht_tmp_file = new_temp_file(); ht.write(ht_tmp_file); ht = hl.read_table(ht_tmp_file). return ht. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:243,Modifiability,Config,Configuration,243,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:397,Testability,Log,Log,397,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:1826,Testability,test,test,1826,"ight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlation coefficients; between variant :math:`j` and nearby variants. See :func:`ld_score`; for further details.; * :math:`a` captures the contribution of confounding biases, such as; cryptic relatedness and uncontrolled population structure, to the; association test statistic.; * :math:`h_g^2` is the SNP-heritability, or the proportion of variation; in the trait explained by the effects of variants included in the; regression model above.; * :math:`M` is the number of variants used to estimate :math:`h_g^2`.; * :math:`N` is the number of samples in the underlying association study. For more details on the method implemented in this function, see:. * `LD Score regression distinguishes confounding from polygenicity in genome-wide association studies (Bulik-Sullivan et al, 2015) <https://www.ncbi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:2259,Testability,test,test,2259,"; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlation coefficients; between variant :math:`j` and nearby variants. See :func:`ld_score`; for further details.; * :math:`a` captures the contribution of confounding biases, such as; cryptic relatedness and uncontrolled population structure, to the; association test statistic.; * :math:`h_g^2` is the SNP-heritability, or the proportion of variation; in the trait explained by the effects of variants included in the; regression model above.; * :math:`M` is the number of variants used to estimate :math:`h_g^2`.; * :math:`N` is the number of samples in the underlying association study. For more details on the method implemented in this function, see:. * `LD Score regression distinguishes confounding from polygenicity in genome-wide association studies (Bulik-Sullivan et al, 2015) <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4495769/>`__. Examples; --------. Run the method on a matrix table of summary statistics, where the rows; are variants and the columns are different phenotypes:. >>> mt_gwas = ld_score_all_phenos_sumstats; >>> ht_results = hl.experimental.ld_score_regression(; ... weight_expr=mt_gwas['ld_score'],; ... ld_score_expr=mt_gwas['ld_score'],; ... chi_sq_exprs=mt_gw",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:6489,Testability,test,test,6489,data:`.tstr` that uniquely identifies phenotypes; represented in the matrix table. The column key must be a single; expression; compound keys are not accepted.; * ``weight_expr`` and ``ld_score_expr`` must be row-indexed; fields.; * ``chi_sq_exprs`` must be a single entry-indexed field; (not a list of fields).; * ``n_samples_exprs`` must be a single entry-indexed field; (not a list of fields).; * The ``phenotype`` field that keys the table returned by; :func:`.ld_score_regression` will have values corresponding to the; column keys of the input matrix table. This function returns a :class:`~.Table` with one row per set of summary; statistics passed to the ``chi_sq_exprs`` argument. The following; row-indexed fields are included in the table:. * **phenotype** (:py:data:`.tstr`) -- The name of the phenotype. The; returned table is keyed by this field. See the notes below for; details on the possible values of this field.; * **mean_chi_sq** (:py:data:`.tfloat64`) -- The mean chi-squared; test statistic for the given phenotype.; * **intercept** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; intercept :math:`1 + Na`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. * **snp_heritability** (`Struct`) -- Contains fields:. - **estimate** (:py:data:`.tfloat64`) -- A point estimate of the; SNP-heritability :math:`h_g^2`.; - **standard_error** (:py:data:`.tfloat64`) -- An estimate of; the standard error of this point estimate. Warning; -------; :func:`.ld_score_regression` considers only the rows for which both row; fields ``weight_expr`` and ``ld_score_expr`` are defined. Rows with missing; values in either field are removed prior to fitting the LD score; regression model. Parameters; ----------; weight_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used to derive; variant weights in the model.; ld_score_expr : :class:`.Float64Expression`; Ro,MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:8073,Testability,test,test,8073,"rror of this point estimate. Warning; -------; :func:`.ld_score_regression` considers only the rows for which both row; fields ``weight_expr`` and ``ld_score_expr`` are defined. Rows with missing; values in either field are removed prior to fitting the LD score; regression model. Parameters; ----------; weight_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used to derive; variant weights in the model.; ld_score_expr : :class:`.Float64Expression`; Row-indexed expression for the LD scores used as covariates; in the model.; chi_sq_exprs : :class:`.Float64Expression` or :obj:`list` of; :class:`.Float64Expression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions for chi-squared; statistics resulting from genome-wide association; studies (GWAS).; n_samples_exprs: :class:`.NumericExpression` or :obj:`list` of; :class:`.NumericExpression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions indicating the number of; samples used in the studies that generated the test; statistics supplied to ``chi_sq_exprs``.; n_blocks : :obj:`int`; The number of blocks used in the jackknife approach to; estimating standard errors.; two_step_threshold : :obj:`int`; Variants with chi-squared statistics greater than this; value are excluded in the first step of the two-step; procedure used to fit the model.; n_reference_panel_variants : :obj:`int`, optional; Number of variants used to estimate the; SNP-heritability :math:`h_g^2`. Returns; -------; :class:`~.Table`; Table keyed by ``phenotype`` with intercept and heritability estimates; for each phenotype passed to the function."""""". chi_sq_exprs = wrap_to_list(chi_sq_exprs); n_samples_exprs = wrap_to_list(n_samples_exprs). assert (len(chi_sq_exprs) == len(n_samples_exprs)) or (len(n_samples_exprs) == 1); __k = 2 # number of covariates, including intercept. ds = chi_sq_exprs[0]._indices.source. analyze('ld_score_regression/weight_expr', weight_expr, d",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:8777,Testability,assert,assert,8777,"ass:`.NumericExpression` or :obj:`list` of; :class:`.NumericExpression`; One or more row-indexed (if table) or entry-indexed; (if matrix table) expressions indicating the number of; samples used in the studies that generated the test; statistics supplied to ``chi_sq_exprs``.; n_blocks : :obj:`int`; The number of blocks used in the jackknife approach to; estimating standard errors.; two_step_threshold : :obj:`int`; Variants with chi-squared statistics greater than this; value are excluded in the first step of the two-step; procedure used to fit the model.; n_reference_panel_variants : :obj:`int`, optional; Number of variants used to estimate the; SNP-heritability :math:`h_g^2`. Returns; -------; :class:`~.Table`; Table keyed by ``phenotype`` with intercept and heritability estimates; for each phenotype passed to the function."""""". chi_sq_exprs = wrap_to_list(chi_sq_exprs); n_samples_exprs = wrap_to_list(n_samples_exprs). assert (len(chi_sq_exprs) == len(n_samples_exprs)) or (len(n_samples_exprs) == 1); __k = 2 # number of covariates, including intercept. ds = chi_sq_exprs[0]._indices.source. analyze('ld_score_regression/weight_expr', weight_expr, ds._row_indices); analyze('ld_score_regression/ld_score_expr', ld_score_expr, ds._row_indices). # format input dataset; if isinstance(ds, hl.MatrixTable):; if len(chi_sq_exprs) != 1:; raise ValueError(""""""Only one chi_sq_expr allowed if originating; from a matrix table.""""""); if len(n_samples_exprs) != 1:; raise ValueError(""""""Only one n_samples_expr allowed if; originating from a matrix table.""""""). col_key = list(ds.col_key); if len(col_key) != 1:; raise ValueError(""""""Matrix table must be keyed by a single; phenotype field.""""""). analyze('ld_score_regression/chi_squared_expr', chi_sq_exprs[0], ds._entry_indices); analyze('ld_score_regression/n_samples_expr', n_samples_exprs[0], ds._entry_indices). ds = ds._select_all(; row_exprs={; '__locus': ds.locus,; '__alleles': ds.alleles,; '__w_initial': weight_expr,; '__w_initial_floor': ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:10309,Testability,assert,assert,10309,"lowed if; originating from a matrix table.""""""). col_key = list(ds.col_key); if len(col_key) != 1:; raise ValueError(""""""Matrix table must be keyed by a single; phenotype field.""""""). analyze('ld_score_regression/chi_squared_expr', chi_sq_exprs[0], ds._entry_indices); analyze('ld_score_regression/n_samples_expr', n_samples_exprs[0], ds._entry_indices). ds = ds._select_all(; row_exprs={; '__locus': ds.locus,; '__alleles': ds.alleles,; '__w_initial': weight_expr,; '__w_initial_floor': hl.max(weight_expr, 1.0),; '__x': ld_score_expr,; '__x_floor': hl.max(ld_score_expr, 1.0),; },; row_key=['__locus', '__alleles'],; col_exprs={'__y_name': ds[col_key[0]]},; col_key=['__y_name'],; entry_exprs={'__y': chi_sq_exprs[0], '__n': n_samples_exprs[0]},; ); ds = ds.annotate_entries(**{'__w': ds.__w_initial}). ds = ds.filter_rows(; hl.is_defined(ds.__locus); & hl.is_defined(ds.__alleles); & hl.is_defined(ds.__w_initial); & hl.is_defined(ds.__x); ). else:; assert isinstance(ds, Table); for y in chi_sq_exprs:; analyze('ld_score_regression/chi_squared_expr', y, ds._row_indices); for n in n_samples_exprs:; analyze('ld_score_regression/n_samples_expr', n, ds._row_indices). ys = ['__y{:}'.format(i) for i, _ in enumerate(chi_sq_exprs)]; ws = ['__w{:}'.format(i) for i, _ in enumerate(chi_sq_exprs)]; ns = ['__n{:}'.format(i) for i, _ in enumerate(n_samples_exprs)]. ds = ds.select(; **dict(; **{'__locus': ds.locus, '__alleles': ds.alleles, '__w_initial': weight_expr, '__x': ld_score_expr},; **{y: chi_sq_exprs[i] for i, y in enumerate(ys)},; **{w: weight_expr for w in ws},; **{n: n_samples_exprs[i] for i, n in enumerate(ns)},; ); ); ds = ds.key_by(ds.__locus, ds.__alleles). table_tmp_file = new_temp_file(); ds.write(table_tmp_file); ds = hl.read_table(table_tmp_file). hts = [; ds.select(**{; '__w_initial': ds.__w_initial,; '__w_initial_floor': hl.max(ds.__w_initial, 1.0),; '__x': ds.__x,; '__x_floor': hl.max(ds.__x, 1.0),; '__y_name': i,; '__y': ds[ys[i]],; '__w': ds[ws[i]],; '__n': hl.int(ds[ns[",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:75,Usability,Feedback,Feedback,75,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html:285,Usability,Guid,Guides,285,"﻿. Hail | ; hail.experimental.ld_score_regression. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.ld_score_regression. Source code for hail.experimental.ld_score_regression; import hail as hl; from hail.expr.expressions import analyze, expr_float64, expr_numeric; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(; weight_expr=expr_float64,; ld_score_expr=expr_numeric,; chi_sq_exprs=oneof(expr_float64, sequenceof(expr_float64)),; n_samples_exprs=oneof(expr_numeric, sequenceof(expr_numeric)),; n_blocks=int,; two_step_threshold=int,; n_reference_panel_variants=nullable(int),; ); def ld_score_regression(; weight_expr,; ld_score_expr,; chi_sq_exprs,; n_samples_exprs,; n_blocks=200,; two_step_threshold=30,; n_reference_panel_variants=None,; ) -> Table:; r""""""Estimate SNP-heritability and level of confounding biases from genome-wide association study; (GWAS) summary statistics. Given a set or multiple sets of GWAS summary statistics, :func:`.ld_score_regression` estimates the heritability; of a trait or set of traits and the level of confounding biases present in; the underlying studies by regressing chi-squared statistics on LD scores,; leveraging the model:. .. math::. \mathrm{E}[\chi_j^2] = 1 + Na + \frac{Nh_g^2}{M}l_j. * :math:`\mathrm{E}[\chi_j^2]` is the expected chi-squared statistic; for variant :math:`j` resulting from a test of association between; variant :math:`j` and a trait.; * :math:`l_j = \sum_{k} r_{jk}^2` is the LD score of variant; :math:`j`, calculated as the sum of squared correlat",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/ld_score_regression.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/ld_score_regression.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:1435,Availability,error,error,1435,"cy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a non-tail recursive function, since `triangle1(9)`; needs to modify the result of the inner recursive call to `triangle1(8)` by; adding 9 to the result. The second function is tail recursive: the result of `triangle2(9, 0)` is; the same as the result of the inner recursive call, `triangle2(8, 9)`. Example; -------; To find the sum of all the numbers from n=1...10:; >>> triangle_f = lambda f, x, total",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:3093,Availability,error,error,3093,"the inner recursive call to `triangle1(8)` by; adding 9 to the result. The second function is tail recursive: the result of `triangle2(9, 0)` is; the same as the result of the inner recursive call, `triangle2(8, 9)`. Example; -------; To find the sum of all the numbers from n=1...10:; >>> triangle_f = lambda f, x, total: hl.if_else(x == 0, total, f(x - 1, total + x)); >>> x = hl.experimental.loop(triangle_f, hl.tint32, 10, 0); >>> hl.eval(x); 55. Let's say we want to find the root of a polynomial equation:; >>> def polynomial(x):; ... return 5 * x**3 - 2 * x - 1. We'll use `Newton's method<https://en.wikipedia.org/wiki/Newton%27s_method>`; to find it, so we'll also define the derivative:. >>> def derivative(x):; ... return 15 * x**2 - 2. and starting at :math:`x_0 = 0`, we'll compute the next step :math:`x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}`; until the difference between :math:`x_{i}` and :math:`x_{i+1}` falls below; our convergence threshold:. >>> threshold = 0.005; >>> def find_root(f, guess, error):; ... converged = hl.is_defined(error) & (error < threshold); ... new_guess = guess - (polynomial(guess) / derivative(guess)); ... new_error = hl.abs(new_guess - guess); ... return hl.if_else(converged, guess, f(new_guess, new_error)); >>> x = hl.experimental.loop(find_root, hl.tfloat, 0.0, hl.missing(hl.tfloat)); >>> hl.eval(x); 0.8052291984599675. Warning; -------; Using arguments of a type other than numeric types and booleans can cause; memory issues if if you expect the recursive call to happen many times. Parameters; ----------; f : function ( (marker, \*args) -> :class:`.Expression`; Function of one callable marker, denoting where the recursive call (or calls) is located,; and many `args`, the loop variables.; typ : :class:`str` or :class:`.HailType`; Type the loop returns.; args : variable-length args of :class:`.Expression`; Expressions to initialize the loop values.; Returns; -------; :class:`.Expression`; Result of the loop with `args` as initial loop value",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:3132,Availability,error,error,3132,"e result. The second function is tail recursive: the result of `triangle2(9, 0)` is; the same as the result of the inner recursive call, `triangle2(8, 9)`. Example; -------; To find the sum of all the numbers from n=1...10:; >>> triangle_f = lambda f, x, total: hl.if_else(x == 0, total, f(x - 1, total + x)); >>> x = hl.experimental.loop(triangle_f, hl.tint32, 10, 0); >>> hl.eval(x); 55. Let's say we want to find the root of a polynomial equation:; >>> def polynomial(x):; ... return 5 * x**3 - 2 * x - 1. We'll use `Newton's method<https://en.wikipedia.org/wiki/Newton%27s_method>`; to find it, so we'll also define the derivative:. >>> def derivative(x):; ... return 15 * x**2 - 2. and starting at :math:`x_0 = 0`, we'll compute the next step :math:`x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}`; until the difference between :math:`x_{i}` and :math:`x_{i+1}` falls below; our convergence threshold:. >>> threshold = 0.005; >>> def find_root(f, guess, error):; ... converged = hl.is_defined(error) & (error < threshold); ... new_guess = guess - (polynomial(guess) / derivative(guess)); ... new_error = hl.abs(new_guess - guess); ... return hl.if_else(converged, guess, f(new_guess, new_error)); >>> x = hl.experimental.loop(find_root, hl.tfloat, 0.0, hl.missing(hl.tfloat)); >>> hl.eval(x); 0.8052291984599675. Warning; -------; Using arguments of a type other than numeric types and booleans can cause; memory issues if if you expect the recursive call to happen many times. Parameters; ----------; f : function ( (marker, \*args) -> :class:`.Expression`; Function of one callable marker, denoting where the recursive call (or calls) is located,; and many `args`, the loop variables.; typ : :class:`str` or :class:`.HailType`; Type the loop returns.; args : variable-length args of :class:`.Expression`; Expressions to initialize the loop values.; Returns; -------; :class:`.Expression`; Result of the loop with `args` as initial loop values.; """""". loop_name = Env.get_uid(). def contains_recursive_c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:3142,Availability,error,error,3142,"e result. The second function is tail recursive: the result of `triangle2(9, 0)` is; the same as the result of the inner recursive call, `triangle2(8, 9)`. Example; -------; To find the sum of all the numbers from n=1...10:; >>> triangle_f = lambda f, x, total: hl.if_else(x == 0, total, f(x - 1, total + x)); >>> x = hl.experimental.loop(triangle_f, hl.tint32, 10, 0); >>> hl.eval(x); 55. Let's say we want to find the root of a polynomial equation:; >>> def polynomial(x):; ... return 5 * x**3 - 2 * x - 1. We'll use `Newton's method<https://en.wikipedia.org/wiki/Newton%27s_method>`; to find it, so we'll also define the derivative:. >>> def derivative(x):; ... return 15 * x**2 - 2. and starting at :math:`x_0 = 0`, we'll compute the next step :math:`x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}`; until the difference between :math:`x_{i}` and :math:`x_{i+1}` falls below; our convergence threshold:. >>> threshold = 0.005; >>> def find_root(f, guess, error):; ... converged = hl.is_defined(error) & (error < threshold); ... new_guess = guess - (polynomial(guess) / derivative(guess)); ... new_error = hl.abs(new_guess - guess); ... return hl.if_else(converged, guess, f(new_guess, new_error)); >>> x = hl.experimental.loop(find_root, hl.tfloat, 0.0, hl.missing(hl.tfloat)); >>> hl.eval(x); 0.8052291984599675. Warning; -------; Using arguments of a type other than numeric types and booleans can cause; memory issues if if you expect the recursive call to happen many times. Parameters; ----------; f : function ( (marker, \*args) -> :class:`.Expression`; Function of one callable marker, denoting where the recursive call (or calls) is located,; and many `args`, the loop variables.; typ : :class:`str` or :class:`.HailType`; Type the loop returns.; args : variable-length args of :class:`.Expression`; Expressions to initialize the loop values.; Returns; -------; :class:`.Expression`; Result of the loop with `args` as initial loop values.; """""". loop_name = Env.get_uid(). def contains_recursive_c",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:5420,Availability,error,error,5420,"(loop_ir, ir.If):; if contains_recursive_call(loop_ir.cond):; raise TypeError(""branch condition can't contain recursive call!""); check_tail_recursive(loop_ir.cnsq); check_tail_recursive(loop_ir.altr); elif isinstance(loop_ir, ir.Let):; if contains_recursive_call(loop_ir.value):; raise TypeError(""bound value used in other expression can't contain recursive call!""); check_tail_recursive(loop_ir.body); elif isinstance(loop_ir, ir.TailLoop):; if any(contains_recursive_call(x) for n, x in loop_ir.params):; raise TypeError(""parameters passed to inner loop can't contain recursive call!""); elif not isinstance(loop_ir, ir.Recur) and contains_recursive_call(loop_ir):; raise TypeError(""found recursive expression outside of tail position!""). @typecheck(recur_exprs=expr_any); def make_loop(*recur_exprs):; if len(recur_exprs) != len(args):; raise TypeError('Recursive call in loop has wrong number of arguments'); err = None; for i, (rexpr, expr) in enumerate(zip(recur_exprs, args)):; if rexpr.dtype != expr.dtype:; if err is None:; err = 'Type error in recursive call,'; err += f'\n at argument index {i}, loop arg type: {expr.dtype}, '; err += f'recur arg type: {rexpr.dtype}'; if err is not None:; raise TypeError(err); irs = [expr._ir for expr in recur_exprs]; indices, aggregations = unify_all(*recur_exprs); return construct_expr(ir.Recur(loop_name, irs, typ), typ, indices, aggregations). uid_irs = []; loop_vars = []. for expr in args:; uid = Env.get_uid(); loop_vars.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uid_irs.append((uid, expr._ir)). loop_f = to_expr(f(make_loop, *loop_vars)); if loop_f.dtype != typ:; raise TypeError(f""requested type {typ} does not match inferred type {loop_f.dtype}""); check_tail_recursive(loop_f._ir); indices, aggregations = unify_all(*args, loop_f). return construct_expr(ir.TailLoop(loop_name, loop_f._ir, uid_irs), loop_f.dtype, indices, aggregations). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:160,Deployability,Install,Installation,160,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:228,Deployability,Configurat,Configuration,228,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:6348,Deployability,update,updated,6348,"(loop_ir, ir.If):; if contains_recursive_call(loop_ir.cond):; raise TypeError(""branch condition can't contain recursive call!""); check_tail_recursive(loop_ir.cnsq); check_tail_recursive(loop_ir.altr); elif isinstance(loop_ir, ir.Let):; if contains_recursive_call(loop_ir.value):; raise TypeError(""bound value used in other expression can't contain recursive call!""); check_tail_recursive(loop_ir.body); elif isinstance(loop_ir, ir.TailLoop):; if any(contains_recursive_call(x) for n, x in loop_ir.params):; raise TypeError(""parameters passed to inner loop can't contain recursive call!""); elif not isinstance(loop_ir, ir.Recur) and contains_recursive_call(loop_ir):; raise TypeError(""found recursive expression outside of tail position!""). @typecheck(recur_exprs=expr_any); def make_loop(*recur_exprs):; if len(recur_exprs) != len(args):; raise TypeError('Recursive call in loop has wrong number of arguments'); err = None; for i, (rexpr, expr) in enumerate(zip(recur_exprs, args)):; if rexpr.dtype != expr.dtype:; if err is None:; err = 'Type error in recursive call,'; err += f'\n at argument index {i}, loop arg type: {expr.dtype}, '; err += f'recur arg type: {rexpr.dtype}'; if err is not None:; raise TypeError(err); irs = [expr._ir for expr in recur_exprs]; indices, aggregations = unify_all(*recur_exprs); return construct_expr(ir.Recur(loop_name, irs, typ), typ, indices, aggregations). uid_irs = []; loop_vars = []. for expr in args:; uid = Env.get_uid(); loop_vars.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uid_irs.append((uid, expr._ir)). loop_f = to_expr(f(make_loop, *loop_vars)); if loop_f.dtype != typ:; raise TypeError(f""requested type {typ} does not match inferred type {loop_f.dtype}""); check_tail_recursive(loop_f._ir); indices, aggregations = unify_all(*args, loop_f). return construct_expr(ir.TailLoop(loop_name, loop_f._ir, uid_irs), loop_f.dtype, indices, aggregations). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:228,Modifiability,Config,Configuration,228,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:3815,Modifiability,variab,variables,3815,"define the derivative:. >>> def derivative(x):; ... return 15 * x**2 - 2. and starting at :math:`x_0 = 0`, we'll compute the next step :math:`x_{i+1} = x_i - \frac{f(x_i)}{f'(x_i)}`; until the difference between :math:`x_{i}` and :math:`x_{i+1}` falls below; our convergence threshold:. >>> threshold = 0.005; >>> def find_root(f, guess, error):; ... converged = hl.is_defined(error) & (error < threshold); ... new_guess = guess - (polynomial(guess) / derivative(guess)); ... new_error = hl.abs(new_guess - guess); ... return hl.if_else(converged, guess, f(new_guess, new_error)); >>> x = hl.experimental.loop(find_root, hl.tfloat, 0.0, hl.missing(hl.tfloat)); >>> hl.eval(x); 0.8052291984599675. Warning; -------; Using arguments of a type other than numeric types and booleans can cause; memory issues if if you expect the recursive call to happen many times. Parameters; ----------; f : function ( (marker, \*args) -> :class:`.Expression`; Function of one callable marker, denoting where the recursive call (or calls) is located,; and many `args`, the loop variables.; typ : :class:`str` or :class:`.HailType`; Type the loop returns.; args : variable-length args of :class:`.Expression`; Expressions to initialize the loop values.; Returns; -------; :class:`.Expression`; Result of the loop with `args` as initial loop values.; """""". loop_name = Env.get_uid(). def contains_recursive_call(non_recursive):; if isinstance(non_recursive, ir.Recur) and non_recursive.name == loop_name:; return True; return any([contains_recursive_call(c) for c in non_recursive.children]). def check_tail_recursive(loop_ir):; if isinstance(loop_ir, ir.If):; if contains_recursive_call(loop_ir.cond):; raise TypeError(""branch condition can't contain recursive call!""); check_tail_recursive(loop_ir.cnsq); check_tail_recursive(loop_ir.altr); elif isinstance(loop_ir, ir.Let):; if contains_recursive_call(loop_ir.value):; raise TypeError(""bound value used in other expression can't contain recursive call!""); check_tail_r",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:3900,Modifiability,variab,variable-length,3900," \frac{f(x_i)}{f'(x_i)}`; until the difference between :math:`x_{i}` and :math:`x_{i+1}` falls below; our convergence threshold:. >>> threshold = 0.005; >>> def find_root(f, guess, error):; ... converged = hl.is_defined(error) & (error < threshold); ... new_guess = guess - (polynomial(guess) / derivative(guess)); ... new_error = hl.abs(new_guess - guess); ... return hl.if_else(converged, guess, f(new_guess, new_error)); >>> x = hl.experimental.loop(find_root, hl.tfloat, 0.0, hl.missing(hl.tfloat)); >>> hl.eval(x); 0.8052291984599675. Warning; -------; Using arguments of a type other than numeric types and booleans can cause; memory issues if if you expect the recursive call to happen many times. Parameters; ----------; f : function ( (marker, \*args) -> :class:`.Expression`; Function of one callable marker, denoting where the recursive call (or calls) is located,; and many `args`, the loop variables.; typ : :class:`str` or :class:`.HailType`; Type the loop returns.; args : variable-length args of :class:`.Expression`; Expressions to initialize the loop values.; Returns; -------; :class:`.Expression`; Result of the loop with `args` as initial loop values.; """""". loop_name = Env.get_uid(). def contains_recursive_call(non_recursive):; if isinstance(non_recursive, ir.Recur) and non_recursive.name == loop_name:; return True; return any([contains_recursive_call(c) for c in non_recursive.children]). def check_tail_recursive(loop_ir):; if isinstance(loop_ir, ir.If):; if contains_recursive_call(loop_ir.cond):; raise TypeError(""branch condition can't contain recursive call!""); check_tail_recursive(loop_ir.cnsq); check_tail_recursive(loop_ir.altr); elif isinstance(loop_ir, ir.Let):; if contains_recursive_call(loop_ir.value):; raise TypeError(""bound value used in other expression can't contain recursive call!""); check_tail_recursive(loop_ir.body); elif isinstance(loop_ir, ir.TailLoop):; if any(contains_recursive_call(x) for n, x in loop_ir.params):; raise TypeError(""parameters p",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:382,Testability,Log,Log,382,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:60,Usability,Feedback,Feedback,60,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/loop.html:270,Usability,Guid,Guides,270,"﻿. Hail | ; hail.experimental.loop. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.loop. Source code for hail.experimental.loop; from typing import Callable. from hail import ir; from hail.expr.expressions import construct_expr, construct_variable, expr_any, to_expr, unify_all; from hail.expr.types import hail_type; from hail.typecheck import anytype, typecheck; from hail.utils.java import Env. [docs]@typecheck(f=anytype, typ=hail_type, args=expr_any); def loop(f: Callable, typ, *args):; r""""""Define and call a tail-recursive function with given arguments. Notes; -----; The argument `f` must be a function where the first argument defines the; recursive call, and the remaining arguments are the arguments to the; recursive function, e.g. to define the recursive function. .. math::. f(x, y) = \begin{cases}; y & \textrm{if } x \equiv 0 \\; f(x - 1, y + x) & \textrm{otherwise}; \end{cases}. we would write:; >>> f = lambda recur, x, y: hl.if_else(x == 0, y, recur(x - 1, y + x)). Full recursion is not supported, and any non-tail-recursive methods will; throw an error when called. This means that the result of any recursive call within the function must; also be the result of the entire function, without modification. Let's; consider two different recursive definitions for the triangle function; :math:`f(x) = 0 + 1 + \dots + x`:. >>> def triangle1(x):; ... if x == 1:; ... return x; ... return x + triangle1(x - 1). >>> def triangle2(x, total):; ... if x == 0:; ... return total; ... return triangle2(x - 1, total + x). The first function definition, `triangle1`, will call itself and then add x.; This is an example of a n",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/loop.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/loop.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:159,Deployability,Install,Installation,159,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:227,Deployability,Configurat,Configuration,227,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:3303,Deployability,update,updated,3303,"lt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'_loadings': loadings_expr, '_af': af_expr}, entry_exprs={'_call': call_expr}; ). if isinstance(loadings_source, hl.MatrixTable):; n_variants = loadings_source.count_rows(); else:; n_variants = loadings_source.count(). mt = mt.filter_rows(hl.is_defined(mt._loadings) & hl.is_defined(mt._af) & (mt._af > 0) & (mt._af < 1)). gt_norm = (mt._call.n_alt_alleles() - 2 * mt._af) / hl.sqrt(n_variants * 2 * mt._af * (1 - mt._af)). return mt.select_cols(scores=hl.agg.array_sum(mt._loadings * gt_norm)).cols(). def _get_expr_or_join(expr, source, other_source, loc):; if source != other_source:; if isinstance(source, hl.MatrixTable):; source = source.annotate_rows(**{loc: expr}); else:; source = source.annotate(**{loc: expr}); expr = source[other_source.row_key][loc]; return expr. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:227,Modifiability,Config,Configuration,227,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:892,Performance,load,loadings,892,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1128,Performance,load,loadings,1128,"; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', a",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1492,Performance,load,loadings,1492,".pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1552,Performance,load,loadings,1552,"pr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'_loadings': loadings_expr, '_af': af_expr}, entry_exprs={'_call': call_expr}",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1719,Performance,load,loadings,1719," [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'_loadings': loadings_expr, '_af': af_expr}, entry_exprs={'_call': call_expr}; ). if isinstance(loadings_source, hl.MatrixTable):; n_variants = loadings_source.count_rows(); else:; n_variants = loadi",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1807,Performance,load,loadings,1807,"oject(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'_loadings': loadings_expr, '_af': af_expr}, entry_exprs={'_call': call_expr}; ). if isinstance(loadings_source, hl.MatrixTable):; n_variants = loadings_source.count_rows(); else:; n_variants = loadings_source.count(). mt = mt.filter_rows(hl.is_defined(mt._loadings) & hl.is_defined(mt._af) & (mt._af > 0) & (m",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:1970,Performance,load,loadings,1970,"he original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"""; raise_unless_entry_indexed('pc_project', call_expr); raise_unless_row_indexed('pc_project', loadings_expr); raise_unless_row_indexed('pc_project', af_expr). gt_source = call_expr._indices.source; loadings_source = loadings_expr._indices.source; af_source = af_expr._indices.source. loadings_expr = _get_expr_or_join(loadings_expr, loadings_source, gt_source, '_loadings'); af_expr = _get_expr_or_join(af_expr, af_source, gt_source, '_af'). mt = gt_source._annotate_all(; row_exprs={'_loadings': loadings_expr, '_af': af_expr}, entry_exprs={'_call': call_expr}; ). if isinstance(loadings_source, hl.MatrixTable):; n_variants = loadings_source.count_rows(); else:; n_variants = loadings_source.count(). mt = mt.filter_rows(hl.is_defined(mt._loadings) & hl.is_defined(mt._af) & (mt._af > 0) & (mt._af < 1)). gt_norm = (mt._call.n_alt_alleles() - 2 * mt._af) / hl.sqrt(n_variants * 2 * mt._af * (1 - mt._af)). return mt.select_cols(scores=hl.agg.array_sum(mt._loadings * gt_norm)).cols(). def _get_expr_or_join(expr, source, other_source, loc):",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:381,Testability,Log,Log,381,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:59,Usability,Feedback,Feedback,59,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/pca.html:269,Usability,Guid,Guides,269,"﻿. Hail | ; hail.experimental.pca. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.pca. Source code for hail.experimental.pca; import hail as hl; from hail.expr.expressions import (; expr_array,; expr_call,; expr_numeric,; raise_unless_entry_indexed,; raise_unless_row_indexed,; ); from hail.typecheck import typecheck. [docs]@typecheck(call_expr=expr_call, loadings_expr=expr_array(expr_numeric), af_expr=expr_numeric); def pc_project(call_expr, loadings_expr, af_expr):; """"""Projects genotypes onto pre-computed PCs. Requires loadings and; allele-frequency from a reference dataset (see example). Note that; `loadings_expr` must have no missing data and reflect the rows; from the original PCA run for this method to be accurate. Example; -------; >>> # Compute loadings and allele frequency for reference dataset; >>> _, _, loadings_ht = hl.hwe_normalized_pca(mt.GT, k=10, compute_loadings=True) # doctest: +SKIP; >>> mt = mt.annotate_rows(af=hl.agg.mean(mt.GT.n_alt_alleles()) / 2) # doctest: +SKIP; >>> loadings_ht = loadings_ht.annotate(af=mt.rows()[loadings_ht.key].af) # doctest: +SKIP; >>> # Project new genotypes onto loadings; >>> ht = pc_project(mt_to_project.GT, loadings_ht.loadings, loadings_ht.af) # doctest: +SKIP. Parameters; ----------; call_expr : :class:`.CallExpression`; Entry-indexed call expression for genotypes; to project onto loadings.; loadings_expr : :class:`.ArrayNumericExpression`; Location of expression for loadings; af_expr : :class:`.Float64Expression`; Location of expression for allele frequency. Returns; -------; :class:`.Table`; Table with scores calculated from loadings in column `scores`; """"",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/pca.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/pca.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:177,Deployability,Install,Installation,177,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:245,Deployability,Configurat,Configuration,245,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:13533,Deployability,update,updated,13533,"er/mother schema,; and the resulting entry schema is the same as the proband_entry/father_entry/mother_entry schema.; If the `keep_trio_cols` option is set, then an additional `source_trio` column is added with the trio column data.; If the `keep_trio_entries` option is set, then an additional `source_trio_entry` column is added with the trio entry data. Note; ----; This assumes that the input MatrixTable is a trio MatrixTable (similar to; the result of :func:`~.trio_matrix`) Its entry schema has to contain; 'proband_entry`, `father_entry` and `mother_entry` all with the same type.; Its column schema has to contain 'proband`, `father` and `mother` all with; the same type. Parameters; ----------; tm : :class:`.MatrixTable`; Trio MatrixTable (entries have to be a Struct with `proband_entry`, `mother_entry` and `father_entry` present); col_keys : :obj:`list` of str; Column key(s) for the resulting sample MatrixTable; keep_trio_cols: bool; Whether to add a `source_trio` column with the trio column data (default `True`); keep_trio_entries: bool; Whether to add a `source_trio_entries` column with the trio entry data (default `False`). Returns; -------; :class:`.MatrixTable`; Sample MatrixTable; """""". select_entries_expr = {'__trio_entries': hl.array([tm.proband_entry, tm.father_entry, tm.mother_entry])}; if keep_trio_entries:; select_entries_expr['source_trio_entry'] = hl.struct(**tm.entry); tm = tm.select_entries(**select_entries_expr). tm = tm.key_cols_by(); select_cols_expr = {'__trio_members': hl.enumerate(hl.array([tm.proband, tm.father, tm.mother]))}; if keep_trio_cols:; select_cols_expr['source_trio'] = hl.struct(**tm.col); tm = tm.select_cols(**select_cols_expr). mt = tm.explode_cols(tm.__trio_members). mt = mt.transmute_entries(**mt.__trio_entries[mt.__trio_members[0]]). mt = mt.key_cols_by(); mt = mt.transmute_cols(**mt.__trio_members[1]). if col_keys:; mt = mt.key_cols_by(*col_keys). return mt. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:2420,Integrability,wrap,wrapper,2420," Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid on non-PAR region of Y. In addition, individual phased genotype calls are returned as missing in the following situations:; 1. All mother genotype calls non-PAR region of Y; 2. Diploid father genotype calls on non-PAR region of X for a male proband (proband and mother are still phased as father doesn't participate in allele transmission). Note; ----; :func:`~.phase_trio_matrix_by_transmission` provides a convenience wrapper for phasing a trio matrix. Parameters; ----------; locus : :class:`.LocusExpression`; Expression for the locus in the trio matrix; alleles : :class:`.ArrayExpression`; Expression for the alleles in the trio matrix; proband_call : :class:`.CallExpression`; Expression for the proband call in the trio matrix; father_call : :class:`.CallExpression`; Expression for the father call in the trio matrix; mother_call : :class:`.CallExpression`; Expression for the mother call in the trio matrix. Returns; -------; :class:`.ArrayExpression`; Array containing: [phased proband call, phased father call, phased mother call]"""""". def call_to_one_hot_alleles_array(; call: hl.expr.CallExpression, alleles: hl.expr.ArrayExpression; ) -> hl.expr.ArrayExpression:; """"""; Get the set of all different one-hot-encoded allele-vectors in a genotype call.; It is returned as an ordered array where the first vector corresponds to the first allele,; and the second vector (only present if het) the seco",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:245,Modifiability,Config,Configuration,245,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:399,Testability,Log,Log,399,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:77,Usability,Feedback,Feedback,77,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html:287,Usability,Guid,Guides,287,"﻿. Hail | ; hail.experimental.phase_by_transmission. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.phase_by_transmission. Source code for hail.experimental.phase_by_transmission; from typing import List. import hail as hl; from hail.expr.expressions import expr_array, expr_call, expr_locus, expr_str; from hail.matrixtable import MatrixTable; from hail.typecheck import sequenceof, typecheck. [docs]@typecheck(; locus=expr_locus(),; alleles=expr_array(expr_str),; proband_call=expr_call,; father_call=expr_call,; mother_call=expr_call,; ); def phase_by_transmission(; locus: hl.expr.LocusExpression,; alleles: hl.expr.ArrayExpression,; proband_call: hl.expr.CallExpression,; father_call: hl.expr.CallExpression,; mother_call: hl.expr.CallExpression,; ) -> hl.expr.ArrayExpression:; """"""Phases genotype calls in a trio based allele transmission. Notes; -----; In the phased calls returned, the order is as follows:; - Proband: father_allele | mother_allele; - Parents: transmitted_allele | untransmitted_allele. Phasing of sex chromosomes:; - Sex chromosomes of male individuals should be haploid to be phased correctly.; - If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female. Returns `NA` when genotype calls cannot be phased.; The following genotype calls combinations cannot be phased by transmission:; 1. One of the calls in the trio is missing; 2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation); 3. All individuals of the trio are heterozygous for the same two alleles; 4. Father is diploid on non-PAR region of X or Y; 5. Proband is diploid o",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/phase_by_transmission.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/phase_by_transmission.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:161,Deployability,Install,Installation,161,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:229,Deployability,Configurat,Configuration,229,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:11564,Deployability,update,updated,11564,"top=row_file_sizes_edges[1:],; fill_color=""#036564"",; line_color=""#033649"",; ). rows_grid = gridplot([[p_rows_per_partition, p_stats], [p, p_file_size]]). if 'entry_file_sizes' in all_data:; title = f'Statistics for {data_type}: {t_path}'. msg = f""Rows: {sum(all_data['rows_per_partition']):,}<br/>Partitions: {len(all_data['rows_per_partition']):,}<br/>Size: {total_entry_file_size}<br/>""; if success_file[0]:; msg += success_file[0]. source = ColumnDataSource(pd.DataFrame(all_data)); p = figure(tools=tools, width=panel_size, height=panel_size); p.title.text = title; p.xaxis.axis_label = 'Number of rows'; p.yaxis.axis_label = f'File size ({entry_scale}B)'; color_map = factor_cmap('spans_chromosome', palette=Spectral8, factors=list(set(all_data['spans_chromosome']))); p.scatter('rows_per_partition', 'entry_file_sizes', color=color_map, legend='spans_chromosome', source=source); p.legend.location = 'bottom_right'; p.select_one(HoverTool).tooltips = [; (x, f'@{x}') for x in ('rows_per_partition', 'entry_file_sizes_human', 'partition_bounds', 'index'); ]. p_stats = Div(text=msg); p_rows_per_partition = figure(x_range=p.x_range, width=panel_size, height=subpanel_size); p_rows_per_partition.quad(; top=rows_per_partition_hist,; bottom=0,; left=rows_per_partition_edges[:-1],; right=rows_per_partition_edges[1:],; fill_color=""#036564"",; line_color=""#033649"",; ); p_file_size = figure(y_range=p.y_range, width=subpanel_size, height=panel_size). row_file_sizes_hist, row_file_sizes_edges = np.histogram(all_data['entry_file_sizes'], bins=50); p_file_size.quad(; right=row_file_sizes_hist,; left=0,; bottom=row_file_sizes_edges[:-1],; top=row_file_sizes_edges[1:],; fill_color=""#036564"",; line_color=""#033649"",; ); entries_grid = gridplot([[p_rows_per_partition, p_stats], [p, p_file_size]]). return Tabs(tabs=[TabPanel(child=entries_grid, title='Entries'), TabPanel(child=rows_grid, title='Rows')]); else:; return rows_grid. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:229,Modifiability,Config,Configuration,229,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:4615,Performance,load,load,4615,"t for a Hail Table or MatrixTable. Parameters; ----------; t_path : str; Path to the Hail Table or MatrixTable files. Returns; -------; :class:`bokeh.plotting.figure` or :class:`bokeh.models.layouts.Column`; """""". def get_rows_data(rows_files):; file_sizes = []; partition_bounds = []; parts_file = [x['path'] for x in rows_files if x['path'].endswith('parts')]; if parts_file:; parts = hadoop_ls(parts_file[0]); for i, x in enumerate(parts):; index = x['path'].split(f'{parts_file[0]}/part-')[1].split('-')[0]; if i < len(parts) - 1:; test_index = parts[i + 1]['path'].split(f'{parts_file[0]}/part-')[1].split('-')[0]; if test_index == index:; continue; file_sizes.append(x['size_bytes']); metadata_file = [x['path'] for x in rows_files if x['path'].endswith('metadata.json.gz')]; if metadata_file:; with hadoop_open(metadata_file[0], 'rb') as f:; rows_meta = json.load(f); try:; partition_bounds = [; (; x['start']['locus']['contig'],; x['start']['locus']['position'],; x['end']['locus']['contig'],; x['end']['locus']['position'],; ); for x in rows_meta['jRangeBounds']; ]; except KeyError:; pass; return partition_bounds, file_sizes. def scale_file_sizes(file_sizes):; min_file_size = min(file_sizes) * 1.1; total_file_size = sum(file_sizes); all_scales = [('T', 1e12), ('G', 1e9), ('M', 1e6), ('K', 1e3), ('', 1e0)]; for overall_scale, overall_factor in all_scales:; if total_file_size > overall_factor:; total_file_size /= overall_factor; break; for scale, factor in all_scales:; if min_file_size > factor:; file_sizes = [x / factor for x in file_sizes]; break; total_file_size = f'{total_file_size:.1f} {overall_scale}B'; return total_file_size, file_sizes, scale. files = hadoop_ls(t_path). rows_file = [x['path'] for x in files if x['path'].endswith('rows')]; entries_file = [x['path'] for x in files if x['path'].endswith('entries')]; success_file = [x['modification_time'] for x in files if x['path'].endswith('SUCCESS')]. metadata_file = [x['path'] for x in files if x['path'].endswith('met",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:5919,Performance,load,load,5919,"tal_file_size = sum(file_sizes); all_scales = [('T', 1e12), ('G', 1e9), ('M', 1e6), ('K', 1e3), ('', 1e0)]; for overall_scale, overall_factor in all_scales:; if total_file_size > overall_factor:; total_file_size /= overall_factor; break; for scale, factor in all_scales:; if min_file_size > factor:; file_sizes = [x / factor for x in file_sizes]; break; total_file_size = f'{total_file_size:.1f} {overall_scale}B'; return total_file_size, file_sizes, scale. files = hadoop_ls(t_path). rows_file = [x['path'] for x in files if x['path'].endswith('rows')]; entries_file = [x['path'] for x in files if x['path'].endswith('entries')]; success_file = [x['modification_time'] for x in files if x['path'].endswith('SUCCESS')]. metadata_file = [x['path'] for x in files if x['path'].endswith('metadata.json.gz')]; if not metadata_file:; raise FileNotFoundError('No metadata.json.gz file found.'). with hadoop_open(metadata_file[0], 'rb') as f:; overall_meta = json.load(f); rows_per_partition = overall_meta['components']['partition_counts']['counts']. if not rows_file:; raise FileNotFoundError('No rows directory found.'); rows_files = hadoop_ls(rows_file[0]). data_type = 'Table'; if entries_file:; data_type = 'MatrixTable'; rows_file = [x['path'] for x in rows_files if x['path'].endswith('rows')]; rows_files = hadoop_ls(rows_file[0]); row_partition_bounds, row_file_sizes = get_rows_data(rows_files). total_file_size, row_file_sizes, row_scale = scale_file_sizes(row_file_sizes). panel_size = 480; subpanel_size = 120. if not row_partition_bounds:; warning('Table is not partitioned. Only plotting file sizes'); row_file_sizes_hist, row_file_sizes_edges = np.histogram(row_file_sizes, bins=50); p_file_size = figure(width=panel_size, height=panel_size); p_file_size.quad(; right=row_file_sizes_hist,; left=0,; bottom=row_file_sizes_edges[:-1],; top=row_file_sizes_edges[1:],; fill_color=""#036564"",; line_color=""#033649"",; ); p_file_size.yaxis.axis_label = f'File size ({row_scale}B)'; return p_file_siz",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:383,Testability,Log,Log,383,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:61,Usability,Feedback,Feedback,61,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/plots.html:271,Usability,Guid,Guides,271,"﻿. Hail | ; hail.experimental.plots. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.plots. Source code for hail.experimental.plots; import json. import numpy as np; import pandas as pd; from bokeh.layouts import gridplot; from bokeh.models import ColumnDataSource, Div, HoverTool, TabPanel, Tabs, Title; from bokeh.palettes import Spectral8; from bokeh.plotting import figure; from bokeh.transform import factor_cmap. import hail as hl; from hail.typecheck import typecheck; from hail.utils.hadoop_utils import hadoop_ls, hadoop_open; from hail.utils.java import warning. [docs]def plot_roc_curve(ht, scores, tp_label='tp', fp_label='fp', colors=None, title='ROC Curve', hover_mode='mouse'):; """"""Create ROC curve from Hail Table. One or more `score` fields must be provided, which are assessed against `tp_label` and `fp_label` as truth data. High scores should correspond to true positives. Parameters; ----------; ht : :class:`.Table`; Table with required data; scores : :class:`str` or :obj:`list` of :obj:`.str`; Top-level location of scores in ht against which to generate PR curves.; tp_label : :class:`str`; Top-level location of true positives in ht.; fp_label : :class:`str`; Top-level location of false positives in ht.; colors : :obj:`dict` of :class:`str`; Optional colors to use (score -> desired color).; title : :class:`str`; Title of plot.; hover_mode : :class:`str`; Hover mode; one of 'mouse' (default), 'vline' or 'hline'. Returns; -------; :obj:`tuple` of :class:`bokeh.plotting.figure` and :obj:`list` of :class:`str`; Figure, and list of AUCs corresponding to scores.; """"""; if colors is None:; # Get a palette aut",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/plots.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/plots.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:161,Deployability,Install,Installation,161,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:229,Deployability,Configurat,Configuration,229,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:5047,Deployability,update,updated,5047,"ggregate(; **{rv: hl.agg.take(ht[rv], 1)[0] for rv in ht.row_value if rv not in set([*key, field, value])},; **{; fv: hl.agg.filter(; ht[field] == fv,; hl.rbind(hl.agg.take(ht[value], 1), lambda take: hl.if_else(hl.len(take) > 0, take[0], 'NA')),; ); for fv in field_vals; },; ). ht_tmp = new_temp_file(); ht.write(ht_tmp). return ht. [docs]@typecheck(ht=Table, field=str, into=sequenceof(str), delim=oneof(str, int)); def separate(ht, field, into, delim) -> Table:; """"""Separate a field into multiple fields by splitting on a delimiter; character or position. :func:`.separate` mimics the functionality of the `separate()` function in R's; ``tidyr`` package. This function will create a new table where ``field`` has been split into; multiple new fields, whose names are given by ``into``. If ``delim`` is a ``str`` (including regular expression strings), ``field``; will be separated into columns by that string. In this case, the length; of ``into`` must match the number of resulting fields. If ``delim`` is an ``int``, ``field`` will be separated into two row fields,; where the first field contains the first ``delim`` characters of ``field``; and the second field contains the remaining characters. Parameters; ----------; ht : :class:`.Table`; A Hail table.; field : :class:`str`; The name of the field to separate in ``ht``.; into : list of :class:`str`; The names of the fields to create by separating ``field``.; delimiter : :class:`str` or :obj:`int`; The character or position by which to separate ``field``. Returns; -------; :class:`.Table`; Table with original ``field`` split into fields whose names are defined; by `into`."""""". if isinstance(delim, int):; ht = ht.annotate(**{into[0]: ht[field][:delim], into[1]: ht[field][delim:]}); else:; split = ht[field].split(delim); ht = ht.annotate(**{into[i]: split[i] for i in range(len(into))}); ht = ht.drop(field). ht_tmp = new_temp_file(); ht.write(ht_tmp). return ht. © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:229,Modifiability,Config,Configuration,229,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:1196,Modifiability,variab,variable-length,1196,"); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr` package. This is a way to turn ""long"" format data into ""wide""; format data. Given a ``field``, :func:`.spread` will create a new table by grouping; ``ht`` by its row key and, optionally, any additional fields passed to the;",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:383,Testability,Log,Log,383,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:61,Usability,Feedback,Feedback,61,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html:271,Usability,Guid,Guides,271,"﻿. Hail | ; hail.experimental.tidyr. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.tidyr. Source code for hail.experimental.tidyr; import hail as hl; from hail.table import Table; from hail.typecheck import nullable, oneof, sequenceof, typecheck; from hail.utils import new_temp_file, wrap_to_list. [docs]@typecheck(ht=Table, key=str, value=str, fields=str); def gather(ht, key, value, *fields) -> Table:; """"""Collapse fields into key-value pairs. :func:`.gather` mimics the functionality of the `gather()` function found in R's; ``tidyr`` package. This is a way to turn ""wide"" format data into ""long""; format data. Parameters; ----------; ht : :class:`.Table`; A Hail table.; key : :class:`str`; The name of the key field in the gathered table.; value : :class:`str`; The name of the value field in the gathered table.; fields : variable-length args of obj:`str`; Names of fields to gather in ``ht``. Returns; -------; :class:`.Table`; Table with original ``fields`` gathered into ``key`` and ``value`` fields."""""". ht = ht.annotate(_col_val=hl.array([hl.struct(field_name=field, value=ht[field]) for field in fields])); ht = ht.drop(*fields); ht = ht.explode(ht['_col_val']); ht = ht.annotate(**{key: ht['_col_val'][0], value: ht['_col_val'][1]}); ht = ht.drop('_col_val'). ht_tmp = new_temp_file(); ht.write(ht_tmp). return hl.read_table(ht_tmp). [docs]@typecheck(ht=Table, field=str, value=str, key=nullable(oneof(str, sequenceof(str)))); def spread(ht, field, value, key=None) -> Table:; """"""Spread a key-value pair of fields across multiple fields. :func:`.spread` mimics the functionality of the `spread()` function in R's; `tidyr",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/tidyr.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/tidyr.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:160,Deployability,Install,Installation,160,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:228,Deployability,Configurat,Configuration,228,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:4310,Deployability,update,updated,4310,"(time=expr_str, format=expr_str, zone_id=expr_str); def strptime(time, format, zone_id):; """"""; Interpret a formatted datetime string as a Unix timestamp (number of seconds since 1970-01-01T00:00Z (ISO)). Examples; --------. >>> hl.eval(hl.experimental.strptime(""07/08/19 3:00:01 AM"", ""%D %l:%M:%S %p"", ""America/New_York"")); 1562569201. >>> hl.eval(hl.experimental.strptime(""Saturday, October 11, 1997. 05:45:23 AM"", ""%A, %B %e, %Y. %r"", ""GMT+2"")); 876541523. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the parser implicitly uses the ""en_US"" locale. This function will fail if there is not enough information in the string to determine a particular timestamp.; For example, if you have the string `""07/08/09""` and the format string `""%Y.%m.%d""`, this method will fail, since that's not specific; enough to determine seconds from. You can fix this by adding ""00:00:00"" to your date string and ""%H:%M:%S"" to your format string. Parameters; ----------; time : str or :class:`.Expression` of type :py:data:`.tstr`; The string from which to parse the time.; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to parse the time.; zone_id: str or :class:`.Expression` of type :py:data:`.tstr`; An id representing the timezone. See notes above. Returns; -------; :class:`~.Int64Expression`; The Unix timestamp associated with the given time string.; """"""; return _func(""strptime"", hl.tint64, time, format, zone_id). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:228,Modifiability,Config,Configuration,228,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:382,Testability,Log,Log,382,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:60,Usability,Feedback,Feedback,60,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/experimental/time.html:270,Usability,Guid,Guides,270,"﻿. Hail | ; hail.experimental.time. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.experimental.time. Source code for hail.experimental.time; import hail as hl; from hail.expr.expressions import expr_int64, expr_str; from hail.expr.functions import _func; from hail.typecheck import typecheck. [docs]@typecheck(format=expr_str, time=expr_int64, zone_id=expr_str); def strftime(format, time, zone_id):; """"""; Convert Unix timestamp to a formatted datetime string. Examples; --------. >>> hl.eval(hl.experimental.strftime(""%Y.%m.%d %H:%M:%S %z"", 1562569201, ""America/New_York"")); '2019.07.08 03:00:01 -04:00'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""GMT+2"")); 'Saturday, October 11, 1997. 05:45:23 AM'. >>> hl.eval(hl.experimental.strftime(""%A, %B %e, %Y. %r"", 876541523, ""+08:00"")); 'Saturday, October 11, 1997. 11:45:23 AM'. Notes; -----; The following formatting characters are supported in format strings: A a B b D d e F H I j k l M m n p R r S s T t U u V v W Y y z; See documentation here: https://linux.die.net/man/3/strftime. A zone id can take one of three forms. It can be an explicit offset, like ""+01:00"", a relative offset, like ""GMT+2"",; or a IANA timezone database (TZDB) identifier, like ""America/New_York"". Wikipedia maintains a list of TZDB identifiers here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones. Currently, the formatter implicitly uses the ""en_US"" locale. Parameters; ----------; format : str or :class:`.Expression` of type :py:data:`.tstr`; The format string describing how to render the time.; time : int of :class:`.Expression` of type :py:data:`.tint64`; A long represent",MatchSource.WIKI,docs/0.2/_modules/hail/experimental/time.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/experimental/time.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:4849,Availability,error,error,4849,"expr_any); def default(self, then):; """"""Finish the switch statement by adding a default case. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBui",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:4966,Availability,error,error,4966," call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBuilder.default` method calls must be the; same type. Parameters; ----------; missing_false: :obj:`.bool`; Treat missing predicates as ``False``. See Also; --",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8126,Availability,error,error,8126,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8246,Availability,error,error,8246,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:156,Deployability,Install,Installation,156,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:224,Deployability,Configurat,Configuration,224,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8658,Deployability,update,updated,8658,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:4754,Integrability,message,message,4754,"expr_any); def default(self, then):; """"""Finish the switch statement by adding a default case. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBui",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:4792,Integrability,message,message,4792,"expr_any); def default(self, then):; """"""Finish the switch statement by adding a default case. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBui",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:4870,Integrability,message,message,4870,"expr_any); def default(self, then):; """"""Finish the switch statement by adding a default case. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBui",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:5007,Integrability,message,message,5007,"rameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBuilder.default` method calls must be the; same type. Parameters; ----------; missing_false: :obj:`.bool`; Treat missing predicates as ``False``. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:5258,Integrability,message,message,5258,":; """"""Finish the switch statement by returning missing. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the switch statement by throwing an error with the given message. Notes; -----; If no value from a :meth:`.SwitchBuilder.when` call is matched, then an; error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBuilder.default` method calls must be the; same type. Parameters; ----------; missing_false: :obj:`.bool`; Treat missing predicates as ``False``. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`; """""". def __init__(self, missing_false=False):; super(CaseBuilder, self).__init__(); self._missing_false = missing_false. def _finish(self, default):; assert len(self._cases) > 0. from hail.expr.functions import if_else. expr = default; for conditi",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8033,Integrability,message,message,8033,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8071,Integrability,message,message,8071,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8147,Integrability,message,message,8147,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8287,Integrability,message,message,8287,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:8538,Integrability,message,message,8538,"ion` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_missing' cannot be called without at least one 'when' call""); from hail.expr.functions import missing. return self._finish(missing(self._ret_type)). [docs] @typecheck_method(message=expr_str); def or_error(self, message):; """"""Finish the case statement by throwing an error with the given message. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; an error is thrown. Parameters; ----------; message : :class:`.Expression` of type :obj:`.tstr`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; raise ExpressionException(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:224,Modifiability,Config,Configuration,224,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:378,Testability,Log,Log,378,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:2000,Testability,assert,assert,2000,"ave same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; assert len(self._cases) > 0 or self._when_missing_case is not None. def f(base):; # build cond chain bottom-up; if default is self._base:; expr = base; else:; expr = default; for value, then in self._cases[::-1]:; expr = hl.if_else(base == value, then, expr); # needs to be on the outside, because upstream missingness would propagate; if self._when_missing_case is not None:; expr = hl.if_else(hl.is_missing(base), self._when_missing_case, expr); return expr. return hl.bind(f, self._base). [docs] @typecheck_method(value=expr_any, then=expr_any); def when(self, value, then) -> 'SwitchBuilder':; """"""Add a value test. If the `base` expression is equal to `value`, then; returns `then`. Warning; -------; Missingness always compares to missing. Both ``NA == NA`` and; ``NA != NA`` return ``NA``. Use :meth:`~SwitchBuilder.when_missing`; to test missingness. Parameters; ----------; value : :class:`.Expression`; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:2613,Testability,test,test,2613,"ders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; assert len(self._cases) > 0 or self._when_missing_case is not None. def f(base):; # build cond chain bottom-up; if default is self._base:; expr = base; else:; expr = default; for value, then in self._cases[::-1]:; expr = hl.if_else(base == value, then, expr); # needs to be on the outside, because upstream missingness would propagate; if self._when_missing_case is not None:; expr = hl.if_else(hl.is_missing(base), self._when_missing_case, expr); return expr. return hl.bind(f, self._base). [docs] @typecheck_method(value=expr_any, then=expr_any); def when(self, value, then) -> 'SwitchBuilder':; """"""Add a value test. If the `base` expression is equal to `value`, then; returns `then`. Warning; -------; Missingness always compares to missing. Both ``NA == NA`` and; ``NA != NA`` return ``NA``. Use :meth:`~SwitchBuilder.when_missing`; to test missingness. Parameters; ----------; value : :class:`.Expression`; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates and returns `self`.; """"""; can_compare = unify_types(self._base.dtype, value.dtype); if not can_compare:; raise TypeError(""cannot compare expressions of type '{}' and '{}'"".format(self._base.dtype, value.dtype)). self._unify_type(then.dtype); self._cases.append((value, then)); return self. [docs] @typecheck_method(then=expr_any); def when_missing(self, then) -> 'SwitchBuilder':; """"""Add a test for missingness. If the `base` expression is missing,; returns `then`. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; M",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:2840,Testability,test,test,2840,"ase=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; assert len(self._cases) > 0 or self._when_missing_case is not None. def f(base):; # build cond chain bottom-up; if default is self._base:; expr = base; else:; expr = default; for value, then in self._cases[::-1]:; expr = hl.if_else(base == value, then, expr); # needs to be on the outside, because upstream missingness would propagate; if self._when_missing_case is not None:; expr = hl.if_else(hl.is_missing(base), self._when_missing_case, expr); return expr. return hl.bind(f, self._base). [docs] @typecheck_method(value=expr_any, then=expr_any); def when(self, value, then) -> 'SwitchBuilder':; """"""Add a value test. If the `base` expression is equal to `value`, then; returns `then`. Warning; -------; Missingness always compares to missing. Both ``NA == NA`` and; ``NA != NA`` return ``NA``. Use :meth:`~SwitchBuilder.when_missing`; to test missingness. Parameters; ----------; value : :class:`.Expression`; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates and returns `self`.; """"""; can_compare = unify_types(self._base.dtype, value.dtype); if not can_compare:; raise TypeError(""cannot compare expressions of type '{}' and '{}'"".format(self._base.dtype, value.dtype)). self._unify_type(then.dtype); self._cases.append((value, then)); return self. [docs] @typecheck_method(then=expr_any); def when_missing(self, then) -> 'SwitchBuilder':; """"""Add a test for missingness. If the `base` expression is missing,; returns `then`. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates and returns `self`.; """"""; if self._when_missing_case is not None:; raise ExpressionException(""'when_missing' can only be called once""); self._unify_type(then.dtype). self._when_missing_case = then; return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:3382,Testability,test,test,3382,"f._when_missing_case is not None:; expr = hl.if_else(hl.is_missing(base), self._when_missing_case, expr); return expr. return hl.bind(f, self._base). [docs] @typecheck_method(value=expr_any, then=expr_any); def when(self, value, then) -> 'SwitchBuilder':; """"""Add a value test. If the `base` expression is equal to `value`, then; returns `then`. Warning; -------; Missingness always compares to missing. Both ``NA == NA`` and; ``NA != NA`` return ``NA``. Use :meth:`~SwitchBuilder.when_missing`; to test missingness. Parameters; ----------; value : :class:`.Expression`; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates and returns `self`.; """"""; can_compare = unify_types(self._base.dtype, value.dtype); if not can_compare:; raise TypeError(""cannot compare expressions of type '{}' and '{}'"".format(self._base.dtype, value.dtype)). self._unify_type(then.dtype); self._cases.append((value, then)); return self. [docs] @typecheck_method(then=expr_any); def when_missing(self, then) -> 'SwitchBuilder':; """"""Add a test for missingness. If the `base` expression is missing,; returns `then`. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.SwitchBuilder`; Mutates and returns `self`.; """"""; if self._when_missing_case is not None:; raise ExpressionException(""'when_missing' can only be called once""); self._unify_type(then.dtype). self._when_missing_case = then; return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the switch statement by adding a default case. Notes; -----; If no value from a :meth:`~.SwitchBuilder.when` call is matched, then; `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0 and self._when_missing_case is None:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the switch statement by returning missing. Notes; -----; If no value ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:6163,Testability,assert,assert,6163,"n(""'or_error' cannot be called without at least one 'when' call""); error_expr = construct_expr(ir.Die(message._ir, self._ret_type), self._ret_type); return self._finish(error_expr). [docs]class CaseBuilder(ConditionalBuilder):; """"""Class for chaining multiple if-else statements. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(x.length() == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.CaseBuilder.when` or; :meth:`~hail.expr.builders.CaseBuilder.default` method calls must be the; same type. Parameters; ----------; missing_false: :obj:`.bool`; Treat missing predicates as ``False``. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`; """""". def __init__(self, missing_false=False):; super(CaseBuilder, self).__init__(); self._missing_false = missing_false. def _finish(self, default):; assert len(self._cases) > 0. from hail.expr.functions import if_else. expr = default; for conditional, then in self._cases[::-1]:; expr = if_else(conditional, then, expr, missing_false=self._missing_false); return expr. [docs] @typecheck_method(condition=expr_bool, then=expr_any); def when(self, condition, then) -> 'CaseBuilder':; """"""Add a branch. If `condition` is ``True``, then returns `then`. Warning; -------; Missingness is treated similarly to :func:`.cond`. Missingness is; **not** treated as ``False``. A `condition` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:6786,Testability,test,test,6786,"Builder.default` method calls must be the; same type. Parameters; ----------; missing_false: :obj:`.bool`; Treat missing predicates as ``False``. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`; """""". def __init__(self, missing_false=False):; super(CaseBuilder, self).__init__(); self._missing_false = missing_false. def _finish(self, default):; assert len(self._cases) > 0. from hail.expr.functions import if_else. expr = default; for conditional, then in self._cases[::-1]:; expr = if_else(conditional, then, expr, missing_false=self._missing_false); return expr. [docs] @typecheck_method(condition=expr_bool, then=expr_any); def when(self, condition, then) -> 'CaseBuilder':; """"""Add a branch. If `condition` is ``True``, then returns `then`. Warning; -------; Missingness is treated similarly to :func:`.cond`. Missingness is; **not** treated as ``False``. A `condition` that evaluates to missing; will return a missing result, not proceed to the next case. Always; test missingness first in a :class:`.CaseBuilder`. Parameters; ----------; condition: :class:`.BooleanExpression`; then : :class:`.Expression`. Returns; -------; :class:`.CaseBuilder`; Mutates and returns `self`.; """"""; self._unify_type(then.dtype); self._cases.append((condition, then)); return self. [docs] @typecheck_method(then=expr_any); def default(self, then):; """"""Finish the case statement by adding a default case. Notes; -----; If no condition from a :meth:`~.CaseBuilder.when` call is ``True``,; then `then` is returned. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if len(self._cases) == 0:; return then; self._unify_type(then.dtype); return self._finish(then). [docs] def or_missing(self):; """"""Finish the case statement by returning missing. Notes; -----; If no condition from a :meth:`.CaseBuilder.when` call is ``True``, then; the result is missing. Parameters; ----------; then : :class:`.Expression`. Returns; -------; :class:`.Expression`; """""";",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:56,Usability,Feedback,Feedback,56,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/builders.html:266,Usability,Guid,Guides,266,"﻿. Hail | ; hail.expr.builders. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.builders. Source code for hail.expr.builders; import hail as hl; from hail import ir; from hail.expr.expressions import (; ExpressionException,; construct_expr,; expr_any,; expr_bool,; expr_str,; unify_types,; unify_types_limited,; ); from hail.typecheck import typecheck_method. class ConditionalBuilder(object):; def __init__(self):; self._ret_type = None; self._cases = []. def _unify_type(self, t):; if self._ret_type is None:; self._ret_type = t; else:; r = unify_types_limited(self._ret_type, t); if not r:; raise TypeError(""'then' expressions must have same type, found '{}' and '{}'"".format(self._ret_type, t)). [docs]class SwitchBuilder(ConditionalBuilder):; """"""Class for generating conditional trees based on value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. Notes; -----; All expressions appearing as the `then` parameters to; :meth:`~hail.expr.builders.SwitchBuilder.when` or; :meth:`~hail.expr.builders.SwitchBuilder.default` method calls must be the; same type. See Also; --------; :func:`.case`, :func:`.cond`, :func:`.switch`. Parameters; ----------; expr : :class:`.Expression`; Value to match against.; """""". @typecheck_method(base=expr_any); def __init__(self, base):; self._base = base; self._when_missing_case = None; super(SwitchBuilder, self).__init__(). def _finish(self, default):; a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/builders.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/builders.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5163,Availability,error,error,5163,"turn res. return hl.rbind(cdf, compute). @typecheck(raw_cdf=expr_struct()); def _result_from_raw_cdf(raw_cdf):; levels = raw_cdf.levels; item_weights = (; hl._stream_range(hl.len(levels) - 1); .flatmap(; lambda l: hl._stream_range(levels[l], levels[l + 1]).map(; lambda i: hl.struct(level=l, value=raw_cdf['items'][i]); ); ); .aggregate(lambda x: hl.agg.group_by(x.value, hl.agg.sum(hl.bit_lshift(1, x.level)))); ); weights = item_weights.values(); ranks = weights.scan(lambda acc, weight: acc + weight, 0); values = item_weights.keys(); return hl.struct(values=values, ranks=ranks, _compaction_counts=raw_cdf._compaction_counts). @typecheck(k=expr_int32, left=expr_struct(), right=expr_struct()); def _cdf_combine(k, left, right):; t = tstruct(levels=tarray(tint32), items=tarray(tfloat64), _compaction_counts=tarray(tint32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5403,Availability,error,error,5403,"alue=raw_cdf['items'][i]); ); ); .aggregate(lambda x: hl.agg.group_by(x.value, hl.agg.sum(hl.bit_lshift(1, x.level)))); ); weights = item_weights.values(); ranks = weights.scan(lambda acc, weight: acc + weight, 0); values = item_weights.keys(); return hl.struct(values=values, ranks=ranks, _compaction_counts=raw_cdf._compaction_counts). @typecheck(k=expr_int32, left=expr_struct(), right=expr_struct()); def _cdf_combine(k, left, right):; t = tstruct(levels=tarray(tint32), items=tarray(tfloat64), _compaction_counts=tarray(tint32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5438,Availability,error,error,5438,"alue=raw_cdf['items'][i]); ); ); .aggregate(lambda x: hl.agg.group_by(x.value, hl.agg.sum(hl.bit_lshift(1, x.level)))); ); weights = item_weights.values(); ranks = weights.scan(lambda acc, weight: acc + weight, 0); values = item_weights.keys(); return hl.struct(values=values, ranks=ranks, _compaction_counts=raw_cdf._compaction_counts). @typecheck(k=expr_int32, left=expr_struct(), right=expr_struct()); def _cdf_combine(k, left, right):; t = tstruct(levels=tarray(tint32), items=tarray(tfloat64), _compaction_counts=tarray(tint32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5524,Availability,error,error,5524,")); ); weights = item_weights.values(); ranks = weights.scan(lambda acc, weight: acc + weight, 0); values = item_weights.keys(); return hl.struct(values=values, ranks=ranks, _compaction_counts=raw_cdf._compaction_counts). @typecheck(k=expr_int32, left=expr_struct(), right=expr_struct()); def _cdf_combine(k, left, right):; t = tstruct(levels=tarray(tint32), items=tarray(tfloat64), _compaction_counts=tarray(tint32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_pytho",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5643,Availability,error,error,5643,"; return hl.struct(values=values, ranks=ranks, _compaction_counts=raw_cdf._compaction_counts). @typecheck(k=expr_int32, left=expr_struct(), right=expr_struct()); def _cdf_combine(k, left, right):; t = tstruct(levels=tarray(tint32), items=tarray(tfloat64), _compaction_counts=tarray(tint32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameter",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:6569,Availability,error,error,6569,"ntiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no com",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:6807,Availability,error,error,6807,": cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=h",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:6842,Availability,error,error,6842,": cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=h",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:6928,Availability,error,error,6928,"failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=hail_type); def missing(t: Union[HailType, str]):; """"""Creates an expression representing a missing value of a specified type. Examples; --------. >",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:7032,Availability,error,error,7032," / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=hail_type); def missing(t: Union[HailType, str]):; """"""Creates an expression representing a missing value of a specified type. Examples; --------. >>> hl.eval(hl.missing(hl.tarray(hl.tstr))); None. >>> hl.eval(hl.missing('array<str>')); None. Notes; ----",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:7575,Availability,error,error,7575,"----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=hail_type); def missing(t: Union[HailType, str]):; """"""Creates an expression representing a missing value of a specified type. Examples; --------. >>> hl.eval(hl.missing(hl.tarray(hl.tstr))); None. >>> hl.eval(hl.missing('array<str>')); None. Notes; -----; This method is useful for constructing an expression that includes missing; values, since :obj:`None` cannot be interpreted as an expression. Parameters; ----------; t : :class:`str` or :class:`.HailType`; Type of the missing expression. Returns; -------; :class:`.Expression`; A missing expression of type `t`.; """"""; return construct_expr(ir.NA(t), t). [docs]@deprecated(version=""0.2.62"", reason=""Replaced by hl.missing""); @typecheck(t=hail_type); def null(t: Union[HailType, str]):; """"""Deprecated in favor of :func:`.missing`. Creates an expression representing a missing value of a specified type. Examples; -------",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:17873,Availability,error,errors,17873,"hBuilder. return SwitchBuilder(expr). [docs]@typecheck(f=anytype, exprs=expr_any, _ctx=nullable(str)); def bind(f: Callable, *exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. Examples; --------. >>> hl.eval(hl.bind(lambda x: x + 1, 1)); 2. :func:`.bind` also can take multiple arguments:. >>> hl.eval(hl.bind(lambda x, y: x / y, x, x)); 1.0. Parameters; ----------; f : function ( (args) -> :class:`.Expression`); Function of `exprs`.; exprs : variable-length args of :class:`.Expression`; Expressions to bind. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """"""; args = []; uids = []; irs = []. for expr in exprs:; uid = Env.get_uid(base=_ctx); args.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uids.append(uid); irs.append(expr._ir). lambda_result = to_expr(f(*args)); if _ctx:; indices, aggregations = unify_all(lambda_result) # FIXME: hacky. May drop field refs from errors?; else:; indices, aggregations = unify_all(*exprs, lambda_result). res_ir = lambda_result._ir; for uid, value_ir in builtins.zip(uids, irs):; if _ctx == 'agg':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=False); elif _ctx == 'scan':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. This is :func:`.bind` with flipped argument order. Examples; --------. >>> hl.eval(hl.rbind(1, lambda x: x + 1)); 2. :func:`.rbind` also can take multiple arguments:. >>> hl.eval(hl.rbind(4.0, 2.0, lambda x, y: x / y)); 2.0. Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Expressions to bind.; f : function ( (args) -> :class:`.Expression`); Function of `exprs`. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """""". *args, f = ex",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:64237,Availability,fault,fault,64237,"7. >>> hl.eval(hl.pchisqtail(5, 1, lower_tail=True)); 0.9746526813225317. >>> hl.eval(hl.pchisqtail(5, 1, log_p=True)); -3.6750823266311876. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the CDF.; df : float or :class:`.Expression` of type :py:data:`.tfloat64`; Degrees of freedom.; ncp: float or :class:`.Expression` of type :py:data:`.tfloat64`; Noncentrality parameter, defaults to 0 if unspecified.; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; if ncp is None:; return _func(""pchisqtail"", tfloat64, x, df, lower_tail, log_p); else:; return _func(""pnchisqtail"", tfloat64, x, df, ncp, lower_tail, log_p). PGENCHISQ_RETURN_TYPE = tstruct(value=tfloat64, n_iterations=tint32, converged=tbool, fault=tint32). [docs]@typecheck(; x=expr_float64,; w=expr_array(expr_float64),; k=expr_array(expr_int32),; lam=expr_array(expr_float64),; mu=expr_float64,; sigma=expr_float64,; max_iterations=nullable(expr_int32),; min_accuracy=nullable(expr_float64),; ); def pgenchisq(x, w, k, lam, mu, sigma, *, max_iterations=None, min_accuracy=None) -> Float64Expression:; r""""""The cumulative probability function of a `generalized chi-squared distribution; <https://en.wikipedia.org/wiki/Generalized_chi-squared_distribution>`__. The generalized chi-squared distribution has many interpretations. We share here four; interpretations of the values of this distribution:. 1. A linear combination of normal variables and squares of normal variables. 2. A weighted sum of sums of squares of normally distributed values plus a normally distributed; value. 3. A weighted sum of chi-squared distributed values plus a normally distributed value. 4. A `""quadratic form"" <https://en.wik",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70446,Availability,error,error,70446," evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is eith",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70700,Availability,error,error,70700,"n` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71261,Availability,error,error,71261,"ndard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71296,Availability,fault,fault,71296,":obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=Fa",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71353,Availability,fault,fault,71353,"y:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=False)); 0.022750131948179212. >>> hl.eval(hl.pn",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71392,Availability,fault,fault,71392,"tions of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=False)); 0.022750131948179212. >>> hl.eval(hl.pnorm(2, log_p=True)); -0.023012909328963493. ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71508,Availability,error,error,71508,"min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=False)); 0.022750131948179212. >>> hl.eval(hl.pnorm(2, log_p=True)); -0.023012909328963493. Notes; -----; Returns the left-tail probability `p` = Prob(:math:`Z < x`) with :math:`Z`; a normal random variable. ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105023,Availability,down,downcode,105023,"k \}`, let :math:`p_i` be the probability that; a randomly chosen character is :math:`c_i`, e.g. the number of instances; of :math:`c_i` divided by :math:`n`. Then the base-2 Shannon entropy is; given by. .. math::. H = \sum_{i=1}^k p_i \log_2(p_i). Parameters; ----------; s : :class:`.StringExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""entropy"", tfloat64, s). @typecheck(x=expr_any, trunc=nullable(expr_int32)); def _showstr(x, trunc=None):; if trunc is None:; return _func(""showStr"", tstr, x); return _func(""showStr"", tstr, x, trunc). [docs]@typecheck(x=expr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of ty",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105173,Availability,down,downcode,105173,"; of :math:`c_i` divided by :math:`n`. Then the base-2 Shannon entropy is; given by. .. math::. H = \sum_{i=1}^k p_i \log_2(p_i). Parameters; ----------; s : :class:`.StringExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""entropy"", tfloat64, s). @typecheck(x=expr_any, trunc=nullable(expr_int32)); def _showstr(x, trunc=None):; if trunc is None:; return _func(""showStr"", tstr, x); return _func(""showStr"", tstr, x, trunc). [docs]@typecheck(x=expr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _f",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105229,Availability,down,downcode,105229,"py is; given by. .. math::. H = \sum_{i=1}^k p_i \log_2(p_i). Parameters; ----------; s : :class:`.StringExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""entropy"", tfloat64, s). @typecheck(x=expr_any, trunc=nullable(expr_int32)); def _showstr(x, trunc=None):; if trunc is None:; return _func(""showStr"", tstr, x); return _func(""showStr"", tstr, x, trunc). [docs]@typecheck(x=expr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""gqFromPL"", tint32, pl). [docs]@typecheck(n=expr_int32); def tr",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105309,Availability,down,downcode,105309,"----; s : :class:`.StringExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""entropy"", tfloat64, s). @typecheck(x=expr_any, trunc=nullable(expr_int32)); def _showstr(x, trunc=None):; if trunc is None:; return _func(""showStr"", tstr, x); return _func(""showStr"", tstr, x, trunc). [docs]@typecheck(x=expr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""gqFromPL"", tint32, pl). [docs]@typecheck(n=expr_int32); def triangle(n) -> Int32Expression:; """"""Returns the triangle number of `n`. Examples; ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105389,Availability,down,downcode,105389,"type :py:data:`.tfloat64`; """"""; return _func(""entropy"", tfloat64, s). @typecheck(x=expr_any, trunc=nullable(expr_int32)); def _showstr(x, trunc=None):; if trunc is None:; return _func(""showStr"", tstr, x); return _func(""showStr"", tstr, x, trunc). [docs]@typecheck(x=expr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""gqFromPL"", tint32, pl). [docs]@typecheck(n=expr_int32); def triangle(n) -> Int32Expression:; """"""Returns the triangle number of `n`. Examples; --------. >>> hl.eval(hl.triangle(3)); 6. Notes; -----; The calculation is ``n *",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105664,Availability,down,downcoded,105664,"xpr_any); def str(x) -> StringExpression:; """"""Returns the string representation of `x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""gqFromPL"", tint32, pl). [docs]@typecheck(n=expr_int32); def triangle(n) -> Int32Expression:; """"""Returns the triangle number of `n`. Examples; --------. >>> hl.eval(hl.triangle(3)); 6. Notes; -----; The calculation is ``n * (n + 1) / 2``. Parameters; ----------; n : :class:`.Expression` of type :py:data:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""triangle"", tint32, n). [docs]@typecheck(f=func_spec(1, expr_bool), collection=expr_oneof",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:105751,Availability,down,downcode,105751,"x`. Examples; --------. >>> hl.eval(hl.str(hl.struct(a=5, b=7))); '{""a"":5,""b"":7}'. Parameters; ----------; x. Returns; -------; :class:`.StringExpression`; """"""; if x.dtype == tstr:; return x; else:; return _func(""str"", tstr, x). [docs]@typecheck(c=expr_call, i=expr_int32); def downcode(c, i) -> CallExpression:; """"""Create a new call by setting all alleles other than i to ref. Examples; --------; Preserve the third allele and downcode all other alleles to reference. >>> hl.eval(hl.downcode(hl.call(1, 2), 2)); Call(alleles=[0, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(2, 2), 2)); Call(alleles=[1, 1], phased=False). >>> hl.eval(hl.downcode(hl.call(0, 1), 2)); Call(alleles=[0, 0], phased=False). Parameters; ----------; c : :class:`.CallExpression`; A call.; i : :class:`.Expression` of type :py:data:`.tint32`; The index of the allele that will be sent to the alternate allele. All; other alleles will be downcoded to reference. Returns; -------; :class:`.CallExpression`; """"""; return _func(""downcode"", tcall, c, i). @typecheck(pl=expr_array(expr_int32)); def gq_from_pl(pl) -> Int32Expression:; """"""Compute genotype quality from Phred-scaled probability likelihoods. Examples; --------. >>> hl.eval(hl.gq_from_pl([0, 69, 1035])); 69. Parameters; ----------; pl : :class:`.Expression` of type :class:`.tarray` of :obj:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""gqFromPL"", tint32, pl). [docs]@typecheck(n=expr_int32); def triangle(n) -> Int32Expression:; """"""Returns the triangle number of `n`. Examples; --------. >>> hl.eval(hl.triangle(3)); 6. Notes; -----; The calculation is ``n * (n + 1) / 2``. Parameters; ----------; n : :class:`.Expression` of type :py:data:`.tint32`. Returns; -------; :class:`.Expression` of type :py:data:`.tint32`; """"""; return _func(""triangle"", tint32, n). [docs]@typecheck(f=func_spec(1, expr_bool), collection=expr_oneof(expr_set(), expr_array())); def filter(f: Callable, collection):; """"""Returns a new",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:145843,Availability,down,downstream,145843,"s.dtype.element_type); stream_req = stream_f(ctx_var); make_prod_ir = stream_req._ir; if isinstance(make_prod_ir.typ, hl.tarray):; make_prod_ir = ir.ToStream(make_prod_ir); t = stream_req.dtype.element_type. key_typ = hl.tstruct(**{k: t[k] for k in key}); vals_typ = hl.tarray(t). key_uid = Env.get_uid(); vals_uid = Env.get_uid(). key_var = construct_variable(key_uid, key_typ); vals_var = construct_variable(vals_uid, vals_typ). join_ir = join_f(key_var, vals_var); zj = ir.ToArray(ir.StreamZipJoinProducers(contexts._ir, ctx_uid, make_prod_ir, key, key_uid, vals_uid, join_ir._ir)); indices, aggs = unify_all(contexts, stream_req, join_ir); return construct_expr(zj, zj.typ, indices, aggs). [docs]@typecheck(arrays=expr_oneof(expr_stream(expr_any), expr_array(expr_any)), key=sequenceof(builtins.str)); def keyed_intersection(*arrays, key):; """"""Compute the intersection of sorted arrays on a given key. Requires sorted arrays with distinct keys. Warning; -------; Experimental. Does not support downstream randomness. Parameters; ----------; arrays; key. Returns; -------; :class:`.ArrayExpression`; """"""; return _union_intersection_base(; 'keyed_intersection',; arrays,; key,; lambda key_var, vals_var: hl.tuple((key_var, vals_var)),; lambda res: res.filter(lambda x: hl.fold(lambda acc, elt: acc & hl.is_defined(elt), True, x[1])).map(; lambda x: x[1].first(); ),; ). [docs]@typecheck(arrays=expr_oneof(expr_stream(expr_any), expr_array(expr_any)), key=sequenceof(builtins.str)); def keyed_union(*arrays, key):; """"""Compute the distinct union of sorted arrays on a given key. Requires sorted arrays with distinct keys. Warning; -------; Experimental. Does not support downstream randomness. Parameters; ----------; exprs; key. Returns; -------; :class:`.ArrayExpression`; """"""; return _union_intersection_base(; 'keyed_union',; arrays,; key,; lambda keys_var, vals_var: hl.fold(; lambda acc, elt: hl.coalesce(acc, elt), hl.missing(vals_var.dtype.element_type), vals_var; ),; lambda res: res,; ). [d",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:146516,Availability,down,downstream,146516,"typ, indices, aggs). [docs]@typecheck(arrays=expr_oneof(expr_stream(expr_any), expr_array(expr_any)), key=sequenceof(builtins.str)); def keyed_intersection(*arrays, key):; """"""Compute the intersection of sorted arrays on a given key. Requires sorted arrays with distinct keys. Warning; -------; Experimental. Does not support downstream randomness. Parameters; ----------; arrays; key. Returns; -------; :class:`.ArrayExpression`; """"""; return _union_intersection_base(; 'keyed_intersection',; arrays,; key,; lambda key_var, vals_var: hl.tuple((key_var, vals_var)),; lambda res: res.filter(lambda x: hl.fold(lambda acc, elt: acc & hl.is_defined(elt), True, x[1])).map(; lambda x: x[1].first(); ),; ). [docs]@typecheck(arrays=expr_oneof(expr_stream(expr_any), expr_array(expr_any)), key=sequenceof(builtins.str)); def keyed_union(*arrays, key):; """"""Compute the distinct union of sorted arrays on a given key. Requires sorted arrays with distinct keys. Warning; -------; Experimental. Does not support downstream randomness. Parameters; ----------; exprs; key. Returns; -------; :class:`.ArrayExpression`; """"""; return _union_intersection_base(; 'keyed_union',; arrays,; key,; lambda keys_var, vals_var: hl.fold(; lambda acc, elt: hl.coalesce(acc, elt), hl.missing(vals_var.dtype.element_type), vals_var; ),; lambda res: res,; ). [docs]@typecheck(collection=expr_oneof(expr_array(), expr_set()), delimiter=expr_str); def delimit(collection, delimiter=',') -> StringExpression:; """"""Joins elements of `collection` into single string delimited by `delimiter`. Examples; --------. >>> a = ['Bob', 'Charlie', 'Alice', 'Bob', 'Bob']. >>> hl.eval(hl.delimit(a)); 'Bob,Charlie,Alice,Bob,Bob'. Notes; -----; If the element type of `collection` is not :py:data:`.tstr`, then the; :func:`str` function will be called on each element before joining with; the delimiter. Parameters; ----------; collection : :class:`.ArrayExpression` or :class:`.SetExpression`; Collection.; delimiter : str or :class:`.StringExpressio",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:161407,Availability,avail,available,161407,"he locus ``'1:45323'``:. >>> hl.eval(hl.get_sequence('1', 45323, reference_genome='GRCh37')) # doctest: +SKIP; ""T"". Notes; -----; This function requires `reference genome` has an attached; reference sequence. Use :meth:`.ReferenceGenome.add_sequence` to; load and attach a reference sequence to a reference genome. Returns ``None`` if `contig` and `position` are not valid coordinates in; `reference_genome`. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; Locus contig.; position : :class:`.Expression` of type :py:data:`.tint32`; Locus position.; before : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include before the locus of interest. Truncates at; contig boundary.; after : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include after the locus of interest. Truncates at; contig boundary.; reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to use. Must have a reference sequence available. Returns; -------; :class:`.StringExpression`; """""". if not reference_genome.has_sequence():; raise TypeError(; ""Reference genome '{}' does not have a sequence loaded. Use 'add_sequence' to load the sequence from a FASTA file."".format(; reference_genome.name; ); ). return _func(""getReferenceSequence"", tstr, contig, position, before, after, type_args=(tlocus(reference_genome),)). [docs]@typecheck(contig=expr_str, reference_genome=reference_genome_type); def is_valid_contig(contig, reference_genome='default') -> BooleanExpression:; """"""Returns ``True`` if `contig` is a valid contig name in `reference_genome`. Examples; --------. >>> hl.eval(hl.is_valid_contig('1', reference_genome='GRCh37')); True. >>> hl.eval(hl.is_valid_contig('chr1', reference_genome='GRCh37')); False. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; reference_genome : :class:`str` or :class:`.ReferenceGenome`. Returns; -------; :class:`.BooleanExpression`; """"""; return",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:164179,Availability,error,error,164179,"tion, reference_genome='default') -> BooleanExpression:; """"""Returns ``True`` if `contig` and `position` is a valid site in `reference_genome`. Examples; --------. >>> hl.eval(hl.is_valid_locus('1', 324254, 'GRCh37')); True. >>> hl.eval(hl.is_valid_locus('chr1', 324254, 'GRCh37')); False. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; position : :class:`.Expression` of type :py:data:`.tint`; reference_genome : :class:`str` or :class:`.ReferenceGenome`. Returns; -------; :class:`.BooleanExpression`; """"""; return _func(""isValidLocus"", tbool, contig, position, type_args=(tlocus(reference_genome),)). [docs]@typecheck(locus=expr_locus(), is_female=expr_bool, father=expr_call, mother=expr_call, child=expr_call); def mendel_error_code(locus, is_female, father, mother, child):; r""""""Compute a Mendelian violation code for genotypes. >>> father = hl.call(0, 0); >>> mother = hl.call(1, 1); >>> child1 = hl.call(0, 1) # consistent; >>> child2 = hl.call(0, 0) # Mendel error; >>> locus = hl.locus('2', 2000000). >>> hl.eval(hl.mendel_error_code(locus, True, father, mother, child1)); None. >>> hl.eval(hl.mendel_error_code(locus, True, father, mother, child2)); 7. Note; ----; Ignores call phasing, and assumes diploid and biallelic. Haploid calls for; hemiploid samples on sex chromosomes also are acceptable input. Notes; -----; In the table below, the copy state of a locus with respect to a trio is; defined as follows, where PAR is the `pseudoautosomal region; <https://en.wikipedia.org/wiki/Pseudoautosomal_region>`__ (PAR) of X and Y; defined by the reference genome and the autosome is defined by; :meth:`.LocusExpression.in_autosome`:. - Auto -- in autosome or in PAR, or in non-PAR of X and female child; - HemiX -- in non-PAR of X and male child; - HemiY -- in non-PAR of Y and male child. `Any` refers to the set \{ HomRef, Het, HomVar, NoCall \} and `~`; denotes complement in this set. +------+---------+---------+--------+------------+---------------+; | ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:172390,Availability,toler,tolerance,172390,"enome`.; """""". if not 0.0 <= min_match <= 1.0:; raise TypeError(""'liftover' requires 'min_match' is in the range [0, 1]. Got {}"".format(min_match)). if isinstance(x.dtype, tlocus):; rg = x.dtype.reference_genome; method_name = ""liftoverLocus""; rtype = tstruct(result=tlocus(dest_reference_genome), is_negative_strand=tbool); else:; rg = x.dtype.point_type.reference_genome; method_name = ""liftoverLocusInterval""; rtype = tstruct(result=tinterval(tlocus(dest_reference_genome)), is_negative_strand=tbool). if not rg.has_liftover(dest_reference_genome.name):; raise TypeError(; """"""Reference genome '{}' does not have liftover to '{}'.; Use 'add_liftover' to load a liftover chain file."""""".format(rg.name, dest_reference_genome.name); ). expr = _func(method_name, rtype, x, to_expr(min_match, tfloat64)); if not include_strand:; expr = expr.result; return expr. [docs]@typecheck(; f=func_spec(1, expr_float64),; min=expr_float64,; max=expr_float64,; max_iter=builtins.int,; epsilon=builtins.float,; tolerance=builtins.float,; ); def uniroot(f: Callable, min, max, *, max_iter=1000, epsilon=2.2204460492503131e-16, tolerance=1.220703e-4):; """"""Finds a root of the function `f` within the interval `[min, max]`. Examples; --------. >>> hl.eval(hl.uniroot(lambda x: x - 1, -5, 5)); 1.0. Notes; -----; `f(min)` and `f(max)` must not have the same sign. If no root can be found, the result of this call will be `NA` (missing). :func:`.uniroot` returns an estimate for a root with accuracy; `4 * epsilon * abs(x) + tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expression`.; min : :class:`.Float64Expression`; max : :class:`.Float64Expression`; max_iter : `int`; The maximum number of iterations before giving up.; epsilon : `float`; The scaling factor in the accuracy of the root found.; tolerance : `float`; The constant factor in approximate accuracy of the root found. Returns; -------; :class:`.Float64Express",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:172505,Availability,toler,tolerance,172505," range [0, 1]. Got {}"".format(min_match)). if isinstance(x.dtype, tlocus):; rg = x.dtype.reference_genome; method_name = ""liftoverLocus""; rtype = tstruct(result=tlocus(dest_reference_genome), is_negative_strand=tbool); else:; rg = x.dtype.point_type.reference_genome; method_name = ""liftoverLocusInterval""; rtype = tstruct(result=tinterval(tlocus(dest_reference_genome)), is_negative_strand=tbool). if not rg.has_liftover(dest_reference_genome.name):; raise TypeError(; """"""Reference genome '{}' does not have liftover to '{}'.; Use 'add_liftover' to load a liftover chain file."""""".format(rg.name, dest_reference_genome.name); ). expr = _func(method_name, rtype, x, to_expr(min_match, tfloat64)); if not include_strand:; expr = expr.result; return expr. [docs]@typecheck(; f=func_spec(1, expr_float64),; min=expr_float64,; max=expr_float64,; max_iter=builtins.int,; epsilon=builtins.float,; tolerance=builtins.float,; ); def uniroot(f: Callable, min, max, *, max_iter=1000, epsilon=2.2204460492503131e-16, tolerance=1.220703e-4):; """"""Finds a root of the function `f` within the interval `[min, max]`. Examples; --------. >>> hl.eval(hl.uniroot(lambda x: x - 1, -5, 5)); 1.0. Notes; -----; `f(min)` and `f(max)` must not have the same sign. If no root can be found, the result of this call will be `NA` (missing). :func:`.uniroot` returns an estimate for a root with accuracy; `4 * epsilon * abs(x) + tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expression`.; min : :class:`.Float64Expression`; max : :class:`.Float64Expression`; max_iter : `int`; The maximum number of iterations before giving up.; epsilon : `float`; The scaling factor in the accuracy of the root found.; tolerance : `float`; The constant factor in approximate accuracy of the root found. Returns; -------; :class:`.Float64Expression`; The root of the function `f`.; """""". # Based on:; # https://github.com/wch/r-source/blob/e5b21d0397",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:172899,Availability,toler,tolerance,172899,"ome)), is_negative_strand=tbool). if not rg.has_liftover(dest_reference_genome.name):; raise TypeError(; """"""Reference genome '{}' does not have liftover to '{}'.; Use 'add_liftover' to load a liftover chain file."""""".format(rg.name, dest_reference_genome.name); ). expr = _func(method_name, rtype, x, to_expr(min_match, tfloat64)); if not include_strand:; expr = expr.result; return expr. [docs]@typecheck(; f=func_spec(1, expr_float64),; min=expr_float64,; max=expr_float64,; max_iter=builtins.int,; epsilon=builtins.float,; tolerance=builtins.float,; ); def uniroot(f: Callable, min, max, *, max_iter=1000, epsilon=2.2204460492503131e-16, tolerance=1.220703e-4):; """"""Finds a root of the function `f` within the interval `[min, max]`. Examples; --------. >>> hl.eval(hl.uniroot(lambda x: x - 1, -5, 5)); 1.0. Notes; -----; `f(min)` and `f(max)` must not have the same sign. If no root can be found, the result of this call will be `NA` (missing). :func:`.uniroot` returns an estimate for a root with accuracy; `4 * epsilon * abs(x) + tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expression`.; min : :class:`.Float64Expression`; max : :class:`.Float64Expression`; max_iter : `int`; The maximum number of iterations before giving up.; epsilon : `float`; The scaling factor in the accuracy of the root found.; tolerance : `float`; The constant factor in approximate accuracy of the root found. Returns; -------; :class:`.Float64Expression`; The root of the function `f`.; """""". # Based on:; # https://github.com/wch/r-source/blob/e5b21d0397c607883ff25cca379687b86933d730/src/library/stats/src/zeroin.c. def error_if_missing(x):; res = f(x); return case().when(is_defined(res), res).or_error(format(""'uniroot': value of f(x) is missing for x = %.1e"", x)). wrapped_f = hl.experimental.define_function(error_if_missing, 'float'). def uniroot(recur, a, b, c, fa, fb, fc, prev, iterations_remaining):; tol = 2 ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:173271,Availability,toler,tolerance,173271,"_float64,; max=expr_float64,; max_iter=builtins.int,; epsilon=builtins.float,; tolerance=builtins.float,; ); def uniroot(f: Callable, min, max, *, max_iter=1000, epsilon=2.2204460492503131e-16, tolerance=1.220703e-4):; """"""Finds a root of the function `f` within the interval `[min, max]`. Examples; --------. >>> hl.eval(hl.uniroot(lambda x: x - 1, -5, 5)); 1.0. Notes; -----; `f(min)` and `f(max)` must not have the same sign. If no root can be found, the result of this call will be `NA` (missing). :func:`.uniroot` returns an estimate for a root with accuracy; `4 * epsilon * abs(x) + tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expression`.; min : :class:`.Float64Expression`; max : :class:`.Float64Expression`; max_iter : `int`; The maximum number of iterations before giving up.; epsilon : `float`; The scaling factor in the accuracy of the root found.; tolerance : `float`; The constant factor in approximate accuracy of the root found. Returns; -------; :class:`.Float64Expression`; The root of the function `f`.; """""". # Based on:; # https://github.com/wch/r-source/blob/e5b21d0397c607883ff25cca379687b86933d730/src/library/stats/src/zeroin.c. def error_if_missing(x):; res = f(x); return case().when(is_defined(res), res).or_error(format(""'uniroot': value of f(x) is missing for x = %.1e"", x)). wrapped_f = hl.experimental.define_function(error_if_missing, 'float'). def uniroot(recur, a, b, c, fa, fb, fc, prev, iterations_remaining):; tol = 2 * epsilon * abs(b) + tolerance / 2; cb = c - b; t1 = fb / fc; t2 = fb / fa; q1 = fa / fc # = t1 / t2; pq = if_else(; a == c,; (cb * t1) / (t1 - 1.0), # linear; -t2 * (cb * q1 * (q1 - t1) - (b - a) * (t1 - 1.0)) / ((q1 - 1.0) * (t1 - 1.0) * (t2 - 1.0)),; ) # quadratic. interpolated = if_else(; (sign(pq) == sign(cb)); & (0.75 * abs(cb) > abs(pq) + tol / 2) # b + pq within [b, c]; & (abs(pq) < abs(prev / 2)), # pq not too large; pq,; cb / 2,; ). ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:173886,Availability,toler,tolerance,173886," tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expression`.; min : :class:`.Float64Expression`; max : :class:`.Float64Expression`; max_iter : `int`; The maximum number of iterations before giving up.; epsilon : `float`; The scaling factor in the accuracy of the root found.; tolerance : `float`; The constant factor in approximate accuracy of the root found. Returns; -------; :class:`.Float64Expression`; The root of the function `f`.; """""". # Based on:; # https://github.com/wch/r-source/blob/e5b21d0397c607883ff25cca379687b86933d730/src/library/stats/src/zeroin.c. def error_if_missing(x):; res = f(x); return case().when(is_defined(res), res).or_error(format(""'uniroot': value of f(x) is missing for x = %.1e"", x)). wrapped_f = hl.experimental.define_function(error_if_missing, 'float'). def uniroot(recur, a, b, c, fa, fb, fc, prev, iterations_remaining):; tol = 2 * epsilon * abs(b) + tolerance / 2; cb = c - b; t1 = fb / fc; t2 = fb / fa; q1 = fa / fc # = t1 / t2; pq = if_else(; a == c,; (cb * t1) / (t1 - 1.0), # linear; -t2 * (cb * q1 * (q1 - t1) - (b - a) * (t1 - 1.0)) / ((q1 - 1.0) * (t1 - 1.0) * (t2 - 1.0)),; ) # quadratic. interpolated = if_else(; (sign(pq) == sign(cb)); & (0.75 * abs(cb) > abs(pq) + tol / 2) # b + pq within [b, c]; & (abs(pq) < abs(prev / 2)), # pq not too large; pq,; cb / 2,; ). new_step = if_else((abs(prev) >= tol) & (abs(fa) > abs(fb)), interpolated, cb / 2) # try interpolation. new_b = b + if_else(new_step < 0, hl.min(new_step, -tol), hl.max(new_step, tol)); new_fb = wrapped_f(new_b). return if_else(; iterations_remaining == 0,; missing('float'),; if_else(; abs(fc) < abs(fb),; recur(b, c, b, fb, fc, fb, prev, iterations_remaining),; if_else(; (abs(cb / 2) <= tol) | (fb == 0),; b, # acceptable approximation found; if_else(; sign(new_fb) == sign(fc), # use c = b for next iteration if signs match; recur(b, new_b, b, fb, new_fb, fb, new_step, iterations_re",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:176739,Availability,toler,tolerance,176739,"%.3e', 0.09345332)); '9.345e-02'. >>> hl.eval(hl.format('%.4f', hl.missing(hl.tfloat64))); 'null'. >>> hl.eval(hl.format('%s %s %s', 'hello', hl.tuple([3, hl.locus('1', 2453)]), True)); 'hello (3, 1:2453) true'. Notes; -----; See the `Java documentation <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__; for valid format specifiers and arguments. Missing values are printed as ``'null'`` except when using the; format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:176827,Availability,toler,tolerance,176827,"%.3e', 0.09345332)); '9.345e-02'. >>> hl.eval(hl.format('%.4f', hl.missing(hl.tfloat64))); 'null'. >>> hl.eval(hl.format('%s %s %s', 'hello', hl.tuple([3, hl.locus('1', 2453)]), True)); 'hello (3, 1:2453) true'. Notes; -----; See the `Java documentation <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__; for valid format specifiers and arguments. Missing values are printed as ``'null'`` except when using the; format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:177045,Availability,toler,tolerance,177045," <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__; for valid format specifiers and arguments. Missing values are printed as ``'null'`` except when using the; format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int32(0). indices, aggregations = unify_all(x, y); return hl.bind(; lambda x, y: (; hl.case(); .when(y >= word_size, hl.sign(x) if op == '>>' else zero); .when(y >= 0, construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations)); .or_",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:177175,Availability,toler,tolerance,177175,"mat specifiers and arguments. Missing values are printed as ``'null'`` except when using the; format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int32(0). indices, aggregations = unify_all(x, y); return hl.bind(; lambda x, y: (; hl.case(); .when(y >= word_size, hl.sign(x) if op == '>>' else zero); .when(y >= 0, construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations)); .or_error('cannot shift by a negative value: ' + hl.str(x) + f"" {op} "" + hl.str(y)); ),; x,; y,; ). def _bit_op(x, y, ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:177289,Availability,toler,tolerance,177289," format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int32(0). indices, aggregations = unify_all(x, y); return hl.bind(; lambda x, y: (; hl.case(); .when(y >= word_size, hl.sign(x) if op == '>>' else zero); .when(y >= 0, construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations)); .or_error('cannot shift by a negative value: ' + hl.str(x) + f"" {op} "" + hl.str(y)); ),; x,; y,; ). def _bit_op(x, y, op):; if x.dtype == hl.tint32 and y.dtype == hl.tint32:; t = hl.tint32; else:; t = hl.tint64;",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:177342,Availability,toler,tolerance,177342,"---------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int32(0). indices, aggregations = unify_all(x, y); return hl.bind(; lambda x, y: (; hl.case(); .when(y >= word_size, hl.sign(x) if op == '>>' else zero); .when(y >= 0, construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations)); .or_error('cannot shift by a negative value: ' + hl.str(x) + f"" {op} "" + hl.str(y)); ),; x,; y,; ). def _bit_op(x, y, op):; if x.dtype == hl.tint32 and y.dtype == hl.tint32:; t = hl.tint32; else:; t = hl.tint64; coercer = coercer_from_dtype(t); x = coercer.coerce(x); y = coercer.coerce(",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:177613,Availability,toler,tolerance,177613,"pression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; -------; :class:`.BooleanExpression`; """""". return _func(""approxEqual"", hl.tbool, x, y, tolerance, absolute, nan_same). def _shift_op(x, y, op):; assert op in ('<<', '>>', '>>>'); t = x.dtype; if t == hl.tint64:; word_size = 64; zero = hl.int64(0); else:; word_size = 32; zero = hl.int32(0). indices, aggregations = unify_all(x, y); return hl.bind(; lambda x, y: (; hl.case(); .when(y >= word_size, hl.sign(x) if op == '>>' else zero); .when(y >= 0, construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations)); .or_error('cannot shift by a negative value: ' + hl.str(x) + f"" {op} "" + hl.str(y)); ),; x,; y,; ). def _bit_op(x, y, op):; if x.dtype == hl.tint32 and y.dtype == hl.tint32:; t = hl.tint32; else:; t = hl.tint64; coercer = coercer_from_dtype(t); x = coercer.coerce(x); y = coercer.coerce(y). indices, aggregations = unify_all(x, y); return construct_expr(ir.ApplyBinaryPrimOp(op, x._ir, y._ir), t, indices, aggregations). [docs]@typecheck(x=expr_oneof(expr_int32, expr_int64), y=expr_oneof(expr_int32, expr_int64)); def bit_and(x, y):; """"""Bitwise and `x` and `y`. E",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:184844,Availability,toler,tolerance,184844,"lement in `array` not smaller; than `elem`. This is a value between 0 and the length of `array`, inclusive; (if all elements in `array` are smaller than `elem`, the returned value is; the length of `array` or the index of the first missing value, if one; exists). If either `elem` or `array` is missing, the result is missing. Examples; --------. >>> a = hl.array([0, 2, 4, 8]). >>> hl.eval(hl.binary_search(a, -1)); 0. >>> hl.eval(hl.binary_search(a, 1)); 1. >>> hl.eval(hl.binary_search(a, 10)); 4. """"""; c = coercer_from_dtype(array.dtype.element_type); if not c.can_coerce(elem.dtype):; raise TypeError(; f""'binary_search': cannot search an array of type {array.dtype} for a value of type {elem.dtype}""; ); elem = c.coerce(elem); return hl.switch(elem).when_missing(hl.missing(hl.tint32)).default(_lower_bound(array, elem)). @typecheck(s=expr_str); def _escape_string(s):; return _func(""escapeString"", hl.tstr, s). @typecheck(left=expr_any, right=expr_any, tolerance=expr_float64, absolute=expr_bool); def _values_similar(left, right, tolerance=1e-6, absolute=False):; assert left.dtype == right.dtype; return (is_missing(left) & is_missing(right)) | (; (is_defined(left) & is_defined(right)) & _func(""valuesSimilar"", hl.tbool, left, right, tolerance, absolute); ). @typecheck(coords=expr_array(expr_array(expr_float64)), radius=expr_float64); def _locus_windows_per_contig(coords, radius):; rt = hl.ttuple(hl.tarray(hl.tint32), hl.tarray(hl.tint32)); return _func(""locus_windows_per_contig"", rt, coords, radius). [docs]@typecheck(a=expr_array(), seed=nullable(builtins.int)); def shuffle(a, seed: Optional[builtins.int] = None) -> ArrayExpression:; """"""Randomly permute an array. Example; -------. >>> hl.reset_global_randomness(); >>> hl.eval(hl.shuffle(hl.range(5))); [4, 0, 2, 1, 3]. Parameters; ----------; a : :class:`.ArrayExpression`; Array to permute.; seed : :obj:`int`, optional; Random seed. Returns; -------; :class:`.ArrayExpression`; """"""; return sorted(a, key=lambda _: hl.rand_unif(0",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:184922,Availability,toler,tolerance,184922,"lement in `array` not smaller; than `elem`. This is a value between 0 and the length of `array`, inclusive; (if all elements in `array` are smaller than `elem`, the returned value is; the length of `array` or the index of the first missing value, if one; exists). If either `elem` or `array` is missing, the result is missing. Examples; --------. >>> a = hl.array([0, 2, 4, 8]). >>> hl.eval(hl.binary_search(a, -1)); 0. >>> hl.eval(hl.binary_search(a, 1)); 1. >>> hl.eval(hl.binary_search(a, 10)); 4. """"""; c = coercer_from_dtype(array.dtype.element_type); if not c.can_coerce(elem.dtype):; raise TypeError(; f""'binary_search': cannot search an array of type {array.dtype} for a value of type {elem.dtype}""; ); elem = c.coerce(elem); return hl.switch(elem).when_missing(hl.missing(hl.tint32)).default(_lower_bound(array, elem)). @typecheck(s=expr_str); def _escape_string(s):; return _func(""escapeString"", hl.tstr, s). @typecheck(left=expr_any, right=expr_any, tolerance=expr_float64, absolute=expr_bool); def _values_similar(left, right, tolerance=1e-6, absolute=False):; assert left.dtype == right.dtype; return (is_missing(left) & is_missing(right)) | (; (is_defined(left) & is_defined(right)) & _func(""valuesSimilar"", hl.tbool, left, right, tolerance, absolute); ). @typecheck(coords=expr_array(expr_array(expr_float64)), radius=expr_float64); def _locus_windows_per_contig(coords, radius):; rt = hl.ttuple(hl.tarray(hl.tint32), hl.tarray(hl.tint32)); return _func(""locus_windows_per_contig"", rt, coords, radius). [docs]@typecheck(a=expr_array(), seed=nullable(builtins.int)); def shuffle(a, seed: Optional[builtins.int] = None) -> ArrayExpression:; """"""Randomly permute an array. Example; -------. >>> hl.reset_global_randomness(); >>> hl.eval(hl.shuffle(hl.range(5))); [4, 0, 2, 1, 3]. Parameters; ----------; a : :class:`.ArrayExpression`; Array to permute.; seed : :obj:`int`, optional; Random seed. Returns; -------; :class:`.ArrayExpression`; """"""; return sorted(a, key=lambda _: hl.rand_unif(0",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:185128,Availability,toler,tolerance,185128," if one; exists). If either `elem` or `array` is missing, the result is missing. Examples; --------. >>> a = hl.array([0, 2, 4, 8]). >>> hl.eval(hl.binary_search(a, -1)); 0. >>> hl.eval(hl.binary_search(a, 1)); 1. >>> hl.eval(hl.binary_search(a, 10)); 4. """"""; c = coercer_from_dtype(array.dtype.element_type); if not c.can_coerce(elem.dtype):; raise TypeError(; f""'binary_search': cannot search an array of type {array.dtype} for a value of type {elem.dtype}""; ); elem = c.coerce(elem); return hl.switch(elem).when_missing(hl.missing(hl.tint32)).default(_lower_bound(array, elem)). @typecheck(s=expr_str); def _escape_string(s):; return _func(""escapeString"", hl.tstr, s). @typecheck(left=expr_any, right=expr_any, tolerance=expr_float64, absolute=expr_bool); def _values_similar(left, right, tolerance=1e-6, absolute=False):; assert left.dtype == right.dtype; return (is_missing(left) & is_missing(right)) | (; (is_defined(left) & is_defined(right)) & _func(""valuesSimilar"", hl.tbool, left, right, tolerance, absolute); ). @typecheck(coords=expr_array(expr_array(expr_float64)), radius=expr_float64); def _locus_windows_per_contig(coords, radius):; rt = hl.ttuple(hl.tarray(hl.tint32), hl.tarray(hl.tint32)); return _func(""locus_windows_per_contig"", rt, coords, radius). [docs]@typecheck(a=expr_array(), seed=nullable(builtins.int)); def shuffle(a, seed: Optional[builtins.int] = None) -> ArrayExpression:; """"""Randomly permute an array. Example; -------. >>> hl.reset_global_randomness(); >>> hl.eval(hl.shuffle(hl.range(5))); [4, 0, 2, 1, 3]. Parameters; ----------; a : :class:`.ArrayExpression`; Array to permute.; seed : :obj:`int`, optional; Random seed. Returns; -------; :class:`.ArrayExpression`; """"""; return sorted(a, key=lambda _: hl.rand_unif(0.0, 1.0)). [docs]@typecheck(path=builtins.str, point_or_interval=expr_any); def query_table(path, point_or_interval):; """"""Query records from a table corresponding to a given point or range of keys. Notes; -----; This function does not dispatch t",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:157,Deployability,Install,Installation,157,"﻿. Hail | ; hail.expr.functions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.functions. Source code for hail.expr.functions; import builtins; import functools; import itertools; import operator; from typing import Any, Callable, Iterable, Optional, TypeVar, Union. import numpy as np; import pandas as pd; from deprecated import deprecated. import hail; import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; ArrayNumericExpression,; BooleanExpression,; CallExpression,; DictExpression,; Expression,; ExpressionException,; Float32Expression,; Float64Expression,; Int32Expression,; Int64Expression,; IntervalExpression,; LocusExpression,; NumericExpression,; SetExpression,; StreamExpression,; StringExpression,; StructExpression,; TupleExpression,; apply_expr,; cast_expr,; coercer_from_dtype,; construct_expr,; construct_variable,; expr_any,; expr_array,; expr_bool,; expr_call,; expr_dict,; expr_float32,; expr_float64,; expr_int32,; expr_int64,; expr_interval,; expr_locus,; expr_ndarray,; expr_numeric,; expr_oneof,; expr_set,; expr_str,; expr_stream,; expr_struct,; expr_tuple,; impute_type,; to_expr,; unify_all,; unify_exprs,; unify_types_limited,; ); from hail.expr.types import (; HailType,; hail_type,; is_float32,; is_float64,; is_int32,; is_int64,; is_numeric,; is_primitive,; tarray,; tbool,; tcall,; tdict,; tfloat32,; tfloat64,; tint32,; tint64,; tinterval,; tlocus,; tndarray,; trngstate,; tset,; tstr,; tstream,; tstruct,; ttuple,; ); from hail.genetics.allele_type import AlleleType; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typec",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:225,Deployability,Configurat,Configuration,225,"﻿. Hail | ; hail.expr.functions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.functions. Source code for hail.expr.functions; import builtins; import functools; import itertools; import operator; from typing import Any, Callable, Iterable, Optional, TypeVar, Union. import numpy as np; import pandas as pd; from deprecated import deprecated. import hail; import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; ArrayNumericExpression,; BooleanExpression,; CallExpression,; DictExpression,; Expression,; ExpressionException,; Float32Expression,; Float64Expression,; Int32Expression,; Int64Expression,; IntervalExpression,; LocusExpression,; NumericExpression,; SetExpression,; StreamExpression,; StringExpression,; StructExpression,; TupleExpression,; apply_expr,; cast_expr,; coercer_from_dtype,; construct_expr,; construct_variable,; expr_any,; expr_array,; expr_bool,; expr_call,; expr_dict,; expr_float32,; expr_float64,; expr_int32,; expr_int64,; expr_interval,; expr_locus,; expr_ndarray,; expr_numeric,; expr_oneof,; expr_set,; expr_str,; expr_stream,; expr_struct,; expr_tuple,; impute_type,; to_expr,; unify_all,; unify_exprs,; unify_types_limited,; ); from hail.expr.types import (; HailType,; hail_type,; is_float32,; is_float64,; is_int32,; is_int64,; is_numeric,; is_primitive,; tarray,; tbool,; tcall,; tdict,; tfloat32,; tfloat64,; tint32,; tint64,; tinterval,; tlocus,; tndarray,; trngstate,; tset,; tstr,; tstream,; tstruct,; ttuple,; ); from hail.genetics.allele_type import AlleleType; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typec",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:62490,Deployability,release,release,62490,"ing two heads; out of ten flips:. >>> hl.eval(hl.binom_test(2, 10, 0.5, 'two-sided')); 0.10937499999999994. Test if a coin is biased towards tails after observing four heads out of ten; flips:. >>> hl.eval(hl.binom_test(4, 10, 0.5, 'less')); 0.3769531250000001. Test if a coin is biased towards heads after observing thirty-two heads out; of fifty flips:. >>> hl.eval(hl.binom_test(32, 50, 0.5, 'greater')); 0.03245432353613613. Parameters; ----------; x : int or :class:`.Expression` of type :py:data:`.tint32`; Number of successes.; n : int or :class:`.Expression` of type :py:data:`.tint32`; Number of trials.; p : float or :class:`.Expression` of type :py:data:`.tfloat64`; Probability of success, between 0 and 1.; alternative; : One of, ""two-sided"", ""greater"", ""less"", (deprecated: ""two.sided""). Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; p-value.; """""". if alternative == 'two.sided':; warning(; '""two.sided"" is a deprecated and will be removed in a future '; 'release, please use ""two-sided"" for the `alternative` parameter '; 'to hl.binom_test'; ); alternative = 'two-sided'. alt_enum = {""two-sided"": 0, ""less"": 1, ""greater"": 2}[alternative]; return _func(""binomTest"", tfloat64, x, n, p, to_expr(alt_enum)). [docs]@typecheck(x=expr_float64, df=expr_float64, ncp=nullable(expr_float64), lower_tail=expr_bool, log_p=expr_bool); def pchisqtail(x, df, ncp=None, lower_tail=False, log_p=False) -> Float64Expression:; """"""Returns the probability under the right-tail starting at x for a chi-squared; distribution with df degrees of freedom. Examples; --------. >>> hl.eval(hl.pchisqtail(5, 1)); 0.025347318677468304. >>> hl.eval(hl.pchisqtail(5, 1, ncp=2)); 0.20571085634347097. >>> hl.eval(hl.pchisqtail(5, 1, lower_tail=True)); 0.9746526813225317. >>> hl.eval(hl.pchisqtail(5, 1, log_p=True)); -3.6750823266311876. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the CDF.; df : float or :class:`.Expre",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:68494,Deployability,release,released,68494,"a=0).value); 1.0. >>> hl.eval(hl.pgenchisq(-80, w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.14284718767288906; >>> hl.eval(hl.pgenchisq(-20, w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.5950150356303258; >>> hl.eval(hl.pgenchisq(10 , w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.923219534175858; >>> hl.eval(hl.pgenchisq(40 , w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.9971746768781656. Notes; -----. We follow Wikipedia's notational conventions. Some texts refer to the weight vector (our `w`) as; :math:`\lambda` or `lb` and the non-centrality vector (our `lam`) as `nc`. We use the Davies' algorithm which was published as:. `Davies, Robert. ""The distribution of a linear combination of chi-squared random variables.""; Applied Statistics 29 323-333. 1980. <http://www.robertnz.net/pdf/lc_chisq.pdf>`__. Davies included Fortran source code in the original publication. Davies also released a `C; language port <http://www.robertnz.net/QF.htm>`__. Hail's implementation is a fairly direct port; of the C implementation to Scala. Davies provides 39 test cases with the source code. The Hail; tests include all 39 test cases as well as a few additional tests. Davies' website cautions:. The method works well in most situations if you want only modest accuracy, say 0.0001. But; problems may arise if the sum is dominated by one or two terms with a total of only one or; two degrees of freedom and x is small. For an accessible introduction the Generalized Chi-Squared Distribution, we strongly recommend; the introduction of this paper:. `Das, Abhranil; Geisler, Wilson (2020). ""A method to integrate and classify normal; distributions"". <https://arxiv.org/abs/2012.14331>`__. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expre",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:69202,Deployability,integrat,integrate,69202,"h was published as:. `Davies, Robert. ""The distribution of a linear combination of chi-squared random variables.""; Applied Statistics 29 323-333. 1980. <http://www.robertnz.net/pdf/lc_chisq.pdf>`__. Davies included Fortran source code in the original publication. Davies also released a `C; language port <http://www.robertnz.net/QF.htm>`__. Hail's implementation is a fairly direct port; of the C implementation to Scala. Davies provides 39 test cases with the source code. The Hail; tests include all 39 test cases as well as a few additional tests. Davies' website cautions:. The method works well in most situations if you want only modest accuracy, say 0.0001. But; problems may arise if the sum is dominated by one or two terms with a total of only one or; two degrees of freedom and x is small. For an accessible introduction the Generalized Chi-Squared Distribution, we strongly recommend; the introduction of this paper:. `Das, Abhranil; Geisler, Wilson (2020). ""A method to integrate and classify normal; distributions"". <https://arxiv.org/abs/2012.14331>`__. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of typ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70416,Deployability,integrat,integration,70416," evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is eith",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70886,Deployability,integrat,integration,70886,"Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_fl",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71038,Deployability,integrat,integration,71038,"d in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:188705,Deployability,update,updated,188705,"oerce_endpoint(point):; if point.dtype == key_typ[0]:; point = hl.struct(**{key_names[0]: point}); ts = point.dtype; if isinstance(ts, tstruct):; i = 0; while i < len(ts):; if i >= len(key_typ):; raise ValueError(; f""query_table: queried with {len(ts)} key field(s), but table only has {len(key_typ)} key field(s)""; ); if key_typ[i] != ts[i]:; raise ValueError(; f""query_table: key mismatch at key field {i} ({list(ts.keys())[i]!r}): query type is {ts[i]}, table key type is {key_typ[i]}""; ); i += 1. if i == 0:; raise ValueError(""query_table: cannot query with empty key""). point_size = builtins.len(point.dtype); return hl.tuple([; hl.struct(**{; key_names[i]: (point[i] if i < point_size else hl.missing(key_typ[i])); for i in builtins.range(builtins.len(key_typ)); }),; hl.int32(point_size),; ]); else:; raise ValueError(; f""query_table: key mismatch: cannot query a table with key ""; f""({', '.join(builtins.str(x) for x in key_typ.values())}) with query point type {point.dtype}""; ). if point_or_interval.dtype != key_typ[0] and isinstance(point_or_interval.dtype, hl.tinterval):; partition_interval = hl.interval(; start=coerce_endpoint(point_or_interval.start),; end=coerce_endpoint(point_or_interval.end),; includes_start=point_or_interval.includes_start,; includes_end=point_or_interval.includes_end,; ); else:; point = coerce_endpoint(point_or_interval); partition_interval = hl.interval(start=point, end=point, includes_start=True, includes_end=True); return construct_expr(; ir.ToArray(ir.ReadPartition(partition_interval._ir, reader=ir.PartitionNativeIntervalReader(path, row_typ))),; type=hl.tarray(row_typ),; indices=partition_interval._indices,; aggregations=partition_interval._aggregations,; ). @typecheck(msg=expr_str, result=expr_any); def _console_log(msg, result):; indices, aggregations = unify_all(msg, result); return construct_expr(ir.ConsoleLog(msg._ir, result._ir), result.dtype, indices, aggregations). © Copyright 2015-2024, Hail Team.; Last updated on Oct 04, 2024.; . ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:30544,Energy Efficiency,power,power,30544,"""""""; return _func(""dnorm"", tfloat64, x, mu, sigma, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, log_p=expr_bool); def dpois(x, lamb, log_p=False) -> Float64Expression:; """"""Compute the (log) probability density at x of a Poisson distribution with rate parameter `lamb`. Examples; --------. >>> hl.eval(hl.dpois(5, 3)); 0.10081881344492458. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; lamb : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability density.; """"""; return _func(""dpois"", tfloat64, x, lamb, log_p). [docs]@typecheck(x=oneof(expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def exp(x) -> Float64Expression:; """"""Computes `e` raised to the power `x`. Examples; --------. >>> hl.eval(hl.exp(2)); 7.38905609893065. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""exp"", tfloat64, x). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def fisher_exact_test(c1, c2, c3, c4) -> StructExpression:; """"""Calculates the p-value, odds ratio, and 95% confidence interval using; Fisher's exact test for a 2x2 table. Examples; --------. >>> hl.eval(hl.fisher_exact_test(10, 10, 10, 10)); Struct(p_value=1.0000000000000002, odds_ratio=1.0,; ci_95_lower=0.24385796914260355, ci_95_upper=4.100747675033819). >>> hl.eval(hl.fisher_exact_test(51, 43, 22, 92)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967,; ci_95_lower=2.5659373368",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:34323,Energy Efficiency,efficient,efficient,34323," 4.0. Parameters; ----------; x : :class:`.Float32Expression`,:class:`.Float64Expression` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Float32Expression`, :class:`.Float64Expression`, or :class:`.NDArrayNumericExpression`; """"""; return _func(""ceil"", x.dtype, x). [docs]@typecheck(n_hom_ref=expr_int32, n_het=expr_int32, n_hom_var=expr_int32, one_sided=expr_bool); def hardy_weinberg_test(n_hom_ref, n_het, n_hom_var, one_sided=False) -> StructExpression:; """"""Performs test of Hardy-Weinberg equilibrium. Examples; --------. >>> hl.eval(hl.hardy_weinberg_test(250, 500, 250)); Struct(het_freq_hwe=0.5002501250625313, p_value=0.9747844394217698). >>> hl.eval(hl.hardy_weinberg_test(37, 200, 85)); Struct(het_freq_hwe=0.48964964307448583, p_value=1.1337210383168987e-06). Notes; -----; By default, this method performs a two-sided exact test with mid-p-value correction of; `Hardy-Weinberg equilibrium <https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle>`__; via an efficient implementation of the; `Levene-Haldane distribution <../_static/LeveneHaldane.pdf>`__,; which models the number of heterozygous individuals under equilibrium. The mean of this distribution is ``(n_ref * n_var) / (2n - 1)``, where; ``n_ref = 2*n_hom_ref + n_het`` is the number of reference alleles,; ``n_var = 2*n_hom_var + n_het`` is the number of variant alleles,; and ``n = n_hom_ref + n_het + n_hom_var`` is the number of individuals.; So the expected frequency of heterozygotes under equilibrium,; `het_freq_hwe`, is this mean divided by ``n``. To perform one-sided exact test of excess heterozygosity with mid-p-value; correction instead, set `one_sided=True` and the p-value returned will be; from the one-sided exact test. Parameters; ----------; n_hom_ref : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous reference genotypes.; n_het : int or :class:`.Expression` of type :py:data:`.tint32`; Number of heterozygous genotypes.; n_hom_var : int or :class:`.Ex",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:109361,Energy Efficiency,reduce,reduce,109361," >>> hl.eval(hl.any([False, True, False])); True. >>> hl.eval(hl.any([False, False, False])); False. The third form:. >>> a = ['The', 'quick', 'brown', 'fox']; >>> s = {1, 3, 5, 6, 7, 9}. >>> hl.eval(hl.any(lambda x: x[-1] == 'x', a)); True. >>> hl.eval(hl.any(lambda x: x % 4 == 0, s)); False. Notes; -----; :func:`~.any` returns ``False`` when given an empty array or empty argument list.; """"""; base = hl.literal(False); if builtins.len(args) == 0:; return base; if builtins.len(args) == 1:; arg = arg_check(args[0], 'any', 'collection', oneof(collection_type, expr_bool)); if arg.dtype == hl.tbool:; return arg; return arg.any(lambda x: x); if builtins.len(args) == 2:; if callable(args[0]):; f = arg_check(args[0], 'any', 'f', any_to_bool_type); collection = arg_check(args[1], 'any', 'collection', collection_type); return collection.any(f); n_args = builtins.len(args); args = [args_check(x, 'any', 'exprs', i, n_args, expr_bool) for i, x in builtins.enumerate(args)]; return functools.reduce(operator.ior, args, base). [docs]def all(*args) -> BooleanExpression:; """"""Check for all ``True`` in boolean expressions or collections of booleans. :func:`~.all` comes in three forms:. 1. ``hl.all(boolean, ...)``. Are all arguments ``True``?. 2. ``hl.all(collection)``. Are all elements of the collection ``True``?. 3. ``hl.all(function, collection)``. Does ``function`` return ``True`` for; all values in this collection?. Examples; --------. The first form:. >>> hl.eval(hl.all()); True. >>> hl.eval(hl.all(True)); True. >>> hl.eval(hl.all(False)); False. >>> hl.eval(hl.all(True, True, True)); True. >>> hl.eval(hl.all(False, False, True, False)); False. The second form:. >>> hl.eval(hl.all([False, True, False])); False. >>> hl.eval(hl.all([True, True, True])); True. The third form:. >>> a = ['The', 'quick', 'brown', 'fox']; >>> s = {1, 3, 5, 6, 7, 9}. >>> hl.eval(hl.all(lambda x: hl.len(x) > 3, a)); False. >>> hl.eval(hl.all(lambda x: x < 10, s)); True. Notes; -----; :func:`~.all` returns `",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:111027,Energy Efficiency,reduce,reduce,111027,"d form:. >>> hl.eval(hl.all([False, True, False])); False. >>> hl.eval(hl.all([True, True, True])); True. The third form:. >>> a = ['The', 'quick', 'brown', 'fox']; >>> s = {1, 3, 5, 6, 7, 9}. >>> hl.eval(hl.all(lambda x: hl.len(x) > 3, a)); False. >>> hl.eval(hl.all(lambda x: x < 10, s)); True. Notes; -----; :func:`~.all` returns ``True`` when given an empty array or empty argument list.; """"""; base = hl.literal(True); if builtins.len(args) == 0:; return base; if builtins.len(args) == 1:; arg = arg_check(args[0], 'any', 'collection', oneof(collection_type, expr_bool)); if arg.dtype == hl.tbool:; return arg; return arg.all(lambda x: x); if builtins.len(args) == 2:; if callable(args[0]):; f = arg_check(args[0], 'all', 'f', any_to_bool_type); collection = arg_check(args[1], 'all', 'collection', collection_type); return collection.all(f); n_args = builtins.len(args); args = [args_check(x, 'all', 'exprs', i, n_args, expr_bool) for i, x in builtins.enumerate(args)]; return functools.reduce(operator.iand, args, base). [docs]@typecheck(f=func_spec(1, expr_bool), collection=expr_oneof(expr_set(), expr_array())); def find(f: Callable, collection):; """"""Returns the first element where `f` returns ``True``. Examples; --------. >>> a = ['The', 'quick', 'brown', 'fox']; >>> s = {1, 3, 5, 6, 7, 9}. >>> hl.eval(hl.find(lambda x: x[-1] == 'x', a)); 'fox'. >>> hl.eval(hl.find(lambda x: x % 4 == 0, s)); None. Notes; -----; If `f` returns ``False`` for every element, then the result is missing. Sets are unordered. If `collection` is of type :class:`.tset`, then the; element returned comes from no guaranteed ordering. Parameters; ----------; f : function ( (arg) -> :class:`.BooleanExpression`); Function to evaluate for each element of the collection. Must return a; :class:`.BooleanExpression`.; collection : :class:`.ArrayExpression` or :class:`.SetExpression`; Collection expression. Returns; -------; :class:`.Expression`; Expression whose type is the element type of the collection.; """""";",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:114047,Energy Efficiency,Reduce,Reduces,114047,"s 'f' to return an expression of type '{}', found '{}'"".format(s, t)); return t. return collection.flatmap(f). [docs]@typecheck(f=func_spec(1, expr_any), collection=expr_oneof(expr_set(), expr_array())); def group_by(f: Callable, collection) -> DictExpression:; """"""Group collection elements into a dict according to a lambda function. Examples; --------. >>> a = ['The', 'quick', 'brown', 'fox']; >>> hl.eval(hl.group_by(lambda x: hl.len(x), a)); {3: ['The', 'fox'], 5: ['quick', 'brown']}. Parameters; ----------; f : function ( (arg) -> :class:`.Expression`); Function to evaluate for each element of the collection to produce a key for the; resulting dictionary.; collection : :class:`.ArrayExpression` or :class:`.SetExpression`; Collection expression. Returns; -------; :class:`.DictExpression`.; Dictionary keyed by results of `f`.; """"""; return collection.group_by(f). [docs]@typecheck(f=func_spec(2, expr_any), zero=expr_any, collection=expr_oneof(expr_set(), expr_array())); def fold(f: Callable, zero, collection) -> Expression:; """"""Reduces a collection with the given function `f`, provided the initial value `zero`. Examples; --------; >>> a = [0, 1, 2]. >>> hl.eval(hl.fold(lambda i, j: i + j, 0, a)); 3. Parameters; ----------; f : function ( (:class:`.Expression`, :class:`.Expression`) -> :class:`.Expression`); Function which takes the cumulative value and the next element, and; returns a new value.; zero : :class:`.Expression`; Initial value to pass in as left argument of `f`.; collection : :class:`.ArrayExpression` or :class:`.SetExpression`. Returns; -------; :class:`.Expression`; """"""; return collection.fold(lambda x, y: f(x, y), zero). [docs]@typecheck(f=func_spec(2, expr_any), zero=expr_any, a=expr_array()); def array_scan(f: Callable, zero, a) -> ArrayExpression:; """"""Map each element of `a` to cumulative value of function `f`, with initial value `zero`. Examples; --------; >>> a = [0, 1, 2]. >>> hl.eval(hl.array_scan(lambda i, j: i + j, 0, a)); [0, 0, 1, 3]. Paramet",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:124815,Energy Efficiency,reduce,reduce,124815,"r} requires at least one argument""); if (; builtins.len(exprs) == 1; and (isinstance(exprs[0].dtype, (tarray, tset))); and is_numeric(exprs[0].dtype.element_type); ):; [e] = exprs; if filter_nan and e.dtype.element_type in (tfloat32, tfloat64):; name = 'nan' + name; return array(e)._filter_missing_method(filter_missing, name, exprs[0].dtype.element_type); else:; if not builtins.all(is_numeric(e.dtype) for e in exprs):; expr_types = ', '.join(""'{}'"".format(e.dtype) for e in exprs); raise TypeError(; f""{name!r} expects a single numeric array expression or multiple numeric expressions\n""; f"" Found {builtins.len(exprs)} arguments with types {expr_types}""; ); unified_typ = unify_types_limited(*(e.dtype for e in exprs)); ec = coercer_from_dtype(unified_typ); indices, aggs = unify_all(*exprs). func_name = name; if filter_missing:; func_name += '_ignore_missing'; if filter_nan and unified_typ in (tfloat32, tfloat64):; func_name = 'nan' + func_name; return construct_expr(; functools.reduce(lambda l, r: ir.Apply(func_name, unified_typ, l, r), [ec.coerce(e)._ir for e in exprs]),; unified_typ,; indices,; aggs,; ). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def nanmax(*exprs, filter_missing: builtins.bool = True) -> NumericExpression:; """"""Returns the maximum value of a collection or of given arguments, excluding NaN. Examples; --------. Compute the maximum value of an array:. >>> hl.eval(hl.nanmax([1.1, 50.1, float('nan')])); 50.1. Take the maximum value of arguments:. >>> hl.eval(hl.nanmax(1.1, 50.1, float('nan'))); 50.1. Notes; -----; Like the Python builtin ``max`` function, this function can either take a; single iterable expression (an array or set of numeric elements), or; variable-length arguments of numeric expressions. Note; ----; If `filter_missing` is ``True``, then the result is the maximum of; non-missing arguments or elements. If `filter_missing` is ``False``, then; any missin",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:10126,Integrability,wrap,wrapper,10126,"ef literal(x: Any, dtype: Optional[Union[HailType, str]] = None):; """"""Captures and broadcasts a Python variable or object as an expression. Examples; --------. >>> table = hl.utils.range_table(8); >>> greetings = hl.literal({1: 'Good morning', 4: 'Good afternoon', 6 : 'Good evening'}); >>> table.annotate(greeting = greetings.get(table.idx)).show(); +-------+------------------+; | idx | greeting |; +-------+------------------+; | int32 | str |; +-------+------------------+; | 0 | NA |; | 1 | ""Good morning"" |; | 2 | NA |; | 3 | NA |; | 4 | ""Good afternoon"" |; | 5 | NA |; | 6 | ""Good evening"" |; | 7 | NA |; +-------+------------------+. Notes; -----; Use this function to capture large Python objects for use in expressions. This; function provides an alternative to adding an object as a global annotation on a; :class:`.Table` or :class:`.MatrixTable`. Parameters; ----------; x; Object to capture and broadcast as an expression. Returns; -------; :class:`.Expression`; """"""; wrapper = {'has_expr': False, 'has_free_vars': False}. def typecheck_expr(t, x):; if isinstance(x, Expression):; wrapper['has_expr'] = True; wrapper['has_free_vars'] |= (; builtins.len(x._ir.free_vars) > 0; or builtins.len(x._ir.free_agg_vars) > 0; or builtins.len(x._ir.free_scan_vars) > 0; ). if x.dtype != t:; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': ob",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:10239,Integrability,wrap,wrapper,10239,"hon variable or object as an expression. Examples; --------. >>> table = hl.utils.range_table(8); >>> greetings = hl.literal({1: 'Good morning', 4: 'Good afternoon', 6 : 'Good evening'}); >>> table.annotate(greeting = greetings.get(table.idx)).show(); +-------+------------------+; | idx | greeting |; +-------+------------------+; | int32 | str |; +-------+------------------+; | 0 | NA |; | 1 | ""Good morning"" |; | 2 | NA |; | 3 | NA |; | 4 | ""Good afternoon"" |; | 5 | NA |; | 6 | ""Good evening"" |; | 7 | NA |; +-------+------------------+. Notes; -----; Use this function to capture large Python objects for use in expressions. This; function provides an alternative to adding an object as a global annotation on a; :class:`.Table` or :class:`.MatrixTable`. Parameters; ----------; x; Object to capture and broadcast as an expression. Returns; -------; :class:`.Expression`; """"""; wrapper = {'has_expr': False, 'has_free_vars': False}. def typecheck_expr(t, x):; if isinstance(x, Expression):; wrapper['has_expr'] = True; wrapper['has_free_vars'] |= (; builtins.len(x._ir.free_vars) > 0; or builtins.len(x._ir.free_agg_vars) > 0; or builtins.len(x._ir.free_scan_vars) > 0; ). if x.dtype != t:; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:10267,Integrability,wrap,wrapper,10267,"hon variable or object as an expression. Examples; --------. >>> table = hl.utils.range_table(8); >>> greetings = hl.literal({1: 'Good morning', 4: 'Good afternoon', 6 : 'Good evening'}); >>> table.annotate(greeting = greetings.get(table.idx)).show(); +-------+------------------+; | idx | greeting |; +-------+------------------+; | int32 | str |; +-------+------------------+; | 0 | NA |; | 1 | ""Good morning"" |; | 2 | NA |; | 3 | NA |; | 4 | ""Good afternoon"" |; | 5 | NA |; | 6 | ""Good evening"" |; | 7 | NA |; +-------+------------------+. Notes; -----; Use this function to capture large Python objects for use in expressions. This; function provides an alternative to adding an object as a global annotation on a; :class:`.Table` or :class:`.MatrixTable`. Parameters; ----------; x; Object to capture and broadcast as an expression. Returns; -------; :class:`.Expression`; """"""; wrapper = {'has_expr': False, 'has_free_vars': False}. def typecheck_expr(t, x):; if isinstance(x, Expression):; wrapper['has_expr'] = True; wrapper['has_free_vars'] |= (; builtins.len(x._ir.free_vars) > 0; or builtins.len(x._ir.free_agg_vars) > 0; or builtins.len(x._ir.free_scan_vars) > 0; ). if x.dtype != t:; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11211,Integrability,wrap,wrapper,11211,"['has_free_vars'] |= (; builtins.len(x._ir.free_vars) > 0; or builtins.len(x._ir.free_agg_vars) > 0; or builtins.len(x._ir.free_scan_vars) > 0; ). if x.dtype != t:; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return constru",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11310,Integrability,depend,depend,11310,"['has_free_vars'] |= (; builtins.len(x._ir.free_vars) > 0; or builtins.len(x._ir.free_agg_vars) > 0; or builtins.len(x._ir.free_scan_vars) > 0; ). if x.dtype != t:; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return constru",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11419,Integrability,wrap,wrapper,11419,"; raise TypeError(f""'literal': type mismatch: expected '{t}', found '{x.dtype}'""); elif x._indices.source is not None:; if x._indices.axes:; raise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:69202,Integrability,integrat,integrate,69202,"h was published as:. `Davies, Robert. ""The distribution of a linear combination of chi-squared random variables.""; Applied Statistics 29 323-333. 1980. <http://www.robertnz.net/pdf/lc_chisq.pdf>`__. Davies included Fortran source code in the original publication. Davies also released a `C; language port <http://www.robertnz.net/QF.htm>`__. Hail's implementation is a fairly direct port; of the C implementation to Scala. Davies provides 39 test cases with the source code. The Hail; tests include all 39 test cases as well as a few additional tests. Davies' website cautions:. The method works well in most situations if you want only modest accuracy, say 0.0001. But; problems may arise if the sum is dominated by one or two terms with a total of only one or; two degrees of freedom and x is small. For an accessible introduction the Generalized Chi-Squared Distribution, we strongly recommend; the introduction of this paper:. `Das, Abhranil; Geisler, Wilson (2020). ""A method to integrate and classify normal; distributions"". <https://arxiv.org/abs/2012.14331>`__. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of typ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70416,Integrability,integrat,integration,70416," evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is eith",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:70886,Integrability,integrat,integration,70886,"Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_fl",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71038,Integrability,integrat,integration,71038,"d in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:225,Modifiability,Config,Configuration,225,"﻿. Hail | ; hail.expr.functions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.functions. Source code for hail.expr.functions; import builtins; import functools; import itertools; import operator; from typing import Any, Callable, Iterable, Optional, TypeVar, Union. import numpy as np; import pandas as pd; from deprecated import deprecated. import hail; import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; ArrayNumericExpression,; BooleanExpression,; CallExpression,; DictExpression,; Expression,; ExpressionException,; Float32Expression,; Float64Expression,; Int32Expression,; Int64Expression,; IntervalExpression,; LocusExpression,; NumericExpression,; SetExpression,; StreamExpression,; StringExpression,; StructExpression,; TupleExpression,; apply_expr,; cast_expr,; coercer_from_dtype,; construct_expr,; construct_variable,; expr_any,; expr_array,; expr_bool,; expr_call,; expr_dict,; expr_float32,; expr_float64,; expr_int32,; expr_int64,; expr_interval,; expr_locus,; expr_ndarray,; expr_numeric,; expr_oneof,; expr_set,; expr_str,; expr_stream,; expr_struct,; expr_tuple,; impute_type,; to_expr,; unify_all,; unify_exprs,; unify_types_limited,; ); from hail.expr.types import (; HailType,; hail_type,; is_float32,; is_float64,; is_int32,; is_int64,; is_numeric,; is_primitive,; tarray,; tbool,; tcall,; tdict,; tfloat32,; tfloat64,; tint32,; tint64,; tinterval,; tlocus,; tndarray,; trngstate,; tset,; tstr,; tstream,; tstruct,; ttuple,; ); from hail.genetics.allele_type import AlleleType; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typec",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:9247,Modifiability,variab,variable,9247,"-----; t : :class:`str` or :class:`.HailType`; Type of the missing expression. Returns; -------; :class:`.Expression`; A missing expression of type `t`.; """"""; return construct_expr(ir.NA(t), t). [docs]@deprecated(version=""0.2.62"", reason=""Replaced by hl.missing""); @typecheck(t=hail_type); def null(t: Union[HailType, str]):; """"""Deprecated in favor of :func:`.missing`. Creates an expression representing a missing value of a specified type. Examples; --------. >>> hl.eval(hl.null(hl.tarray(hl.tstr))); None. >>> hl.eval(hl.null('array<str>')); None. Notes; -----; This method is useful for constructing an expression that includes missing; values, since :obj:`None` cannot be interpreted as an expression. Parameters; ----------; t : :class:`str` or :class:`.HailType`; Type of the missing expression. Returns; -------; :class:`.Expression`; A missing expression of type `t`.; """"""; return missing(t). [docs]@typecheck(x=anytype, dtype=nullable(hail_type)); def literal(x: Any, dtype: Optional[Union[HailType, str]] = None):; """"""Captures and broadcasts a Python variable or object as an expression. Examples; --------. >>> table = hl.utils.range_table(8); >>> greetings = hl.literal({1: 'Good morning', 4: 'Good afternoon', 6 : 'Good evening'}); >>> table.annotate(greeting = greetings.get(table.idx)).show(); +-------+------------------+; | idx | greeting |; +-------+------------------+; | int32 | str |; +-------+------------------+; | 0 | NA |; | 1 | ""Good morning"" |; | 2 | NA |; | 3 | NA |; | 4 | ""Good afternoon"" |; | 5 | NA |; | 6 | ""Good evening"" |; | 7 | NA |; +-------+------------------+. Notes; -----; Use this function to capture large Python objects for use in expressions. This; function provides an alternative to adding an object as a global annotation on a; :class:`.Table` or :class:`.MatrixTable`. Parameters; ----------; x; Object to capture and broadcast as an expression. Returns; -------; :class:`.Expression`; """"""; wrapper = {'has_expr': False, 'has_free_vars': False}. def ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:17062,Modifiability,variab,variable,17062,"es as ``False``. See Also; --------; :class:`.CaseBuilder`, :func:`.switch`, :func:`.cond`. Returns; -------; :class:`.CaseBuilder`.; """"""; from .builders import CaseBuilder. return CaseBuilder(missing_false=missing_false). [docs]@typecheck(expr=expr_any); def switch(expr) -> 'hail.expr.builders.SwitchBuilder':; """"""Build a conditional tree on the value of an expression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. See Also; --------; :class:`.SwitchBuilder`, :func:`.case`, :func:`.cond`. Parameters; ----------; expr : :class:`.Expression`; Value to match against. Returns; -------; :class:`.SwitchBuilder`; """"""; from .builders import SwitchBuilder. return SwitchBuilder(expr). [docs]@typecheck(f=anytype, exprs=expr_any, _ctx=nullable(str)); def bind(f: Callable, *exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. Examples; --------. >>> hl.eval(hl.bind(lambda x: x + 1, 1)); 2. :func:`.bind` also can take multiple arguments:. >>> hl.eval(hl.bind(lambda x, y: x / y, x, x)); 1.0. Parameters; ----------; f : function ( (args) -> :class:`.Expression`); Function of `exprs`.; exprs : variable-length args of :class:`.Expression`; Expressions to bind. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """"""; args = []; uids = []; irs = []. for expr in exprs:; uid = Env.get_uid(base=_ctx); args.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uids.append(uid); irs.append(expr._ir). lambda_result = to_expr(f(*args)); if _ctx:; indices, aggregations = unify_all(lambda_result) # FIXME: hacky. May drop field refs from errors?; else:; indices, aggregations = unify_all(*exprs, lambda_result). res_ir = lambda_result._ir; for uid, value_ir in builtins.zip(uids, ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:17366,Modifiability,variab,variable-length,17366,"ression. Examples; --------. >>> csq = hl.literal('loss of function'); >>> expr = (hl.switch(csq); ... .when('synonymous', 1); ... .when('SYN', 1); ... .when('missense', 2); ... .when('MIS', 2); ... .when('loss of function', 3); ... .when('LOF', 3); ... .or_missing()); >>> hl.eval(expr); 3. See Also; --------; :class:`.SwitchBuilder`, :func:`.case`, :func:`.cond`. Parameters; ----------; expr : :class:`.Expression`; Value to match against. Returns; -------; :class:`.SwitchBuilder`; """"""; from .builders import SwitchBuilder. return SwitchBuilder(expr). [docs]@typecheck(f=anytype, exprs=expr_any, _ctx=nullable(str)); def bind(f: Callable, *exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. Examples; --------. >>> hl.eval(hl.bind(lambda x: x + 1, 1)); 2. :func:`.bind` also can take multiple arguments:. >>> hl.eval(hl.bind(lambda x, y: x / y, x, x)); 1.0. Parameters; ----------; f : function ( (args) -> :class:`.Expression`); Function of `exprs`.; exprs : variable-length args of :class:`.Expression`; Expressions to bind. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """"""; args = []; uids = []; irs = []. for expr in exprs:; uid = Env.get_uid(base=_ctx); args.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uids.append(uid); irs.append(expr._ir). lambda_result = to_expr(f(*args)); if _ctx:; indices, aggregations = unify_all(lambda_result) # FIXME: hacky. May drop field refs from errors?; else:; indices, aggregations = unify_all(*exprs, lambda_result). res_ir = lambda_result._ir; for uid, value_ir in builtins.zip(uids, irs):; if _ctx == 'agg':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=False); elif _ctx == 'scan':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it i",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:18357,Modifiability,variab,variable,18357,"of `exprs`.; exprs : variable-length args of :class:`.Expression`; Expressions to bind. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """"""; args = []; uids = []; irs = []. for expr in exprs:; uid = Env.get_uid(base=_ctx); args.append(construct_variable(uid, expr._type, expr._indices, expr._aggregations)); uids.append(uid); irs.append(expr._ir). lambda_result = to_expr(f(*args)); if _ctx:; indices, aggregations = unify_all(lambda_result) # FIXME: hacky. May drop field refs from errors?; else:; indices, aggregations = unify_all(*exprs, lambda_result). res_ir = lambda_result._ir; for uid, value_ir in builtins.zip(uids, irs):; if _ctx == 'agg':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=False); elif _ctx == 'scan':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. This is :func:`.bind` with flipped argument order. Examples; --------. >>> hl.eval(hl.rbind(1, lambda x: x + 1)); 2. :func:`.rbind` also can take multiple arguments:. >>> hl.eval(hl.rbind(4.0, 2.0, lambda x, y: x / y)); 2.0. Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Expressions to bind.; f : function ( (args) -> :class:`.Expression`); Function of `exprs`. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """""". *args, f = exprs; args = [expr_any.check(arg, 'rbind', f'argument {index}') for index, arg in builtins.enumerate(args)]. return hl.bind(f, *args, _ctx=_ctx). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def chi_squared_test(c1, c2, c3, c4) -> StructExpression:; """"""Performs chi-squared test of independence on a 2x2 contingency table. Examples; --------. >>> hl.eval(hl.chi_squared_test(10, 10, 10, 10)); Struct(p_value=1.0, odd",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:18649,Modifiability,variab,variable-length,18649,"expr._type, expr._indices, expr._aggregations)); uids.append(uid); irs.append(expr._ir). lambda_result = to_expr(f(*args)); if _ctx:; indices, aggregations = unify_all(lambda_result) # FIXME: hacky. May drop field refs from errors?; else:; indices, aggregations = unify_all(*exprs, lambda_result). res_ir = lambda_result._ir; for uid, value_ir in builtins.zip(uids, irs):; if _ctx == 'agg':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=False); elif _ctx == 'scan':; res_ir = ir.AggLet(uid, value_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. This is :func:`.bind` with flipped argument order. Examples; --------. >>> hl.eval(hl.rbind(1, lambda x: x + 1)); 2. :func:`.rbind` also can take multiple arguments:. >>> hl.eval(hl.rbind(4.0, 2.0, lambda x, y: x / y)); 2.0. Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Expressions to bind.; f : function ( (args) -> :class:`.Expression`); Function of `exprs`. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """""". *args, f = exprs; args = [expr_any.check(arg, 'rbind', f'argument {index}') for index, arg in builtins.enumerate(args)]. return hl.bind(f, *args, _ctx=_ctx). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def chi_squared_test(c1, c2, c3, c4) -> StructExpression:; """"""Performs chi-squared test of independence on a 2x2 contingency table. Examples; --------. >>> hl.eval(hl.chi_squared_test(10, 10, 10, 10)); Struct(p_value=1.0, odds_ratio=1.0). >>> hl.eval(hl.chi_squared_test(51, 43, 22, 92)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). Notes; -----; The odds ratio is given by ``(c1 / c2) / (c3 / c4)``. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:24318,Modifiability,variab,variable,24318,".. ]); ... ); >>> hl.eval(hl.cochran_mantel_haenszel_test(a, b, c, d)); Struct(test_statistic=0.2188830334629822, p_value=0.6398923118508772). Notes; -----; See the `Wikipedia article <https://en.m.wikipedia.org/wiki/Cochran%E2%80%93Mantel%E2%80%93Haenszel_statistics>`_; for more details. Parameters; ----------; a : :class:`.ArrayExpression` of type :py:data:`.tint64`; Values for the upper-left cell in the contingency tables.; b : :class:`.ArrayExpression` of type :py:data:`.tint64`; Values for the upper-right cell in the contingency tables.; c : :class:`.ArrayExpression` of type :py:data:`.tint64`; Values for the lower-left cell in the contingency tables.; d : :class:`.ArrayExpression` of type :py:data:`.tint64`; Values for the lower-right cell in the contingency tables. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `test_statistic`; (:py:data:`.tfloat64`) and `p_value` (:py:data:`.tfloat64`).; """"""; # The variable names below correspond to the notation used in the Wikipedia article.; # https://en.m.wikipedia.org/wiki/Cochran%E2%80%93Mantel%E2%80%93Haenszel_statistics; n1 = hl.zip(a, b).map(lambda ab: ab[0] + ab[1]); n2 = hl.zip(c, d).map(lambda cd: cd[0] + cd[1]); m1 = hl.zip(a, c).map(lambda ac: ac[0] + ac[1]); m2 = hl.zip(b, d).map(lambda bd: bd[0] + bd[1]); t = hl.zip(n1, n2).map(lambda nn: nn[0] + nn[1]). def numerator_term(a, n1, m1, t):; return a - n1 * m1 / t. # The numerator comes from the link below, not from the Wikipedia article.; # https://www.biostathandbook.com/cmh.html; numerator = (hl.abs(hl.sum(hl.zip(a, n1, m1, t).map(lambda tup: numerator_term(*tup)))) - 0.5) ** 2. def denominator_term(n1, n2, m1, m2, t):; return n1 * n2 * m1 * m2 / (t**3 - t**2). denominator = hl.sum(hl.zip(n1, n2, m1, m2, t).map(lambda tup: denominator_term(*tup))). test_statistic = numerator / denominator; p_value = pchisqtail(test_statistic, 1); return struct(test_statistic=test_statistic, p_value=p_value). [docs]@typecheck(; col",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:49266,Modifiability,variab,variable-length,49266,"se where the position is ``0`` **AND** the interval is; **left-exclusive** which is normalized to be ``1`` and left-inclusive.; Likewise, in the case where the position is ``END + 1`` **AND**; the interval is **right-exclusive** which is normalized to be ``END``; and right-inclusive. Parameters; ----------; s : str or :class:`.StringExpression`; String to parse.; reference_genome : :class:`str` or :class:`.hail.genetics.ReferenceGenome`; Reference genome to use.; invalid_missing : :class:`.BooleanExpression`; If ``True``, invalid intervals are set to NA rather than causing an exception. Returns; -------; :class:`.IntervalExpression`; """"""; return _func('LocusInterval', tinterval(tlocus(reference_genome)), s, invalid_missing). [docs]@typecheck(alleles=expr_int32, phased=expr_bool); def call(*alleles, phased=False) -> CallExpression:; """"""Construct a call expression. Examples; --------. >>> hl.eval(hl.call(1, 0)); Call(alleles=[0, 1], phased=False). Parameters; ----------; alleles : variable-length args of :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; List of allele indices.; phased : :obj:`bool`; If ``True``, preserve the order of `alleles`. Returns; -------; :class:`.CallExpression`; """"""; if builtins.len(alleles) > 2:; raise NotImplementedError(""'call' supports a maximum of 2 alleles.""); return _func('Call', tcall, *alleles, phased). [docs]@typecheck(gt_index=expr_int32); def unphased_diploid_gt_index_call(gt_index) -> CallExpression:; """"""Construct an unphased, diploid call from a genotype index. Examples; --------. >>> hl.eval(hl.unphased_diploid_gt_index_call(4)); Call(alleles=[1, 2], phased=False). Parameters; ----------; gt_index : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; Unphased, diploid genotype index. Returns; -------; :class:`.CallExpression`; """"""; return _func('UnphasedDiploidGtIndexCall', tcall, to_expr(gt_index)). [docs]@typecheck(s=expr_str); def parse_call(s) -> CallExpression:; """"""Construct a call expression by par",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:58777,Modifiability,variab,variable-length,58777,"xpr_float64))); @ndarray_broadcasting; def expit(x) -> Float64Expression:; """"""The logistic sigmoid function. .. math::. \textrm{expit}(x) = \frac{1}{1 + e^{-x}}. Examples; --------; >>> hl.eval(hl.expit(.01)); 0.5024999791668749; >>> hl.eval(hl.expit(0.0)); 0.5. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return hl.if_else(x >= 0, 1 / (1 + hl.exp(-x)), hl.rbind(hl.exp(x), lambda exped: exped / (exped + 1))). [docs]@typecheck(args=expr_any); def coalesce(*args):; """"""Returns the first non-missing value of `args`. Examples; --------. >>> x1 = hl.missing('int'); >>> x2 = 2; >>> hl.eval(hl.coalesce(x1, x2)); 2. Notes; -----; All arguments must have the same type, or must be convertible to a common; type (all numeric, for instance). See Also; --------; :func:`.or_else`. Parameters; ----------; args : variable-length args of :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; if builtins.len(args) < 1:; raise ValueError(""'coalesce' requires at least one expression argument""); *exprs, success = unify_exprs(*args); if not success:; arg_types = ''.join([f""\n argument {i}: type '{arg.dtype}'"" for i, arg in builtins.enumerate(exprs)]); raise TypeError(f""'coalesce' requires all arguments to have the same type or compatible types"" f""{arg_types}""); indices, aggregations = unify_all(*exprs); return construct_expr(ir.Coalesce(*(e._ir for e in exprs)), exprs[0].dtype, indices, aggregations). [docs]@typecheck(a=expr_any, b=expr_any); def or_else(a, b):; """"""If `a` is missing, return `b`. Examples; --------. >>> hl.eval(hl.or_else(5, 7)); 5. >>> hl.eval(hl.or_else(hl.missing(hl.tint32), 7)); 7. See Also; --------; :func:`.coalesce`. Parameters; ----------; a: :class:`.Expression`; b: :class:`.Expression`. Returns; -------; :class:`.Expression`; """"""; a, b, success = unify_exprs(a, b)",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:64929,Modifiability,variab,variables,64929,"-; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; if ncp is None:; return _func(""pchisqtail"", tfloat64, x, df, lower_tail, log_p); else:; return _func(""pnchisqtail"", tfloat64, x, df, ncp, lower_tail, log_p). PGENCHISQ_RETURN_TYPE = tstruct(value=tfloat64, n_iterations=tint32, converged=tbool, fault=tint32). [docs]@typecheck(; x=expr_float64,; w=expr_array(expr_float64),; k=expr_array(expr_int32),; lam=expr_array(expr_float64),; mu=expr_float64,; sigma=expr_float64,; max_iterations=nullable(expr_int32),; min_accuracy=nullable(expr_float64),; ); def pgenchisq(x, w, k, lam, mu, sigma, *, max_iterations=None, min_accuracy=None) -> Float64Expression:; r""""""The cumulative probability function of a `generalized chi-squared distribution; <https://en.wikipedia.org/wiki/Generalized_chi-squared_distribution>`__. The generalized chi-squared distribution has many interpretations. We share here four; interpretations of the values of this distribution:. 1. A linear combination of normal variables and squares of normal variables. 2. A weighted sum of sums of squares of normally distributed values plus a normally distributed; value. 3. A weighted sum of chi-squared distributed values plus a normally distributed value. 4. A `""quadratic form"" <https://en.wikipedia.org/wiki/Quadratic_form_(statistics)>`__ in a vector; of uncorrelated `standard normal; <https://en.wikipedia.org/wiki/Normal_distribution#Standard_normal_distribution>`__ values. The parameters of this function correspond to the parameters of the third interpretation. .. math::. \begin{aligned}; w &: R^n \quad k : Z^n \quad lam : R^n \quad mu : R \quad sigma : R \\; \\; x &\sim N(mu, sigma^2) \\; y_i &\sim \mathrm{NonCentralChiSquared}(k_i, lam_i) \\; \\; Z &= x + w y^T \\; &= x + \sum_i w_i y_i \\; Z &\sim \mathrm{GeneralizedNonCentralChiSquared}(w, k, lam, mu, sigma); \end{aligned}. The generalized chi-squared distribution often arises when working on linear models with standard; normal noise because the sum of th",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:64961,Modifiability,variab,variables,64961,"-; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; if ncp is None:; return _func(""pchisqtail"", tfloat64, x, df, lower_tail, log_p); else:; return _func(""pnchisqtail"", tfloat64, x, df, ncp, lower_tail, log_p). PGENCHISQ_RETURN_TYPE = tstruct(value=tfloat64, n_iterations=tint32, converged=tbool, fault=tint32). [docs]@typecheck(; x=expr_float64,; w=expr_array(expr_float64),; k=expr_array(expr_int32),; lam=expr_array(expr_float64),; mu=expr_float64,; sigma=expr_float64,; max_iterations=nullable(expr_int32),; min_accuracy=nullable(expr_float64),; ); def pgenchisq(x, w, k, lam, mu, sigma, *, max_iterations=None, min_accuracy=None) -> Float64Expression:; r""""""The cumulative probability function of a `generalized chi-squared distribution; <https://en.wikipedia.org/wiki/Generalized_chi-squared_distribution>`__. The generalized chi-squared distribution has many interpretations. We share here four; interpretations of the values of this distribution:. 1. A linear combination of normal variables and squares of normal variables. 2. A weighted sum of sums of squares of normally distributed values plus a normally distributed; value. 3. A weighted sum of chi-squared distributed values plus a normally distributed value. 4. A `""quadratic form"" <https://en.wikipedia.org/wiki/Quadratic_form_(statistics)>`__ in a vector; of uncorrelated `standard normal; <https://en.wikipedia.org/wiki/Normal_distribution#Standard_normal_distribution>`__ values. The parameters of this function correspond to the parameters of the third interpretation. .. math::. \begin{aligned}; w &: R^n \quad k : Z^n \quad lam : R^n \quad mu : R \quad sigma : R \\; \\; x &\sim N(mu, sigma^2) \\; y_i &\sim \mathrm{NonCentralChiSquared}(k_i, lam_i) \\; \\; Z &= x + w y^T \\; &= x + \sum_i w_i y_i \\; Z &\sim \mathrm{GeneralizedNonCentralChiSquared}(w, k, lam, mu, sigma); \end{aligned}. The generalized chi-squared distribution often arises when working on linear models with standard; normal noise because the sum of th",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:68320,Modifiability,variab,variables,68320," 1], mu=-3, sigma=0).value); 0.516439358616939; >>> hl.eval(hl.pgenchisq(10 , w=[-2, -1], k=[5, 2], lam=[3, 1], mu=-3, sigma=0).value); 1.0; >>> hl.eval(hl.pgenchisq(40 , w=[-2, -1], k=[5, 2], lam=[3, 1], mu=-3, sigma=0).value); 1.0. >>> hl.eval(hl.pgenchisq(-80, w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.14284718767288906; >>> hl.eval(hl.pgenchisq(-20, w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.5950150356303258; >>> hl.eval(hl.pgenchisq(10 , w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.923219534175858; >>> hl.eval(hl.pgenchisq(40 , w=[1, -10, 2], k=[1, 2, 3], lam=[2, 3, 7], mu=-10, sigma=0).value); 0.9971746768781656. Notes; -----. We follow Wikipedia's notational conventions. Some texts refer to the weight vector (our `w`) as; :math:`\lambda` or `lb` and the non-centrality vector (our `lam`) as `nc`. We use the Davies' algorithm which was published as:. `Davies, Robert. ""The distribution of a linear combination of chi-squared random variables.""; Applied Statistics 29 323-333. 1980. <http://www.robertnz.net/pdf/lc_chisq.pdf>`__. Davies included Fortran source code in the original publication. Davies also released a `C; language port <http://www.robertnz.net/QF.htm>`__. Hail's implementation is a fairly direct port; of the C implementation to Scala. Davies provides 39 test cases with the source code. The Hail; tests include all 39 test cases as well as a few additional tests. Davies' website cautions:. The method works well in most situations if you want only modest accuracy, say 0.0001. But; problems may arise if the sum is dominated by one or two terms with a total of only one or; two degrees of freedom and x is small. For an accessible introduction the Generalized Chi-Squared Distribution, we strongly recommend; the introduction of this paper:. `Das, Abhranil; Geisler, Wilson (2020). ""A method to integrate and classify normal; distributions"". <https://arxiv.org/abs/2012.14331>`__. Param",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:72499,Modifiability,variab,variable,72499,"d accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=False)); 0.022750131948179212. >>> hl.eval(hl.pnorm(2, log_p=True)); -0.023012909328963493. Notes; -----; Returns the left-tail probability `p` = Prob(:math:`Z < x`) with :math:`Z`; a normal random variable. Defaults to a standard normal random variable. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""pnorm"", tfloat64, x, mu, sigma, lower_tail, log_p). [docs]@typecheck(x=expr_float64, n=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pT(x, n, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a `t-distribution; <https://en.wikiped",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:72546,Modifiability,variab,variable,72546,"ficant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns cumulative probability of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.pnorm(0)); 0.5. >>> hl.eval(hl.pnorm(1, mu=2, sigma=2)); 0.30853753872598694. >>> hl.eval(hl.pnorm(2, lower_tail=False)); 0.022750131948179212. >>> hl.eval(hl.pnorm(2, log_p=True)); -0.023012909328963493. Notes; -----; Returns the left-tail probability `p` = Prob(:math:`Z < x`) with :math:`Z`; a normal random variable. Defaults to a standard normal random variable. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""pnorm"", tfloat64, x, mu, sigma, lower_tail, log_p). [docs]@typecheck(x=expr_float64, n=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pT(x, n, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a `t-distribution; <https://en.wikipedia.org/wiki/Student%27s_t-distribution>`__ with; `n` degrees of freedom. Examples;",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:73860,Modifiability,variab,variable,73860,"ault = 1).; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""pnorm"", tfloat64, x, mu, sigma, lower_tail, log_p). [docs]@typecheck(x=expr_float64, n=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pT(x, n, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a `t-distribution; <https://en.wikipedia.org/wiki/Student%27s_t-distribution>`__ with; `n` degrees of freedom. Examples; --------. >>> hl.eval(hl.pT(0, 10)); 0.5. >>> hl.eval(hl.pT(1, 10)); 0.82955343384897. >>> hl.eval(hl.pT(1, 10, lower_tail=False)); 0.17044656615103004. >>> hl.eval(hl.pT(1, 10, log_p=True)); -0.186867754489647. Notes; -----; If `lower_tail` is true, returns Prob(:math:`X \leq` `x`) where :math:`X` is; a t-distributed random variable with `n` degrees of freedom. If `lower_tail`; is false, returns Prob(:math:`X` > `x`). Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; n : float or :class:`.Expression` of type :py:data:`.tfloat64`; Degrees of freedom of the t-distribution.; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`. """"""; return _func(""pT"", tfloat64, x, n, lower_tail, log_p). [docs]@typecheck(x=expr_float64, df1=expr_float64, df2=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pF(x, df1, df2, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a `F-distribution; <https://en.wikipedia.org/wiki/F-distribution>`__ with ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:75186,Modifiability,variab,variable,75186,"ail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`. """"""; return _func(""pT"", tfloat64, x, n, lower_tail, log_p). [docs]@typecheck(x=expr_float64, df1=expr_float64, df2=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pF(x, df1, df2, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a `F-distribution; <https://en.wikipedia.org/wiki/F-distribution>`__ with parameters; `df1` and `df2`. Examples; --------. >>> hl.eval(hl.pF(0, 3, 10)); 0.0. >>> hl.eval(hl.pF(1, 3, 10)); 0.5676627969783028. >>> hl.eval(hl.pF(1, 3, 10, lower_tail=False)); 0.4323372030216972. >>> hl.eval(hl.pF(1, 3, 10, log_p=True)); -0.566227703842908. Notes; -----; If `lower_tail` is true, returns Prob(:math:`X \leq` `x`) where :math:`X` is; a random variable with distribution :math:`F`(df1, df2). If `lower_tail`; is false, returns Prob(:math:`X` > `x`). Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; df1 : float or :class:`.Expression` of type :py:data:`.tfloat64`; Parameter of the F-distribution; df2 : float or :class:`.Expression` of type :py:data:`.tfloat64`; Parameter of the F-distribution; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""pF"", tfloat64, x, df1, df2, lower_tail, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def ppois(x, lamb, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:76365,Modifiability,variab,variable,76365," :class:`.Expression` of type :py:data:`.tfloat64`; df1 : float or :class:`.Expression` of type :py:data:`.tfloat64`; Parameter of the F-distribution; df2 : float or :class:`.Expression` of type :py:data:`.tfloat64`; Parameter of the F-distribution; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""pF"", tfloat64, x, df1, df2, lower_tail, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def ppois(x, lamb, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The cumulative probability function of a Poisson distribution. Examples; --------. >>> hl.eval(hl.ppois(2, 1)); 0.9196986029286058. Notes; -----; If `lower_tail` is true, returns Prob(:math:`X \leq` `x`) where :math:`X` is a; Poisson random variable with rate parameter `lamb`. If `lower_tail` is false,; returns Prob(:math:`X` > `x`). Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; lamb : float or :class:`.Expression` of type :py:data:`.tfloat64`; Rate parameter of Poisson distribution.; lower_tail : bool or :class:`.BooleanExpression`; If ``True``, compute the probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""ppois"", tfloat64, x, lamb, lower_tail, log_p). [docs]@typecheck(p=expr_float64, df=expr_float64, ncp=nullable(expr_float64), lower_tail=expr_bool, log_p=expr_bool); def qchisqtail(p, df, ncp=None, lower_tail=False, log_p=False) -> Float64Expression:; """"""The quantile function of a chi-squared distribution with `df` degrees of; freedom, inver",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:77762,Modifiability,variab,variable,77762,"he probability of an outcome at or below `x`,; otherwise greater than `x`.; log_p : bool or :class:`.BooleanExpression`; Return the natural logarithm of the probability. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""ppois"", tfloat64, x, lamb, lower_tail, log_p). [docs]@typecheck(p=expr_float64, df=expr_float64, ncp=nullable(expr_float64), lower_tail=expr_bool, log_p=expr_bool); def qchisqtail(p, df, ncp=None, lower_tail=False, log_p=False) -> Float64Expression:; """"""The quantile function of a chi-squared distribution with `df` degrees of; freedom, inverts :func:`~.pchisqtail`. Examples; --------. >>> hl.eval(hl.qchisqtail(0.05, 2)); 5.991464547107979. >>> hl.eval(hl.qchisqtail(0.05, 2, ncp=2)); 10.838131614372958. >>> hl.eval(hl.qchisqtail(0.05, 2, lower_tail=True)); 0.10258658877510107. >>> hl.eval(hl.qchisqtail(hl.log(0.05), 2, log_p=True)); 5.991464547107979. Notes; -----; Returns right-quantile `x` for which `p` = Prob(:math:`Z^2` > x) with; :math:`Z^2` a chi-squared random variable with degrees of freedom specified; by `df`. The probability `p` must satisfy 0 < `p` < 1. Parameters; ----------; p : float or :class:`.Expression` of type :py:data:`.tfloat64`; Probability.; df : float or :class:`.Expression` of type :py:data:`.tfloat64`; Degrees of freedom.; ncp: float or :class:`.Expression` of type :py:data:`.tfloat64`; Corresponds to `ncp` parameter in :func:`.pchisqtail`.; lower_tail : bool or :class:`.BooleanExpression`; Corresponds to `lower_tail` parameter in :func:`.pchisqtail`.; log_p : bool or :class:`.BooleanExpression`; Exponentiate `p`, corresponds to `log_p` parameter in :func:`.pchisqtail`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; if ncp is None:; return _func(""qchisqtail"", tfloat64, p, df, lower_tail, log_p); else:; return _func(""qnchisqtail"", tfloat64, p, df, ncp, lower_tail, log_p). [docs]@typecheck(p=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, lo",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:79387,Modifiability,variab,variable,79387,"`log_p` parameter in :func:`.pchisqtail`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; if ncp is None:; return _func(""qchisqtail"", tfloat64, p, df, lower_tail, log_p); else:; return _func(""qnchisqtail"", tfloat64, p, df, ncp, lower_tail, log_p). [docs]@typecheck(p=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def qnorm(p, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The quantile function of a normal distribution with mean `mu` and; standard deviation `sigma`, inverts :func:`~.pnorm`. Returns quantile of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.qnorm(0.90)); 1.2815515655446008. >>> hl.eval(hl.qnorm(0.90, mu=1, sigma=2)); 3.5631031310892016. >>> hl.eval(hl.qnorm(0.90, lower_tail=False)); -1.2815515655446008. >>> hl.eval(hl.qnorm(hl.log(0.90), log_p=True)); 1.2815515655446008. Notes; -----; Returns left-quantile `x` for which p = Prob(:math:`Z` < x) with :math:`Z`; a normal random variable with mean `mu` and standard deviation `sigma`.; Defaults to a standard normal random variable, and the probability `p` must; satisfy 0 < `p` < 1. Parameters; ----------; p : float or :class:`.Expression` of type :py:data:`.tfloat64`; Probability.; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; lower_tail : bool or :class:`.BooleanExpression`; Corresponds to `lower_tail` parameter in :func:`.pnorm`.; log_p : bool or :class:`.BooleanExpression`; Exponentiate `p`, corresponds to `log_p` parameter in :func:`.pnorm`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""qnorm"", tfloat64, p, mu, sigma, lower_tail, log_p). [docs]@typecheck(p=expr_float64, lamb=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def qpois(p, lamb, lower_tail=True, log_p=False) -> Float64Expression:; r""",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:79481,Modifiability,variab,variable,79481,":; return _func(""qchisqtail"", tfloat64, p, df, lower_tail, log_p); else:; return _func(""qnchisqtail"", tfloat64, p, df, ncp, lower_tail, log_p). [docs]@typecheck(p=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def qnorm(p, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The quantile function of a normal distribution with mean `mu` and; standard deviation `sigma`, inverts :func:`~.pnorm`. Returns quantile of; standard normal distribution by default. Examples; --------. >>> hl.eval(hl.qnorm(0.90)); 1.2815515655446008. >>> hl.eval(hl.qnorm(0.90, mu=1, sigma=2)); 3.5631031310892016. >>> hl.eval(hl.qnorm(0.90, lower_tail=False)); -1.2815515655446008. >>> hl.eval(hl.qnorm(hl.log(0.90), log_p=True)); 1.2815515655446008. Notes; -----; Returns left-quantile `x` for which p = Prob(:math:`Z` < x) with :math:`Z`; a normal random variable with mean `mu` and standard deviation `sigma`.; Defaults to a standard normal random variable, and the probability `p` must; satisfy 0 < `p` < 1. Parameters; ----------; p : float or :class:`.Expression` of type :py:data:`.tfloat64`; Probability.; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; lower_tail : bool or :class:`.BooleanExpression`; Corresponds to `lower_tail` parameter in :func:`.pnorm`.; log_p : bool or :class:`.BooleanExpression`; Exponentiate `p`, corresponds to `log_p` parameter in :func:`.pnorm`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""qnorm"", tfloat64, p, mu, sigma, lower_tail, log_p). [docs]@typecheck(p=expr_float64, lamb=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def qpois(p, lamb, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The quantile function of a Poisson distribution with rate parameter; `lamb`, inverts :func:`~.ppois`. Examples; --------. >>> hl.",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:80660,Modifiability,variab,variable,80660,":py:data:`.tfloat64`; Probability.; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; lower_tail : bool or :class:`.BooleanExpression`; Corresponds to `lower_tail` parameter in :func:`.pnorm`.; log_p : bool or :class:`.BooleanExpression`; Exponentiate `p`, corresponds to `log_p` parameter in :func:`.pnorm`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""qnorm"", tfloat64, p, mu, sigma, lower_tail, log_p). [docs]@typecheck(p=expr_float64, lamb=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def qpois(p, lamb, lower_tail=True, log_p=False) -> Float64Expression:; r""""""The quantile function of a Poisson distribution with rate parameter; `lamb`, inverts :func:`~.ppois`. Examples; --------. >>> hl.eval(hl.qpois(0.99, 1)); 4. Notes; -----; Returns the smallest integer :math:`x` such that Prob(:math:`X \leq x`) :math:`\geq` `p` where :math:`X`; is a Poisson random variable with rate parameter `lambda`. Parameters; ----------; p : float or :class:`.Expression` of type :py:data:`.tfloat64`; lamb : float or :class:`.Expression` of type :py:data:`.tfloat64`; Rate parameter of Poisson distribution.; lower_tail : bool or :class:`.BooleanExpression`; Corresponds to `lower_tail` parameter in inverse :func:`.ppois`.; log_p : bool or :class:`.BooleanExpression`; Exponentiate `p` before testing. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; """"""; return _func(""qpois"", tint32, p, lamb, lower_tail, log_p). [docs]@typecheck(start=expr_int32, stop=nullable(expr_int32), step=expr_int32); def range(start, stop=None, step=1) -> ArrayNumericExpression:; """"""Returns an array of integers from `start` to `stop` by `step`. Examples; --------. >>> hl.eval(hl.range(10)); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]. >>> hl.eval(hl.range(3, 10)); [3, 4, 5, 6, 7, 8, 9]. >>> hl.eval(hl.range(0, 10, step=3)); [0, 3, ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:95512,Modifiability,polymorphi,polymorphism,95512,"mericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""sqrt"", tfloat64, x). [docs]@typecheck(x=expr_array(expr_float64), y=expr_array(expr_float64)); def corr(x, y) -> Float64Expression:; """"""Compute the; `Pearson correlation coefficient <https://en.wikipedia.org/wiki/Pearson_correlation_coefficient>`__; between `x` and `y`. Examples; --------; >>> hl.eval(hl.corr([1, 2, 4], [2, 3, 1])); -0.6546536707079772. Notes; -----; Only indices where both `x` and `y` are non-missing will be included in the; calculation. If `x` and `y` have length zero, then the result is missing. Parameters; ----------; x : :class:`.Expression` of type ``array<tfloat64>``; y : :class:`.Expression` of type ``array<tfloat64>``. Returns; -------; :class:`.Float64Expression`; """"""; return _func(""corr"", tfloat64, x, y). [docs]@typecheck(ref=expr_str, alt=expr_str); @ir.udf(tstr, tstr); def numeric_allele_type(ref, alt) -> Int32Expression:; """"""Returns the type of the polymorphism as an integer. The value returned; is the integer value of :class:`.AlleleType` representing that kind of; polymorphism. Examples; --------. >>> hl.eval(hl.numeric_allele_type('A', 'T')) == AlleleType.SNP; True. Notes; -----; The values of :class:`.AlleleType` are not stable and thus should not be; relied upon across hail versions.; """"""; _base_regex = ""^([ACGTNM])+$""; _symbolic_regex = r""(^\.)|(\.$)|(^<)|(>$)|(\[)|(\])""; return hl.bind(; lambda r, a: hl.if_else(; r.matches(_base_regex),; hl.case(); .when(; a.matches(_base_regex),; hl.case(); .when(; r.length() == a.length(),; hl.if_else(; r.length() == 1,; hl.if_else(r != a, AlleleType.SNP, AlleleType.UNKNOWN),; hl.if_else(hamming(r, a) == 1, AlleleType.SNP, AlleleType.MNP),; ),; ); .when((r.length() < a.length()) & (r[0] == a[0]) & a.endswith(r[1:]), AlleleType.INSERTION); .when((r[0] == a[0]) & r.endswith(a[1:]), AlleleType.DELETION); .default(AlleleType.COMPLEX),; ); .when(a == '*', A",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:95632,Modifiability,polymorphi,polymorphism,95632,"""sqrt"", tfloat64, x). [docs]@typecheck(x=expr_array(expr_float64), y=expr_array(expr_float64)); def corr(x, y) -> Float64Expression:; """"""Compute the; `Pearson correlation coefficient <https://en.wikipedia.org/wiki/Pearson_correlation_coefficient>`__; between `x` and `y`. Examples; --------; >>> hl.eval(hl.corr([1, 2, 4], [2, 3, 1])); -0.6546536707079772. Notes; -----; Only indices where both `x` and `y` are non-missing will be included in the; calculation. If `x` and `y` have length zero, then the result is missing. Parameters; ----------; x : :class:`.Expression` of type ``array<tfloat64>``; y : :class:`.Expression` of type ``array<tfloat64>``. Returns; -------; :class:`.Float64Expression`; """"""; return _func(""corr"", tfloat64, x, y). [docs]@typecheck(ref=expr_str, alt=expr_str); @ir.udf(tstr, tstr); def numeric_allele_type(ref, alt) -> Int32Expression:; """"""Returns the type of the polymorphism as an integer. The value returned; is the integer value of :class:`.AlleleType` representing that kind of; polymorphism. Examples; --------. >>> hl.eval(hl.numeric_allele_type('A', 'T')) == AlleleType.SNP; True. Notes; -----; The values of :class:`.AlleleType` are not stable and thus should not be; relied upon across hail versions.; """"""; _base_regex = ""^([ACGTNM])+$""; _symbolic_regex = r""(^\.)|(\.$)|(^<)|(>$)|(\[)|(\])""; return hl.bind(; lambda r, a: hl.if_else(; r.matches(_base_regex),; hl.case(); .when(; a.matches(_base_regex),; hl.case(); .when(; r.length() == a.length(),; hl.if_else(; r.length() == 1,; hl.if_else(r != a, AlleleType.SNP, AlleleType.UNKNOWN),; hl.if_else(hamming(r, a) == 1, AlleleType.SNP, AlleleType.MNP),; ),; ); .when((r.length() < a.length()) & (r[0] == a[0]) & a.endswith(r[1:]), AlleleType.INSERTION); .when((r[0] == a[0]) & r.endswith(a[1:]), AlleleType.DELETION); .default(AlleleType.COMPLEX),; ); .when(a == '*', AlleleType.STAR); .when(a.matches(_symbolic_regex), AlleleType.SYMBOLIC); .default(AlleleType.UNKNOWN),; AlleleType.UNKNOWN,; ),; ref,; alt,; ).",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:97099,Modifiability,polymorphi,polymorphism,97099,"; .when(; a.matches(_base_regex),; hl.case(); .when(; r.length() == a.length(),; hl.if_else(; r.length() == 1,; hl.if_else(r != a, AlleleType.SNP, AlleleType.UNKNOWN),; hl.if_else(hamming(r, a) == 1, AlleleType.SNP, AlleleType.MNP),; ),; ); .when((r.length() < a.length()) & (r[0] == a[0]) & a.endswith(r[1:]), AlleleType.INSERTION); .when((r[0] == a[0]) & r.endswith(a[1:]), AlleleType.DELETION); .default(AlleleType.COMPLEX),; ); .when(a == '*', AlleleType.STAR); .when(a.matches(_symbolic_regex), AlleleType.SYMBOLIC); .default(AlleleType.UNKNOWN),; AlleleType.UNKNOWN,; ),; ref,; alt,; ). @deprecated(version='0.2.129', reason=""Replaced by the public numeric_allele_type""); @typecheck(ref=expr_str, alt=expr_str); def _num_allele_type(ref, alt) -> Int32Expression:; """"""Provided for backwards compatibility, don't use it in new code, or; within the hail library itself; """"""; return numeric_allele_type(ref, alt). [docs]@typecheck(ref=expr_str, alt=expr_str); def is_snp(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a single nucleotide polymorphism. Examples; --------. >>> hl.eval(hl.is_snp('A', 'T')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.SNP. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_mnp(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a multiple nucleotide polymorphism. Examples; --------. >>> hl.eval(hl.is_mnp('AA', 'GT')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.MNP. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_transition(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a t",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:97568,Modifiability,polymorphi,polymorphism,97568,"hen(a.matches(_symbolic_regex), AlleleType.SYMBOLIC); .default(AlleleType.UNKNOWN),; AlleleType.UNKNOWN,; ),; ref,; alt,; ). @deprecated(version='0.2.129', reason=""Replaced by the public numeric_allele_type""); @typecheck(ref=expr_str, alt=expr_str); def _num_allele_type(ref, alt) -> Int32Expression:; """"""Provided for backwards compatibility, don't use it in new code, or; within the hail library itself; """"""; return numeric_allele_type(ref, alt). [docs]@typecheck(ref=expr_str, alt=expr_str); def is_snp(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a single nucleotide polymorphism. Examples; --------. >>> hl.eval(hl.is_snp('A', 'T')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.SNP. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_mnp(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a multiple nucleotide polymorphism. Examples; --------. >>> hl.eval(hl.is_mnp('AA', 'GT')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.MNP. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_transition(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a transition. Examples; --------. >>> hl.eval(hl.is_transition('A', 'T')); False. >>> hl.eval(hl.is_transition('AAA', 'AGA')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return is_snp(ref, alt) & _is_snp_transition(ref, alt). [docs]@typecheck(ref=expr_str, alt=expr_str); def is_transversion(ref, alt) -> BooleanExpression:; """"",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:101363,Modifiability,polymorphi,polymorphism,101363," alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute an insertion or deletion. Examples; --------. >>> hl.eval(hl.is_indel('ATT', 'A')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return hl.bind(lambda t: (t == AlleleType.INSERTION) | (t == AlleleType.DELETION), numeric_allele_type(ref, alt)). [docs]@typecheck(ref=expr_str, alt=expr_str); def is_star(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute an upstream deletion. Examples; --------. >>> hl.eval(hl.is_star('A', '*')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.STAR. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_complex(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles constitute a complex polymorphism. Examples; --------. >>> hl.eval(hl.is_complex('ATT', 'GCAC')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.COMPLEX. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_strand_ambiguous(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles are strand ambiguous. Strand ambiguous allele pairs are ``A/T``, ``T/A``,; ``C/G``, and ``G/C`` where the first allele is `ref`; and the second allele is `alt`. Examples; --------. >>> hl.eval(hl.is_strand_ambiguous('A', 'T')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; alleles = hl.literal({('A', 'T'), ('T', 'A'), ('G', 'C",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:102470,Modifiability,polymorphi,polymorphism,102470,"x('ATT', 'GCAC')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; return numeric_allele_type(ref, alt) == AlleleType.COMPLEX. [docs]@typecheck(ref=expr_str, alt=expr_str); def is_strand_ambiguous(ref, alt) -> BooleanExpression:; """"""Returns ``True`` if the alleles are strand ambiguous. Strand ambiguous allele pairs are ``A/T``, ``T/A``,; ``C/G``, and ``G/C`` where the first allele is `ref`; and the second allele is `alt`. Examples; --------. >>> hl.eval(hl.is_strand_ambiguous('A', 'T')); True. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.BooleanExpression`; """"""; alleles = hl.literal({('A', 'T'), ('T', 'A'), ('G', 'C'), ('C', 'G')}); return alleles.contains((ref, alt)). [docs]@typecheck(ref=expr_str, alt=expr_str); def allele_type(ref, alt) -> StringExpression:; """"""Returns the type of the polymorphism as a string. Examples; --------. >>> hl.eval(hl.allele_type('A', 'T')); 'SNP'. >>> hl.eval(hl.allele_type('ATT', 'A')); 'Deletion'. Notes; -----; The possible return values are:; - ``""SNP""``; - ``""MNP""``; - ``""Insertion""``; - ``""Deletion""``; - ``""Complex""``; - ``""Star""``; - ``""Symbolic""``; - ``""Unknown""``. Parameters; ----------; ref : :class:`.StringExpression`; Reference allele.; alt : :class:`.StringExpression`; Alternate allele. Returns; -------; :class:`.StringExpression`; """"""; return hl.literal(AlleleType.strings())[numeric_allele_type(ref, alt)]. [docs]@typecheck(s1=expr_str, s2=expr_str); def hamming(s1, s2) -> Int32Expression:; """"""Returns the Hamming distance between the two strings. Examples; --------. >>> hl.eval(hl.hamming('ATATA', 'ATGCA')); 2. >>> hl.eval(hl.hamming('abcdefg', 'zzcdefz')); 3. Notes; -----; This method will fail if the two strings have different length. Parameters; ----------; s1 : :class:`.Strin",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:115833,Modifiability,Extend,ExtendNA,115833,"mulative value of function `f`, with initial value `zero`. Examples; --------; >>> a = [0, 1, 2]. >>> hl.eval(hl.array_scan(lambda i, j: i + j, 0, a)); [0, 0, 1, 3]. Parameters; ----------; f : function ( (:class:`.Expression`, :class:`.Expression`) -> :class:`.Expression`); Function which takes the cumulative value and the next element, and; returns a new value.; zero : :class:`.Expression`; Initial value to pass in as left argument of `f`.; a : :class:`.ArrayExpression`. Returns; -------; :class:`.ArrayExpression`.; """"""; return a.scan(lambda x, y: f(x, y), zero). @typecheck(streams=expr_stream(), fill_missing=bool); def _zip_streams(*streams, fill_missing: bool = False) -> StreamExpression:; n_streams = builtins.len(streams); uids = [Env.get_uid() for _ in builtins.range(n_streams)]; types = [stream._type.element_type for stream in streams]; body_ir = ir.MakeTuple([ir.Ref(uid, type) for uid, type in builtins.zip(uids, types)]); indices, aggregations = unify_all(*streams); behavior = 'ExtendNA' if fill_missing else 'TakeMinLength'; return construct_expr(; ir.StreamZip([s._ir for s in streams], uids, body_ir, behavior),; tstream(ttuple(*(s.dtype.element_type for s in streams))),; indices,; aggregations,; ). [docs]@typecheck(arrays=expr_array(), fill_missing=bool); def zip(*arrays, fill_missing: bool = False) -> ArrayExpression:; """"""Zip together arrays into a single array. Examples; --------. >>> hl.eval(hl.zip([1, 2, 3], [4, 5, 6])); [(1, 4), (2, 5), (3, 6)]. If the arrays are different lengths, the behavior is decided by the `fill_missing` parameter. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300])); [(1, 10, 100)]. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300], fill_missing=True)); [(1, 10, 100), (None, 20, 200), (None, None, 300)]. Notes; -----; The element type of the resulting array is a :class:`.ttuple` with a field; for each array. Parameters; ----------; arrays: : variable-length args of :class:`.ArrayExpression`; Array expressions.; fill_missing : :ob",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:116743,Modifiability,variab,variable-length,116743,"e in builtins.zip(uids, types)]); indices, aggregations = unify_all(*streams); behavior = 'ExtendNA' if fill_missing else 'TakeMinLength'; return construct_expr(; ir.StreamZip([s._ir for s in streams], uids, body_ir, behavior),; tstream(ttuple(*(s.dtype.element_type for s in streams))),; indices,; aggregations,; ). [docs]@typecheck(arrays=expr_array(), fill_missing=bool); def zip(*arrays, fill_missing: bool = False) -> ArrayExpression:; """"""Zip together arrays into a single array. Examples; --------. >>> hl.eval(hl.zip([1, 2, 3], [4, 5, 6])); [(1, 4), (2, 5), (3, 6)]. If the arrays are different lengths, the behavior is decided by the `fill_missing` parameter. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300])); [(1, 10, 100)]. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300], fill_missing=True)); [(1, 10, 100), (None, 20, 200), (None, None, 300)]. Notes; -----; The element type of the resulting array is a :class:`.ttuple` with a field; for each array. Parameters; ----------; arrays: : variable-length args of :class:`.ArrayExpression`; Array expressions.; fill_missing : :obj:`bool`; If ``False``, return an array with length equal to the shortest length; of the `arrays`. If ``True``, return an array equal to the longest; length of the `arrays`, by extending the shorter arrays with missing; values. Returns; -------; :class:`.ArrayExpression`; """"""; return _zip_streams(*(a._to_stream() for a in arrays), fill_missing=fill_missing).to_array(). def _zip_func(*arrays, fill_missing=False, f):; n_arrays = builtins.len(arrays); uids = [Env.get_uid() for _ in builtins.range(n_arrays)]; refs = [; construct_expr(ir.Ref(uid, a.dtype.element_type), a.dtype.element_type, a._indices, a._aggregations); for uid, a in builtins.zip(uids, arrays); ]; body_result = f(*refs); indices, aggregations = unify_all(*arrays, body_result); behavior = 'ExtendNA' if fill_missing else 'TakeMinLength'; return construct_expr(; ir.toArray(ir.StreamZip([ir.toStream(a._ir) for a in arrays], uids, body_resu",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:117009,Modifiability,extend,extending,117009,"e.element_type for s in streams))),; indices,; aggregations,; ). [docs]@typecheck(arrays=expr_array(), fill_missing=bool); def zip(*arrays, fill_missing: bool = False) -> ArrayExpression:; """"""Zip together arrays into a single array. Examples; --------. >>> hl.eval(hl.zip([1, 2, 3], [4, 5, 6])); [(1, 4), (2, 5), (3, 6)]. If the arrays are different lengths, the behavior is decided by the `fill_missing` parameter. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300])); [(1, 10, 100)]. >>> hl.eval(hl.zip([1], [10, 20], [100, 200, 300], fill_missing=True)); [(1, 10, 100), (None, 20, 200), (None, None, 300)]. Notes; -----; The element type of the resulting array is a :class:`.ttuple` with a field; for each array. Parameters; ----------; arrays: : variable-length args of :class:`.ArrayExpression`; Array expressions.; fill_missing : :obj:`bool`; If ``False``, return an array with length equal to the shortest length; of the `arrays`. If ``True``, return an array equal to the longest; length of the `arrays`, by extending the shorter arrays with missing; values. Returns; -------; :class:`.ArrayExpression`; """"""; return _zip_streams(*(a._to_stream() for a in arrays), fill_missing=fill_missing).to_array(). def _zip_func(*arrays, fill_missing=False, f):; n_arrays = builtins.len(arrays); uids = [Env.get_uid() for _ in builtins.range(n_arrays)]; refs = [; construct_expr(ir.Ref(uid, a.dtype.element_type), a.dtype.element_type, a._indices, a._aggregations); for uid, a in builtins.zip(uids, arrays); ]; body_result = f(*refs); indices, aggregations = unify_all(*arrays, body_result); behavior = 'ExtendNA' if fill_missing else 'TakeMinLength'; return construct_expr(; ir.toArray(ir.StreamZip([ir.toStream(a._ir) for a in arrays], uids, body_result._ir, behavior)),; tarray(body_result.dtype),; indices,; aggregations,; ). [docs]@typecheck(a=expr_array(), start=expr_int32, index_first=bool); def enumerate(a, start=0, *, index_first=True):; """"""Returns an array of (index, element) tuples. Examples;",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:117593,Modifiability,Extend,ExtendNA,117593,"20, 200), (None, None, 300)]. Notes; -----; The element type of the resulting array is a :class:`.ttuple` with a field; for each array. Parameters; ----------; arrays: : variable-length args of :class:`.ArrayExpression`; Array expressions.; fill_missing : :obj:`bool`; If ``False``, return an array with length equal to the shortest length; of the `arrays`. If ``True``, return an array equal to the longest; length of the `arrays`, by extending the shorter arrays with missing; values. Returns; -------; :class:`.ArrayExpression`; """"""; return _zip_streams(*(a._to_stream() for a in arrays), fill_missing=fill_missing).to_array(). def _zip_func(*arrays, fill_missing=False, f):; n_arrays = builtins.len(arrays); uids = [Env.get_uid() for _ in builtins.range(n_arrays)]; refs = [; construct_expr(ir.Ref(uid, a.dtype.element_type), a.dtype.element_type, a._indices, a._aggregations); for uid, a in builtins.zip(uids, arrays); ]; body_result = f(*refs); indices, aggregations = unify_all(*arrays, body_result); behavior = 'ExtendNA' if fill_missing else 'TakeMinLength'; return construct_expr(; ir.toArray(ir.StreamZip([ir.toStream(a._ir) for a in arrays], uids, body_result._ir, behavior)),; tarray(body_result.dtype),; indices,; aggregations,; ). [docs]@typecheck(a=expr_array(), start=expr_int32, index_first=bool); def enumerate(a, start=0, *, index_first=True):; """"""Returns an array of (index, element) tuples. Examples; --------. >>> hl.eval(hl.enumerate(['A', 'B', 'C'])); [(0, 'A'), (1, 'B'), (2, 'C')]. >>> hl.eval(hl.enumerate(['A', 'B', 'C'], start=3)); [(3, 'A'), (4, 'B'), (5, 'C')]. >>> hl.eval(hl.enumerate(['A', 'B', 'C'], index_first=False)); [('A', 0), ('B', 1), ('C', 2)]. Parameters; ----------; a : :class:`.ArrayExpression`; start : :class:`.Int32Expression`; The index value from which the counter is started, 0 by default.; index_first: :obj:`bool`; If ``True``, the index is the first value of the element tuples. If; ``False``, the index is the second value. Returns; -------; ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:125612,Modifiability,variab,variable-length,125612,"coercer_from_dtype(unified_typ); indices, aggs = unify_all(*exprs). func_name = name; if filter_missing:; func_name += '_ignore_missing'; if filter_nan and unified_typ in (tfloat32, tfloat64):; func_name = 'nan' + func_name; return construct_expr(; functools.reduce(lambda l, r: ir.Apply(func_name, unified_typ, l, r), [ec.coerce(e)._ir for e in exprs]),; unified_typ,; indices,; aggs,; ). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def nanmax(*exprs, filter_missing: builtins.bool = True) -> NumericExpression:; """"""Returns the maximum value of a collection or of given arguments, excluding NaN. Examples; --------. Compute the maximum value of an array:. >>> hl.eval(hl.nanmax([1.1, 50.1, float('nan')])); 50.1. Take the maximum value of arguments:. >>> hl.eval(hl.nanmax(1.1, 50.1, float('nan'))); 50.1. Notes; -----; Like the Python builtin ``max`` function, this function can either take a; single iterable expression (an array or set of numeric elements), or; variable-length arguments of numeric expressions. Note; ----; If `filter_missing` is ``True``, then the result is the maximum of; non-missing arguments or elements. If `filter_missing` is ``False``, then; any missing argument or element causes the result to be missing. NaN arguments / array elements are ignored; the maximum value of `NaN` and; any non-`NaN` value `x` is `x`. See Also; --------; :func:`max`, :func:`min`, :func:`nanmin`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing maximum. Returns; -------; :class:`.NumericExpression`; """""". return _comparison_func('max', exprs, filter_missing, filter_nan=True). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filt",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:127073,Modifiability,variab,variable-length,127073,"max`, :func:`min`, :func:`nanmin`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing maximum. Returns; -------; :class:`.NumericExpression`; """""". return _comparison_func('max', exprs, filter_missing, filter_nan=True). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def max(*exprs, filter_missing: builtins.bool = True) -> NumericExpression:; """"""Returns the maximum element of a collection or of given numeric expressions. Examples; --------. Take the maximum value of an array:. >>> hl.eval(hl.max([1, 3, 5, 6, 7, 9])); 9. Take the maximum value of values:. >>> hl.eval(hl.max(1, 50, 2)); 50. Notes; -----; Like the Python builtin ``max`` function, this function can either take a; single iterable expression (an array or set of numeric elements), or; variable-length arguments of numeric expressions. Note; ----; If `filter_missing` is ``True``, then the result is the maximum of; non-missing arguments or elements. If `filter_missing` is ``False``, then; any missing argument or element causes the result to be missing. If any element or argument is `NaN`, then the result is `NaN`. See Also; --------; :func:`nanmax`, :func:`min`, :func:`nanmin`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing maximum. Returns; -------; :class:`.NumericExpression`; """"""; return _comparison_func('max', exprs, filter_missing, filter_nan=False). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def nanmin(*",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:128536,Modifiability,variab,variable-length,128536,"s; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing maximum. Returns; -------; :class:`.NumericExpression`; """"""; return _comparison_func('max', exprs, filter_missing, filter_nan=False). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def nanmin(*exprs, filter_missing: builtins.bool = True) -> NumericExpression:; """"""Returns the minimum value of a collection or of given arguments, excluding NaN. Examples; --------. Compute the minimum value of an array:. >>> hl.eval(hl.nanmin([1.1, 50.1, float('nan')])); 1.1. Take the minimum value of arguments:. >>> hl.eval(hl.nanmin(1.1, 50.1, float('nan'))); 1.1. Notes; -----; Like the Python builtin ``min`` function, this function can either take a; single iterable expression (an array or set of numeric elements), or; variable-length arguments of numeric expressions. Note; ----; If `filter_missing` is ``True``, then the result is the minimum of; non-missing arguments or elements. If `filter_missing` is ``False``, then; any missing argument or element causes the result to be missing. NaN arguments / array elements are ignored; the minimum value of `NaN` and; any non-`NaN` value `x` is `x`. See Also; --------; :func:`min`, :func:`max`, :func:`nanmax`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing minimum. Returns; -------; :class:`.NumericExpression`; """""". return _comparison_func('min', exprs, filter_missing, filter_nan=True). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filt",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:129999,Modifiability,variab,variable-length,129999,"n`, :func:`max`, :func:`nanmax`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing minimum. Returns; -------; :class:`.NumericExpression`; """""". return _comparison_func('min', exprs, filter_missing, filter_nan=True). [docs]@typecheck(; exprs=expr_oneof(expr_numeric, expr_set(expr_numeric), expr_array(expr_numeric)), filter_missing=builtins.bool; ); def min(*exprs, filter_missing: builtins.bool = True) -> NumericExpression:; """"""Returns the minimum element of a collection or of given numeric expressions. Examples; --------. Take the minimum value of an array:. >>> hl.eval(hl.min([1, 3, 5, 6, 7, 9])); 1. Take the minimum value of arguments:. >>> hl.eval(hl.min(1, 50, 2)); 1. Notes; -----; Like the Python builtin ``min`` function, this function can either take a; single iterable expression (an array or set of numeric elements), or; variable-length arguments of numeric expressions. Note; ----; If `filter_missing` is ``True``, then the result is the minimum of; non-missing arguments or elements. If `filter_missing` is ``False``, then; any missing argument or element causes the result to be missing. If any element or argument is `NaN`, then the result is `NaN`. See Also; --------; :func:`nanmin`, :func:`max`, :func:`nanmax`. Parameters; ----------; exprs : :class:`.ArrayExpression` or :class:`.SetExpression` or varargs of :class:`.NumericExpression`; Single numeric array or set, or multiple numeric values.; filter_missing : :obj:`bool`; Remove missing arguments/elements before computing minimum. Returns; -------; :class:`.NumericExpression`; """"""; return _comparison_func('min', exprs, filter_missing, filter_nan=False). [docs]@typecheck(x=expr_oneof(expr_numeric, expr_array(expr_numeric), expr_ndarray(expr_numeric))); def abs(x):; """"""Take the absolute value of a n",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:168248,Modifiability,polymorphi,polymorphism,168248,"& (child_n == 1), 1); .when((father_n == 0) & (mother_n == 0) & (child_n == 1), 2); .when((father_n == 0) & (mother_n == 0) & (child_n == 2), 5); .when((father_n == 2) & (mother_n == 2) & (child_n == 0), 8); .when((father_n == 0) & (child_n == 2), 3); .when((mother_n == 0) & (child_n == 2), 4); .when((father_n == 2) & (child_n == 0), 6); .when((mother_n == 2) & (child_n == 0), 7); .or_missing(); ). hemi_x_cond = (; hl.case(missing_false=True); .when((mother_n == 2) & (child_n == 0), 9); .when((mother_n == 0) & (child_n > 0), 10); .or_missing(); ). hemi_y_cond = (; hl.case(missing_false=True); .when((father_n > 0) & (child_n == 0), 11); .when((father_n == 0) & (child_n > 0), 12); .or_missing(); ). return (; hl.case(); .when(locus.in_autosome_or_par() | is_female, auto_cond); .when(locus.in_x_nonpar() & (~is_female), hemi_x_cond); .when(locus.in_y_nonpar() & (~is_female), hemi_y_cond); .or_missing(); ). [docs]@typecheck(locus=expr_locus(), alleles=expr_array(expr_str)); def min_rep(locus, alleles):; """"""Computes the minimal representation of a (locus, alleles) polymorphism. Examples; --------. >>> hl.eval(hl.min_rep(hl.locus('1', 100000), ['TAA', 'TA'])); Struct(locus=Locus(contig=1, position=100000, reference_genome=GRCh37), alleles=['TA', 'T']). >>> hl.eval(hl.min_rep(hl.locus('1', 100000), ['AATAA', 'AACAA'])); Struct(locus=Locus(contig=1, position=100002, reference_genome=GRCh37), alleles=['T', 'C']). Notes; -----; Computing the minimal representation can cause the locus shift right (the; position can increase). Parameters; ----------; locus : :class:`.LocusExpression`; alleles : :class:`.ArrayExpression` of type :py:data:`.tstr`. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `locus`; (:class:`.LocusExpression`) and `alleles`; (:class:`.ArrayExpression` of type :py:data:`.tstr`).; """"""; ret_type = tstruct(locus=locus.dtype, alleles=alleles.dtype); return _func('min_rep', ret_type, locus, alleles). [docs]@typecheck(; x=o",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:176515,Modifiability,variab,variable-length,176515,"ot': min must be less than max in call to uniroot, got: min %.1e, max %.1e"", min, max)); ). [docs]@typecheck(f=expr_str, args=expr_any); def format(f, *args):; """"""Returns a formatted string using a specified format string and arguments. Examples; --------. >>> hl.eval(hl.format('%.3e', 0.09345332)); '9.345e-02'. >>> hl.eval(hl.format('%.4f', hl.missing(hl.tfloat64))); 'null'. >>> hl.eval(hl.format('%s %s %s', 'hello', hl.tuple([3, hl.locus('1', 2453)]), True)); 'hello (3, 1:2453) true'. Notes; -----; See the `Java documentation <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__; for valid format specifiers and arguments. Missing values are printed as ``'null'`` except when using the; format flags `'b'` and `'B'` (printed as ``'false'`` instead). Parameters; ----------; f : :class:`.StringExpression`; Java `format string <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#syntax>`__.; args : variable-length arguments of :class:`.Expression`; Arguments to format. Returns; -------; :class:`.StringExpression`; """""". return _func(""format"", hl.tstr, f, hl.tuple(args)). [docs]@typecheck(x=expr_float64, y=expr_float64, tolerance=expr_float64, absolute=expr_bool, nan_same=expr_bool); def approx_equal(x, y, tolerance=1e-6, absolute=False, nan_same=False):; """"""Tests whether two numbers are approximately equal. Examples; --------; >>> hl.eval(hl.approx_equal(0.25, 0.2500001)); True. >>> hl.eval(hl.approx_equal(0.25, 0.251, tolerance=1e-3, absolute=True)); False. Parameters; ----------; x : :class:`.NumericExpression`; y : :class:`.NumericExpression`; tolerance : :class:`.NumericExpression`; absolute : :class:`.BooleanExpression`; If True, compute ``abs(x - y) <= tolerance``. Otherwise, compute; ``abs(x - y) <= max(tolerance * max(abs(x), abs(y)), 2 ** -1022)``.; nan_same : :class:`.BooleanExpression`; If True, then ``NaN == NaN`` will evaluate to True. Otherwise,; it will return False. Returns; ----",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:180505,Modifiability,extend,extended,180505,"ion` or :class:`.Int64Expression`. Returns; -------; :class:`.Int32Expression` or :class:`.Int64Expression`; """"""; return _bit_op(x, y, '|'). [docs]@typecheck(x=expr_oneof(expr_int32, expr_int64), y=expr_oneof(expr_int32, expr_int64)); def bit_xor(x, y):; """"""Bitwise exclusive-or `x` and `y`. Examples; --------; >>> hl.eval(hl.bit_xor(5, 3)); 6. Notes; -----; See `the Python wiki <https://wiki.python.org/moin/BitwiseOperators>`__; for more information about bit operators. Parameters; ----------; x : :class:`.Int32Expression` or :class:`.Int64Expression`; y : :class:`.Int32Expression` or :class:`.Int64Expression`. Returns; -------; :class:`.Int32Expression` or :class:`.Int64Expression`; """"""; return _bit_op(x, y, '^'). [docs]@typecheck(x=expr_oneof(expr_int32, expr_int64), y=expr_int32); def bit_lshift(x, y):; """"""Bitwise left-shift `x` by `y`. Examples; --------; >>> hl.eval(hl.bit_lshift(5, 3)); 40. >>> hl.eval(hl.bit_lshift(1, 8)); 256. Unlike Python, Hail integers are fixed-size (32 or 64 bits),; and bits extended beyond will be ignored:. >>> hl.eval(hl.bit_lshift(1, 31)); -2147483648. >>> hl.eval(hl.bit_lshift(1, 32)); 0. >>> hl.eval(hl.bit_lshift(hl.int64(1), 32)); 4294967296. >>> hl.eval(hl.bit_lshift(hl.int64(1), 64)); 0. Notes; -----; See `the Python wiki <https://wiki.python.org/moin/BitwiseOperators>`__; for more information about bit operators. Parameters; ----------; x : :class:`.Int32Expression` or :class:`.Int64Expression`; y : :class:`.Int32Expression` or :class:`.Int64Expression`. Returns; -------; :class:`.Int32Expression` or :class:`.Int64Expression`; """"""; return _shift_op(x, y, '<<'). [docs]@typecheck(x=expr_oneof(expr_int32, expr_int64), y=expr_int32, logical=builtins.bool); def bit_rshift(x, y, logical=False):; """"""Bitwise right-shift `x` by `y`. Examples; --------; >>> hl.eval(hl.bit_rshift(256, 3)); 32. With ``logical=False`` (default), the sign is preserved:. >>> hl.eval(hl.bit_rshift(-1, 1)); -1. With ``logical=True``, the sign bit is treated as a",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:19182,Performance,Perform,Performs,19182,"alue_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. This is :func:`.bind` with flipped argument order. Examples; --------. >>> hl.eval(hl.rbind(1, lambda x: x + 1)); 2. :func:`.rbind` also can take multiple arguments:. >>> hl.eval(hl.rbind(4.0, 2.0, lambda x, y: x / y)); 2.0. Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Expressions to bind.; f : function ( (args) -> :class:`.Expression`); Function of `exprs`. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """""". *args, f = exprs; args = [expr_any.check(arg, 'rbind', f'argument {index}') for index, arg in builtins.enumerate(args)]. return hl.bind(f, *args, _ctx=_ctx). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def chi_squared_test(c1, c2, c3, c4) -> StructExpression:; """"""Performs chi-squared test of independence on a 2x2 contingency table. Examples; --------. >>> hl.eval(hl.chi_squared_test(10, 10, 10, 10)); Struct(p_value=1.0, odds_ratio=1.0). >>> hl.eval(hl.chi_squared_test(51, 43, 22, 92)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). Notes; -----; The odds ratio is given by ``(c1 / c2) / (c3 / c4)``. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, o",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:20416,Performance,Perform,Performs,20416,".eval(hl.chi_squared_test(51, 43, 22, 92)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). Notes; -----; The odds ratio is given by ``(c1 / c2) / (c3 / c4)``. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""chi_squared_test"", ret_type, c1, c2, c3, c4). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32, min_cell_count=expr_int32); def contingency_table_test(c1, c2, c3, c4, min_cell_count) -> StructExpression:; """"""Performs chi-squared or Fisher's exact test of independence on a 2x2; contingency table. Examples; --------. >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=22)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=23)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967). Notes; -----; If all cell counts are at least `min_cell_count`, the chi-squared test is; used. Otherwise, Fisher's exact test is used. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :cla",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:22174,Performance,Perform,Perform,22174,":data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :class:`.Expression` of type :py:data:`.tint32`; Minimum count in every cell to use the chi-squared test. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""contingency_table_test"", ret_type, c1, c2, c3, c4, min_cell_count). # We use 64-bit integers.; # It is relatively easy to encounter an integer overflow bug with 32-bit integers.; [docs]@typecheck(a=expr_array(expr_int64), b=expr_array(expr_int64), c=expr_array(expr_int64), d=expr_array(expr_int64)); def cochran_mantel_haenszel_test(; a: Union[tarray, list], b: Union[tarray, list], c: Union[tarray, list], d: Union[tarray, list]; ) -> StructExpression:; """"""Perform the Cochran-Mantel-Haenszel test for association. Examples; --------; >>> a = [56, 61, 73, 71]; >>> b = [69, 257, 65, 48]; >>> c = [40, 57, 71, 55]; >>> d = [77, 301, 79, 48]; >>> hl.eval(hl.cochran_mantel_haenszel_test(a, b, c, d)); Struct(test_statistic=5.0496881823306765, p_value=0.024630370456863417). >>> mt = ds.filter_rows(mt.locus == hl.Locus(20, 10633237)); >>> mt.count_rows(); 1; >>> a, b, c, d = mt.aggregate_entries(; ... hl.tuple([; ... hl.array([hl.agg.count_where(mt.GT.is_non_ref() & mt.pheno.is_case & mt.pheno.is_female), hl.agg.count_where(mt.GT.is_non_ref() & mt.pheno.is_case & ~mt.pheno.is_female)]),; ... hl.array([hl.agg.count_where(mt.GT.is_non_ref() & ~mt.pheno.is_case & mt.pheno.is_female), hl.agg.count_where(mt.GT.is_non_ref() & ~mt.pheno.is_case & ~mt.pheno.is_female)]),; ... hl.array([hl.agg.count_where(~mt.GT.is_non_ref() & mt.pheno.is_case & ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:33807,Performance,Perform,Performs,33807,"ss than or equal to `x`. Examples; --------. >>> hl.eval(hl.floor(3.1)); 3.0. Parameters; ----------; x : :class:`.Float32Expression`, :class:`.Float64Expression`, or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Float32Expression`, :class:`.Float64Expression`, or :class:`.NDArrayNumericExpression`; """"""; return _func(""floor"", x.dtype, x). [docs]@typecheck(x=expr_oneof(expr_float32, expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def ceil(x):; """"""The smallest integral value that is greater than or equal to `x`. Examples; --------. >>> hl.eval(hl.ceil(3.1)); 4.0. Parameters; ----------; x : :class:`.Float32Expression`,:class:`.Float64Expression` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Float32Expression`, :class:`.Float64Expression`, or :class:`.NDArrayNumericExpression`; """"""; return _func(""ceil"", x.dtype, x). [docs]@typecheck(n_hom_ref=expr_int32, n_het=expr_int32, n_hom_var=expr_int32, one_sided=expr_bool); def hardy_weinberg_test(n_hom_ref, n_het, n_hom_var, one_sided=False) -> StructExpression:; """"""Performs test of Hardy-Weinberg equilibrium. Examples; --------. >>> hl.eval(hl.hardy_weinberg_test(250, 500, 250)); Struct(het_freq_hwe=0.5002501250625313, p_value=0.9747844394217698). >>> hl.eval(hl.hardy_weinberg_test(37, 200, 85)); Struct(het_freq_hwe=0.48964964307448583, p_value=1.1337210383168987e-06). Notes; -----; By default, this method performs a two-sided exact test with mid-p-value correction of; `Hardy-Weinberg equilibrium <https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle>`__; via an efficient implementation of the; `Levene-Haldane distribution <../_static/LeveneHaldane.pdf>`__,; which models the number of heterozygous individuals under equilibrium. The mean of this distribution is ``(n_ref * n_var) / (2n - 1)``, where; ``n_ref = 2*n_hom_ref + n_het`` is the number of reference alleles,; ``n_var = 2*n_hom_var + n_het`` is the number of variant alleles,; and ``n = n_hom_ref + n_het + n",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:34155,Performance,perform,performs,34155,"oadcasting; def ceil(x):; """"""The smallest integral value that is greater than or equal to `x`. Examples; --------. >>> hl.eval(hl.ceil(3.1)); 4.0. Parameters; ----------; x : :class:`.Float32Expression`,:class:`.Float64Expression` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Float32Expression`, :class:`.Float64Expression`, or :class:`.NDArrayNumericExpression`; """"""; return _func(""ceil"", x.dtype, x). [docs]@typecheck(n_hom_ref=expr_int32, n_het=expr_int32, n_hom_var=expr_int32, one_sided=expr_bool); def hardy_weinberg_test(n_hom_ref, n_het, n_hom_var, one_sided=False) -> StructExpression:; """"""Performs test of Hardy-Weinberg equilibrium. Examples; --------. >>> hl.eval(hl.hardy_weinberg_test(250, 500, 250)); Struct(het_freq_hwe=0.5002501250625313, p_value=0.9747844394217698). >>> hl.eval(hl.hardy_weinberg_test(37, 200, 85)); Struct(het_freq_hwe=0.48964964307448583, p_value=1.1337210383168987e-06). Notes; -----; By default, this method performs a two-sided exact test with mid-p-value correction of; `Hardy-Weinberg equilibrium <https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle>`__; via an efficient implementation of the; `Levene-Haldane distribution <../_static/LeveneHaldane.pdf>`__,; which models the number of heterozygous individuals under equilibrium. The mean of this distribution is ``(n_ref * n_var) / (2n - 1)``, where; ``n_ref = 2*n_hom_ref + n_het`` is the number of reference alleles,; ``n_var = 2*n_hom_var + n_het`` is the number of variant alleles,; and ``n = n_hom_ref + n_het + n_hom_var`` is the number of individuals.; So the expected frequency of heterozygotes under equilibrium,; `het_freq_hwe`, is this mean divided by ``n``. To perform one-sided exact test of excess heterozygosity with mid-p-value; correction instead, set `one_sided=True` and the p-value returned will be; from the one-sided exact test. Parameters; ----------; n_hom_ref : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous reference g",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:34886,Performance,perform,perform,34886,"0.9747844394217698). >>> hl.eval(hl.hardy_weinberg_test(37, 200, 85)); Struct(het_freq_hwe=0.48964964307448583, p_value=1.1337210383168987e-06). Notes; -----; By default, this method performs a two-sided exact test with mid-p-value correction of; `Hardy-Weinberg equilibrium <https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle>`__; via an efficient implementation of the; `Levene-Haldane distribution <../_static/LeveneHaldane.pdf>`__,; which models the number of heterozygous individuals under equilibrium. The mean of this distribution is ``(n_ref * n_var) / (2n - 1)``, where; ``n_ref = 2*n_hom_ref + n_het`` is the number of reference alleles,; ``n_var = 2*n_hom_var + n_het`` is the number of variant alleles,; and ``n = n_hom_ref + n_het + n_hom_var`` is the number of individuals.; So the expected frequency of heterozygotes under equilibrium,; `het_freq_hwe`, is this mean divided by ``n``. To perform one-sided exact test of excess heterozygosity with mid-p-value; correction instead, set `one_sided=True` and the p-value returned will be; from the one-sided exact test. Parameters; ----------; n_hom_ref : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous reference genotypes.; n_het : int or :class:`.Expression` of type :py:data:`.tint32`; Number of heterozygous genotypes.; n_hom_var : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous variant genotypes.; one_sided : :obj:`bool`; ``False`` by default. When ``True``, perform one-sided test for excess heterozygosity. Returns; -------; :class:`.StructExpression`; A struct expression with two fields, `het_freq_hwe`; (:py:data:`.tfloat64`) and `p_value` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(het_freq_hwe=tfloat64, p_value=tfloat64); return _func(""hardy_weinberg_test"", ret_type, n_hom_ref, n_het, n_hom_var, one_sided). [docs]@typecheck(contig=expr_str, pos=expr_int32, reference_genome=reference_genome_type); def locus(contig, pos, reference_genome: Union[st",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:35469,Performance,perform,perform,35469,"brium. The mean of this distribution is ``(n_ref * n_var) / (2n - 1)``, where; ``n_ref = 2*n_hom_ref + n_het`` is the number of reference alleles,; ``n_var = 2*n_hom_var + n_het`` is the number of variant alleles,; and ``n = n_hom_ref + n_het + n_hom_var`` is the number of individuals.; So the expected frequency of heterozygotes under equilibrium,; `het_freq_hwe`, is this mean divided by ``n``. To perform one-sided exact test of excess heterozygosity with mid-p-value; correction instead, set `one_sided=True` and the p-value returned will be; from the one-sided exact test. Parameters; ----------; n_hom_ref : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous reference genotypes.; n_het : int or :class:`.Expression` of type :py:data:`.tint32`; Number of heterozygous genotypes.; n_hom_var : int or :class:`.Expression` of type :py:data:`.tint32`; Number of homozygous variant genotypes.; one_sided : :obj:`bool`; ``False`` by default. When ``True``, perform one-sided test for excess heterozygosity. Returns; -------; :class:`.StructExpression`; A struct expression with two fields, `het_freq_hwe`; (:py:data:`.tfloat64`) and `p_value` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(het_freq_hwe=tfloat64, p_value=tfloat64); return _func(""hardy_weinberg_test"", ret_type, n_hom_ref, n_het, n_hom_var, one_sided). [docs]@typecheck(contig=expr_str, pos=expr_int32, reference_genome=reference_genome_type); def locus(contig, pos, reference_genome: Union[str, ReferenceGenome] = 'default') -> LocusExpression:; """"""Construct a locus expression from a chromosome and position. Examples; --------. >>> hl.eval(hl.locus(""1"", 10000, reference_genome='GRCh37')); Locus(contig=1, position=10000, reference_genome=GRCh37). Parameters; ----------; contig : str or :class:`.StringExpression`; Chromosome.; pos : int or :class:`.Expression` of type :py:data:`.tint32`; Base position along the chromosome.; reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference gen",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:60727,Performance,Perform,Performs,60727,"rns; -------; :class:`.Expression`; """"""; a, b, success = unify_exprs(a, b); if not success:; raise TypeError(; f""'or_else' requires the 'a' and 'b' arguments to have the same type\n""; f"" a: type '{a.dtype}'\n""; f"" b: type '{b.dtype}'""; ); return coalesce(a, b). [docs]@typecheck(predicate=expr_bool, value=expr_any); def or_missing(predicate, value):; """"""Returns `value` if `predicate` is ``True``, otherwise returns missing. Examples; --------. >>> hl.eval(hl.or_missing(True, 5)); 5. >>> hl.eval(hl.or_missing(False, 5)); None. Parameters; ----------; predicate : :class:`.BooleanExpression`; value : :class:`.Expression`; Value to return if `predicate` is ``True``. Returns; -------; :class:`.Expression`; This expression has the same type as `b`.; """""". return hl.if_else(predicate, value, hl.missing(value.dtype)). [docs]@typecheck(; x=expr_int32, n=expr_int32, p=expr_float64, alternative=enumeration(""two.sided"", ""two-sided"", ""greater"", ""less""); ); def binom_test(x, n, p, alternative: str) -> Float64Expression:; """"""Performs a binomial test on `p` given `x` successes in `n` trials. Returns the p-value from the `exact binomial test; <https://en.wikipedia.org/wiki/Binomial_test>`__ of the null hypothesis that; success has probability `p`, given `x` successes in `n` trials. The alternatives are interpreted as follows:; - ``'less'``: a one-tailed test of the significance of `x` or fewer successes,; - ``'greater'``: a one-tailed test of the significance of `x` or more successes, and; - ``'two-sided'``: a two-tailed test of the significance of `x` or any equivalent or more unlikely outcome. Examples; --------. All the examples below use a fair coin as the null hypothesis. Zero is; interpreted as tail and one as heads. Test if a coin is biased towards heads or tails after observing two heads; out of ten flips:. >>> hl.eval(hl.binom_test(2, 10, 0.5, 'two-sided')); 0.10937499999999994. Test if a coin is biased towards tails after observing four heads out of ten; flips:. >>> hl.eval(h",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:160651,Performance,load,load,160651,", pair adenine (A) with uracil (U) instead of thymine (T). Returns; -------; :class:`.StringExpression`; """"""; s = s.reverse(). if rna:; pairs = [('A', 'U'), ('U', 'A'), ('T', 'A'), ('G', 'C'), ('C', 'G')]; else:; pairs = [('A', 'T'), ('T', 'A'), ('G', 'C'), ('C', 'G')]. d = {}; for b1, b2 in pairs:; d[b1] = b2; d[b1.lower()] = b2.lower(). return s.translate(d). [docs]@typecheck(; contig=expr_str, position=expr_int32, before=expr_int32, after=expr_int32, reference_genome=reference_genome_type; ); def get_sequence(contig, position, before=0, after=0, reference_genome='default') -> StringExpression:; """"""Return the reference sequence at a given locus. Examples; --------. Return the reference allele for ``'GRCh37'`` at the locus ``'1:45323'``:. >>> hl.eval(hl.get_sequence('1', 45323, reference_genome='GRCh37')) # doctest: +SKIP; ""T"". Notes; -----; This function requires `reference genome` has an attached; reference sequence. Use :meth:`.ReferenceGenome.add_sequence` to; load and attach a reference sequence to a reference genome. Returns ``None`` if `contig` and `position` are not valid coordinates in; `reference_genome`. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; Locus contig.; position : :class:`.Expression` of type :py:data:`.tint32`; Locus position.; before : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include before the locus of interest. Truncates at; contig boundary.; after : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include after the locus of interest. Truncates at; contig boundary.; reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to use. Must have a reference sequence available. Returns; -------; :class:`.StringExpression`; """""". if not reference_genome.has_sequence():; raise TypeError(; ""Reference genome '{}' does not have a sequence loaded. Use 'add_sequence' to load the sequence from a FASTA file."".format(; reference_genome.na",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:161576,Performance,load,loaded,161576,"n requires `reference genome` has an attached; reference sequence. Use :meth:`.ReferenceGenome.add_sequence` to; load and attach a reference sequence to a reference genome. Returns ``None`` if `contig` and `position` are not valid coordinates in; `reference_genome`. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; Locus contig.; position : :class:`.Expression` of type :py:data:`.tint32`; Locus position.; before : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include before the locus of interest. Truncates at; contig boundary.; after : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include after the locus of interest. Truncates at; contig boundary.; reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to use. Must have a reference sequence available. Returns; -------; :class:`.StringExpression`; """""". if not reference_genome.has_sequence():; raise TypeError(; ""Reference genome '{}' does not have a sequence loaded. Use 'add_sequence' to load the sequence from a FASTA file."".format(; reference_genome.name; ); ). return _func(""getReferenceSequence"", tstr, contig, position, before, after, type_args=(tlocus(reference_genome),)). [docs]@typecheck(contig=expr_str, reference_genome=reference_genome_type); def is_valid_contig(contig, reference_genome='default') -> BooleanExpression:; """"""Returns ``True`` if `contig` is a valid contig name in `reference_genome`. Examples; --------. >>> hl.eval(hl.is_valid_contig('1', reference_genome='GRCh37')); True. >>> hl.eval(hl.is_valid_contig('chr1', reference_genome='GRCh37')); False. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; reference_genome : :class:`str` or :class:`.ReferenceGenome`. Returns; -------; :class:`.BooleanExpression`; """"""; return _func(""isValidContig"", tbool, contig, type_args=(tlocus(reference_genome),)). [docs]@typecheck(contig=expr_str, reference_genome=reference_ge",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:161606,Performance,load,load,161606,"th:`.ReferenceGenome.add_sequence` to; load and attach a reference sequence to a reference genome. Returns ``None`` if `contig` and `position` are not valid coordinates in; `reference_genome`. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; Locus contig.; position : :class:`.Expression` of type :py:data:`.tint32`; Locus position.; before : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include before the locus of interest. Truncates at; contig boundary.; after : :class:`.Expression` of type :py:data:`.tint32`, optional; Number of bases to include after the locus of interest. Truncates at; contig boundary.; reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to use. Must have a reference sequence available. Returns; -------; :class:`.StringExpression`; """""". if not reference_genome.has_sequence():; raise TypeError(; ""Reference genome '{}' does not have a sequence loaded. Use 'add_sequence' to load the sequence from a FASTA file."".format(; reference_genome.name; ); ). return _func(""getReferenceSequence"", tstr, contig, position, before, after, type_args=(tlocus(reference_genome),)). [docs]@typecheck(contig=expr_str, reference_genome=reference_genome_type); def is_valid_contig(contig, reference_genome='default') -> BooleanExpression:; """"""Returns ``True`` if `contig` is a valid contig name in `reference_genome`. Examples; --------. >>> hl.eval(hl.is_valid_contig('1', reference_genome='GRCh37')); True. >>> hl.eval(hl.is_valid_contig('chr1', reference_genome='GRCh37')); False. Parameters; ----------; contig : :class:`.Expression` of type :py:data:`.tstr`; reference_genome : :class:`str` or :class:`.ReferenceGenome`. Returns; -------; :class:`.BooleanExpression`; """"""; return _func(""isValidContig"", tbool, contig, type_args=(tlocus(reference_genome),)). [docs]@typecheck(contig=expr_str, reference_genome=reference_genome_type); def contig_length(contig, reference_genome='default') -> Int32E",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:170267,Performance,load,loaded,170267,"ome=reference_genome_type,; min_match=builtins.float,; include_strand=builtins.bool,; ); def liftover(x, dest_reference_genome, min_match=0.95, include_strand=False):; """"""Lift over coordinates to a different reference genome. Examples; --------. Lift over the locus coordinates from reference genome ``'GRCh37'`` to; ``'GRCh38'``:. >>> hl.eval(hl.liftover(hl.locus('1', 1034245, 'GRCh37'), 'GRCh38')) # doctest: +SKIP; Locus(contig='chr1', position=1098865, reference_genome='GRCh38'). Lift over the locus interval coordinates from reference genome ``'GRCh37'``; to ``'GRCh38'``:. >>> hl.eval(hl.liftover(hl.locus_interval('20', 60001, 82456, True, True, 'GRCh37'), 'GRCh38')) # doctest: +SKIP; Interval(Locus(contig='chr20', position=79360, reference_genome='GRCh38'),; Locus(contig='chr20', position=101815, reference_genome='GRCh38'),; True,; True). See :ref:`liftover_howto` for more instructions on lifting over a Table; or MatrixTable. Notes; -----; This function requires the reference genome of `x` has a chain file loaded; for `dest_reference_genome`. Use :meth:`.ReferenceGenome.add_liftover` to; load and attach a chain file to a reference genome. Returns ``None`` if `x` could not be converted. Warning; -------; Before using the result of :func:`.liftover` as a new row key or column; key, be sure to filter out missing values. Parameters; ----------; x : :class:`.Expression` of type :class:`.tlocus` or :class:`.tinterval` of :class:`.tlocus`; Locus or locus interval to lift over.; dest_reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to convert to.; min_match : :obj:`float`; Minimum ratio of bases that must remap.; include_strand : :obj:`bool`; If True, output the result as a :class:`.StructExpression` with the first field `result` being; the locus or locus interval and the second field `is_negative_strand` is a boolean indicating; whether the locus or locus interval has been mapped to the negative strand of the destination; reference genome. Ot",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:170350,Performance,load,load,170350,"ome, min_match=0.95, include_strand=False):; """"""Lift over coordinates to a different reference genome. Examples; --------. Lift over the locus coordinates from reference genome ``'GRCh37'`` to; ``'GRCh38'``:. >>> hl.eval(hl.liftover(hl.locus('1', 1034245, 'GRCh37'), 'GRCh38')) # doctest: +SKIP; Locus(contig='chr1', position=1098865, reference_genome='GRCh38'). Lift over the locus interval coordinates from reference genome ``'GRCh37'``; to ``'GRCh38'``:. >>> hl.eval(hl.liftover(hl.locus_interval('20', 60001, 82456, True, True, 'GRCh37'), 'GRCh38')) # doctest: +SKIP; Interval(Locus(contig='chr20', position=79360, reference_genome='GRCh38'),; Locus(contig='chr20', position=101815, reference_genome='GRCh38'),; True,; True). See :ref:`liftover_howto` for more instructions on lifting over a Table; or MatrixTable. Notes; -----; This function requires the reference genome of `x` has a chain file loaded; for `dest_reference_genome`. Use :meth:`.ReferenceGenome.add_liftover` to; load and attach a chain file to a reference genome. Returns ``None`` if `x` could not be converted. Warning; -------; Before using the result of :func:`.liftover` as a new row key or column; key, be sure to filter out missing values. Parameters; ----------; x : :class:`.Expression` of type :class:`.tlocus` or :class:`.tinterval` of :class:`.tlocus`; Locus or locus interval to lift over.; dest_reference_genome : :class:`str` or :class:`.ReferenceGenome`; Reference genome to convert to.; min_match : :obj:`float`; Minimum ratio of bases that must remap.; include_strand : :obj:`bool`; If True, output the result as a :class:`.StructExpression` with the first field `result` being; the locus or locus interval and the second field `is_negative_strand` is a boolean indicating; whether the locus or locus interval has been mapped to the negative strand of the destination; reference genome. Otherwise, output the converted locus or locus interval. Returns; -------; :class:`.Expression`; A locus or locus interval co",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:172050,Performance,load,load,172050,"s interval and the second field `is_negative_strand` is a boolean indicating; whether the locus or locus interval has been mapped to the negative strand of the destination; reference genome. Otherwise, output the converted locus or locus interval. Returns; -------; :class:`.Expression`; A locus or locus interval converted to `dest_reference_genome`.; """""". if not 0.0 <= min_match <= 1.0:; raise TypeError(""'liftover' requires 'min_match' is in the range [0, 1]. Got {}"".format(min_match)). if isinstance(x.dtype, tlocus):; rg = x.dtype.reference_genome; method_name = ""liftoverLocus""; rtype = tstruct(result=tlocus(dest_reference_genome), is_negative_strand=tbool); else:; rg = x.dtype.point_type.reference_genome; method_name = ""liftoverLocusInterval""; rtype = tstruct(result=tinterval(tlocus(dest_reference_genome)), is_negative_strand=tbool). if not rg.has_liftover(dest_reference_genome.name):; raise TypeError(; """"""Reference genome '{}' does not have liftover to '{}'.; Use 'add_liftover' to load a liftover chain file."""""".format(rg.name, dest_reference_genome.name); ). expr = _func(method_name, rtype, x, to_expr(min_match, tfloat64)); if not include_strand:; expr = expr.result; return expr. [docs]@typecheck(; f=func_spec(1, expr_float64),; min=expr_float64,; max=expr_float64,; max_iter=builtins.int,; epsilon=builtins.float,; tolerance=builtins.float,; ); def uniroot(f: Callable, min, max, *, max_iter=1000, epsilon=2.2204460492503131e-16, tolerance=1.220703e-4):; """"""Finds a root of the function `f` within the interval `[min, max]`. Examples; --------. >>> hl.eval(hl.uniroot(lambda x: x - 1, -5, 5)); 1.0. Notes; -----; `f(min)` and `f(max)` must not have the same sign. If no root can be found, the result of this call will be `NA` (missing). :func:`.uniroot` returns an estimate for a root with accuracy; `4 * epsilon * abs(x) + tolerance`. 4*EPSILON*abs(x) + tol. Parameters; ----------; f : function ( (arg) -> :class:`.Float64Expression`); Must return a :class:`.Float64Expressio",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:183705,Performance,perform,perform,183705,"~', x._ir), x.dtype, x._indices, x._aggregations). [docs]@typecheck(x=expr_oneof(expr_int32, expr_int64)); def bit_count(x):; """"""Count the number of 1s in the in the `two's complement <https://en.wikipedia.org/wiki/Two%27s_complement>`__ binary representation of `x`. Examples; --------; The binary representation of `7` is `111`, so:. >>> hl.eval(hl.bit_count(7)); 3. Parameters; ----------; x : :class:`.Int32Expression` or :class:`.Int64Expression`. Returns; ----------; :class:`.Int32Expression`; """"""; return construct_expr(ir.ApplyUnaryPrimOp('BitCount', x._ir), tint32, x._indices, x._aggregations). [docs]@typecheck(array=expr_array(expr_numeric), elem=expr_numeric); def binary_search(array, elem) -> Int32Expression:; """"""Binary search `array` for the insertion point of `elem`. Parameters; ----------; array : :class:`.Expression` of type :class:`.tarray`; elem : :class:`.Expression`. Returns; -------; :class:`.Int32Expression`. Notes; -----; This function assumes that `array` is sorted in ascending order, and does; not perform any sortedness check. Missing values sort last. The returned index is the lower bound on the insertion point of `elem` into; the ordered array, or the index of the first element in `array` not smaller; than `elem`. This is a value between 0 and the length of `array`, inclusive; (if all elements in `array` are smaller than `elem`, the returned value is; the length of `array` or the index of the first missing value, if one; exists). If either `elem` or `array` is missing, the result is missing. Examples; --------. >>> a = hl.array([0, 2, 4, 8]). >>> hl.eval(hl.binary_search(a, -1)); 0. >>> hl.eval(hl.binary_search(a, 1)); 1. >>> hl.eval(hl.binary_search(a, 10)); 4. """"""; c = coercer_from_dtype(array.dtype.element_type); if not c.can_coerce(elem.dtype):; raise TypeError(; f""'binary_search': cannot search an array of type {array.dtype} for a value of type {elem.dtype}""; ); elem = c.coerce(elem); return hl.switch(elem).when_missing(hl.missing(hl.tint32",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:71067,Safety,abort,aborting,71067,"d in Python.; mu : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; sigma : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The standard deviation of the normal term.; max_iterations : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The maximum number of iterations of the numerical integration before raising an error. The; default maximum number of iterations is ``1e5``.; min_accuracy : :obj:`int` or :class:`.Expression` of type :py:data:`.tint32`; The minimum accuracy of the returned value. If the minimum accuracy is not achieved, this; function will raise an error. The default minimum accuracy is ``1e-5``. Returns; -------; :class:`.StructExpression`; This method returns a structure with the value as well as information about the numerical; integration. - value : :class:`.Float64Expression`. If converged is true, the value of the CDF evaluated; at `x`. Otherwise, this is the last value the integration evaluated before aborting. - n_iterations : :class:`.Int32Expression`. The number of iterations before stopping. - converged : :class:`.BooleanExpression`. True if the `min_accuracy` was achieved and round; off error is not likely significant. - fault : :class:`.Int32Expression`. If converged is true, fault is zero. If converged is; false, fault is either one or two. One indicates that the requried accuracy was not; achieved. Two indicates the round-off error is possibly significant. """"""; if max_iterations is None:; max_iterations = hl.literal(10_000); if min_accuracy is None:; min_accuracy = hl.literal(1e-5); return _func(""pgenchisq"", PGENCHISQ_RETURN_TYPE, x - mu, w, k, lam, sigma, max_iterations, min_accuracy). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, lower_tail=expr_bool, log_p=expr_bool); def pnorm(x, mu=0, sigma=1, lower_tail=True, log_p=False) -> Float64Expression:; """"""The cumulative probability function of a normal distribution with mean",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:186286,Safety,safe,safeguards,186286,"rray(hl.tint32), hl.tarray(hl.tint32)); return _func(""locus_windows_per_contig"", rt, coords, radius). [docs]@typecheck(a=expr_array(), seed=nullable(builtins.int)); def shuffle(a, seed: Optional[builtins.int] = None) -> ArrayExpression:; """"""Randomly permute an array. Example; -------. >>> hl.reset_global_randomness(); >>> hl.eval(hl.shuffle(hl.range(5))); [4, 0, 2, 1, 3]. Parameters; ----------; a : :class:`.ArrayExpression`; Array to permute.; seed : :obj:`int`, optional; Random seed. Returns; -------; :class:`.ArrayExpression`; """"""; return sorted(a, key=lambda _: hl.rand_unif(0.0, 1.0)). [docs]@typecheck(path=builtins.str, point_or_interval=expr_any); def query_table(path, point_or_interval):; """"""Query records from a table corresponding to a given point or range of keys. Notes; -----; This function does not dispatch to a distributed runtime; it can be used inside; already-distributed queries such as in :meth:`.Table.annotate`. Warning; -------; This function contains no safeguards against reading large amounts of data; using a single thread. Parameters; ----------; path : :class:`str`; Table path.; point_or_interval; Point or interval to query. Returns; -------; :class:`.ArrayExpression`; """"""; table = hl.read_table(path); row_typ = table.row.dtype. key_typ = table.key.dtype; key_names = list(key_typ); len = builtins.len; if len(key_typ) == 0:; raise ValueError(""query_table: cannot query unkeyed table""). def coerce_endpoint(point):; if point.dtype == key_typ[0]:; point = hl.struct(**{key_names[0]: point}); ts = point.dtype; if isinstance(ts, tstruct):; i = 0; while i < len(ts):; if i >= len(key_typ):; raise ValueError(; f""query_table: queried with {len(ts)} key field(s), but table only has {len(key_typ)} key field(s)""; ); if key_typ[i] != ts[i]:; raise ValueError(; f""query_table: key mismatch at key field {i} ({list(ts.keys())[i]!r}): query type is {ts[i]}, table key type is {key_typ[i]}""; ); i += 1. if i == 0:; raise ValueError(""query_table: cannot query with empty",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:69027,Security,access,accessible,69027,"eight vector (our `w`) as; :math:`\lambda` or `lb` and the non-centrality vector (our `lam`) as `nc`. We use the Davies' algorithm which was published as:. `Davies, Robert. ""The distribution of a linear combination of chi-squared random variables.""; Applied Statistics 29 323-333. 1980. <http://www.robertnz.net/pdf/lc_chisq.pdf>`__. Davies included Fortran source code in the original publication. Davies also released a `C; language port <http://www.robertnz.net/QF.htm>`__. Hail's implementation is a fairly direct port; of the C implementation to Scala. Davies provides 39 test cases with the source code. The Hail; tests include all 39 test cases as well as a few additional tests. Davies' website cautions:. The method works well in most situations if you want only modest accuracy, say 0.0001. But; problems may arise if the sum is dominated by one or two terms with a total of only one or; two degrees of freedom and x is small. For an accessible introduction the Generalized Chi-Squared Distribution, we strongly recommend; the introduction of this paper:. `Das, Abhranil; Geisler, Wilson (2020). ""A method to integrate and classify normal; distributions"". <https://arxiv.org/abs/2012.14331>`__. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The value at which to evaluate the cumulative distribution function (CDF).; w : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A weight for each non-central chi-square term.; k : :obj:`list` of :obj:`int` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tint32`; A degrees of freedom parameter for each non-central chi-square term.; lam : :obj:`list` of :obj:`float` or :class:`.Expression` of type :py:class:`.tarray` of :py:data:`.tfloat64`; A non-centrality parameter for each non-central chi-square term. We use `lam` instead; of `lambda` because the latter is a reserved word in Python.; mu : :obj:`float` or :class:`.Exp",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:379,Testability,Log,Log,379,"﻿. Hail | ; hail.expr.functions. 	Fill out the Community Feedback Survey!; . Query Docs. Batch Docs. Forum. Science. Blog. Hail Docs; ; ; ; (0.2); ; ; . ; . Installation; Hail on the Cloud; Tutorials; Reference (Python API); Configuration Reference; Overview; How-To Guides; Cheatsheets; Datasets; Annotation Database; Libraries; For Software Developers; Other Resources; Change Log And Version Policy. menu; Hail. Module code; hail.expr.functions. Source code for hail.expr.functions; import builtins; import functools; import itertools; import operator; from typing import Any, Callable, Iterable, Optional, TypeVar, Union. import numpy as np; import pandas as pd; from deprecated import deprecated. import hail; import hail as hl; from hail import ir; from hail.expr.expressions import (; ArrayExpression,; ArrayNumericExpression,; BooleanExpression,; CallExpression,; DictExpression,; Expression,; ExpressionException,; Float32Expression,; Float64Expression,; Int32Expression,; Int64Expression,; IntervalExpression,; LocusExpression,; NumericExpression,; SetExpression,; StreamExpression,; StringExpression,; StructExpression,; TupleExpression,; apply_expr,; cast_expr,; coercer_from_dtype,; construct_expr,; construct_variable,; expr_any,; expr_array,; expr_bool,; expr_call,; expr_dict,; expr_float32,; expr_float64,; expr_int32,; expr_int64,; expr_interval,; expr_locus,; expr_ndarray,; expr_numeric,; expr_oneof,; expr_set,; expr_str,; expr_stream,; expr_struct,; expr_tuple,; impute_type,; to_expr,; unify_all,; unify_exprs,; unify_types_limited,; ); from hail.expr.types import (; HailType,; hail_type,; is_float32,; is_float64,; is_int32,; is_int64,; is_numeric,; is_primitive,; tarray,; tbool,; tcall,; tdict,; tfloat32,; tfloat64,; tint32,; tint64,; tinterval,; tlocus,; tndarray,; trngstate,; tset,; tstr,; tstream,; tstruct,; ttuple,; ); from hail.genetics.allele_type import AlleleType; from hail.genetics.reference_genome import ReferenceGenome, reference_genome_type; from hail.typec",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:5904,Testability,log,log,5904,"int32)); return _func('approxCDFCombine', t, k, left, right). @typecheck(cdf=expr_struct(), failure_prob=expr_oneof(expr_float32, expr_float64), all_quantiles=bool); def _error_from_cdf(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_pr",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:6131,Testability,log,log,6131,"):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :class:`.StructExpression`; Result of :func:`.approx_cdf` aggregator; failure_prob: :class:`.NumericExpression`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :class:`.NumericExpression`; Upper bound on error of quantile estimates.; """""". def compute_sum(cdf):; s = hl.sum(; hl.range(0, hl.len(cdf._compaction_counts)).map(lambda i: cdf._compaction_counts[i] * (2 ** (2 * i))); ); return s / (cdf.ranks[-1] ** 2). def update_grid_size(p, s):; return 4 * hl.sqrt(hl.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; return hl.fold(lambda p, i: update_grid_size(p, s), 1 / failure_prob, hl.range(0, 5)). def compute_single_error(s, failure_prob=failure_prob):; return hl.sqrt(hl.log(2 / failure_prob) * s / 2). def compute_global_error(s):; return hl.rbind(compute_grid_size(s), lambda p: 1 / p + compute_single_error(s, failure_prob / p)). if all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:7276,Testability,log,log,7276,"f all_quantiles:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_global_error)); else:; return hl.rbind(cdf, lambda cdf: hl.rbind(compute_sum(cdf), compute_single_error)). def _error_from_cdf_python(cdf, failure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=hail_type); def missing(t: Union[HailType, str]):; """"""Creates an expression representing a missing value of a specified type. Examples; --------. >>> hl.eval(hl.missing(hl.tarray(hl.tstr))); None. >>> hl.eval(hl.missing('array<str>')); None. Notes; -----; This method is useful for constructing an expression that includes missing; values, since :obj:`None` cannot be interpreted as an expression. Parameters; ----------; t : :class:`str` or :class:`.HailType`; Type of the missing expression. Returns; -------; :class:`.Expre",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:7506,Testability,log,log,7506,"ilure_prob, all_quantiles=False):; """"""Estimates error of approx_cdf aggregator, using Hoeffding's inequality. Parameters; ----------; cdf : :obj:`dict`; Result of :func:`.approx_cdf` aggregator, evaluated to a python dict; failure_prob: :obj:`float`; Upper bound on probability of true error being greater than estimated error.; all_quantiles: :obj:`bool`; If ``True``, with probability 1 - `failure_prob`, error estimate applies; to all quantiles simultaneously. Returns; -------; :obj:`float`; Upper bound on error of quantile estimates.; """"""; import math. s = 0; for i in builtins.range(builtins.len(cdf._compaction_counts)):; s += cdf._compaction_counts[i] << (2 * i); s = s / (cdf.ranks[-1] ** 2). def update_grid_size(p):; return 4 * math.sqrt(math.log(2 * p / failure_prob) / (2 * s)). def compute_grid_size(s):; p = 1 / failure_prob; for _ in builtins.range(5):; p = update_grid_size(p); return p. def compute_single_error(s, failure_prob=failure_prob):; return math.sqrt(math.log(2 / failure_prob) * s / 2). if s == 0:; # no compactions ergo no error; return 0; elif all_quantiles:; p = compute_grid_size(s); return 1 / p + compute_single_error(s, failure_prob / p); else:; return compute_single_error(s, failure_prob). [docs]@typecheck(t=hail_type); def missing(t: Union[HailType, str]):; """"""Creates an expression representing a missing value of a specified type. Examples; --------. >>> hl.eval(hl.missing(hl.tarray(hl.tstr))); None. >>> hl.eval(hl.missing('array<str>')); None. Notes; -----; This method is useful for constructing an expression that includes missing; values, since :obj:`None` cannot be interpreted as an expression. Parameters; ----------; t : :class:`str` or :class:`.HailType`; Type of the missing expression. Returns; -------; :class:`.Expression`; A missing expression of type `t`.; """"""; return construct_expr(ir.NA(t), t). [docs]@deprecated(version=""0.2.62"", reason=""Replaced by hl.missing""); @typecheck(t=hail_type); def null(t: Union[HailType, str]):; """"""Deprecate",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11595,Testability,assert,assert,11595,"ise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11615,Testability,assert,assert,11615,"ise ExpressionException(; f""'literal' can only accept scalar or global expression arguments,""; f"" found indices {x._indices.axes}""; ); return False; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11730,Testability,assert,assert,11730,"; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11750,Testability,assert,assert,11750,"; elif x is None or x is pd.NA:; return False; else:; t._typecheck_one_level(x); return True. if dtype is None:; dtype = impute_type(x). # Special handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11867,Testability,assert,assert,11867,"cial handling of numpy. Have to extract from numpy scalars, do nothing on numpy arrays; if isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a /",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:11958,Testability,assert,assert,11958," isinstance(x, np.generic):; x = x.item(); elif isinstance(x, np.ndarray):; pass; else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:12046,Testability,assert,assert,12046," else:; try:; dtype._traverse(x, typecheck_expr); except TypeError as e:; raise TypeError(""'literal': object did not match the passed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `pr",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:12156,Testability,assert,assert,12156,"ssed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ------",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:12178,Testability,assert,assert,12178,"ssed type '{}'"".format(dtype)) from e. if wrapper['has_free_vars']:; raise ValueError(; ""'literal' cannot be used with hail expressions that depend ""; ""on other expressions. Use expression 'x' directly ""; ""instead of passing it to 'literal'.""; ). if wrapper['has_expr']:; return literal(hl.eval(to_expr(x, dtype)), dtype). if x is None or x is pd.NA:; return hl.missing(dtype); elif is_primitive(dtype):; if dtype == tint32:; assert is_int32(x); assert tint32.min_value <= x <= tint32.max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ------",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:12639,Testability,test,tests,12639,"max_value; return construct_expr(ir.I32(x), tint32); elif dtype == tint64:; assert is_int64(x); assert tint64.min_value <= x <= tint64.max_value; return construct_expr(ir.I64(x), tint64); elif dtype == tfloat32:; assert is_float32(x); return construct_expr(ir.F32(x), tfloat32); elif dtype == tfloat64:; assert is_float64(x); return construct_expr(ir.F64(x), tfloat64); elif dtype == tbool:; assert isinstance(x, builtins.bool); return construct_expr(ir.TrueIR() if x else ir.FalseIR(), tbool); else:; assert dtype == tstr; assert isinstance(x, builtins.str); return construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`, :func:`.if_else`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `cond",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:13229,Testability,test,test,13229,"eturn construct_expr(ir.Str(x), tstr); else:; return construct_expr(ir.EncodedLiteral(dtype, x), dtype). [docs]@deprecated(version=""0.2.59"", reason=""Replaced by hl.if_else""); @typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def cond(condition, consequent, alternate, missing_false: bool = False):; """"""Deprecated in favor of :func:`.if_else`. Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.cond(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.cond(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`, :func:`.if_else`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `condition`.; """"""; return if_else(condition, consequent, alternate, missing_false). [docs]@typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def if_else(condition, consequent, alternate, missing_false: bool = False):; """"""Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.if_else(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.if_else(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:13951,Testability,test,tests,13951,"; [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`, :func:`.if_else`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `condition`.; """"""; return if_else(condition, consequent, alternate, missing_false). [docs]@typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def if_else(condition, consequent, alternate, missing_false: bool = False):; """"""Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.if_else(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.if_else(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`. Returns; -------; :cla",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:14547,Testability,test,test,14547,"h`, :func:`.if_else`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `condition`.; """"""; return if_else(condition, consequent, alternate, missing_false). [docs]@typecheck(condition=expr_bool, consequent=expr_any, alternate=expr_any, missing_false=bool); def if_else(condition, consequent, alternate, missing_false: bool = False):; """"""Expression for an if/else statement; tests a condition and returns one of two options based on the result. Examples; --------. >>> x = 5; >>> hl.eval(hl.if_else(x < 2, 'Hi', 'Bye')); 'Bye'. >>> a = hl.literal([1, 2, 3, 4]); >>> hl.eval(hl.if_else(hl.len(a) > 0, 2.0 * a, a / 2.0)); [2.0, 4.0, 6.0, 8.0]. Notes; -----. If `condition` evaluates to ``True``, returns `consequent`. If `condition`; evaluates to ``False``, returns `alternate`. If `predicate` is missing, returns; missing. Note; ----; The type of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `condition`.; """"""; if missing_false:; condition = hl.bind(lambda x: hl.is_defined(x) & x, condition); indices, aggregations = unify_all(condition, consequent, alternate). consequent, alternate, success = unify_exprs(consequent, alternate); if not success:; raise TypeError(; f""'if_else' and 'cond' require the 'consequent' and 'alternate' arguments to have the same type\n""; f"" consequent: type '{consequent.dtype}'\n""; f"" alternate: type '{alternate.dtype}'""; ); assert consequent.dtype == alternate.dtype. return construct_expr(ir.If(condition._ir, consequent._ir, alternate._ir), ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:15414,Testability,assert,assert,15414,"pe of `consequent` and `alternate` must be the same. Parameters; ----------; condition : :class:`.BooleanExpression`; Condition to test.; consequent : :class:`.Expression`; Branch to return if the condition is ``True``.; alternate : :class:`.Expression`; Branch to return if the condition is ``False``.; missing_false : :obj:`.bool`; If ``True``, treat missing `condition` as ``False``. See Also; --------; :func:`.case`, :func:`.switch`. Returns; -------; :class:`.Expression`; One of `consequent`, `alternate`, or missing, based on `condition`.; """"""; if missing_false:; condition = hl.bind(lambda x: hl.is_defined(x) & x, condition); indices, aggregations = unify_all(condition, consequent, alternate). consequent, alternate, success = unify_exprs(consequent, alternate); if not success:; raise TypeError(; f""'if_else' and 'cond' require the 'consequent' and 'alternate' arguments to have the same type\n""; f"" consequent: type '{consequent.dtype}'\n""; f"" alternate: type '{alternate.dtype}'""; ); assert consequent.dtype == alternate.dtype. return construct_expr(ir.If(condition._ir, consequent._ir, alternate._ir), consequent.dtype, indices, aggregations). [docs]def case(missing_false: bool = False) -> 'hail.expr.builders.CaseBuilder':; """"""Chain multiple if-else statements with a :class:`.CaseBuilder`. Examples; --------. >>> x = hl.literal('foo bar baz'); >>> expr = (hl.case(); ... .when(x[:3] == 'FOO', 1); ... .when(hl.len(x) == 11, 2); ... .when(x == 'secret phrase', 3); ... .default(0)); >>> hl.eval(expr); 2. Parameters; ----------; missing_false : :obj:`bool`; Treat missing predicates as ``False``. See Also; --------; :class:`.CaseBuilder`, :func:`.switch`, :func:`.cond`. Returns; -------; :class:`.CaseBuilder`.; """"""; from .builders import CaseBuilder. return CaseBuilder(missing_false=missing_false). [docs]@typecheck(expr=expr_any); def switch(expr) -> 'hail.expr.builders.SwitchBuilder':; """"""Build a conditional tree on the value of an expression. Examples; --------. >>> csq = h",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:19203,Testability,test,test,19203,"alue_ir, res_ir, is_scan=True); else:; res_ir = ir.Let(uid, value_ir, res_ir). return construct_expr(res_ir, lambda_result.dtype, indices, aggregations). [docs]def rbind(*exprs, _ctx=None):; """"""Bind a temporary variable and use it in a function. This is :func:`.bind` with flipped argument order. Examples; --------. >>> hl.eval(hl.rbind(1, lambda x: x + 1)); 2. :func:`.rbind` also can take multiple arguments:. >>> hl.eval(hl.rbind(4.0, 2.0, lambda x, y: x / y)); 2.0. Parameters; ----------; exprs : variable-length args of :class:`.Expression`; Expressions to bind.; f : function ( (args) -> :class:`.Expression`); Function of `exprs`. Returns; -------; :class:`.Expression`; Result of evaluating `f` with `exprs` as arguments.; """""". *args, f = exprs; args = [expr_any.check(arg, 'rbind', f'argument {index}') for index, arg in builtins.enumerate(args)]. return hl.bind(f, *args, _ctx=_ctx). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def chi_squared_test(c1, c2, c3, c4) -> StructExpression:; """"""Performs chi-squared test of independence on a 2x2 contingency table. Examples; --------. >>> hl.eval(hl.chi_squared_test(10, 10, 10, 10)); Struct(p_value=1.0, odds_ratio=1.0). >>> hl.eval(hl.chi_squared_test(51, 43, 22, 92)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). Notes; -----; The odds ratio is given by ``(c1 / c2) / (c3 / c4)``. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, o",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:20455,Testability,test,test,20455,".eval(hl.chi_squared_test(51, 43, 22, 92)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). Notes; -----; The odds ratio is given by ``(c1 / c2) / (c3 / c4)``. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""chi_squared_test"", ret_type, c1, c2, c3, c4). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32, min_cell_count=expr_int32); def contingency_table_test(c1, c2, c3, c4, min_cell_count) -> StructExpression:; """"""Performs chi-squared or Fisher's exact test of independence on a 2x2; contingency table. Examples; --------. >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=22)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=23)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967). Notes; -----; If all cell counts are at least `min_cell_count`, the chi-squared test is; used. Otherwise, Fisher's exact test is used. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :cla",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:20895,Testability,test,test,20895,"t or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""chi_squared_test"", ret_type, c1, c2, c3, c4). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32, min_cell_count=expr_int32); def contingency_table_test(c1, c2, c3, c4, min_cell_count) -> StructExpression:; """"""Performs chi-squared or Fisher's exact test of independence on a 2x2; contingency table. Examples; --------. >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=22)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=23)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967). Notes; -----; If all cell counts are at least `min_cell_count`, the chi-squared test is; used. Otherwise, Fisher's exact test is used. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :class:`.Expression` of type :py:data:`.tint32`; Minimum count in every cell to use the chi-squared test. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""contingency_table_test"", ret_type, c1, c2, c3, c4, min_cell_count). # We use 64-bit integers.; # It is relatively easy to encounter an integer over",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:20936,Testability,test,test,20936," 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""chi_squared_test"", ret_type, c1, c2, c3, c4). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32, min_cell_count=expr_int32); def contingency_table_test(c1, c2, c3, c4, min_cell_count) -> StructExpression:; """"""Performs chi-squared or Fisher's exact test of independence on a 2x2; contingency table. Examples; --------. >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=22)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=23)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967). Notes; -----; If all cell counts are at least `min_cell_count`, the chi-squared test is; used. Otherwise, Fisher's exact test is used. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :class:`.Expression` of type :py:data:`.tint32`; Minimum count in every cell to use the chi-squared test. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""contingency_table_test"", ret_type, c1, c2, c3, c4, min_cell_count). # We use 64-bit integers.; # It is relatively easy to encounter an integer overflow bug with 32-bit integers.; [docs]@typecheck(a=expr_array(expr_",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:21461,Testability,test,test,21461,"red or Fisher's exact test of independence on a 2x2; contingency table. Examples; --------. >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=22)); Struct(p_value=1.4626257805267089e-07, odds_ratio=4.959830866807611). >>> hl.eval(hl.contingency_table_test(51, 43, 22, 92, min_cell_count=23)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967). Notes; -----; If all cell counts are at least `min_cell_count`, the chi-squared test is; used. Otherwise, Fisher's exact test is used. Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :class:`.Expression` of type :py:data:`.tint32`; Minimum count in every cell to use the chi-squared test. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""contingency_table_test"", ret_type, c1, c2, c3, c4, min_cell_count). # We use 64-bit integers.; # It is relatively easy to encounter an integer overflow bug with 32-bit integers.; [docs]@typecheck(a=expr_array(expr_int64), b=expr_array(expr_int64), c=expr_array(expr_int64), d=expr_array(expr_int64)); def cochran_mantel_haenszel_test(; a: Union[tarray, list], b: Union[tarray, list], c: Union[tarray, list], d: Union[tarray, list]; ) -> StructExpression:; """"""Perform the Cochran-Mantel-Haenszel test for association. Examples; --------; >>> a = [56, 61, 73, 71]; >>> b = [69, 257, 65, 48]; >>> c = [40, 57, 71, 55]; >>> d = [77, 301, 79, 48]; >>> hl.eval(hl.cochran_mantel_haenszel_test(a, b, c, d)); Struct(test_statis",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:22210,Testability,test,test,22210,":data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4.; min_cell_count : int or :class:`.Expression` of type :py:data:`.tint32`; Minimum count in every cell to use the chi-squared test. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with two fields, `p_value`; (:py:data:`.tfloat64`) and `odds_ratio` (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64); return _func(""contingency_table_test"", ret_type, c1, c2, c3, c4, min_cell_count). # We use 64-bit integers.; # It is relatively easy to encounter an integer overflow bug with 32-bit integers.; [docs]@typecheck(a=expr_array(expr_int64), b=expr_array(expr_int64), c=expr_array(expr_int64), d=expr_array(expr_int64)); def cochran_mantel_haenszel_test(; a: Union[tarray, list], b: Union[tarray, list], c: Union[tarray, list], d: Union[tarray, list]; ) -> StructExpression:; """"""Perform the Cochran-Mantel-Haenszel test for association. Examples; --------; >>> a = [56, 61, 73, 71]; >>> b = [69, 257, 65, 48]; >>> c = [40, 57, 71, 55]; >>> d = [77, 301, 79, 48]; >>> hl.eval(hl.cochran_mantel_haenszel_test(a, b, c, d)); Struct(test_statistic=5.0496881823306765, p_value=0.024630370456863417). >>> mt = ds.filter_rows(mt.locus == hl.Locus(20, 10633237)); >>> mt.count_rows(); 1; >>> a, b, c, d = mt.aggregate_entries(; ... hl.tuple([; ... hl.array([hl.agg.count_where(mt.GT.is_non_ref() & mt.pheno.is_case & mt.pheno.is_female), hl.agg.count_where(mt.GT.is_non_ref() & mt.pheno.is_case & ~mt.pheno.is_female)]),; ... hl.array([hl.agg.count_where(mt.GT.is_non_ref() & ~mt.pheno.is_case & mt.pheno.is_female), hl.agg.count_where(mt.GT.is_non_ref() & ~mt.pheno.is_case & ~mt.pheno.is_female)]),; ... hl.array([hl.agg.count_where(~mt.GT.is_non_ref() & mt.pheno.is_case & ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:26198,Testability,assert,assert,26198,"*tup))). test_statistic = numerator / denominator; p_value = pchisqtail(test_statistic, 1); return struct(test_statistic=test_statistic, p_value=p_value). [docs]@typecheck(; collection=expr_oneof(; expr_dict(), expr_set(expr_tuple([expr_any, expr_any])), expr_array(expr_tuple([expr_any, expr_any])); ); ); def dict(collection) -> DictExpression:; """"""Creates a dictionary. Examples; --------. >>> hl.eval(hl.dict([('foo', 1), ('bar', 2), ('baz', 3)])); {'bar': 2, 'baz': 3, 'foo': 1}. Notes; -----; This method expects arrays or sets with elements of type :class:`.ttuple`; with 2 fields. The first field of the tuple becomes the key, and the second; field becomes the value. Parameters; ----------; collection : :class:`.DictExpression` or :class:`.ArrayExpression` or :class:`.SetExpression`. Returns; -------; :class:`.DictExpression`; """"""; if isinstance(collection.dtype, (tarray, tset)):; key_type, value_type = collection.dtype.element_type.types; return _func('dict', tdict(key_type, value_type), collection); else:; assert isinstance(collection.dtype, tdict); return collection. [docs]@typecheck(x=expr_float64, a=expr_float64, b=expr_float64); def dbeta(x, a, b) -> Float64Expression:; """"""; Returns the probability density at `x` of a `beta distribution; <https://en.wikipedia.org/wiki/Beta_distribution>`__ with parameters `a`; (alpha) and `b` (beta). Examples; --------. >>> hl.eval(hl.dbeta(.2, 5, 20)); 4.900377563180943. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Point in [0,1] at which to sample. If a < 1 then x must be positive.; If b < 1 then x must be less than 1.; a : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The alpha parameter in the beta distribution. The result is undefined; for non-positive a.; b : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; The beta parameter in the beta distribution. The result is undefined; for non-positive b. Returns; -------; :class:`.Float64Expr",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:28115,Testability,log,logarithm,28115,"or non-positive b. Returns; -------; :class:`.Float64Expression`; """"""; return _func(""dbeta"", tfloat64, x, a, b). [docs]@typecheck(x=expr_float64, df=expr_float64, ncp=nullable(expr_float64), log_p=expr_bool); def dchisq(x, df, ncp=None, log_p=False) -> Float64Expression:; """"""Compute the probability density at `x` of a chi-squared distribution with `df`; degrees of freedom. Examples; --------. >>> hl.eval(hl.dchisq(1, 2)); 0.3032653298563167. >>> hl.eval(hl.dchisq(1, 2, ncp=2)); 0.17472016746112667. >>> hl.eval(hl.dchisq(1, 2, log_p=True)); -1.1931471805599454. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; df : float or :class:`.Expression` of type :py:data:`.tfloat64`; Degrees of freedom.; ncp: float or :class:`.Expression` of type :py:data:`.tfloat64`; Noncentrality parameter, defaults to 0 if unspecified.; log_p : bool or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The probability density.; """"""; if ncp is None:; return _func(""dchisq"", tfloat64, x, df, log_p); else:; return _func(""dnchisq"", tfloat64, x, df, ncp, log_p). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, log_p=expr_bool); def dnorm(x, mu=0, sigma=1, log_p=False) -> Float64Expression:; """"""Compute the probability density at `x` of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns density of standard normal; distribution by default. Examples; --------. >>> hl.eval(hl.dnorm(1)); 0.24197072451914337. >>> hl.eval(hl.dnorm(1, mu=1, sigma=2)); 0.19947114020071635. >>> hl.eval(hl.dnorm(1, log_p=True)); -1.4189385332046727. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Real number at which to compute the probability density.; mu : float or :class:`.Expression` of type :py:data:`.tfl",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:29325,Testability,log,logarithm,29325,"); else:; return _func(""dnchisq"", tfloat64, x, df, ncp, log_p). [docs]@typecheck(x=expr_float64, mu=expr_float64, sigma=expr_float64, log_p=expr_bool); def dnorm(x, mu=0, sigma=1, log_p=False) -> Float64Expression:; """"""Compute the probability density at `x` of a normal distribution with mean; `mu` and standard deviation `sigma`. Returns density of standard normal; distribution by default. Examples; --------. >>> hl.eval(hl.dnorm(1)); 0.24197072451914337. >>> hl.eval(hl.dnorm(1, mu=1, sigma=2)); 0.19947114020071635. >>> hl.eval(hl.dnorm(1, log_p=True)); -1.4189385332046727. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Real number at which to compute the probability density.; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The probability density.; """"""; return _func(""dnorm"", tfloat64, x, mu, sigma, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, log_p=expr_bool); def dpois(x, lamb, log_p=False) -> Float64Expression:; """"""Compute the (log) probability density at x of a Poisson distribution with rate parameter `lamb`. Examples; --------. >>> hl.eval(hl.dpois(5, 3)); 0.10081881344492458. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; lamb : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability den",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:29670,Testability,log,log,29670,"eviation `sigma`. Returns density of standard normal; distribution by default. Examples; --------. >>> hl.eval(hl.dnorm(1)); 0.24197072451914337. >>> hl.eval(hl.dnorm(1, mu=1, sigma=2)); 0.19947114020071635. >>> hl.eval(hl.dnorm(1, log_p=True)); -1.4189385332046727. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Real number at which to compute the probability density.; mu : float or :class:`.Expression` of type :py:data:`.tfloat64`; Mean (default = 0).; sigma: float or :class:`.Expression` of type :py:data:`.tfloat64`; Standard deviation (default = 1).; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The probability density.; """"""; return _func(""dnorm"", tfloat64, x, mu, sigma, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, log_p=expr_bool); def dpois(x, lamb, log_p=False) -> Float64Expression:; """"""Compute the (log) probability density at x of a Poisson distribution with rate parameter `lamb`. Examples; --------. >>> hl.eval(hl.dpois(5, 3)); 0.10081881344492458. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; lamb : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability density.; """"""; return _func(""dpois"", tfloat64, x, lamb, log_p). [docs]@typecheck(x=oneof(expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def exp(x) -> Float64Expression:; """"""Computes `e` raised to the power `x`. Examples; --------. >>> hl.eval(hl.exp(2)); 7.38905609893065. Parameters; ----------; ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:30183,Testability,log,logarithm,30183," type :py:data:`.tfloat64`; Standard deviation (default = 1).; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The probability density.; """"""; return _func(""dnorm"", tfloat64, x, mu, sigma, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, log_p=expr_bool); def dpois(x, lamb, log_p=False) -> Float64Expression:; """"""Compute the (log) probability density at x of a Poisson distribution with rate parameter `lamb`. Examples; --------. >>> hl.eval(hl.dpois(5, 3)); 0.10081881344492458. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; lamb : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability density.; """"""; return _func(""dpois"", tfloat64, x, lamb, log_p). [docs]@typecheck(x=oneof(expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def exp(x) -> Float64Expression:; """"""Computes `e` raised to the power `x`. Examples; --------. >>> hl.eval(hl.exp(2)); 7.38905609893065. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""exp"", tfloat64, x). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def fisher_exact_test(c1, c2, c3, c4) -> StructExpression:; """"""Calculates the p-value, odds ratio, and 95% confidence interval using; Fisher's exact test for a 2x2 table. Examples; --------. >>> hl.eval(hl.fisher_exact",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:30307,Testability,log,log,30307,", the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The probability density.; """"""; return _func(""dnorm"", tfloat64, x, mu, sigma, log_p). [docs]@typecheck(x=expr_float64, lamb=expr_float64, log_p=expr_bool); def dpois(x, lamb, log_p=False) -> Float64Expression:; """"""Compute the (log) probability density at x of a Poisson distribution with rate parameter `lamb`. Examples; --------. >>> hl.eval(hl.dpois(5, 3)); 0.10081881344492458. Parameters; ----------; x : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Non-negative number at which to compute the probability density.; lamb : :obj:`float` or :class:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability density.; """"""; return _func(""dpois"", tfloat64, x, lamb, log_p). [docs]@typecheck(x=oneof(expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def exp(x) -> Float64Expression:; """"""Computes `e` raised to the power `x`. Examples; --------. >>> hl.eval(hl.exp(2)); 7.38905609893065. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""exp"", tfloat64, x). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def fisher_exact_test(c1, c2, c3, c4) -> StructExpression:; """"""Calculates the p-value, odds ratio, and 95% confidence interval using; Fisher's exact test for a 2x2 table. Examples; --------. >>> hl.eval(hl.fisher_exact_test(10, 10, 10, 10)); Struct(p_value=1.0000000000000002, odds_ratio=1.0,; ci_95_lower=0.24385796914260355, ci_95_upper=4.1007",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:31116,Testability,test,test,31116,"ss:`.Expression` of type :py:data:`.tfloat64`; Poisson rate parameter. Must be non-negative.; log_p : :obj:`bool` or :class:`.BooleanExpression`; If ``True``, the natural logarithm of the probability density is returned. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64`; The (log) probability density.; """"""; return _func(""dpois"", tfloat64, x, lamb, log_p). [docs]@typecheck(x=oneof(expr_float64, expr_ndarray(expr_float64))); @ndarray_broadcasting; def exp(x) -> Float64Expression:; """"""Computes `e` raised to the power `x`. Examples; --------. >>> hl.eval(hl.exp(2)); 7.38905609893065. Parameters; ----------; x : float or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""exp"", tfloat64, x). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def fisher_exact_test(c1, c2, c3, c4) -> StructExpression:; """"""Calculates the p-value, odds ratio, and 95% confidence interval using; Fisher's exact test for a 2x2 table. Examples; --------. >>> hl.eval(hl.fisher_exact_test(10, 10, 10, 10)); Struct(p_value=1.0000000000000002, odds_ratio=1.0,; ci_95_lower=0.24385796914260355, ci_95_upper=4.100747675033819). >>> hl.eval(hl.fisher_exact_test(51, 43, 22, 92)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967,; ci_95_lower=2.5659373368248444, ci_95_upper=9.677929632035475). Notes; -----; This method is identical to the version implemented in; `R <https://stat.ethz.ch/R-manual/R-devel/library/stats/html/fisher.test.html>`_ with default; parameters (two-sided, alpha = 0.05, null hypothesis that the odds ratio equals 1). Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expre",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
https://hail.is/docs/0.2/_modules/hail/expr/functions.html:31649,Testability,test,test,31649,"or :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`. Returns; -------; :class:`.Expression` of type :py:data:`.tfloat64` or :class:`.NDArrayNumericExpression`; """"""; return _func(""exp"", tfloat64, x). [docs]@typecheck(c1=expr_int32, c2=expr_int32, c3=expr_int32, c4=expr_int32); def fisher_exact_test(c1, c2, c3, c4) -> StructExpression:; """"""Calculates the p-value, odds ratio, and 95% confidence interval using; Fisher's exact test for a 2x2 table. Examples; --------. >>> hl.eval(hl.fisher_exact_test(10, 10, 10, 10)); Struct(p_value=1.0000000000000002, odds_ratio=1.0,; ci_95_lower=0.24385796914260355, ci_95_upper=4.100747675033819). >>> hl.eval(hl.fisher_exact_test(51, 43, 22, 92)); Struct(p_value=2.1564999740157304e-07, odds_ratio=4.918058171469967,; ci_95_lower=2.5659373368248444, ci_95_upper=9.677929632035475). Notes; -----; This method is identical to the version implemented in; `R <https://stat.ethz.ch/R-manual/R-devel/library/stats/html/fisher.test.html>`_ with default; parameters (two-sided, alpha = 0.05, null hypothesis that the odds ratio equals 1). Returned fields may be ``nan`` or ``inf``. Parameters; ----------; c1 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 1.; c2 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 2.; c3 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 3.; c4 : int or :class:`.Expression` of type :py:data:`.tint32`; Value for cell 4. Returns; -------; :class:`.StructExpression`; A :class:`.tstruct` expression with four fields, `p_value`; (:py:data:`.tfloat64`), `odds_ratio` (:py:data:`.tfloat64`),; `ci_95_lower (:py:data:`.tfloat64`), and `ci_95_upper`; (:py:data:`.tfloat64`).; """"""; ret_type = tstruct(p_value=tfloat64, odds_ratio=tfloat64, ci_95_lower=tfloat64, ci_95_upper=tfloat64); return _func(""fisher_exact_test"", ret_type, c1, c2, c3, c4). [docs]@typecheck(x=expr_oneof(expr_float32, expr_float64, expr_ndarray(expr_float64))); ",MatchSource.WIKI,docs/0.2/_modules/hail/expr/functions.html,hail-is,hail,0.2.133,https://hail.is,https://hail.is/docs/0.2/_modules/hail/expr/functions.html
