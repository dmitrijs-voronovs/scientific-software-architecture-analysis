id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/TEveStraightLineSet.html:7723,Availability,error,error,7723,"t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveStraightLineSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSet.html
https://root.cern/root/html534/TEveStraightLineSet.html:20773,Deployability,update,update,20773,"tRnrLines(Bool_t x); virtual voidSetRnrMarkers(Bool_t x); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveStraightLineSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSet.html
https://root.cern/root/html534/TEveStraightLineSet.html:20876,Deployability,update,update,20876,"tRnrLines(Bool_t x); virtual voidSetRnrMarkers(Bool_t x); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveStraightLineSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSet.html
https://root.cern/root/html534/TEveStraightLineSet.html:24684,Modifiability,variab,variable,24684,"Allow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tfDepthTest; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveStraightLineSet::Line_t*fLastLine!; Color_tTAttLine::fLineColorline color; TEveChunkManagerfLinePlex; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; TEveChunkManagerfMarkerPlex; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tfOwnLinesIdsFlag specifying if id-objects are owned by the line-set; Bool_tfOwnMarkersIdsFlag specifying if id-objects are owned by the line-set; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEve",MatchSource.WIKI,root/html534/TEveStraightLineSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSet.html
https://root.cern/root/html534/TEveStraightLineSet.html:24822,Modifiability,variab,variable,24822,"nt::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tfDepthTest; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveStraightLineSet::Line_t*fLastLine!; Color_tTAttLine::fLineColorline color; TEveChunkManagerfLinePlex; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; TEveChunkManagerfMarkerPlex; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tfOwnLinesIdsFlag specifying if id-objects are owned by the line-set; Bool_tfOwnMarkersIdsFlag specifying if id-objects are owned by the line-set; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tfRnrLines; Bool_tfRnrMarkers; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represente",MatchSource.WIKI,root/html534/TEveStraightLineSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSet.html
https://root.cern/root/html534/TEveStraightLineSetEditor.html:4591,Availability,error,error,4591,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveStraightLineSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetEditor.html
https://root.cern/root/html534/TEveStraightLineSetEditor.html:4675,Availability,error,error,4675,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveStraightLineSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetEditor.html
https://root.cern/root/html534/TEveStraightLineSetEditor.html:17530,Availability,mask,mask,17530,,MatchSource.WIKI,root/html534/TEveStraightLineSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetEditor.html
https://root.cern/root/html534/TEveStraightLineSetGL.html:1897,Performance,cache,cached,1897,"LogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TEveStraightLineSetGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetGL.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:7667,Availability,error,error,7667,"t(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:7751,Availability,error,error,7751,"t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:21534,Deployability,update,update,21534,"ol_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveStraightLineSet::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:21637,Deployability,update,update,21637,"ol_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveStraightLineSet::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:27976,Deployability,update,updated,27976,"ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveStraightLineSet::fRnrLines; Bool_tTEveStraightLineSet::fRnrMarkers; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveStraightLineSetProjected(); Constructor. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Set projection manager and model object. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); Callback that actually performs the projection.; Called when projection parameters have been updated. TEveStraightLineSet& operator=(const TEveStraightLineSetProjected& ). TEveStraightLineSetProjected(const TEveStraightLineSetProjected& ). virtual ~TEveStraightLineSetProjected(); {}. TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:25723,Modifiability,variab,variable,25723,"ain transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveStraightLineSet::fDepthTest; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveStraightLineSet::Line_t*TEveStraightLineSet::fLastLine!; Color_tTAttLine::fLineColorline color; TEveChunkManagerTEveStraightLineSet::fLinePlex; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; TEveChunkManagerTEveStraightLineSet::fMarkerPlex; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tTEveStraightLineSet::fOwnLinesIdsFlag specifying if id-objects are owned by the line-set; Bool_tTEveStraightLineSet::fOwnMarkersIdsFlag specifying if id-objects are owned by the line-set; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:25861,Modifiability,variab,variable,25861,"_tTEveProjected::fDepthz coordinate; Bool_tTEveStraightLineSet::fDepthTest; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveStraightLineSet::Line_t*TEveStraightLineSet::fLastLine!; Color_tTAttLine::fLineColorline color; TEveChunkManagerTEveStraightLineSet::fLinePlex; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; TEveChunkManagerTEveStraightLineSet::fMarkerPlex; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tTEveStraightLineSet::fOwnLinesIdsFlag specifying if id-objects are owned by the line-set; Bool_tTEveStraightLineSet::fOwnMarkersIdsFlag specifying if id-objects are owned by the line-set; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveStraightLineSet::fRnrLines; Bool_tTEveStraightLine",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveStraightLineSetProjected.html:27906,Performance,perform,performs,27906,"ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveStraightLineSet::fRnrLines; Bool_tTEveStraightLineSet::fRnrMarkers; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveStraightLineSetProjected(); Constructor. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Set projection manager and model object. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); Callback that actually performs the projection.; Called when projection parameters have been updated. TEveStraightLineSet& operator=(const TEveStraightLineSetProjected& ). TEveStraightLineSetProjected(const TEveStraightLineSetProjected& ). virtual ~TEveStraightLineSetProjected(); {}. TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveStraightLineSetProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveStraightLineSetProjected.html
https://root.cern/root/html534/TEveText.html:4565,Availability,error,error,4565,"irtual voidTEveElement::DestroyOrWarn(); voidTEveElement::DisableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:4649,Availability,error,error,4649," rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:15460,Deployability,update,update,15460,"ren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetText(const char* t); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:15563,Deployability,update,update,15563,"ren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetText(const char* t); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:18689,Modifiability,variab,variable,18689,"l_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tfExtrudeextrude depth; Int_tfFontFileFTFont file name; Int_tfFontModeFTFont FTGL class id; Int_tfFontSizeFTFont face size; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Bool_tfLightingforce lighting; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; Float_tfPolygonOffset[2]depth test; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringfTexttext; Color_tfTextColortext color; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! El",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:18827,Modifiability,variab,variable,18827,"t::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; list<TEveElement*>TEveElement::fChildrenList of children.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tfExtrudeextrude depth; Int_tfFontFileFTFont file name; Int_tfFontModeFTFont FTGL class id; Int_tfFontSizeFTFont face size; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Bool_tfLightingforce lighting; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; Float_tfPolygonOffset[2]depth test; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringfTexttext; Color_tfTextColortext color; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includ",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:13123,Security,validat,validate,13123,"rimitive(ostream& out, Option_t* option = """"); voidTEveElement::SaveVizParams(ostream& out, const TString& tag, const TString& var); virtual voidTEveElement::SelectElement(Bool_t state); voidSetAutoLighting(Bool_t isOn); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTEveElement::SetCompound(TEveCompound* c); voidTEveElement::SetCSCBits(UChar_t f); voidTEveElement::SetDestroyOnZeroRefCnt(Bool_t d); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTEveElement::SetEditMainColor(Bool_t x); voidTEveElement::SetEditMainTransparency(Bool_t x); virtual voidTEveElement::SetElementName(const char* name); virtual voidTEveElement::SetElementNameTitle(const char* name, const char* title); virtual voidTEveElement::SetElementTitle(const char* title); voidSetExtrude(Float_t x); voidSetFontFile(Int_t file); voidSetFontFile(const char* name); voidSetFontMode(Int_t mode); voidSetFontSize(Int_t size, Bool_t validate = kTRUE); voidSetLighting(Bool_t isOn); voidTEveElement::SetMainAlpha(Float_t alpha); virtual voidTEveElement::SetMainColor(Color_t color); voidTEveElement::SetMainColorPixel(Pixel_t pixel); voidTEveElement::SetMainColorPtr(Color_t* color); voidTEveElement::SetMainColorRGB(UChar_t r, UChar_t g, UChar_t b); voidTEveElement::SetMainColorRGB(Float_t r, Float_t g, Float_t b); virtual voidTEveElement::SetMainTransparency(Char_t t); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidTEveElement::SetPickable(Bool_t p); voidTEveElement::SetPickableRecursively(Bool_t p); voidSetPolygonOffset(Float_t factor, Float_t units); virtual Bool_tTEveElement::SetRnrChildren(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEv",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:19924,Security,validat,validate,19924,"t::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; Float_tfPolygonOffset[2]depth test; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringfTexttext; Color_tfTextColortext color; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveText(const char* txt = """"); Constructor. void SetFontSize(Int_t size, Bool_t validate = kTRUE); Set valid font size. void SetFontFile(const char* name); Set font file regarding to static TGLFontManager fgFontFileArray. void SetFontMode(Int_t mode); Set FTFont class ID. void SetPolygonOffset(Float_t factor, Float_t units); Set the scale and units used to calculate depth values.; See glPolygonOffset manual page. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. void ComputeBBox(); Fill bounding-box information. Virtual from TAttBBox.; If member 'TEveFrameBox* fFrame' is set, frame's corners are; used as bbox. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveText icon. TEveText(const TEveText& ). TEveText& operator=(const TEveText& ). virtual ~TEveText(); {}. Int_t GetFontSize() const; { return fFontSize; }. Int_t GetFontFile() const; { return fFontFile; }. Int_t GetFontMode() const; { return fFontMode; }. void SetFontFile(Int_t file); { fFontFile = file; }. const char* GetText() const; { return fText.Data()",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveText.html:19118,Testability,test,test,19118,"Auto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Float_tfExtrudeextrude depth; Int_tfFontFileFTFont file name; Int_tfFontModeFTFont FTGL class id; Int_tfFontSizeFTFont face size; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Bool_tfLightingforce lighting; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; Float_tfPolygonOffset[2]depth test; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringfTexttext; Color_tfTextColortext color; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveText(const char* txt = """"); Constructor. void SetFontSize(Int_t size, Bool_t validate = kTRUE); Set valid font size. void SetFontFile(const char* name); Set font file regarding to static TGLFontManager fgFontFileArray. void SetFontMode(Int_t mode); Set FTFont class ID. void ",MatchSource.WIKI,root/html534/TEveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveText.html
https://root.cern/root/html534/TEveTextEditor.html:4594,Availability,error,error,4594,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTextEditor.html
https://root.cern/root/html534/TEveTextEditor.html:4678,Availability,error,error,4678,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTextEditor.html
https://root.cern/root/html534/TEveTextEditor.html:17565,Availability,mask,mask,17565," kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TGCheckButton*fAutoLighting; Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TEveGValuator*fExtrude; TGFrameElement*TGFrame::fFEpointer to frame element; TGComboBox*fFile; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGCheckButton*fLighting; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveText*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TGComboBox*fMode; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the wi",MatchSource.WIKI,root/html534/TEveTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTextEditor.html
https://root.cern/root/html534/TEveTextGL.html:3626,Integrability,wrap,wrapper,3626,"teBoundingBoxesOfPhysicals(). protected:. voidTGLLogicalShape::PurgeDLRange(UInt_t base, Int_t size) const; voidTGLObject::SetAxisAlignedBBox(const Float_t* p); voidTGLObject::SetAxisAlignedBBox(Float_t xmin, Float_t xmax, Float_t ymin, Float_t ymax, Float_t zmin, Float_t zmax); Bool_tTGLObject::SetModelCheckClass(TObject* obj, TClass* cls). private:. TEveTextGL(const TEveTextGL&); TEveTextGL&operator=(const TEveTextGL&). Data Members; public:. enum TGLLogicalShape::ELODAxes { kLODAxesNone; kLODAxesX; kLODAxesY; kLODAxesZ; kLODAxesAll; };. protected:. TGLBoundingBoxTGLLogicalShape::fBoundingBox! Shape's bounding box.; UInt_tTGLLogicalShape::fDLBase! display-list id base; Bool_tTGLLogicalShape::fDLCache! use display list caching; Int_tTGLLogicalShape::fDLSize! display-list size for different LODs; UShort_tTGLLogicalShape::fDLValid! display-list validity bit-field; TObject*TGLLogicalShape::fExternalObj! Also plays the role of ID.; TGLPhysicalShape*TGLLogicalShape::fFirstPhysical! first replica; TGLFontfFontFTFont wrapper; TEveText*fMmodel object.; Bool_tTGLObject::fMultiColorAre multiple colors used for object rendering.; Bool_tTGLLogicalShape::fOwnExtObj! External object is a fake; UInt_tTGLLogicalShape::fRef! physical instance ref counting; Bool_tTGLLogicalShape::fRefStrong! Strong ref (delete on 0 ref); not in scene; TGLScene*TGLLogicalShape::fScene! scene where object is stored (can be zero!); Double_tfX[4][3]3D position of font; static Bool_tTGLLogicalShape::fgIgnoreSizeForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTextGL(); Constructor. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object. void SetBBox(); Set bounding box. void DirectDraw(TGLRnrCtx& rnrCtx) const; Actual rendering code.; Virtual from TGLLogicalShape. TEveTextGL(const TEveTextGL& ). TEveTextGL& operator=(const TEveTextGL& ). virtual ~TEveTextGL(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; ",MatchSource.WIKI,root/html534/TEveTextGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTextGL.html
https://root.cern/root/html534/TEveTextGL.html:1886,Performance,cache,cached,1886,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TEveTextGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTextGL.html
https://root.cern/root/html534/TEveTrack.html:7794,Availability,error,error,7794,"t(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:7878,Availability,error,error,7878,"t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGLis",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:23804,Deployability,update,update,23804,"rConsumer::ETreeVarType_e cs); voidTEveElement::SetSourceObject(TObject* o); voidSetStatus(Int_t idx); virtual voidSetStdTitle(); virtual voidTEvePointSet::SetTitle(const char* t); virtual voidSetTrackParams(const TEveTrack& t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); Bool_tShouldBreakTrack() const; virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidSortPathMarksByTime(); voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:23907,Deployability,update,update,23907,"rConsumer::ETreeVarType_e cs); voidTEveElement::SetSourceObject(TObject* o); voidSetStatus(Int_t idx); virtual voidSetStdTitle(); virtual voidTEvePointSet::SetTitle(const char* t); virtual voidSetTrackParams(const TEveTrack& t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); Bool_tShouldBreakTrack() const; virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidSortPathMarksByTime(); voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:32200,Deployability,update,updated,32200,"se constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registered pat-marks by time. void PrintPathMarks(); Print registered path-marks. void SecSelected(TEveTrack* ); Emits ""SecSelected(TEveTrack*)"" signal.; Called from TEveTrackGL on secondary-selection. Bool_t ShouldBreakTrack() const; Should this track be broken in projections. UChar_t GetBreakProjectedTracks() const; Deprected -- use TEveTrackPropagator functions. voi",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:364,Energy Efficiency,reduce,reduced,364,". TEveTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrack. class TEveTrack: public TEveLine. Visual representation of a track. If member fDpDs is set, the momentum is reduced on all path-marks that do; not fix the momentum according to the distance travelled from the previous; pathmark. Function Members (Methods); public:. TEveTrack(); TEveTrack(const TEveTrack& t); TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop = 0); TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop = 0); virtual~TEveTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElement::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); voidAddPathMark(const TEvePathMarkD& pm); voidAddPathMark(const TEvePathMark& pm); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Float_t*TAttBBox::AssertBBox(); TEveElement",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:28716,Energy Efficiency,allocate,allocated,28716,"lation label; Int_tfLastPMIdx!Last path-mark index tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDfPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDfPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >fPathMarksTEveVector of known points along the track; Int_tfPdgPDG code; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTEveLine::fSmooth; TRefTEveElement::fSourceExternal object that is ",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:28397,Modifiability,variab,variable,28397,"ntSet3D::fIdsUser-provided point identifications; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; Int_tfIndexReconstruction index; TArrayI*TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Int_tfLabelSimulation label; Int_tfLastPMIdx!Last path-mark index tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDfPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDfPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >fPathMarksTEveVector of known points along the track; Int_tfPdgPDG code; Bool_tTEveElement::fPickable; list<T",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:28535,Modifiability,variab,variable,28535,"dexReconstruction index; TArrayI*TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Int_tfLabelSimulation label; Int_tfLastPMIdx!Last path-mark index tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tfLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDfPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDfPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >fPathMarksTEveVector of known points along the track; Int_tfPdgPDG code; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*fPropagatorPointer to shared render-st",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:30004,Modifiability,variab,variables,30004,"_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDfPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >fPathMarksTEveVector of known points along the track; Int_tfPdgPDG code; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTEveLine::fSmooth; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCoordinate-System of the source tree variables; Int_tfStatusStatus-word, user-defined.; TStringTEvePointSet::fTitleTitle/tooltip of the TEvePointSet.; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveVectorDfVStarting vertex; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tTEveLine::fgDefaultSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrack(); Default constructor. TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop = 0); Constructor from TParticle. TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* p",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrack.html:31862,Usability,clear,cleared,31862,"nstructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<double> reconstructed track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveRecTrack<float> reconstructed track.; It is recomended to use constructor with TEveRecTrack<double> since; TEveTrackPropagator operates with double type. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registered pat-marks by time. void PrintPathMarks(); Print registered",MatchSource.WIKI,root/html534/TEveTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrack.html
https://root.cern/root/html534/TEveTrackEditor.html:4507,Availability,error,error,4507,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTrackEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackEditor.html
https://root.cern/root/html534/TEveTrackEditor.html:4591,Availability,error,error,4591,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTrackEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackEditor.html
https://root.cern/root/html534/TEveTrackEditor.html:17406,Availability,mask,mask,17406,,MatchSource.WIKI,root/html534/TEveTrackEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackEditor.html
https://root.cern/root/html534/TEveTrackGL.html:1883,Performance,cache,cached,1883,"idTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TEveTrackGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackGL.html
https://root.cern/root/html534/TEveTrackList.html:5034,Availability,error,error,5034,"e(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:5118,Availability,error,error,5118,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:18313,Deployability,update,update,18313,"rnr, TEveElement* el); voidSetRnrPoints(Bool_t r); voidSetRnrPoints(Bool_t r, TEveElement* el); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:18416,Deployability,update,update,18416,"rnr, TEveElement* el); voidSetRnrPoints(Bool_t r); voidSetRnrPoints(Bool_t r, TEveElement* el); virtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidWriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:21418,Modifiability,variab,variable,21418,"ement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Double_tfLimPHighest track p in the container.; Double_tfLimPtHighest track pT in the container.; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaxPMaximum track pfor display selection.; Double_tfMaxPtMaximum track pTfor display selection.; Double_tfMinPMinimum track pfor display selection.; Double_tfMinPtMinimum track pTfor display selection.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*fPropagatorBasic track rendering parameters, not enforced to ",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:21556,Modifiability,variab,variable,21556,"eElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Double_tfLimPHighest track p in the container.; Double_tfLimPtHighest track pT in the container.; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaxPMaximum track pfor display selection.; Double_tfMaxPtMaximum track pTfor display selection.; Double_tfMinPMinimum track pfor display selection.; Double_tfMinPtMinimum track pTfor display selection.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*fPropagatorBasic track rendering parameters, not enforced to elements.; Bool_tfRecurseRecurse when propagating marker/line/etc attributes to tracks.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tfRnrLineRender track as line.; Bool_tf",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackList.html:24325,Safety,detect,detected,24325," TEveTrackList(const char* name, TEveTrackPropagator* prop = 0); Constructor. If track-propagator argument is 0, a new default; one is created. ~TEveTrackList(); Destructor. void SetPropagator(TEveTrackPropagator* prop); Set default propagator for tracks.; This is not enforced onto the tracks themselves but this is the; propagator that is shown in the TEveTrackListEditor. void MakeTracks(Bool_t recurse = kTRUE); Regenerate the visual representations of tracks.; The momentum limits are rescanned during the same traversal. void FindMomentumLimits(Bool_t recurse = kTRUE); Loop over children and find highest pT and p of contained TEveTracks.; These are stored in members fLimPt and fLimP. void FindMomentumLimits(TEveElement* el, Bool_t recurse = kTRUE); Loop over track elements of argument el and find highest pT and p.; These are stored in members fLimPt and fLimP. Double_t RoundMomentumLimit(Double_t x); Round the momentum limit up to a nice value. void SanitizeMinMaxCuts(); Set Min/Max cuts so that they are within detected limits. void SetRnrLine(Bool_t rnr); Set rendering of track as line for the list and the elements. void SetRnrLine(Bool_t rnr, TEveElement* el); Set rendering of track as line for children of el. void SetRnrPoints(Bool_t r); Set rendering of track as points for the list and the elements. void SetRnrPoints(Bool_t r, TEveElement* el); Set rendering of track as points for children of el. void SetMainColor(Color_t c); Set main (line) color for the list and the elements. void SetLineColor(Color_t c, TEveElement* el); Set line color for children of el. void SetLineWidth(Width_t w); Set line width for the list and the elements. void SetLineWidth(Width_t w, TEveElement* el); Set line width for children of el. void SetLineStyle(Style_t s); Set line style for the list and the elements. void SetLineStyle(Style_t s, TEveElement* el); Set line style for children of el. void SetMarkerStyle(Style_t s); Set marker style for the list and the elements. void SetMarkerSt",MatchSource.WIKI,root/html534/TEveTrackList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackList.html
https://root.cern/root/html534/TEveTrackListEditor.html:4601,Availability,error,error,4601,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTrackListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListEditor.html
https://root.cern/root/html534/TEveTrackListEditor.html:4685,Availability,error,error,4685,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTrackListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListEditor.html
https://root.cern/root/html534/TEveTrackListEditor.html:17536,Availability,mask,mask,17536,,MatchSource.WIKI,root/html534/TEveTrackListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListEditor.html
https://root.cern/root/html534/TEveTrackListProjected.html:4959,Availability,error,error,4959,"e(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:5043,Availability,error,error,5043,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:19304,Deployability,update,update,19304,"ual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveTrackList::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:19407,Deployability,update,update,19407,"ual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveTrackList::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:22693,Modifiability,variab,variable,22693,"r_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Double_tTEveTrackList::fLimPHighest track p in the container.; Double_tTEveTrackList::fLimPtHighest track pT in the container.; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTEveTrackList::fMaxPMaximum track pfor display selection.; Double_tTEveTrackList::fMaxPtMaximum track pTfor display selection.; Double_tTEveTrackList::fMinPMinimum track pfor display selection.; Double_tTEveTrackList::fMinPtMinimum track pTfor display selection.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to ori",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:22831,Modifiability,variab,variable,22831,"t::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Float_tTEveProjected::fDepthz coordinate; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Double_tTEveTrackList::fLimPHighest track p in the container.; Double_tTEveTrackList::fLimPtHighest track pT in the container.; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTEveTrackList::fMaxPMaximum track pfor display selection.; Double_tTEveTrackList::fMaxPtMaximum track pTfor display selection.; Double_tTEveTrackList::fMinPMinimum track pfor display selection.; Double_tTEveTrackList::fMinPtMinimum track pTfor display selection.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*TEveTrackList::fPropagatorBasic track rendering parameters, not enforced to e",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:25091,Modifiability,inherit,inheriting,25091," instances.; TEveTrackPropagator*TEveTrackList::fPropagatorBasic track rendering parameters, not enforced to elements.; Bool_tTEveTrackList::fRecurseRecurse when propagating marker/line/etc attributes to tracks.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveTrackList::fRnrLineRender track as line.; Bool_tTEveTrackList::fRnrPointsRender track as points.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackListProjected(); Default constructor. void SetProjection(TEveProjectionManager* proj, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); This is not needed for functionality as SetDepth(Float_t d); is overriden -- but SetDepthLocal() is abstract.; Just emits a warning if called. void SetDepth(Float_t d); Set depth of all children inheriting from TEveTrackProjected. void SetDepth(Float_t d, TEveElement* el); Set depth of all children of el inheriting from TEveTrackProjected. TEveTrackProjected& operator=(const TEveTrackListProjected& ). void UpdateProjection(). TEveElement* GetProjectedAsElement(); { return this; }. TEveTrackListProjected(const TEveTrackListProjected& ). virtual ~TEveTrackListProjected(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackListProjected.html:25202,Modifiability,inherit,inheriting,25202," instances.; TEveTrackPropagator*TEveTrackList::fPropagatorBasic track rendering parameters, not enforced to elements.; Bool_tTEveTrackList::fRecurseRecurse when propagating marker/line/etc attributes to tracks.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveTrackList::fRnrLineRender track as line.; Bool_tTEveTrackList::fRnrPointsRender track as points.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackListProjected(); Default constructor. void SetProjection(TEveProjectionManager* proj, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); This is not needed for functionality as SetDepth(Float_t d); is overriden -- but SetDepthLocal() is abstract.; Just emits a warning if called. void SetDepth(Float_t d); Set depth of all children inheriting from TEveTrackProjected. void SetDepth(Float_t d, TEveElement* el); Set depth of all children of el inheriting from TEveTrackProjected. TEveTrackProjected& operator=(const TEveTrackListProjected& ). void UpdateProjection(). TEveElement* GetProjectedAsElement(); { return this; }. TEveTrackListProjected(const TEveTrackListProjected& ). virtual ~TEveTrackListProjected(); {}. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveTrackListProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackListProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:7465,Availability,error,error,7465,"t(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:7549,Availability,error,error,7549,"t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGLis",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:24338,Deployability,update,update,24338," virtual voidTEveTrack::SetTrackParams(const TEveTrack& t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); Bool_tTEveTrack::ShouldBreakTrack() const; virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveTrack::SortPathMarksByTime(); voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveTrack::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:24441,Deployability,update,update,24441," virtual voidTEveTrack::SetTrackParams(const TEveTrack& t); virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); Bool_tTEveTrack::ShouldBreakTrack() const; virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTPolyMarker3D::Size() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveTrack::SortPathMarksByTime(); voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTEvePointSet::TakeAction(TEvePointSelector*); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveProjected::UnRefProjectable(TEveProjectable* assumed_parent, bool notifyParent = true); virtual voidTEveElement::UnSelected(); virtual voidUpdateProjection(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveTrack::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:29718,Energy Efficiency,allocate,allocated,29718,"x tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTEveTrack::fLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDTEveTrack::fPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDTEveTrack::fPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >TEveTrack::fPathMarksTEveVector of known points along the track; Int_tTEveTrack::fPdgPDG code; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*TEveTrack::fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:29345,Modifiability,variab,variable,29345,"ions; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; Int_tTEveTrack::fIndexReconstruction index; TArrayI*TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Int_tTEveTrack::fLabelSimulation label; Int_tTEveTrack::fLastPMIdx!Last path-mark index tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTEveTrack::fLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDTEveTrack::fPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDTEveTrack::fPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >TEveTrack::fPathMarksTEveVector o",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:29483,Modifiability,variab,variable,29483,"TEvePointSet::fIntIdsOptional array of integer ideices.; Int_tTEvePointSet::fIntIdsPerPointNumber of integer indices assigned to each point.; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Int_tTEveTrack::fLabelSimulation label; Int_tTEveTrack::fLastPMIdx!Last path-mark index tried in track-propagation.; Int_tTPolyMarker3D::fLastPointThe index of the last filled point; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTEveTrack::fLockPointsLock points that are currently in - do nothing in MakeTrack().; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TEveProjectionManager*TEveProjected::fManagermanager; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTPolyMarker3D::fNNumber of allocated points; TStringTPolyMarker3D::fNameName of polymarker; Int_tTEveElement::fNumChildren!; TStringTPolyMarker3D::fOptionOptions; Bool_tTPointSet3D::fOwnIdsFlag specifying id-objects are owned by the point-set; TEveVectorDTEveTrack::fPStarting momentum; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates; TEveVectorDTEveTrack::fPEndMomentum at the last point of extrapolation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >TEveTrack::fPathMarksTEveVector of known points along the track; Int_tTEveTrack::fPdgPDG code; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjected.html:31129,Modifiability,variab,variables,31129,"olation; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; vector<TEvePathMarkT<double> >TEveTrack::fPathMarksTEveVector of known points along the track; Int_tTEveTrack::fPdgPDG code; Bool_tTEveElement::fPickable; TEveProjectable*TEveProjected::fProjectablelink to original object; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; TEveTrackPropagator*TEveTrack::fPropagatorPointer to shared render-style; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveLine::fRnrLine; Bool_tTEveLine::fRnrPoints; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTEveLine::fSmooth; TRefTEveElement::fSourceExternal object that is represented by this element.; TEvePointSelectorConsumer::ETreeVarType_eTEvePointSelectorConsumer::fSourceCSCoordinate-System of the source tree variables; Int_tTEveTrack::fStatusStatus-word, user-defined.; TStringTEvePointSet::fTitleTitle/tooltip of the TEvePointSet.; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveVectorDTEveTrack::fVStarting vertex; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tTEveLine::fgDefaultSmooth. private:. TEveVector*fOrigPntsoriginal track points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackProjected(); Default constructor. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); This is virtual method from base-class TEveProjected. void SetDepthLocal(Float_t d); Set depth (z-c",MatchSource.WIKI,root/html534/TEveTrackProjected.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjected.html
https://root.cern/root/html534/TEveTrackProjectedGL.html:1951,Performance,cache,cached,1951,"Physicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTPointSet3DGL::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTPointSet3DGL::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTEveTrackGL::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidTPointSet3DGL::SetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTPointSet3DGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTEveTrackGL::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TEveTrackProjectedGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackProjectedGL.html
https://root.cern/root/html534/TEveTrackPropagator.html:5619,Availability,error,error,5619,"eElement::DisableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); voidFillPointSet(TEvePointSet* ps) const; TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEve",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:5703,Availability,error,error,5703,")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); voidFillPointSet(TEvePointSet* ps) const; TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_i",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:31667,Availability,error,error,31667,"s and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild tracks.; WARNING -- this method / variable was mis-named. Double_t GetMinAng() const; Get maximum step angle.; WARNING -- this method / variable was mis-named. void SetMaxAng(Double_t x); Set maximum step angle and rebuild tracks. void SetMaxStep(Double_t x); Set maximum step-size and rebuild tracks. void SetDelta(Double_t x); Set maximum error and rebuild tracks. void SetFitDaughters(Bool_t x); Set daughter creation point fitting and rebuild tracks. void SetFitReferences(Bool_t x); Set track-reference fitting and rebuild tracks. void SetFitDecay(Bool_t x); Set decay fitting and rebuild tracks. void SetFitLineSegments(Bool_t x); Set line segment fitting and rebuild tracks. void SetFitCluster2Ds(Bool_t x); Set 2D-cluster fitting and rebuild tracks. void SetRnrDecay(Bool_t x); Set decay rendering and rebuild tracks. void SetRnrCluster2Ds(Bool_t x); Set rendering of 2D-clusters and rebuild tracks. void SetRnrDaughters(Bool_t x); Set daughter rendering and rebuild tracks. void SetRnrReferences(Bool_t x); Set track-reference rendering and rebuild tracks. void SetRnrFV(Bool_t x); Set first-vertex rendering and rebuild tracks. void SetProjTrackBreaking(UChar_t x); Set projection break-point mode and rebuild tracks. void SetRnrPTBMarkers(Bool_t x); Set projection break-point rendering and rebuild tracks. void StepRungeKu",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:19119,Deployability,update,update,19119,"elf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetStepper(TEveTrackPropagator::EStepper_e s); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; virtual voidTEveRefBackPtr::StampBackPtrElements(UChar_t stamps); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:19222,Deployability,update,update,19222,"elf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidTEveElement::SetSourceObject(TObject* o); voidSetStepper(TEveTrackPropagator::EStepper_e s); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; virtual voidTEveRefBackPtr::StampBackPtrElements(UChar_t stamps); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28411,Deployability,update,update,28411,"ol_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current posit",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28586,Deployability,update,update,28586,"& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28844,Deployability,update,update,28844,"TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Find intersection of currently propagated track with a plane.; Current tra",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:11385,Energy Efficiency,charge,charge,11385,"::HandleElementPaste(TEveElement* el); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(const TEveVectorD& v, Int_t charge); voidInitTrack(const TEveVectorF& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedF",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:11436,Energy Efficiency,charge,charge,11436,"_tTObject::HandleTimer(TTimer* timer); Bool_tTEveElement::HasChild(TEveElement* el); Bool_tTEveElement::HasChildren() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tTEveElement::HasMainColor() const; virtual Bool_tTEveElement::HasMainTrans() const; Bool_tTEveElement::HasParents() const; virtual Bool_tTEveProjectable::HasProjecteds() const; virtual voidTEveElement::HighlightElement(Bool_t state); voidTEveElement::IncDenyDestroy(); virtual voidTEveElement::IncImpliedHighlighted(); virtual voidTEveElement::IncImpliedSelected(); voidTEveElement::IncParentIgnoreCnt(); virtual voidTEveRefBackPtr::IncRefCount(TEveElement* re); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTEveElement::InitMainTrans(Bool_t can_edit = kTRUE); voidInitTrack(const TEveVectorD& v, Int_t charge); voidInitTrack(const TEveVectorF& v, Int_t charge); virtual voidTObject::Inspect() constMENU ; Bool_tIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ); Bool_tTEveElement::IsPickable() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; TEveElement*TEveElement::LastChild() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTEveElement::NameTitleChanged(); virtual Bool_tTObject::Notify(); Int_tTEveElement::NumChildren() const; Int_tTEveElement::NumParents() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidOnZeroRefCount(); stati",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:26934,Energy Efficiency,charge,charge,26934," user data.; TEveVectorDfVStart vertex.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. ",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27050,Energy Efficiency,charge,charge,27050,"odel from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const ",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28327,Energy Efficiency,charge,charged,28327,"o end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVecto",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28500,Energy Efficiency,charge,charged,28500,"vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, co",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:28708,Energy Efficiency,charge,charged,28708,"rF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p); Distribute offset between first and last point index and rotate; momentum. Bool_t LineToVertex(TEveVectorD& v); Propagate neutral particle to vertex v. void LineToBounds(TEveVectorD& p); Propagatate neutral particle with momentum p to bounds. Bool_t HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& p",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27071,Integrability,wrap,wrapper,27071,"odel from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const ",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27743,Integrability,wrap,wrapper,27743,"hanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27848,Integrability,wrap,wrapper,27848,"n.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.;",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27993,Integrability,wrap,wrapper,27993,"s for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_step = kFALSE); Update helix / B-field projection state. void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut); Wrapper to step helix. void LoopToBounds(TEveVectorD& p); Propagate charged particle with momentum p to bounds.; It is expected that Update() with full-update was called before. Bool_t LoopToVertex(TEveVectorD& v, TEveVectorD& p); Propagate charged particle with momentum p to vertex v.; It is expected that Update() with full-update was called before. Bool_t LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate charged particle with momentum p to line segment with point s and vector r to the second point.; It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds. void DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:24250,Modifiability,variab,variable,24250,"y! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tfEditPathMarksShow widgets for path-mark control in GUI editor.; TMarkerfFVAttMarker attributes for fits vertex.; Bool_tfFitCluster2DsPass through 2D-clusters when extrapolating a track.; Bool_tfFitDaughtersPass through daughter creation points when extrapolating a track.; Bool_tfFitDecayPass through decay point when extrapolating a track.; Bool_tfFitLineSegmentsPass through line when extrapolating a track.; Bool_tfFitReferencesPass through given track-references when extrapolating a track.; TEveTrackPropagator::Helix_tfHHelix.; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveMagField*fMagFieldObj; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Double_tfMaxOrbsMaximal angular path of tracks' orbits (1 ~ 2Pi).; Double_tfMaxRMax radius for track extrapolation; Double_tfMaxZMax z-coordinate for track extrapolation.; Int_tfNMaxMax steps; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tfOwnMagFiledObj; TMarkerfPMAttMarker attributes for rendering of path-marks.; TMarkerfPTBAttMarker attributes for track break-points.; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; vector<TEveVector4D>fPointsCalculated point.; UChar_tfProjTrackBreakingHandling of projected-track breaking.; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Int_tTEveRefCnt::fRefCount; Bool",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:24388,Modifiability,variab,variable,24388,"PathMarksShow widgets for path-mark control in GUI editor.; TMarkerfFVAttMarker attributes for fits vertex.; Bool_tfFitCluster2DsPass through 2D-clusters when extrapolating a track.; Bool_tfFitDaughtersPass through daughter creation points when extrapolating a track.; Bool_tfFitDecayPass through decay point when extrapolating a track.; Bool_tfFitLineSegmentsPass through line when extrapolating a track.; Bool_tfFitReferencesPass through given track-references when extrapolating a track.; TEveTrackPropagator::Helix_tfHHelix.; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TEveMagField*fMagFieldObj; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Double_tfMaxOrbsMaximal angular path of tracks' orbits (1 ~ 2Pi).; Double_tfMaxRMax radius for track extrapolation; Double_tfMaxZMax z-coordinate for track extrapolation.; Int_tfNMaxMax steps; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Bool_tfOwnMagFiledObj; TMarkerfPMAttMarker attributes for rendering of path-marks.; TMarkerfPTBAttMarker attributes for track break-points.; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; vector<TEveVector4D>fPointsCalculated point.; UChar_tfProjTrackBreakingHandling of projected-track breaking.; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Int_tTEveRefCnt::fRefCount; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tfRnrCluster2DsRender 2D-clusters.; Bool_tfRnrDaughtersRender daughter path-marks.; Boo",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:31360,Modifiability,variab,variable,31360,". Bool_t ClosestPointBetweenLines(const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , TEveVectorD& out); Get closest point on line defined with vector p0 and u.; Return false if the point is forced on the line segment. void FillPointSet(TEvePointSet* ps) const; Reset ps and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild tracks.; WARNING -- this method / variable was mis-named. Double_t GetMinAng() const; Get maximum step angle.; WARNING -- this method / variable was mis-named. void SetMaxAng(Double_t x); Set maximum step angle and rebuild tracks. void SetMaxStep(Double_t x); Set maximum step-size and rebuild tracks. void SetDelta(Double_t x); Set maximum error and rebuild tracks. void SetFitDaughters(Bool_t x); Set daughter creation point fitting and rebuild tracks. void SetFitReferences(Bool_t x); Set track-reference fitting and rebuild tracks. void SetFitDecay(Bool_t x); Set decay fitting and rebuild tracks. void SetFitLineSegments(Bool_t x); Set line segment fitting and rebuild tracks. void SetFitCluster2Ds(Bool_t x); Set 2D-cluster fitting and rebuild tracks. void SetRnrDecay(Bool_t x); Set decay rendering and rebuild tracks. void SetRnrCluster2Ds(Bool_t x); Set rendering of 2D-clusters and rebuild tracks. void SetRnrDaughters(Bool_t x); Set daughter rendering and rebuild tracks. void SetRnrReferences(Bool_t x); Set track-refere",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:31462,Modifiability,variab,variable,31462," TEveVectorD& , TEveVectorD& out); Get closest point on line defined with vector p0 and u.; Return false if the point is forced on the line segment. void FillPointSet(TEvePointSet* ps) const; Reset ps and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild tracks.; WARNING -- this method / variable was mis-named. Double_t GetMinAng() const; Get maximum step angle.; WARNING -- this method / variable was mis-named. void SetMaxAng(Double_t x); Set maximum step angle and rebuild tracks. void SetMaxStep(Double_t x); Set maximum step-size and rebuild tracks. void SetDelta(Double_t x); Set maximum error and rebuild tracks. void SetFitDaughters(Bool_t x); Set daughter creation point fitting and rebuild tracks. void SetFitReferences(Bool_t x); Set track-reference fitting and rebuild tracks. void SetFitDecay(Bool_t x); Set decay fitting and rebuild tracks. void SetFitLineSegments(Bool_t x); Set line segment fitting and rebuild tracks. void SetFitCluster2Ds(Bool_t x); Set 2D-cluster fitting and rebuild tracks. void SetRnrDecay(Bool_t x); Set decay rendering and rebuild tracks. void SetRnrCluster2Ds(Bool_t x); Set rendering of 2D-clusters and rebuild tracks. void SetRnrDaughters(Bool_t x); Set daughter rendering and rebuild tracks. void SetRnrReferences(Bool_t x); Set track-reference rendering and rebuild tracks. void SetRnrFV(Bool_t x); Set first-vertex rendering and rebuild trac",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:27105,Performance,cache,cache,27105,"B for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); Default constructor. ~TEveTrackPropagator(); Destructor. void OnZeroRefCount(); Virtual from TEveRefBackPtr - track reference count has reached zero. void CheckReferenceCount(const TEveException& eh = ""TEveElement::CheckReferenceCount ""); Check reference count - virtual from TEveElement.; Must also take into account references from TEveRefBackPtr. void ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element-change notification.; Stamp all tracks as requiring display-list regeneration.; Virtual from TEveElement. void InitTrack(const TEveVectorD& v, Int_t charge); Initialize internal data-members for given particle parameters. void InitTrack(const TEveVectorF& v, Int_t charge); TEveVectorF wrapper. void ResetTrack(); Reset cache holding particle trajectory. Int_t GetCurrentPoint() const; Get index of current point on track. Double_t GetTrackLength(Int_t start_point = 0, Int_t end_point = -1) const; Calculate track length from start_point to end_point.; If end_point is less than 0, distance to the end is returned. Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p); Propagate particle with momentum p to vertex v. Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p); Propagate particle with momentum p to line with start point s and vector r to the second point. Bool_t GoToVertex(TEveVectorF& v, TEveVectorF& p); TEveVectorF wrapper. Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p); TEveVectorF wrapper. void GoToBounds(TEveVectorD& p); Propagate particle to bounds.; Return TRUE if hit bounds. void GoToBounds(TEveVectorF& p); TEveVectorF wrapper. void Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update = kFALSE, Bool_t enforce_max_st",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:30332,Performance,cache,cached,30332,"torD& normal, TEveVectorD& itsect); Intersect helix with a plane. Current position and argument p define; the helix. Bool_t LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Intersect line with a plane. Current position and argument p define; the line. Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Find intersection of currently propagated track with a plane.; Current track position is used as starting point. Args:; p - track momentum to use for extrapolation; point - a point on a plane; normal - normal of the plane; itsect - output, point of intersection; Returns:; kFALSE if intersection can not be found, kTRUE otherwise. void ClosestPointFromVertexToLineSegment(const TEveVectorD& v, const TEveVectorD& s, const TEveVectorD& r, Double_t rMagInv, TEveVectorD& c); Get closest point from given vertex v to line segment defined with s and r.; Argument rMagInv is cached. rMagInv= 1./rMag(). Bool_t ClosestPointBetweenLines(const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , TEveVectorD& out); Get closest point on line defined with vector p0 and u.; Return false if the point is forced on the line segment. void FillPointSet(TEvePointSet* ps) const; Reset ps and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:30704,Performance,cache,cache,30704,"Plane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal, TEveVectorD& itsect); Find intersection of currently propagated track with a plane.; Current track position is used as starting point. Args:; p - track momentum to use for extrapolation; point - a point on a plane; normal - normal of the plane; itsect - output, point of intersection; Returns:; kFALSE if intersection can not be found, kTRUE otherwise. void ClosestPointFromVertexToLineSegment(const TEveVectorD& v, const TEveVectorD& s, const TEveVectorD& r, Double_t rMagInv, TEveVectorD& c); Get closest point from given vertex v to line segment defined with s and r.; Argument rMagInv is cached. rMagInv= 1./rMag(). Bool_t ClosestPointBetweenLines(const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , TEveVectorD& out); Get closest point on line defined with vector p0 and u.; Return false if the point is forced on the line segment. void FillPointSet(TEvePointSet* ps) const; Reset ps and populate it with points in propagation cache. void RebuildTracks(); Rebuild all tracks using this render-style. void SetMagField(Double_t bX, Double_t bY, Double_t bZ); Set constant magnetic field and rebuild tracks. void SetMagFieldObj(TEveMagField* field, Bool_t own_field = kTRUE); Set constant magnetic field and rebuild tracks. void PrintMagField(Double_t x, Double_t y, Double_t z) const. void SetMaxR(Double_t x); Set maximum radius and rebuild tracks. void SetMaxZ(Double_t x); Set maximum z and rebuild tracks. void SetMaxOrbs(Double_t x); Set maximum number of orbits and rebuild tracks. void SetMinAng(Double_t x); Set maximum step angle and rebuild tracks.; WARNING -- this method / variable was mis-named. Double_t GetMinAng() const; Get maximum step angle.; WARNING -- this method / variable was mis-named. void SetMaxAng(Double_t x); Set maximum step angle and rebuild tracks. void SetMaxStep(Double_t x); Set maximum step-size and rebuild tracks. void SetDelta(Double_t x); Set ",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagator.html:817,Security,access,access,817,". TEveTrackPropagator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrackPropagator. class TEveTrackPropagator: public TEveElementList, public TEveRefBackPtr. Holding structure for a number of track rendering parameters.; Calculates path taking into account the parameters. NOTE: Magnetic field direction convention is inverted. This is decoupled from TEveTrack/TEveTrackList to allow sharing of the; Propagator among several instances. Back references are kept so the tracks; can be recreated when the parameters change. TEveTrackList has Get/Set methods for RnrStlye. TEveTrackEditor and; TEveTrackListEditor provide editor access. Enum EProjTrackBreaking_e and member fProjTrackBreaking specify whether 2D; projected tracks get broken into several segments when the projected space; consists of separate domains (like Rho-Z). The track-breaking is enabled by; default. Function Members (Methods); public:. TEveTrackPropagator(const char* n = ""TEveTrackPropagator"", const char* t = """", TEveMagField* field = 0, Bool_t own_field = kTRUE); virtual~TEveTrackPropagator(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElementList::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement:",MatchSource.WIKI,root/html534/TEveTrackPropagator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagator.html
https://root.cern/root/html534/TEveTrackPropagatorEditor.html:4611,Availability,error,error,4611,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTrackPropagatorEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorEditor.html
https://root.cern/root/html534/TEveTrackPropagatorEditor.html:4695,Availability,error,error,4695,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTrackPropagatorEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorEditor.html
https://root.cern/root/html534/TEveTrackPropagatorEditor.html:17570,Availability,mask,mask,17570,";; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveTrackPropagator*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTR",MatchSource.WIKI,root/html534/TEveTrackPropagatorEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorEditor.html
https://root.cern/root/html534/TEveTrackPropagatorEditor.html:388,Integrability,wrap,wrapper,388,". TEveTrackPropagatorEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrackPropagatorEditor. class TEveTrackPropagatorEditor: public TGedFrame. GUI editor for TEveTrackPropagator.; It's only a wrapper around a TEveTrackPropagatorSubEditor that holds actual; widgets. Function Members (Methods); public:. TEveTrackPropagatorEditor(const TGWindow* p = 0, Int_t width = 170, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TEveTrackPropagatorEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* recei",MatchSource.WIKI,root/html534/TEveTrackPropagatorEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorEditor.html
https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html:4448,Availability,error,error,4448,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTrackPropagatorSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html
https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html:4532,Availability,error,error,4532,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTrackPropagatorSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html
https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html:16989,Availability,mask,mask,16989,,MatchSource.WIKI,root/html534/TEveTrackPropagatorSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrackPropagatorSubEditor.html
https://root.cern/root/html534/TEveTrans.html:2537,Availability,error,error,2537,"rrX(); const Double_t*ArrX() const; Double_t*ArrY(); const Double_t*ArrY() const; Double_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TVector3& v) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditRotation(); Bool_tGetEditScale(); Bool_tGetEditTrans() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVector3GetPos() const; voidGetPos(Double_t* x) const; voidGetPos(Float_t* x) const; voidGetPos(TVector3& v) const; voidGetPos(Double_t& x, Double_t& y, Double_",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:2621,Availability,error,error,2621,"uble_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVector3GetBaseVec(Int_t b) const; voidGetBaseVec(Int_t b, TVector3& v) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditRotation(); Bool_tGetEditScale(); Bool_tGetEditTrans() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVector3GetPos() const; voidGetPos(Double_t* x) const; voidGetPos(Float_t* x) const; voidGetPos(TVector3& v) const; voidGetPos(Double_t& x, Double_t& y, Double_t& z) const; voidGetRotAngles(Float_t* x) const; voidGetScale(Double_t& sx, Double_t",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:515,Deployability,continuous,continuous,515,". TEveTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrans. class TEveTrans: public TObject. TEveTrans is a 4x4 transformation matrix for homogeneous coordinates; stored internaly in a column-major order to allow direct usage by; GL. The element type is Double32_t as statically the floats would; be precise enough but continuous operations on the matrix must; retain precision of column vectors. Cartan angles are stored in fA[1-3] (+z, -y, +x). They are; recalculated on demand. Direct element access (first two should be used with care):; operator[i] direct access to elements, i:0->15; CM(i,j) element 4*j + i; i,j:0->3 { CM ~ c-matrix }; operator(i,j) element 4*(j-1) + i - 1 i,j:1->4. Column-vector access:; USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods. For all methods taking the matrix indices:; 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time. Shorthands in method-names:; LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace. Function Members (Methods); public:. TEveTrans(); TEveTrans(const TEveTrans& t); TEveTrans(const Double_t* arr); TEveTrans(const Float_t* arr); virtual~TEveTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_t*Array(); const Double_t*Array() const; Double_t*ArrT(); const Double_t*ArrT() const; Double_t*ArrX(); const Double_t*ArrX() const; Double_t*ArrY(); const Double_t*ArrY() const; Double_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* o",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:692,Security,access,access,692,". TEveTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrans. class TEveTrans: public TObject. TEveTrans is a 4x4 transformation matrix for homogeneous coordinates; stored internaly in a column-major order to allow direct usage by; GL. The element type is Double32_t as statically the floats would; be precise enough but continuous operations on the matrix must; retain precision of column vectors. Cartan angles are stored in fA[1-3] (+z, -y, +x). They are; recalculated on demand. Direct element access (first two should be used with care):; operator[i] direct access to elements, i:0->15; CM(i,j) element 4*j + i; i,j:0->3 { CM ~ c-matrix }; operator(i,j) element 4*(j-1) + i - 1 i,j:1->4. Column-vector access:; USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods. For all methods taking the matrix indices:; 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time. Shorthands in method-names:; LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace. Function Members (Methods); public:. TEveTrans(); TEveTrans(const TEveTrans& t); TEveTrans(const Double_t* arr); TEveTrans(const Float_t* arr); virtual~TEveTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_t*Array(); const Double_t*Array() const; Double_t*ArrT(); const Double_t*ArrT() const; Double_t*ArrX(); const Double_t*ArrX() const; Double_t*ArrY(); const Double_t*ArrY() const; Double_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* o",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:757,Security,access,access,757,". TEveTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrans. class TEveTrans: public TObject. TEveTrans is a 4x4 transformation matrix for homogeneous coordinates; stored internaly in a column-major order to allow direct usage by; GL. The element type is Double32_t as statically the floats would; be precise enough but continuous operations on the matrix must; retain precision of column vectors. Cartan angles are stored in fA[1-3] (+z, -y, +x). They are; recalculated on demand. Direct element access (first two should be used with care):; operator[i] direct access to elements, i:0->15; CM(i,j) element 4*j + i; i,j:0->3 { CM ~ c-matrix }; operator(i,j) element 4*(j-1) + i - 1 i,j:1->4. Column-vector access:; USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods. For all methods taking the matrix indices:; 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time. Shorthands in method-names:; LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace. Function Members (Methods); public:. TEveTrans(); TEveTrans(const TEveTrans& t); TEveTrans(const Double_t* arr); TEveTrans(const Float_t* arr); virtual~TEveTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_t*Array(); const Double_t*Array() const; Double_t*ArrT(); const Double_t*ArrT() const; Double_t*ArrX(); const Double_t*ArrX() const; Double_t*ArrY(); const Double_t*ArrY() const; Double_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* o",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:901,Security,access,access,901,". TEveTrans. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveTrans. class TEveTrans: public TObject. TEveTrans is a 4x4 transformation matrix for homogeneous coordinates; stored internaly in a column-major order to allow direct usage by; GL. The element type is Double32_t as statically the floats would; be precise enough but continuous operations on the matrix must; retain precision of column vectors. Cartan angles are stored in fA[1-3] (+z, -y, +x). They are; recalculated on demand. Direct element access (first two should be used with care):; operator[i] direct access to elements, i:0->15; CM(i,j) element 4*j + i; i,j:0->3 { CM ~ c-matrix }; operator(i,j) element 4*(j-1) + i - 1 i,j:1->4. Column-vector access:; USet Get/SetBaseVec(), Get/SetPos() and Arr[XYZT]() methods. For all methods taking the matrix indices:; 1->X, 2->Y, 3->Z; 4->Position (if applicable). 0 reserved for time. Shorthands in method-names:; LF ~ LocalFrame; PF ~ ParentFrame; IP ~ InPlace. Function Members (Methods); public:. TEveTrans(); TEveTrans(const TEveTrans& t); TEveTrans(const Double_t* arr); TEveTrans(const Float_t* arr); virtual~TEveTrans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_t*Array(); const Double_t*Array() const; Double_t*ArrT(); const Double_t*ArrT() const; Double_t*ArrX(); const Double_t*ArrX() const; Double_t*ArrY(); const Double_t*ArrY() const; Double_t*ArrZ(); const Double_t*ArrZ() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Double_tCM(Int_t i, Int_t j) const; Double_t&CM(Int_t i, Int_t j); virtual Int_tTObject::Compare(const TObject* o",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTrans.html:16300,Security,access,access,16300,"ref. void OrtoNorm3(); Orto-norm columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& ); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.9, Double_t high = 1.1) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestio",MatchSource.WIKI,root/html534/TEveTrans.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTrans.html
https://root.cern/root/html534/TEveTransEditor.html:4483,Availability,error,error,4483,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransEditor.html
https://root.cern/root/html534/TEveTransEditor.html:4567,Availability,error,error,4567,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransEditor.html
https://root.cern/root/html534/TEveTransEditor.html:17382,Availability,mask,mask,17382,"ed; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveTrans*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if",MatchSource.WIKI,root/html534/TEveTransEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransEditor.html
https://root.cern/root/html534/TEveTransSubEditor.html:4196,Availability,error,error,4196,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTransSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransSubEditor.html
https://root.cern/root/html534/TEveTransSubEditor.html:4280,Availability,error,error,4280,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTransSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransSubEditor.html
https://root.cern/root/html534/TEveTransSubEditor.html:16941,Availability,mask,mask,16941,,MatchSource.WIKI,root/html534/TEveTransSubEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTransSubEditor.html
https://root.cern/root/html534/TEveTriangleSet.html:5108,Availability,error,error,5108,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:5192,Availability,error,error,5192,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:16768,Deployability,update,update,16768,"voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); voidSetTransparency(Char_t tr)MENU ; voidSetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); voidSetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertex(Int_t i, Float_t x, Float_t y, Float_t z); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; Int_t*Triangle(Int_t i); UChar_t*TriangleColor(Int_t i); Float_t*TriangleNormal(Int_t i); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Float_t*Vertex(Int_t i); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:16871,Deployability,update,update,16871,"voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); voidSetTransparency(Char_t tr)MENU ; voidSetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); voidSetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertex(Int_t i, Float_t x, Float_t y, Float_t z); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; virtual voidTAtt3D::Sizeof3D() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; Int_t*Triangle(Int_t i); UChar_t*TriangleColor(Int_t i); Float_t*TriangleNormal(Int_t i); virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Float_t*Vertex(Int_t i); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:6869,Integrability,wrap,wrap,6869,"hildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::FindListTreeItem(TGListTree* ltree); virtual TGListTreeItem*TEveElement::FindListTreeItem(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tTEveElement::FindVizModel(); TEveElement*TEveElement::FirstChild() const; virtual TEveElement*TEveElement::ForwardEdit(); virtual TEveElement*TEveElement::ForwardSelection(); voidGenerateRandomColors(); voidGenerateTriangleNormals(); voidGenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Float_t*TAttBBox::GetBBox(); Bool_tTAttBBox::GetBBoxOK() const; UChar_tTEveElement::GetChangeBits() const; TClass*TEveElementList::GetChildClass() const; TEveCompound*TEveElement::GetCompound(); Int_tTEveElement::GetDenyDestroy() const; Bool_tTEveElement::GetDestroyOnZeroRefCnt() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObject*TEveElement::GetEditorObject(const TEveException& eh) const; virtual const char*TEveElementList::GetElementName() const; virtual const char*TEveElementList::GetElementTitle() const; virtual TStringTEveElement::GetHighlightTooltip(); virtual const char*TObject::GetIconName() const; virtual const TGPicture*TEveElement::GetListTreeCheckBoxIcon(); virtual const TGPicture*TEveElement::GetListTreeIcon(Bool_t open = kFALSE); virtual Color_tTEveElement::GetMainColor() const; Color_t*TEveElement::GetMainColorPtr() const; virtual Char_tTEveElement::GetMainTransparency() const; TEveElement*TEveElement",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:21667,Integrability,wrap,wrap,21667,"ernal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; UChar_t*fTringCols[3*fNTrings]; Float_t*fTringNorms[3*fNTrings]; Int_t*fTrings[3*fNTrings]; void*TEveElement::fUserData! Externally assigned and controlled user data.; Float_t*fVerts[3*fNVerts]; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms = kFALSE, Bool_t cols = kFALSE); Constructor. ~TEveTriangleSet(); Destructor. void GenerateTriangleNormals(); Generate triangle normals via cross product of triangle edges. void GenerateRandomColors(); Assign random colors to all triangles. void GenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Generate triangle colors by the z-component of the normal.; Current palette is taken from gStyle. void ComputeBBox(); Compute bounding box.; Virtual from TAttBBox. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TEveTriangleSet* ReadTrivialFile(const char* file); Read a simple ascii input file describing vertices and triangles. TEveTriangleSet(const TEveTriangleSet& ). TEveTriangleSet& operator=(const TEveTriangleSet& ). Bool_t CanEditMainTransparency() const; { return kTRUE; }. Int_t GetNVerts() const; { return fNVerts; }. Int_t GetNTrings() const; { return fNTrings; }. Float_t* Vertex(Int_t i); { return &(fVerts[3*i]); }. Int_t* Triangle(Int_t i); { return &(fTrings[3*i]); }. Float_t* TriangleNormal(Int_t i); { return &(fTringNorms[3*i]); }. UChar_t* TriangleColor(Int_t i); { return &(fTringCols[3*i]); }. void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z); { Float_t* v = Vertex(i); v[0] = x; v[1] = y; v",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:19962,Modifiability,variab,variable,19962,"ts; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Int_tfNTrings; Int_tfNVerts; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; UChar_t*fTringCols[3*fNTrings]; Float_t*fTringNorms[3*fNTrings]; Int_t*fTrings[3*fNTrings]; void*",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:20100,Modifiability,variab,variable,20100,"ion.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; Int_tfNTrings; Int_tfNVerts; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; UChar_t*fTringCols[3*fNTrings]; Float_t*fTringNorms[3*fNTrings]; Int_t*fTrings[3*fNTrings]; void*TEveElement::fUserData! Externally assigned and controlled user data.; Float_t*fVerts[3*fNVerts]; TEveElement*TEveElement::fVizModel! Eleme",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSet.html:21996,Usability,simpl,simple,21996,"d user data.; Float_t*fVerts[3*fNVerts]; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms = kFALSE, Bool_t cols = kFALSE); Constructor. ~TEveTriangleSet(); Destructor. void GenerateTriangleNormals(); Generate triangle normals via cross product of triangle edges. void GenerateRandomColors(); Assign random colors to all triangles. void GenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Generate triangle colors by the z-component of the normal.; Current palette is taken from gStyle. void ComputeBBox(); Compute bounding box.; Virtual from TAttBBox. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TEveTriangleSet* ReadTrivialFile(const char* file); Read a simple ascii input file describing vertices and triangles. TEveTriangleSet(const TEveTriangleSet& ). TEveTriangleSet& operator=(const TEveTriangleSet& ). Bool_t CanEditMainTransparency() const; { return kTRUE; }. Int_t GetNVerts() const; { return fNVerts; }. Int_t GetNTrings() const; { return fNTrings; }. Float_t* Vertex(Int_t i); { return &(fVerts[3*i]); }. Int_t* Triangle(Int_t i); { return &(fTrings[3*i]); }. Float_t* TriangleNormal(Int_t i); { return &(fTringNorms[3*i]); }. UChar_t* TriangleColor(Int_t i); { return &(fTringCols[3*i]); }. void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z); { Float_t* v = Vertex(i); v[0] = x; v[1] = y; v[2] = z; }. void SetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); { Int_t* t = Triangle(i); t[0] = v0; t[1] = v1; t[2] = v2; }. void SetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); { UChar_t* c = TriangleColor(i); c[0] = r; c[1] = g; c[2] = b; c[3] = a; }. void SetTransparency(Char_t tr); { SetMainTransparency(tr",MatchSource.WIKI,root/html534/TEveTriangleSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSet.html
https://root.cern/root/html534/TEveTriangleSetEditor.html:4502,Availability,error,error,4502,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveTriangleSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSetEditor.html
https://root.cern/root/html534/TEveTriangleSetEditor.html:4586,Availability,error,error,4586,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveTriangleSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSetEditor.html
https://root.cern/root/html534/TEveTriangleSetEditor.html:17425,Availability,mask,mask,17425,"private:. TEveTriangleSetEditor(const TEveTriangleSetEditor&); TEveTriangleSetEditor&operator=(const TEveTriangleSetEditor&). Data Members; public:. enum TGFrame::[unnamed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TGLabel*fInfoInfo label.; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveTriangleSet*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fMo",MatchSource.WIKI,root/html534/TEveTriangleSetEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSetEditor.html
https://root.cern/root/html534/TEveTriangleSetGL.html:1962,Performance,cache,cached,1962,"DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TEveTriangleSetGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveTriangleSetGL.html
https://root.cern/root/html534/TEveUtil.html:3734,Availability,error,error,3734,"T's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Float_t GetFraction(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Get fraction of interval [minQ, maxQ] in [minM, maxM]. Bool_t IsU1IntervalContainedByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ). Bool_t IsU1IntervalOverlappingByM",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:2169,Deployability,configurat,configurations,2169," static Bool_tIsU1IntervalOverlappingByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ); static Bool_tIsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corre",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:3469,Integrability,wrap,wrap,3469,"ro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] inter",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:2169,Modifiability,config,configurations,2169," static Bool_tIsU1IntervalOverlappingByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ); static Bool_tIsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corre",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:4095,Modifiability,variab,variables,4095,"(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Float_t GetFraction(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Get fraction of interval [minQ, maxQ] in [minM, maxM]. Bool_t IsU1IntervalContainedByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ). Bool_t IsU1IntervalOverlappingByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ). virtual ~TEveUtil(); {}. TEvePadHolder& operator=(const TEveUtil& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or sugge",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:4369,Modifiability,variab,variables,4369,"col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Float_t GetFraction(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Get fraction of interval [minQ, maxQ] in [minM, maxM]. Bool_t IsU1IntervalContainedByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ). Bool_t IsU1IntervalOverlappingByMeanDelta(Float_t meanM, Float_t deltaM, Float_t meanQ, Float_t deltaQ). virtual ~TEveUtil(); {}. TEvePadHolder& operator=(const TEveUtil& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:2299,Performance,load,loaded,2299,"sU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:2390,Performance,load,loaded,2390,"axQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in o",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:2541,Performance,load,loaded,2541,"ull_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. vo",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveUtil.html:3382,Security,access,access,3382,"ro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] inter",MatchSource.WIKI,root/html534/TEveUtil.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveUtil.html
https://root.cern/root/html534/TEveViewer.html:5778,Availability,error,error,5778,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:5862,Availability,error,error,5862,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:18257,Deployability,update,update,18257,"Element::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; TGLEmbeddedViewer*SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); TGLSAViewer*SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; voidSwitchStereo(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:18360,Deployability,update,update,18360,"Element::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; TGLEmbeddedViewer*SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); TGLSAViewer*SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; voidSwitchStereo(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:21215,Modifiability,variab,variable,21215,"main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; TGLViewer*fGLViewer; TGFrame*fGLViewerFrame; TGFrame*TEveWindowFrame::fGUIFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveE",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:21353,Modifiability,variab,variable,21353,"ass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; TGLViewer*fGLViewer; TGFrame*fGLViewerFrame; TGFrame*TEveWindowFrame::fGUIFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_t",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewer.html:23132,Usability,undo,undocked,23132,"veElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_tTEveWindow::fgCurrentBackgroundColor; static Bool_tfgInitInternal; static UInt_tTEveWindow::fgMainFrameDefHeight; static UInt_tTEveWindow::fgMainFrameDefWidth; static Pixel_tTEveWindow::fgMiniBarBackgroundColor; static Bool_tfgRecreateGlOnDockOps. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'el' from the list of child",MatchSource.WIKI,root/html534/TEveViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewer.html
https://root.cern/root/html534/TEveViewerList.html:4902,Availability,error,error,4902,"r_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual voidDisconnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:4986,Availability,error,error,4986,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:16455,Deployability,update,update,16455,"irtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidSetShowTooltip(Bool_t x); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSwitchColorSet(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Bool_tUseLightColorSet() const; voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:16558,Deployability,update,update,16558,"irtual Bool_tTEveElement::SetRnrSelf(Bool_t rnr); virtual Bool_tTEveElement::SetRnrSelfChildren(Bool_t rnr_self, Bool_t rnr_children); virtual Bool_tTEveElement::SetRnrState(Bool_t rnr); voidSetShowTooltip(Bool_t x); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSwitchColorSet(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); Bool_tUseLightColorSet() const; voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:21774,Deployability,update,updated,21774,"s compound is set to this. void RemoveElementLocal(TEveElement* el); Decompoundofy el, call base-class version. void RemoveElementsLocal(); Decompoundofy children, call base-class version. void Connect(); Connect to TGLViewer class-signals. void Disconnect(); Disconnect from TGLViewer class-signals. void RepaintChangedViewers(Bool_t resetCameras, Bool_t dropLogicals); Repaint viewers that are tagged as changed. void RepaintAllViewers(Bool_t resetCameras, Bool_t dropLogicals); Repaint all viewers. void DeleteAnnotations(); Delete annotations from all viewers. void SceneDestructing(TEveScene* scene); Callback done from a TEveScene destructor allowing proper; removal of the scene from affected viewers. void HandleTooltip(); Show / hide tooltip for various MouseOver events.; Must be called from slots where sender is TGLEventHandler. void OnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::MouseOver() signal. The attempt is made to determine the TEveElement being; represented by the physical shape and global higlight is updated; accordingly. If TEveElement::IsPickable() returns false, the element is not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UIn",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:22075,Deployability,update,updated,22075,"ers(Bool_t resetCameras, Bool_t dropLogicals); Repaint viewers that are tagged as changed. void RepaintAllViewers(Bool_t resetCameras, Bool_t dropLogicals); Repaint all viewers. void DeleteAnnotations(); Delete annotations from all viewers. void SceneDestructing(TEveScene* scene); Callback done from a TEveScene destructor allowing proper; removal of the scene from affected viewers. void HandleTooltip(); Show / hide tooltip for various MouseOver events.; Must be called from slots where sender is TGLEventHandler. void OnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::MouseOver() signal. The attempt is made to determine the TEveElement being; represented by the physical shape and global higlight is updated; accordingly. If TEveElement::IsPickable() returns false, the element is not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::ReClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::UnClicked(). The obj is",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:22326,Deployability,update,updated,22326,"Destructing(TEveScene* scene); Callback done from a TEveScene destructor allowing proper; removal of the scene from affected viewers. void HandleTooltip(); Show / hide tooltip for various MouseOver events.; Must be called from slots where sender is TGLEventHandler. void OnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::MouseOver() signal. The attempt is made to determine the TEveElement being; represented by the physical shape and global higlight is updated; accordingly. If TEveElement::IsPickable() returns false, the element is not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::ReClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::UnClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void SetColorBrightness(Float_t b); Set color brightness. void SwitchColorSet(); Switch background c",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:22584,Deployability,update,updated,22584,"andler. void OnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::MouseOver() signal. The attempt is made to determine the TEveElement being; represented by the physical shape and global higlight is updated; accordingly. If TEveElement::IsPickable() returns false, the element is not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::ReClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::UnClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void SetColorBrightness(Float_t b); Set color brightness. void SwitchColorSet(); Switch background color. TEveViewer& operator=(const TEveViewerList& ). TEveViewerList(const TEveViewerList& ). Bool_t GetShowTooltip() const. { return fShowTooltip; }. void SetShowTooltip(Bool_t x); { fShowTooltip = x; }. Float_t GetColorBrightness() const; { return fBrightne",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:22846,Deployability,update,updated,22846,"() returns false, the element is not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::ReClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::UnClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void SetColorBrightness(Float_t b); Set color brightness. void SwitchColorSet(); Switch background color. TEveViewer& operator=(const TEveViewerList& ). TEveViewerList(const TEveViewerList& ). Bool_t GetShowTooltip() const. { return fShowTooltip; }. void SetShowTooltip(Bool_t x); { fShowTooltip = x; }. Float_t GetColorBrightness() const; { return fBrightness; }. Bool_t UseLightColorSet() const; { return fUseLightColorSet; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:23108,Deployability,update,updated,23108,"s not; highlighted. Highlight is always in single-selection mode. void OnReMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::ReMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnMouseOver(TObject* obj, UInt_t state); Slot for global TGLViewer::UnMouseOver(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::Clicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnReClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::ReClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void OnUnClicked(TObject* obj, UInt_t button, UInt_t state); Slot for global TGLViewer::UnClicked(). The obj is dyn-casted to the TEveElement and global selection is; updated accordingly. If TEveElement::IsPickable() returns false, the element is not; selected. void SetColorBrightness(Float_t b); Set color brightness. void SwitchColorSet(); Switch background color. TEveViewer& operator=(const TEveViewerList& ). TEveViewerList(const TEveViewerList& ). Bool_t GetShowTooltip() const. { return fShowTooltip; }. void SetShowTooltip(Bool_t x); { fShowTooltip = x; }. Float_t GetColorBrightness() const; { return fBrightness; }. Bool_t UseLightColorSet() const; { return fUseLightColorSet; }. » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:19272,Modifiability,variab,variable,19272,"ts; Bool_tTEveElement::fCanEditMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfShowTooltip; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; Bool_tfUseLightColorSet; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveE",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerList.html:19410,Modifiability,variab,variable,19410,"ion.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfShowTooltip; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; Bool_tfUseLightColorSet; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Cla",MatchSource.WIKI,root/html534/TEveViewerList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerList.html
https://root.cern/root/html534/TEveViewerListEditor.html:4514,Availability,error,error,4514,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveViewerListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerListEditor.html
https://root.cern/root/html534/TEveViewerListEditor.html:4598,Availability,error,error,4598,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveViewerListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerListEditor.html
https://root.cern/root/html534/TEveViewerListEditor.html:17506,Availability,mask,mask,17506,"Mode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TEveGValuator*fBrightness; TGClient*TGObject::fClientConnection to display server; TGTextButton*fColorSet; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveViewerList*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tT",MatchSource.WIKI,root/html534/TEveViewerListEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveViewerListEditor.html
https://root.cern/root/html534/TEveVSD.html:1562,Availability,error,error,1562,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateBranches(); virtual voidCreateTrees(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteTrees(); static voidDisableTObjectStreamersForVSDStruct(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TEveVSD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveVSD.html
https://root.cern/root/html534/TEveVSD.html:1646,Availability,error,error,1646,"owse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateBranches(); virtual voidCreateTrees(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteTrees(); static voidDisableTObjectStreamersForVSDStruct(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TEveVSD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveVSD.html
https://root.cern/root/html534/TEveVSD.html:6792,Modifiability,inherit,inherit,6792,"t; voidTObject::MakeZombie(). private:. TEveVSD(const TEveVSD&); TEveVSD&operator=(const TEveVSD&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TEveClusterfC; TEveRecCascadefCC; TEveMCRecCrossReffGI; TEveHitfH; TEveMCTrackfK; TEveRecKinkfKK; TEveRecTrackfR; TTree*fTreeC! Clusters.; TTree*fTreeCC! Cascades.; TTree*fTreeGI! Sim-Rec cross references.; TTree*fTreeH! Hits.; TTree*fTreeK! Kinematics.; TTree*fTreeKK! Kinks.; TTree*fTreeR! Reconstructed tracks.; TTree*fTreeV0! VO's.; TEveRecV0fV0; TEveCluster*fpC!; TEveRecCascade*fpCC!; TEveMCRecCrossRef*fpGI!; TEveHit*fpH!; TEveMCTrack*fpK!; TEveRecKink*fpKK!; TEveRecTrack*fpR!; TEveRecV0*fpV0!. protected:. Int_tfBuffSize!; TDirectory*fDirectory!; TFile*fFile!; Int_tfVerbose!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveVSD(const char* name = ""TEveVSD"", const char* title = """"); Constructor. ~TEveVSD(); Destructor. void SetDirectory(TDirectory* dir); Set directory in which the trees are (or will be) created. void CreateTrees(); Create internal trees. void DeleteTrees(); Delete interal trees. void CreateBranches(); Create internal VSD branches. void SetBranchAddresses(); Set branche addresses of internal trees. void WriteTrees(); Does nothing here ... reimplemented in sub-classes. void LoadTrees(); Load internal trees from directory. void DisableTObjectStreamersForVSDStruct(); Disble TObject streamers for those VSD structs that inherit from; TObject directly. TEveVSD(const TEveVSD& ). TEveVSD& operator=(const TEveVSD& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TEveVSD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveVSD.html
https://root.cern/root/html534/TEveWindow.html:558,Availability,avail,available,558,". TEveWindow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » EVE; » TEveWindow. class TEveWindow: public TEveElementList. Abstract base-class for representing eve-windows.; Sub-classes define a particular GUI frame that gets show; in the window. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TEveWindow(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTEveElementList::AcceptElement(TEveElement* el); virtual voidTEveElement::AddElement(TEveElement* el); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TGListTreeItem* parent_lti); virtual TGListTreeItem*TEveElement::AddIntoListTree(TGListTree* ltree, TEveElement* parent); virtual TGListTreeItem*TEveElement::AddIntoListTrees(TEveElement* parent); virtual voidTEveElement::AddParent(TEveElement* re); virtual voidTEveProjectable::AddProjected(TEveProjected* p); virtual voidTEveProjectable::AddProjectedsToSet(set<TEveElement*>& set); virtual voidTEveElement::AddStamp(UChar_t bits); virtual voidTEveElement::Annihilate(); virtual voidTEveElement::AnnihilateElements(); virtual voidTEveProjectable::AnnihilateProjecteds(); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTEveElement::ApplyVizTag(const TString& tag, const TString& fallback_tag = """"); TEveElement::List_iTEveElement::BeginChildren(); TEveElement::List_ciTEveElement::BeginChildren() const; TEveElement::List_iTEveElement::BeginParents(); TEveElement::List_ciTEveElement::BeginParents() const; TEveProjectable::ProjList_iTEveProjectable::BeginProjecteds(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTEveElement::CanEditElement() const; virtual Bool_tTEveElement::CanEditMainColor() const; virtual Bool_t",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:5277,Availability,error,error,5277,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:5361,Availability,error,error,5361,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:17116,Deployability,update,update,17116,"eElement::SetRnrState(Bool_t rnr); voidSetShowTitleBar(Bool_t x); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSwapWindow(TEveWindow* w); static voidSwapWindows(TEveWindow* w1, TEveWindow* w2); voidSwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTitleBarClicked(); voidUndockWindow()MENU ; voidUndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:17219,Deployability,update,update,17219,"eElement::SetRnrState(Bool_t rnr); voidSetShowTitleBar(Bool_t x); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSwapWindow(TEveWindow* w); static voidSwapWindows(TEveWindow* w1, TEveWindow* w2); voidSwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTitleBarClicked(); voidUndockWindow()MENU ; voidUndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:19899,Modifiability,variab,variable,19899,"tMainColorAllow editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fViz",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:20037,Modifiability,variab,variable,20037,"ditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tfShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_tfgCurrentBac",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindow.html:21583,Usability,undo,undocked,21583,"EveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_tfgCurrentBackgroundColor; static UInt_tfgMainFrameDefHeight; static UInt_tfgMainFrameDefWidth; static Pixel_tfgMiniBarBackgroundColor. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TEveWindow(); Destructor. void PreDeleteElement(); Called before the element is deleted, thus offering the last chance; to detach from acquired resources and from the framework itself.; Here the request is just passed to TEveManager.; If you override it, make sure to call base-class version. void PreUndock(); Virtual function called before a window is undocked. void PostDock(); Virtual function called after a window is docked. void NameTitleChanged(); Name or title of the window changed - propagate to frames.; Virtual from TEveElement. void PopulateEmptyFrame(TEveCompositeFrame* ef); Populate given frame-slot - intended for initial population; of a new slot or low-level window-swapping.; No layout or window-mapping is done. void SwapWindow(TEveWindow* w); Swap frames with the given window. void SwapWindowWithCurrent(); Swap frames with the current window. void UndockWindow(); Undock the window - put it into a dedicated main-frame. void UndockWindowDestroySlot(); Undock the window - put it into a dedicated main-frame.; The old window slot is destroyed. void ReplaceWindow(TEveWindow* w); Replace this window with the passed one.; Eve parentship is properly handled.; This will most likely lead to the destruction of this window.; Layout is called on the frame. void DestroyWindow(); Destroy eve-window - replace i",MatchSource.WIKI,root/html534/TEveWindow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindow.html
https://root.cern/root/html534/TEveWindowEditor.html:4492,Availability,error,error,4492,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TEveWindowEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowEditor.html
https://root.cern/root/html534/TEveWindowEditor.html:4576,Availability,error,error,4576,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TEveWindowEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowEditor.html
https://root.cern/root/html534/TEveWindowEditor.html:17395,Availability,mask,mask,17395,"ed; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveWindow*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if",MatchSource.WIKI,root/html534/TEveWindowEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowEditor.html
https://root.cern/root/html534/TEveWindowFrame.html:5289,Availability,error,error,5289,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowFrame.html:5373,Availability,error,error,5373,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowFrame.html:17493,Deployability,update,update,17493,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowFrame.html:17596,Deployability,update,update,17596,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowFrame.html:20382,Modifiability,variab,variable,20382," color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; TGFrame*fGUIFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveE",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowFrame.html:20520,Modifiability,variab,variable,20520,"g of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; TGFrame*fGUIFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_t",MatchSource.WIKI,root/html534/TEveWindowFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowFrame.html
https://root.cern/root/html534/TEveWindowManager.html:7322,Availability,error,error,7322,"t(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:7406,Availability,error,error,7406,"t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:25715,Availability,down,down,25715,"er can refuse to make a; window current), the state of window is changed accordingly and; WindowSelected() signal is emitted. void DeleteWindow(TEveWindow* w); Called by a window before it gets deleted. void WindowDocked(TEveWindow* window); Emit the ""WindowDocked(TEveWindow*)"" signal. void WindowUndocked(TEveWindow* window); Emit the ""WindowUndocked(TEveWindow*)"" signal. void WindowSelected(TEveWindow* window); Emit the ""WindowSelected(TEveWindow*)"" signal. void WindowDeleted(TEveWindow* window); Emit the ""WindowDeleted(TEveWindow*)"" signal. TEveWindowSlot* GetCurrentWindowAsSlot() const; Return current window dynamic-casted to TEveWindowSlot. void SetDefaultContainer(TEveWindow* w); Set default container window.; It has to be able to create new slots.; When main-frames are closed they will place the windows here. void DestroyWindowRecursively(TEveWindow* window); Destroy window's children and then the window itself.; Protected method used during shutdown. void DestroyWindows(); Wait for all windows to shut-down. void HideAllEveDecorations(); Hide all eve decorations (title-bar and mini-bar) on all frames. void ShowNormalEveDecorations(); Show eve decorations (title-bar or mini-bar) as specified for; the contained window on all frames. void SetShowTitleBars(Bool_t state); Set show title-bar state on all frames.; This does not modify the per-window settings - call; ShowNormalEveDecorations() to restore them. TEveWindowManager(const TEveWindowManager& ). TEveWindowManager& operator=(const TEveWindowManager& ). TEveWindow* GetCurrentWindow() const; { return fCurrentWindow; }. Bool_t IsCurrentWindow(const TEveWindow* w) const; { return w == fCurrentWindow; }. TEveWindow* GetDefaultContainer() const; { return fDefaultContainer; }. Bool_t HasDefaultContainer() const; { return fDefaultContainer != 0; }. » Author: Matevz Tadel 2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:23; This page has be",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:19178,Deployability,update,update,19178,"tate(Bool_t rnr); voidSetShowTitleBars(Bool_t state); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); voidShowNormalEveDecorations(); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidWindowDeleted(TEveWindow* window)SIGNAL ; voidWindowDocked(TEveWindow* window)SIGNAL ; voidWindowSelected(TEveWindow* window)SIGNAL ; voidWindowUndocked(TEveWindow* window)SIGNAL ; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:19281,Deployability,update,update,19281,"tate(Bool_t rnr); voidSetShowTitleBars(Bool_t state); voidTEveElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); voidShowNormalEveDecorations(); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidWindowDeleted(TEveWindow* window)SIGNAL ; voidWindowDocked(TEveWindow* window)SIGNAL ; voidWindowSelected(TEveWindow* window)SIGNAL ; voidWindowUndocked(TEveWindow* window)SIGNAL ; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:22909,Modifiability,variab,variable,22909,"n transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveWindow*fCurrentWindow; TEveWindow*fDefaultContainer; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic ",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowManager.html:23047,Modifiability,variab,variable,23047," rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; TEveWindow*fCurrentWindow; TEveWindow*fDefaultContainer; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query Vi",MatchSource.WIKI,root/html534/TEveWindowManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowManager.html
https://root.cern/root/html534/TEveWindowPack.html:5291,Availability,error,error,5291,"_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); voidEqualizeFrames()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowPack.html:5375,Availability,error,error,5375,"Primitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); voidEqualizeFrames()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowPack.html:17608,Deployability,update,update,17608," o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertical(Bool_t x = kTRUE); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowPack.html:17711,Deployability,update,update,17711," o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidSetVertical(Bool_t x = kTRUE); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowPack.html:20474,Modifiability,variab,variable,20474,"low editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; TGPack*fPack; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEv",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowPack.html:20612,Modifiability,variab,variable,20612,"parencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; TGPack*fPack; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; ",MatchSource.WIKI,root/html534/TEveWindowPack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowPack.html
https://root.cern/root/html534/TEveWindowSlot.html:5218,Availability,error,error,5218,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowSlot.html:5302,Availability,error,error,5302,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowSlot.html:17578,Deployability,update,update,17578," """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); TGCompositeFrame*StartEmbedding(); TEveWindowFrame*StopEmbedding(const char* name = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowSlot.html:17681,Deployability,update,update,17681," """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); TGCompositeFrame*StartEmbedding(); TEveWindowFrame*StopEmbedding(const char* name = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowSlot.html:20488,Modifiability,variab,variable,20488,"ainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TGCompositeFrame*fEmbedBuffer; TGTextButton*fEmptyButt; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveE",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowSlot.html:20626,Modifiability,variab,variable,20626,"lement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TGCompositeFrame*fEmbedBuffer; TGTextButton*fEmptyButt; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Pixel_t",MatchSource.WIKI,root/html534/TEveWindowSlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowSlot.html
https://root.cern/root/html534/TEveWindowTab.html:5257,Availability,error,error,5257,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TEveWindowTab.html:5341,Availability,error,error,5341,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TEveWindowTab.html:17435,Deployability,update,update,17435,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TEveWindowTab.html:17538,Deployability,update,update,17538,"veElement::SetSourceObject(TObject* o); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTEveElement::SetTransMatrix(Double_t* carr); virtual voidTEveElement::SetTransMatrix(const TGeoMatrix& mat); virtual voidTObject::SetUniqueID(UInt_t uid); voidTEveElement::SetUserData(void* ud); voidTEveElement::SetVizModel(TEveElement* model); voidTEveElement::SetVizTag(const TString& tag); virtual voidShowMembers(TMemberInspector&); virtual Bool_tTEveElement::SingleRnrState() const; virtual Int_tTNamed::Sizeof() const; voidTEveElement::SpawnEditor()MENU ; voidTEveElement::StampColorSelection(); voidTEveElement::StampObjProps(); voidTEveElement::StampTransBBox(); voidTEveElement::StampVisibility(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTEveWindow::SwapWindow(TEveWindow* w); static voidTEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2); voidTEveWindow::SwapWindowWithCurrent()MENU ; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTEveElement::TestCSCBits(UChar_t f) const; voidTEveWindow::TitleBarClicked(); voidTEveWindow::UndockWindow()MENU ; voidTEveWindow::UndockWindowDestroySlot()MENU ; virtual voidTEveElement::UnHighlighted(); virtual voidTEveElement::UnSelected(); virtual voidTObject::UseCurrentStyle(); voidTEveElement::VizDB_Apply(const char* tag)MENU ; voidTEveElement::VizDB_Insert(const char* tag, Bool_t replace = kTRUE, Bool_t update = kTRUE)MENU ; voidTEveElement::VizDB_Reapply()MENU ; voidTEveElement::VizDB_UpdateModel(Bool_t update = kTRUE)MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidTEveElement::WriteVizParams(ostream& out, const TString& var).",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TEveWindowTab.html:20297,Modifiability,variab,variable,20297,"low editing of main color.; Bool_tTEveElement::fCanEditMainTransAllow editing of main transformation.; Bool_tTEveElement::fCanEditMainTransparencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TGTab*fTab; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveE",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TEveWindowTab.html:20435,Modifiability,variab,variable,20435,"parencyAllow editing of main transparency.; UChar_tTEveElement::fChangeBits!; TClass*TEveElementList::fChildClassClass of acceptable children, others are rejected.; list<TEveElement*>TEveElement::fChildrenList of children.; Color_tTEveElementList::fColorColor of the object.; TEveCompound*TEveElement::fCompoundCompound this object belongs to.; Int_tTEveElement::fDenyDestroy! Deny-destroy count.; Bool_tTEveElement::fDestroyOnZeroRefCntAuto-destruct when ref-count reaches zero.; Char_tTEveElement::fDestructing!; TEveCompositeFrame*TEveWindow::fEveFrame; Bool_tTEveElement::fHighlighted!; Short_tTEveElement::fImpliedHighlighted!; Short_tTEveElement::fImpliedSelected!; set<TEveElement::TEveListTreeInfo,less<TEveElement::TEveListTreeInfo>,allocator<TEveElement::TEveListTreeInfo> >TEveElement::fItems! Set of list-tree-items.; Color_t*TEveElement::fMainColorPtrPointer to main-color variable.; TEveTrans*TEveElement::fMainTransPointer to main transformation matrix.; Char_tTEveElement::fMainTransparencyMain-transparency variable.; TStringTNamed::fNameobject identifier; Int_tTEveElement::fNumChildren!; Int_tTEveElement::fParentIgnoreCnt! Counter for parents that are ignored in ref-counting.; list<TEveElement*>TEveElement::fParentsList of parents.; Bool_tTEveElement::fPickable; list<TEveProjected*>TEveProjectable::fProjectedListreferences to projected instances.; Bool_tTEveElement::fRnrChildrenRender children of this element.; Bool_tTEveElement::fRnrSelfRender this element.; Bool_tTEveElement::fSelected!; Bool_tTEveWindow::fShowTitleBar; TRefTEveElement::fSourceExternal object that is represented by this element.; TGTab*fTab; TStringTNamed::fTitleobject title; Int_tTEveElement::fTopItemCnt! Counter for top-level list-tree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; st",MatchSource.WIKI,root/html534/TEveWindowTab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TEveWindowTab.html
https://root.cern/root/html534/TExec.html:4233,Availability,error,error,4233,"const char* command); virtual~TExec(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(const char* command = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:4317,Availability,error,error,4317,"d) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(const char* command = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:894,Deployability,update,updated,894,". TExec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TExec. class TExec: public TNamed. TExec is a utility class that can be used to execute a CINT command; when some event happens in a pad.; The command in turn can invoke a CINT macro to paint graphics objects; at positions depending on the histogram or graph contents. Case 1:. The TExec object is in the list of pad primitives (after exec.Draw()).; When the pad is drawn, the TExec::Paint function is called. This function; will execute the specified command.; The following example uses the services of the class Aclock created; in $ROOTSYS/test/Aclock.cxx.; This examples uses a TTimer to redraw a pad at regular intervals (clock).; When the clock is updated, a string with the current date&time is drawn.; {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }. Case 2:. The TExec object may be added to the list of functions of a TH1 or TGraph; object via hist->GetListOfFunctions()->Add(exec).; When the histogram (or graph) is drawn, the TExec will be executed.; If the histogram is made persistent on a file, the TExec object; is also saved with the histogram. When redrawing the histogram in a; new session, the TExec will be executed.; Example:; Assume an histogram TH1F *h already filled.; TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; When the Paint function for the histogram will be called, the ""DoSomething""; function will be called (interpreted or compiled) and also the macro.C. Case 3:. A TExec object is aut",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:3027,Energy Efficiency,power,powerful,3027,"en invoking TPad::AddExec.; Each pad contains a TList of TExecs (0, 1 or more). When a mouse event; (motion, click, etc) happens, the pad object executes sequentially; this list of TExecs. In the code (interpreted or compiled) executed; by the TExec referenced command, one can call the pad service functions; such as TPad::GetEvent, TPad::GetEventX, TPad::GetEventY to find; which type of event and the X,Y position of the mouse.; By default, the list of TExecs is executed. This can be disabled; via the canvas menu ""Option"".; See $ROOTSYS/tutorials/hist/exec2.C for an example.; Root > TFile f(""hsimple.root"");; Root > hpxpy.Draw();; Root > c1.AddExec(""ex2"","".x exec2.C"");; When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. The 3 options above can be combined. Function Members (Methods); public:. TExec(); TExec(const TExec& text); TExec(const char* name, const char* command); virtual~TExec(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump(",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:463,Integrability,depend,depending,463,". TExec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TExec. class TExec: public TNamed. TExec is a utility class that can be used to execute a CINT command; when some event happens in a pad.; The command in turn can invoke a CINT macro to paint graphics objects; at positions depending on the histogram or graph contents. Case 1:. The TExec object is in the list of pad primitives (after exec.Draw()).; When the pad is drawn, the TExec::Paint function is called. This function; will execute the specified command.; The following example uses the services of the class Aclock created; in $ROOTSYS/test/Aclock.cxx.; This examples uses a TTimer to redraw a pad at regular intervals (clock).; When the clock is updated, a string with the current date&time is drawn.; {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }. Case 2:. The TExec object may be added to the list of functions of a TH1 or TGraph; object via hist->GetListOfFunctions()->Add(exec).; When the histogram (or graph) is drawn, the TExec will be executed.; If the histogram is made persistent on a file, the TExec object; is also saved with the histogram. When redrawing the histogram in a; new session, the TExec will be executed.; Example:; Assume an histogram TH1F *h already filled.; TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; When the Paint function for the histogram will be called, the ""DoSomething""; function will be called (interpreted or compiled) and also the macro.C. Case 3:. A TExec object is aut",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:783,Testability,test,test,783,". TExec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TExec. class TExec: public TNamed. TExec is a utility class that can be used to execute a CINT command; when some event happens in a pad.; The command in turn can invoke a CINT macro to paint graphics objects; at positions depending on the histogram or graph contents. Case 1:. The TExec object is in the list of pad primitives (after exec.Draw()).; When the pad is drawn, the TExec::Paint function is called. This function; will execute the specified command.; The following example uses the services of the class Aclock created; in $ROOTSYS/test/Aclock.cxx.; This examples uses a TTimer to redraw a pad at regular intervals (clock).; When the clock is updated, a string with the current date&time is drawn.; {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }. Case 2:. The TExec object may be added to the list of functions of a TH1 or TGraph; object via hist->GetListOfFunctions()->Add(exec).; When the histogram (or graph) is drawn, the TExec will be executed.; If the histogram is made persistent on a file, the TExec object; is also saved with the histogram. When redrawing the histogram in a; new session, the TExec will be executed.; Example:; Assume an histogram TH1F *h already filled.; TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; When the Paint function for the histogram will be called, the ""DoSomething""; function will be called (interpreted or compiled) and also the macro.C. Case 3:. A TExec object is aut",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExec.html:977,Testability,test,test,977,"TExec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TExec. class TExec: public TNamed. TExec is a utility class that can be used to execute a CINT command; when some event happens in a pad.; The command in turn can invoke a CINT macro to paint graphics objects; at positions depending on the histogram or graph contents. Case 1:. The TExec object is in the list of pad primitives (after exec.Draw()).; When the pad is drawn, the TExec::Paint function is called. This function; will execute the specified command.; The following example uses the services of the class Aclock created; in $ROOTSYS/test/Aclock.cxx.; This examples uses a TTimer to redraw a pad at regular intervals (clock).; When the clock is updated, a string with the current date&time is drawn.; {; gSystem->Load(""$ROOTSYS/test/Aclock"");; Aclock ck(400);; gPad->SetFillColor(5);; TDatime dt;; TText t(.5,.3,""t"");; t.SetTextAlign(22);; t.SetTextSize(.07);; t.SetTextColor(4);; t.Draw();; TExec ex(""ex"",""dt.Set();t.SetTitle(dt.AsString())"");; ex.Draw();; }. Case 2:. The TExec object may be added to the list of functions of a TH1 or TGraph; object via hist->GetListOfFunctions()->Add(exec).; When the histogram (or graph) is drawn, the TExec will be executed.; If the histogram is made persistent on a file, the TExec object; is also saved with the histogram. When redrawing the histogram in a; new session, the TExec will be executed.; Example:; Assume an histogram TH1F *h already filled.; TExec *ex1 = new TExec(""ex1"",""DoSomething()"");; TExec *ex2 = new TExec(""ex2"","".x macro.C"");; h->GetListOfFunctions()->Add(ex1);; h->GetListOfFunctions()->Add(ex2);; h->Draw();; When the Paint function for the histogram will be called, the ""DoSomething""; function will be called (interpreted or compiled) and also the macro.C. Case 3:. A TExec object is auto",MatchSource.WIKI,root/html534/TExec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExec.html
https://root.cern/root/html534/TExMap.html:1696,Availability,error,error,1696," value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTime",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:1780,Availability,error,error,1780,"t, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(co",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:342,Security,hash,hash,342,". TExMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMap. class TExMap: public TObject. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMap(Int_t mapSize = 100); TExMap(const TExMap& map); virtual~TExMap(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Long64_t key, Long64_t value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:469,Security,hash,hashing,469,". TExMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMap. class TExMap: public TObject. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMap(Int_t mapSize = 100); TExMap(const TExMap& map); virtual~TExMap(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Long64_t key, Long64_t value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:726,Security,hash,hash,726," TExMap(Int_t mapSize = 100); TExMap(const TExMap& map); virtual~TExMap(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Long64_t key, Long64_t value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:796,Security,hash,hash,796," TExMap(Int_t mapSize = 100); TExMap(const TExMap& map); virtual~TExMap(); voidTObject::AbstractMethod(const char* method) const; voidAdd(Long64_t key, Long64_t value); voidAdd(ULong64_t hash, Long64_t key, Long64_t value); voidAddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(cons",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:2583,Security,hash,hash,2583,"method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator dele",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:2631,Security,hash,hash,2631,"Object::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExpand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetValue(Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key); Long64_tGetValue(ULong64_t hash, Long64_t key, UInt_t& slot); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::ope",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:3966,Security,hash,hash,3966,"Object::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const cha",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:4301,Security,hash,hash,4301,"ption = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Long64_t&operator()(Long64_t key); Long64_t&operator()(ULong64_t hash, Long64_t key); TExMap&operator=(const TExMap&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemove(Long64_t key); voidRemove(ULong64_t hash, Long64_t key); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_t",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:5559,Security,hash,hash,5559,"l_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6254,Security,hash,hash,6254,"ize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(UL",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6389,Security,hash,hash,6389,"dTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6566,Security,hash,hash,6566,"t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. I",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6689,Security,hash,hash,6689,"t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. I",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6743,Security,hash,hash,6743,"; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6796,Security,hash,hash,6796,"eap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has bee",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:6890,Security,hash,hash,6890,"eap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has bee",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7152,Security,hash,hash,7152,"ExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { re",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7221,Security,hash,hash,7221,"ExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { re",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7289,Security,hash,hash,7289," table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7372,Security,hash,hash,7372," table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7531,Security,hash,hash,7531,"vert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comm",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7629,Security,hash,hash,7629,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:7679,Security,hash,hash,7679,"f ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppo",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:8071,Security,hash,hash,8071,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:8222,Security,hash,hash,8222,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:8265,Security,hash,hash,8265,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMap.html:8318,Security,hash,hash,8318,"idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has been removed. void Expand(Int_t newsize); Expand the TExMap. void Streamer(TBuffer& ); Stream all objects in the collection to or from the I/O buffer. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. void Add(ULong64_t hash, Long64_t key, Long64_t value). Int_t Capacity() const; { return fSize; }. Int_t GetSize() const; { return fTally; }. Long64_t GetValue(ULong64_t hash, Long64_t key). void Remove(ULong64_t hash, Long64_t key). Long64_t & operator()(ULong64_t hash, Long64_t key). » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMap.html
https://root.cern/root/html534/TExMapIter.html:338,Security,hash,hash,338,". TExMapIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMapIter. class TExMapIter. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMapIter(const TExMap* map); TExMapIter(const TExMapIter& tei); virtual~TExMapIter(); static TClass*Class(); const TExMap*GetCollection() const; virtual TClass*IsA() const; Bool_tNext(Long64_t& key, Long64_t& value); Bool_tNext(ULong64_t& hash, Long64_t& key, Long64_t& value); TExMapIter&operator=(const TExMapIter&); voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Int_tfCursor; const TExMap*fMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMapIter(const TExMap* map); Create TExMap iterator. TExMapIter & operator=(const TExMapIter& ); Overloaded assignment operator. Bool_t Next(ULong64_t& hash, Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. Bool_t Next(Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. TExMapIter(const TExMap* map). virtual ~TExMapIter(); { }. const TExMap * GetCollection() const; { return fMap; }. void Reset(); { fCursor = 0; }. » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMapIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMapIter.html
https://root.cern/root/html534/TExMapIter.html:465,Security,hash,hashing,465,". TExMapIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMapIter. class TExMapIter. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMapIter(const TExMap* map); TExMapIter(const TExMapIter& tei); virtual~TExMapIter(); static TClass*Class(); const TExMap*GetCollection() const; virtual TClass*IsA() const; Bool_tNext(Long64_t& key, Long64_t& value); Bool_tNext(ULong64_t& hash, Long64_t& key, Long64_t& value); TExMapIter&operator=(const TExMapIter&); voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Int_tfCursor; const TExMap*fMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMapIter(const TExMap* map); Create TExMap iterator. TExMapIter & operator=(const TExMapIter& ); Overloaded assignment operator. Bool_t Next(ULong64_t& hash, Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. Bool_t Next(Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. TExMapIter(const TExMap* map). virtual ~TExMapIter(); { }. const TExMap * GetCollection() const; { return fMap; }. void Reset(); { fCursor = 0; }. » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMapIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMapIter.html
https://root.cern/root/html534/TExMapIter.html:777,Security,hash,hash,777,". TExMapIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMapIter. class TExMapIter. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMapIter(const TExMap* map); TExMapIter(const TExMapIter& tei); virtual~TExMapIter(); static TClass*Class(); const TExMap*GetCollection() const; virtual TClass*IsA() const; Bool_tNext(Long64_t& key, Long64_t& value); Bool_tNext(ULong64_t& hash, Long64_t& key, Long64_t& value); TExMapIter&operator=(const TExMapIter&); voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Int_tfCursor; const TExMap*fMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMapIter(const TExMap* map); Create TExMap iterator. TExMapIter & operator=(const TExMapIter& ); Overloaded assignment operator. Bool_t Next(ULong64_t& hash, Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. Bool_t Next(Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. TExMapIter(const TExMap* map). virtual ~TExMapIter(); { }. const TExMap * GetCollection() const; { return fMap; }. void Reset(); { fCursor = 0; }. » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMapIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMapIter.html
https://root.cern/root/html534/TExMapIter.html:1308,Security,hash,hash,1308,". TExMapIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TExMapIter. class TExMapIter. TExMap. This class stores a (key,value) pair using an external hash.; The (key,value) are Long64_t's and therefore can contain object; pointers or any longs. The map uses an open addressing hashing; method (linear probing). Function Members (Methods); public:. TExMapIter(const TExMap* map); TExMapIter(const TExMapIter& tei); virtual~TExMapIter(); static TClass*Class(); const TExMap*GetCollection() const; virtual TClass*IsA() const; Bool_tNext(Long64_t& key, Long64_t& value); Bool_tNext(ULong64_t& hash, Long64_t& key, Long64_t& value); TExMapIter&operator=(const TExMapIter&); voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. Int_tfCursor; const TExMap*fMap. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMapIter(const TExMap* map); Create TExMap iterator. TExMapIter & operator=(const TExMapIter& ); Overloaded assignment operator. Bool_t Next(ULong64_t& hash, Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. Bool_t Next(Long64_t& key, Long64_t& value); Get next entry from TExMap. Returns kFALSE at end of map. TExMapIter(const TExMap* map). virtual ~TExMapIter(); { }. const TExMap * GetCollection() const; { return fMap; }. void Reset(); { fCursor = 0; }. » Author: Fons Rademakers 26/05/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TExMapIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TExMapIter.html
https://root.cern/root/html534/TF1.html:8414,Availability,error,error,8414,"etoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* option = ""al"")MENU ; virtual voidDrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* option = ""al"")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFixParameter(Int_t ipar, Double_t value); Double_tGetChisquare() const; static TF1*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttL",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:8498,Availability,error,error,8498," virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* option = ""al"")MENU ; virtual voidDrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* option = ""al"")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFixParameter(Int_t ipar, Double_t value); Double_tGetChisquare() const; static TF1*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtua",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:18804,Availability,error,error,18804,"t_t maxpar = 1000, Int_t maxconst = 1000); virtual voidSetMaximum(Double_t maximum = -1111)MENU ; virtual voidSetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNDF(Int_t ndf); virtual voidSetNpx(Int_t npx = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidSetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidSetParent(TObject* p = 0); virtual voidSetParError(Int_t ipar, Double_t error); virtual voidSetParErrors(const Double_t* errors); virtual voidSetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidSetSavedPoint(Int_t point, Double_t value); virtual voidSetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() con",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:18853,Availability,error,errors,18853,"l voidSetMaximum(Double_t maximum = -1111)MENU ; virtual voidSetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNDF(Int_t ndf); virtual voidSetNpx(Int_t npx = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidSetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidSetParent(TObject* p = 0); virtual voidSetParError(Int_t ipar, Double_t error); virtual voidSetParErrors(const Double_t* errors); virtual voidSetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidSetSavedPoint(Int_t point, Double_t value); virtual voidSetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNV",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:25889,Availability,error,errors,25889,"NparNumber of parameters; Int_tfNpfitsNumber of points used in the fit; Int_tfNpxNumber of points used for the graphical representation; Int_tfNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tfType(=0 for standard functions, 1 if pointer to function); Double_tfXmaxUpper bounds for the range; Double_tfXminLower bounds for the range; static Bool_tfgAbsValueuse absolute value of function when computing integral; static TF1*fgCurrentpointer to current function being processed; static Bool_tfgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF1(); F1 default constructor. TF1(const char* name, const char* formula, Double_t xmin = 0, Double_t xmax = 1); F1 constructor using a formula definition. See TFormula constructor for explanation of the formula syntax. See tutorials: fillrandom, first, fit1, formula1, multifit; for real examples. Creates a function of type A or B between xmin and xmax. if formula has the form ""fffffff;xxxx;yyyy"", it is assumed that; the f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32495,Availability,error,error,32495,"; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32535,Availability,error,error,32535,"; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32552,Availability,error,error,32552,"; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32574,Availability,error,error,32574,"; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32611,Availability,error,error,32611,"; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:32744,Availability,error,error,32744,"ivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33708,Availability,error,error,33708,"the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for th",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33748,Availability,error,error,33748,"the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for th",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33765,Availability,error,error,33765,"the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for th",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33787,Availability,error,error,33787,"the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for th",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33824,Availability,error,error,33824,"the step size h smaller. Author: Anna Kreshuk. Double_t Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the second derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for th",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:33957,Availability,error,error,33957,"ivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via T",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:34920,Availability,error,error,34920," the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:34960,Availability,error,error,34960," the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:34977,Availability,error,error,34977," the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:34999,Availability,error,error,34999," the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:35036,Availability,error,error,35036," the step size h smaller. Author: Anna Kreshuk. Double_t Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:35169,Availability,error,error,35169,"ivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with a smooth curve; ""FC"" draw a fill area below a smooth curve. Note that the default value is ""L"". Therefore to draw on top; of an existing picture, specify opt",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:35303,Availability,error,error,35303,"irst, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. Author: Anna Kreshuk. Double_t DerivativeError(); Static function returning the error of the last call to the of Derivative's; functions. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a function. Compute the closest distance of approach from point px,py to this; function. The distance is computed in pixels units. Note that px is called with a negative value when the TF1 is in; TGraph or TH1 list of functions. In this case there is no point; looking at the histogram axis. void Draw(Option_t* option = """"); Draw this function with its current attributes. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with a smooth curve; ""FC"" draw a fill area below a smooth curve. Note that the default value is ""L"". Therefore to draw on top; of an existing picture, specify option ""LSAME"". NB. You must use DrawCopy if you want to draw several times the same; function in the current canvas. TF1 * DrawCopy(Option_t* option = """") const;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:48712,Availability,error,errors,48712,"e function; has sharp peaks, you should increase the number of points (SetNpx); such that the peak is correctly tabulated at several points. void GetRange(Double_t& xmin, Double_t& xmax) const; Return range of a 1-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. TAxis * GetXaxis() const; Get x axis of the function. TAxis * GetYaxis() const; Get y axis of the function. TAxis * GetZaxis() const; Get z axis of the function. (In case this object is a TF2 or TF3). Double_t GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); Compute the gradient (derivative) wrt a parameter ipar; Parameters:; ipar - index of parameter for which the derivative is computed; x - point, where the derivative is computed; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); Compute the gradient wrt parameters; Parameters:; x - point, were the gradient is computed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresse",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:48829,Availability,error,errors,48829," Return range of a 1-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. TAxis * GetXaxis() const; Get x axis of the function. TAxis * GetYaxis() const; Get y axis of the function. TAxis * GetZaxis() const; Get z axis of the function. (In case this object is a TF2 or TF3). Double_t GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); Compute the gradient (derivative) wrt a parameter ipar; Parameters:; ipar - index of parameter for which the derivative is computed; x - point, where the derivative is computed; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); Compute the gradient wrt parameters; Parameters:; x - point, were the gradient is computed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function b",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:49277,Availability,error,errors,49277,"ave values. TAxis * GetXaxis() const; Get x axis of the function. TAxis * GetYaxis() const; Get y axis of the function. TAxis * GetZaxis() const; Get z axis of the function. (In case this object is a TF2 or TF3). Double_t GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); Compute the gradient (derivative) wrt a parameter ipar; Parameters:; ipar - index of parameter for which the derivative is computed; x - point, where the derivative is computed; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); Compute the gradient wrt parameters; Parameters:; x - point, were the gradient is computed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:49394,Availability,error,errors,49394,"ct is a TF2 or TF3). Double_t GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); Compute the gradient (derivative) wrt a parameter ipar; Parameters:; ipar - index of parameter for which the derivative is computed; x - point, where the derivative is computed; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); Compute the gradient wrt parameters; Parameters:; x - point, were the gradient is computed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:50840,Availability,error,error,50840,"ntegral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integr",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:51096,Availability,error,error,51096," the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g-",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:51158,Availability,error,error,51158," the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g-",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:51396,Availability,error,error,51396,"or any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGauss",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:53989,Availability,error,error,53989,"00) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:54234,Availability,error,error,54234,"_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:55769,Availability,error,error,55769," cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fi",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:56014,Availability,error,error,56014,"ction do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussL",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:60692,Availability,error,errors,60692,"ntegration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* indpar = 0); Set the result from the fit; parameter values, errors, chi2, etc...; Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; By default it is assume that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d func",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:61959,Availability,error,error,61959,"e that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class o",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:61971,Availability,error,error,61971,"e that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class o",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:62038,Availability,error,errors,62038,"unction; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associate",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:62051,Availability,error,errors,62051,"unction; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associate",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:62123,Availability,error,errors,62123,"unction; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(Int_t npx = 100); Set the number of points used to draw the function. The default number of points along x is 100 for 1-d functions and 30 for 2-d/3-d functions; You can increase this value to get a better resolution when drawing; pictures with sharp peaks or to get a better result when using TF1::GetRandom; the minimum number of points is 4, the maximum is 10000000 for 1-d and 10000 for 2-d/3-d functions. void SetParError(Int_t ipar, Double_t error); Set error for parameter number ipar. void SetParErrors(const Double_t* errors); Set errors for all active parameters; when calling this function, the array errors must have at least fNpar values. void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associate",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:46280,Deployability,integrat,integrated,46280,"ouble_t* probSum); Compute Quantiles for density distribution of this function; Quantile x_q of a probability distribution Function F is defined as. For instance the median of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. code from Eddy Offermann, Renaissance. input parameters; - this TF1 function; - nprobSum maximum size of array q and size of array probSum; - probSum array of positions where quantiles will be computed.; It is assumed to contain at least nprobSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Getting quantiles from two histograms and storing results in a TGraph,; a so-called QQ-plot. TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one rando",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:47062,Deployability,integrat,integrated,47062,";; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; The parabolic approximation is very good as soon as the number; of bins is greater than 50. IMPORTANT NOTE; The integral of the function is computed at fNpx points. If the function; has sharp peaks, you should increase the number of points (SetNpx); such that the peak is correctly tabulated at several points. void GetRange(Double_t& xmin, Double_t& xmax) const; Return range of a 1-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function. void GetRange(Double_t& xmin, Double_t& y",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:50179,Deployability,integrat,integration,50179,"ed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:52082,Deployability,integrat,integration,52082,"n the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; double r3 = g->IntegralFast(np,x,w,0,5);; double r4 = g->IntegralFast(np,x,w,0,1000);; double r5 = g->IntegralFast(np,x,w,0,10000);; double r6 = g->IntegralFast(np,x,w,0,100000);; printf(""g->Integral(0,5) = %g\n"",r1);; printf(""g->Integral(0,1000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:52134,Deployability,integrat,integrate,52134,"n the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; double r3 = g->IntegralFast(np,x,w,0,5);; double r4 = g->IntegralFast(np,x,w,0,1000);; double r5 = g->IntegralFast(np,x,w,0,10000);; double r6 = g->IntegralFast(np,x,w,0,100000);; printf(""g->Integral(0,5) = %g\n"",r1);; printf(""g->Integral(0,1000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58043,Deployability,integrat,integration,58043,"gPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58803,Deployability,integrat,integration,58803," n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58985,Deployability,integrat,integration,58985,"], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void Release",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59188,Deployability,integrat,integration,59188,"s: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59469,Deployability,integrat,integration,59469,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59636,Deployability,integrat,integration,59636,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* i",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:57516,Energy Efficiency,adapt,adapted,57516,"TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evalua",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59436,Energy Efficiency,adapt,adaptive,59436,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59602,Energy Efficiency,adapt,adaptive,59602,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* i",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:24135,Integrability,wrap,wrap,24135,"ant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tfChisquareFunction fit chisquare; void*fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaximumMaximum value for plotting; TMethodCall*fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tfMinimumMinimum value for plotting; Int_tfNDFNumber of degrees of freedom in the fit; Int",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:28772,Integrability,interface,interface,28772," be Cloned. TF1(const char* name, void* fcn, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using pointer to an interpreted function. See TFormula constructor for explanation of the formula syntax. Creates a function of type C between xmin and xmax.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). see tutorial; myfit for an example of use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:29274,Integrability,interface,interface,29274,"or functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor(const char* name, Int_t npar); Internal Function to Create a TF1 using a Functor. Used by the template constructors. TF1(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* className); F1 constructor from an interpreted class defining the operator() or Eval().; This constructor emulate the syntax of the template constructor using a C++ callable object (functor); which can be used only in C++ compiled mode.; The class name is required to get the type of class given t",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:46280,Integrability,integrat,integrated,46280,"ouble_t* probSum); Compute Quantiles for density distribution of this function; Quantile x_q of a probability distribution Function F is defined as. For instance the median of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. code from Eddy Offermann, Renaissance. input parameters; - this TF1 function; - nprobSum maximum size of array q and size of array probSum; - probSum array of positions where quantiles will be computed.; It is assumed to contain at least nprobSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Getting quantiles from two histograms and storing results in a TGraph,; a so-called QQ-plot. TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one rando",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:47062,Integrability,integrat,integrated,47062,";; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; The parabolic approximation is very good as soon as the number; of bins is greater than 50. IMPORTANT NOTE; The integral of the function is computed at fNpx points. If the function; has sharp peaks, you should increase the number of points (SetNpx); such that the peak is correctly tabulated at several points. void GetRange(Double_t& xmin, Double_t& xmax) const; Return range of a 1-D function. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function. void GetRange(Double_t& xmin, Double_t& y",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:49904,Integrability,rout,routine,49904,"me as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); Compute the gradient wrt parameters; Parameters:; x - point, were the gradient is computed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless the",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:50179,Integrability,integrat,integration,50179,"ed; grad - used to return the computed gradient, assumed to be of at least fNpar size; eps - if the errors of parameters have been computed, the step used in; numerical differentiation is eps*parameter_error.; if the errors have not been computed, step=eps is used; default value of eps = 0.01; Method is the same as in Derivative() function. If a paramter is fixed, the gradient on this parameter = 0. void InitArgs(const Double_t* x, const Double_t* params); Initialize parameters addresses. void InitStandardFunctions(); Create the basic function objects. Double_t Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); Return Integral of function between a and b. based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A, B: End-points of integration interval. Note that B may be less; than A.; - params: Array of function parameters. If 0, use current parameters.; - epsilon: Accuracy parameter (see Accuracy). Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:51356,Integrability,rout,routine,51356,"or any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGauss",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:51402,Integrability,message,message,51402,"or any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the argument EPS may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGauss",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:52082,Integrability,integrat,integration,52082,"n the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; double r3 = g->IntegralFast(np,x,w,0,5);; double r4 = g->IntegralFast(np,x,w,0,1000);; double r5 = g->IntegralFast(np,x,w,0,10000);; double r6 = g->IntegralFast(np,x,w,0,100000);; printf(""g->Integral(0,5) = %g\n"",r1);; printf(""g->Integral(0,1000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:52134,Integrability,integrat,integrate,52134,"n the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. Note 2:; Instead of TF1::Integral, you may want to use the combination of; TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; See an example with the following script:. void gint() {; TF1 *g = new TF1(""g"",""gaus"",-5,5);; g->SetParameters(1,0,1);; //default gaus integration method uses 6 points; //not suitable to integrate on a large domain; double r1 = g->Integral(0,5);; double r2 = g->Integral(0,1000);. //try with user directives computing more points; Int_t np = 1000;; double *x=new double[np];; double *w=new double[np];; g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; double r3 = g->IntegralFast(np,x,w,0,5);; double r4 = g->IntegralFast(np,x,w,0,1000);; double r5 = g->IntegralFast(np,x,w,0,10000);; double r6 = g->IntegralFast(np,x,w,0,100000);; printf(""g->Integral(0,5) = %g\n"",r1);; printf(""g->Integral(0,1000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:54211,Integrability,rout,routine,54211,"_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:55991,Integrability,rout,routine,55991,"ction do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussL",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:57182,Integrability,interface,interface,57182,"ult is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:57562,Integrability,rout,routine,57562,"tResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpt",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58043,Integrability,integrat,integration,58043,"gPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58803,Integrability,integrat,integration,58803," n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58985,Integrability,integrat,integration,58985,"], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void Release",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59053,Integrability,rout,routine,59053,"n, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used i",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59188,Integrability,integrat,integration,59188,"s: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59469,Integrability,integrat,integration,59469,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59636,Integrability,integrat,integration,59636,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* i",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:64075,Integrability,interface,interface,64075,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Double_t GetMaximumStored() const; {return fMaximum;}. Double_t GetMinimumStored() const; {return fMinimum;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:693,Modifiability,variab,variable,693,". TF1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1. class TF1: public TFormula, public TAttLine, public TAttFill, public TAttMarker. TF1: 1-Dim function class; A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function (see TFormula) or a; precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1/TGraph drawing functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:744,Modifiability,variab,variable,744,". TF1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1. class TF1: public TFormula, public TAttLine, public TAttFill, public TAttMarker. TF1: 1-Dim function class; A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function (see TFormula) or a; precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1/TGraph drawing functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:958,Modifiability,variab,variable,958,". TF1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1. class TF1: public TFormula, public TAttLine, public TAttFill, public TAttMarker. TF1: 1-Dim function class; A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function (see TFormula) or a; precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1/TGraph drawing functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:1425,Modifiability,variab,variable,1425,"ion (see TFormula) or a; precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1/TGraph drawing functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters at 0.; expo(3) is a substitute for exp([3]+[4]*x). Case 2: inline expression using TMath functions with parameters; >; TF1 *fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();. C - A general C function with parameters; Consider the macro myfunc.C below:. // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:1611,Modifiability,variab,variable,1611,"functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters at 0.; expo(3) is a substitute for exp([3]+[4]*x). Case 2: inline expression using TMath functions with parameters; >; TF1 *fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();. C - A general C function with parameters; Consider the macro myfunc.C below:. // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; TF1 *f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:6994,Modifiability,variab,variable,6994,"ouble_t xmax, Int_t npar, const char* className, const char* methodName = 0); virtual~TF1(); voidTObject::AbstractMethod(const char* method) const; static voidAbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static voidCalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0e-11); virtual Double_tCentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f1) const; virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDerivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tDerivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tDerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* option = ""al"")MENU ; vir",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:25575,Modifiability,variab,variables,25575,"ea color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaximumMaximum value for plotting; TMethodCall*fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tfMinimumMinimum value for plotting; Int_tfNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tfNpfitsNumber of points used in the fit; Int_tfNpxNumber of points used for the graphical representation; Int_tfNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*fParMax[fNpar] Array of upper limits ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:38078,Modifiability,variab,variables,38078,".DrawDerivative(option);. The resulting graph will be drawn into the current pad.; If this function is used via the context menu, it recommended; to create a new canvas/pad before invoking this function. TObject * DrawIntegral(Option_t* option = ""al""); Draw integral of this function. An intermediate TGraph object is built and drawn with option.; The function returns a pointer to the TGraph object. Do:; TGraph *g = (TGraph*)myfunc.DrawIntegral(option);. The resulting graph will be drawn into the current pad.; If this function is used via the context menu, it recommended; to create a new canvas/pad before invoking this function. void DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); Draw formula between xmin and xmax. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. Computes the value of this function (general case for a 3-d function); at point x,y,z.; For a 1-d function give y=0 and z=0; The current value of variables x,y,z is passed through x, y and z.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalPar(const Double_t* x, const Double_t* params = 0); Evaluate function with given coordinates and parameters. Compute the value of this function at point defined by array x; and current values of parameters in array params.; If argument params is omitted or equal 0, the internal values; of parameters (array fParams) will be used instead.; For a 1-D function only x[0] must be given.; In case of a multi-dimemsional function, the arrays x must be; filled with the corresponding number of dimensions. WARNING. In case of an interpreted function (fType=2), it is the; user's responsability to initialize the parameters via InitArgs; before calling this function.; InitArgs should be called at least once to specify the addresses; of the arguments x and params.; InitArgs should be call",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:45500,Modifiability,variab,variable,45500,"t; Return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of free parameters. Int_t GetNumberFreeParameters() const; Return the number of free parameters. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function info (x, function value); corresponding to cursor position px,py. Double_t GetParError(Int_t ipar) const; Return value of parameter number ipar. void GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; Return limits for parameter ipar. Double_t GetProb() const; Return the fit probability. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); Compute Quantiles for density distribution of this function; Quantile x_q of a probability distribution Function F is defined as. For instance the median of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. code from Eddy Offermann, Renaissance. input parameters; - this TF1 function; - nprobSum maximum size of array q and size of array probSum; - probSum array of positions where quantiles will be computed.; It is assumed to contain at least nprobSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Getting quantiles from two histograms and storing results in a TGraph,; a so-called QQ-plot. TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one ran",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:57516,Modifiability,adapt,adapted,57516,"TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evalua",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59436,Modifiability,adapt,adaptive,59436,"y of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:59602,Modifiability,adapt,adaptive,59602,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* i",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:23540,Performance,cache,cache,23540,kNotEqual; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tfChisquareFunction fit chisquare; void*fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' ,MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:24945,Performance,optimiz,optimization,24945,"ea color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorfFunctor! Functor object to wrap any C++ callable object; Double_t*fGamma!Array gamma.; TH1*fHistogram!Pointer to histogram used for visualisation; Double_t*fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaximumMaximum value for plotting; TMethodCall*fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tfMinimumMinimum value for plotting; Int_tfNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tfNpfitsNumber of points used in the fit; Int_tfNpxNumber of points used for the graphical representation; Int_tfNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*fParMax[fNpar] Array of upper limits ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:31506,Performance,cache,cached,31506,"see tutorial math.exampleFunctor.C for an example of using this constructor. This constructor is used only when using CINT.; In compiled mode the template constructor is used and in that case className is not needed. void CreateFromCintClass(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* cname, const char* fname); Internal function used to create from TF1 from an interpreter CINT class; with the specified type (className) and member function name (methodName). TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void Browse(TBrowser* b); Browse. void Copy(TObject& f1) const; Copy this F1 to a new F1.; Note that the cached integral with its related arrays are not copied; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundo",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:54972,Performance,perform,performing,54972," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will retu",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:56752,Performance,perform,performing,56752," the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralFast(const TGraph *g, Double_t a, Double_t b, Double_t *params); Gauss-Legendre integral, see CalcGaussLegendreSamplingPoints. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Double_t epsilon, Double_t& relerr); See more general prototype below.; This interface kept for back compatibility. Double_t IntegralMultiple(Int_t n, const Double_t* a, const Double_t* b, Int_t minpts, Int_t maxpts, Double_t epsilon, Double_t& relerr, Int_t& nfnevl, Int_t& ifail); Adaptive Quadrature for Multiple Integrals over N-Dimensional; Rectangular Regions. Author(s): A.C. Genz, A.A. Malik; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58520,Performance,perform,performed,58520,"; converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:58620,Performance,perform,performed,58620,"code features many changes compared to the Fortran version.; Note that this function is currently called only by TF2::Integral (n=2); and TF3::Integral (n=3). This function computes, to an attempted specified accuracy, the value of; the integral over an n-dimensional rectangular region. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; eps : Specified relative accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Rid",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:64070,Safety,safe,safe,64070,"iated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; { return Eval(x,y,z,t); }. Double_t operator()(const Double_t* x, const Double_t* params = 0). void SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); { TF1::SetRange(xmin, xmax); }. void SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); { TF1::SetRange(xmin, xmax); }. Double_t GetChisquare() const; {return fChisquare;}. Double_t GetMaximumStored() const; {return fMaximum;}. Double_t GetMinimumStored() const; {return fMinimum;}. Int_t GetNpx() const; {return fNpx;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberFitPoints() const; {return fNpfits;}. TObject * GetParent() const; {return fParent;}. Double_t * GetParErrors() const; {return fParErrors;}. Double_t GetXmin() const; {return fXmin;}. Double_t GetXmax() const; {return f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:60491,Security,access,accessed,60491,"lar region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(Option_t* option = """") const; Dump this function with its attributes. void ReleaseParameter(Int_t ipar); Release parameter number ipar If used in a fit, the parameter; can vary freely. The parameter limits are reset to 0,0. void Save(Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); Save values of function in array fSave. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetCurrent(TF1* f1); Static function setting the current function.; the current function may be accessed in static C-like functions; when fitting or painting a function. void SetFitResult(const ROOT::Fit::FitResult& result, const Int_t* indpar = 0); Set the result from the fit; parameter values, errors, chi2, etc...; Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; By default it is assume that indpar = {0,1,2,....,fNpar-1}. void SetMaximum(Double_t maximum = -1111); Set the maximum value along Y for this function; In case the function is already drawn, set also the maximum in the; helper histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value along Y for this function; In case the function is already drawn, set also the minimum in the; helper histogram. void SetNDF(Int_t ndf); Set the number of degrees of freedom; ndf should be the number of points used in a fit - the number of free parameters. void SetNpx(In",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:2653,Testability,test,test,2653,",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters at 0.; expo(3) is a substitute for exp([3]+[4]*x). Case 2: inline expression using TMath functions with parameters; >; TF1 *fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();. C - A general C function with parameters; Consider the macro myfunc.C below:. // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; TF1 *f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; void myfit(); {; TH1F *h1=new TH1F(""h1"",""test"",100,0,10);; h1->FillRandom(""myfunc"",20000);; TF1 *f1=gROOT->GetFunction(""myfunc"");; f1->SetParameters(800,1);; h1->Fit(""myfunc"");; }. In an interactive session you can do:. Root > .L myfunc.C; Root > myfunc();; Root > myfit();. TF1 objects can reference other TF1 objects (thanks John; Odonnell) of type A or B defined above. This excludes CINT interpreted functions; and compiled functions. However, there is a restriction. A function cannot; reference a basic function if the basic function is a polynomial polN.; Example:. {; TF1 *fcos = new TF1 (""fcos"", ""[0]*cos(x)"", 0., 10.);; fcos->SetParNames( ""cos"");; fcos->SetParameter( 0, 1.1);; TF1 *fsin = new TF1 (""fsin"", ""[0]*sin(x)"", 0., 10.);; fsin->SetParNames( ""sin"");; fsin->SetParameter( 0, 2.1);; TF1 *fsincos = new TF1 (""fsc"", ""fcos+fsin"");; TF1 *fs2 = new TF1 (""fs2"", ""fsc+fsc"");; }. D - A general C++ function object (functor) with paramet",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:9715,Testability,log,logx,9715,"t::FindObject(const TObject* obj) const; virtual voidFixParameter(Int_t ipar, Double_t value); Double_tGetChisquare() const; static TF1*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) c",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:9899,Testability,log,logx,9899,"rawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetPa",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:10075,Testability,log,logx,10075,"Style_tTAttFill::GetFillStyle() const; TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tGetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMaximumStored() const; virtual Double_tGetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*GetMethodCall() const; virtual Double_tGetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t ipar) const; virtual Double_t*GetParErrors() const; virtual voidGetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:10259,Testability,log,logx,10259,"const; virtual Double_tGetMinimumStored() const; virtual Double_tGetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tGetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tGetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tGetNumberFitPoints() const; virtual Int_tGetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*GetParent() const; virtual Double_tGetParError(Int_t ipar) const; virtual Double_t*GetParErrors() const; virtual voidGetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tGetProb() const; virtual Int_tGetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*GetXaxis() const; virtual Double_tGetXmax() const; virtual Double_tGetXmin(",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:11988,Testability,log,logx,11988,", Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tGetProb() const; virtual Int_tGetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*GetXaxis() const; virtual Double_tGetXmax() const; virtual Double_tGetXmin() const; TAxis*GetYaxis() const; TAxis*GetZaxis() const; virtual Double_tGradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidGradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidInitArgs(const Double_t* x, const Double_t* params); static voidInitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 1e-12); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); virtual Do",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:28220,Testability,test,test,28220,"is assumed that; the formula string is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. TF1(const char* name, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using name of an interpreted function. Creates a function of type C between xmin and xmax.; name is the name of an interpreted CINT cunction.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, void* fcn, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using pointer to an interpreted function. See TFormula constructor for explanation of the formula syntax. Creates a function of type C between xmin and xmax.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). see tutorial; myfit for an example of use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see te",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:28698,Testability,test,test,28698,"ns of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, void* fcn, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using pointer to an interpreted function. See TFormula constructor for explanation of the formula syntax. Creates a function of type C between xmin and xmax.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). see tutorial; myfit for an example of use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:28711,Testability,test,test,28711,"ns of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, void* fcn, Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using pointer to an interpreted function. See TFormula constructor for explanation of the formula syntax. Creates a function of type C between xmin and xmax.; The function is defined with npar parameters; fcn must be a function of type:; Double_t fcn(Double_t *x, Double_t *params). see tutorial; myfit for an example of use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A f",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:29200,Testability,test,test,29200,"use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor(const char* name, Int_t npar); Internal Function to Create a TF1 using a Functor. Used by the template constructors. TF1(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* className); F1 constructor from an interpreted class defining the operator() or Eval().; This constructor emulate the syntax of the template constructor using a C++ callable object (functor); which can be used only in C",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:29213,Testability,test,test,29213,"use; also test/stress.cxx (see function stress1). This constructor is called for functions of type C by CINT. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using a pointer to a real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char *name,Double_t (*fcn)(const Double_t *, const Double_t *), Double_t xmin, Double_t xmax, Int_t npar); F1 constructor using a pointer to real function. npar is the number of free parameters used by the function. This constructor creates a function of type C when invoked; with the normal C++ compiler. see test program test/stress.cxx (function stress1) for an example.; note the interface with an intermediate pointer. WARNING! A function created with this constructor cannot be Cloned. TF1(const char* name, ROOT::Math::ParamFunctor f, Double_t xmin = 0, Double_t xmax = 1, Int_t npar = 0); F1 constructor using the Functor class. xmin and xmax define the plotting range of the function; npar is the number of free parameters used by the function. This constructor can be used only in compiled code. WARNING! A function created with this constructor cannot be Cloned. void CreateFromFunctor(const char* name, Int_t npar); Internal Function to Create a TF1 using a Functor. Used by the template constructors. TF1(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* className); F1 constructor from an interpreted class defining the operator() or Eval().; This constructor emulate the syntax of the template constructor using a C++ callable object (functor); which can be used only in C",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:39694,Testability,log,logx,39694,"onding number of dimensions. WARNING. In case of an interpreted function (fType=2), it is the; user's responsability to initialize the parameters via InitArgs; before calling this function.; InitArgs should be called at least once to specify the addresses; of the arguments x and params.; InitArgs should be called everytime these addresses change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a F1 is clicked with the locator. void FixParameter(Int_t ipar, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:40328,Testability,log,logx,40328,"par, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:40367,Testability,log,log,40367,"par, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:40416,Testability,log,log,40416,"par, Double_t value); Fix the value of a parameter; The specified value will be used in a fit operation. TF1 * GetCurrent(); Static function returning the current function being processed. TH1 * GetHistogram() const; Return a pointer to the histogram used to vusualize the function. Double_t GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:40614,Testability,log,logx,40614,"logx = false) const; Return the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maxim",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:41277,Testability,log,logx,41277,"0) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:41316,Testability,log,log,41316,"0) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:41365,Testability,log,log,41365,"0) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:41541,Testability,log,logx,41541,"false) const; Return the X value corresponding to the maximum value of the function; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx.; This way, the step size can be controlled via the SetNpx() function.; If the function is unimodal or if its extrema are far apart, setting; the fNpx to a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:42205,Testability,log,logx,42205,"maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:42244,Testability,log,log,42244,"maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:42293,Testability,log,log,42293,"maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the minimum value of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:42491,Testability,log,logx,42491,"e of the function on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the r",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:43185,Testability,log,logx,43185," of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:43224,Testability,log,log,43224," of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:43273,Testability,log,log,43273," of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX and TF1::GetX. Double_t GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:43455,Testability,log,logx,43455,"l_t logx = false) const; Returns the X value corresponding to the minimum value of the function; on the (xmin, xmax) interval; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const;",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:44290,Testability,log,logx,44290,"cally if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const; Return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of free parameters. Int_t GetNumberFreeParameters() const; Return the number of free parameters. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function info (x, function value); corresponding to cursor position px,py. Double_t GetParError(Int_t ipar) const; Return value of parameter number ipar. void GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; Return limits for parameter ipar. Double_t GetProb() const; Return the fit probability. Int_t GetQuantiles(Int_t nprobSum, Double_t* q",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:44329,Testability,log,log,44329,"cally if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const; Return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of free parameters. Int_t GetNumberFreeParameters() const; Return the number of free parameters. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function info (x, function value); corresponding to cursor position px,py. Double_t GetParError(Int_t ipar) const; Return value of parameter number ipar. void GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; Return limits for parameter ipar. Double_t GetProb() const; Return the fit probability. Int_t GetQuantiles(Int_t nprobSum, Double_t* q",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:44378,Testability,log,log,44378,"cally if the log scale is set in the current Pad. NOTE: see also TF1::GetX. Double_t GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; Returns the X value corresponding to the function value fy for (xmin<x<xmax).; in other words it can find the roots of the function when fy=0 and successive calls; by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval; epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; of iteration of the Brent algorithm; If the flag logx is set the grid search is done in log step size; This is done automatically if the log scale is set in the current Pad. NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX. Int_t GetNDF() const; Return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of free parameters. Int_t GetNumberFreeParameters() const; Return the number of free parameters. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function info (x, function value); corresponding to cursor position px,py. Double_t GetParError(Int_t ipar) const; Return value of parameter number ipar. void GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; Return limits for parameter ipar. Double_t GetProb() const; Return the fit probability. Int_t GetQuantiles(Int_t nprobSum, Double_t* q",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:46777,Testability,log,log,46777,"obSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Getting quantiles from two histograms and storing results in a TGraph,; a so-called QQ-plot. TGraph *gr = new TGraph(nprob);; f1->GetQuantiles(nprob,gr->GetX());; f2->GetQuantiles(nprob,gr->GetY());; gr->Draw(""alp"");. Double_t GetRandom(); Return a random number following this function shape. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; if the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; The parabolic approximation is very good as soon as the number; of bins is greater than 50. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape in [xmin,xmax]. The distribution contained in the function fname (TF1) is integrated; over the channel contents.; It is normalized to 1.; For each bin the integral is approximated by a parabola.; The parabola coefficients are stored as non persistent data members; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Evaluate the parabolic curve in the selected bin to find; the corresponding X value.; The parabolic approximation is very good as soon as the number; of bins is greater than 50. IMPORTANT NOTE; The integral of the function is computed at fNpx points. If the function; has sharp peaks, you should increase the number of points (SetNpx); such that the peak is correctly tabulated at severa",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:63239,Testability,test,tested,63239,"Double_t parmax); Set limits for parameter ipar. The specified limits will be used in a fit operation; when the option ""B"" is specified (Bounds).; To fix a parameter, use TF1::FixParameter. void SetRange(Double_t xmin, Double_t xmax); Initialize the upper and lower bounds to draw the function. The function range is also used in an histogram fit operation; when the option ""R"" is specified. void SetSavedPoint(Int_t point, Double_t value); Restore value of function saved at point. void SetTitle(const char* title = """"); Set function title; if title has the form ""fffffff;xxxx;yyyy"", it is assumed that; the function title is ""fffffff"" and ""xxxx"" and ""yyyy"" are the; titles for the X and Y axis respectively. void Streamer(TBuffer& ); Stream a class object. void Update(); Called by functions such as SetRange, SetNpx, SetParameters; to force the deletion of the associated histogram or Integral. void RejectPoint(Bool_t reject = kTRUE); Static function to set the global flag to reject points; the fgRejectPoint global flag is tested by all fit functions; if TRUE the point is not included in the fit.; This flag can be set by a user in a fitting function.; The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions. Bool_t RejectedPoint(); See TF1::RejectPoint above. Double_t Moment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth moment of function between a and b. See TF1::Integral() for parameter definitions. Double_t CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); Return nth central moment of function between a and b; (i.e the n-th moment around the mean value). See TF1::Integral() for parameter definitions; Author: Gene Van Buren <gene@bnl.gov>. void CalcGaussLegendreSamplingPoints(TGraph *g, Double_t eps); Type safe interface (static method); The number of sampling points are taken from the TGraph. Double_t operator()(Double_t x, Double_t y = 0, Dou",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF1.html:448,Usability,simpl,simple,448,". TF1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TF1. class TF1: public TFormula, public TAttLine, public TAttFill, public TAttMarker. TF1: 1-Dim function class; A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function (see TFormula) or a; precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1/TGraph drawing functions. The following types of functions can be created:. A - Expression using variable x and no parameters; B - Expression using variable x with parameters; C - A general C function with parameters; D - A general C++ function object (functor) with parameters; E - A member function with parameters of a general C++ class. A - Expression using variable x and no parameters; Case 1: inline expression using standard C++ functions/operators. TF1 *fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();. Case 2: inline expression using TMath functions without parameters. TF1 *fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();. Case 3: inline expression using a CINT function by name. Double_t myFunc(x) {; return x+sin(x);; }; TF1 *fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();. B - Expression using variable x with parameters; Case 1: inline expression using standard C++ functions/operators. Example a:; >; TF1 *fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);. This creates a function of variable x with 2 parameters.; The parameters must be initialized via:. fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);. Parameters may be given a name:. fa->SetParName(0,""Constant"");. Example b:; >; TF1 *fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);. gaus(0) is a substitute for [0]*exp(-0.5*((x-[1])/[2])**2); and (0) means start numbering parameters ",MatchSource.WIKI,root/html534/TF1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1.html
https://root.cern/root/html534/TF12.html:3186,Availability,error,error,3186,"y, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTF1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*TF1::DrawDerivative(Option_t* option = ""al"")MENU ; virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual TObject*TF1::DrawIntegral(Option_t* option = ""al"")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTF1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() co",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:3270,Availability,error,error,3270,"cetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*TF1::DrawDerivative(Option_t* option = ""al"")MENU ; virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual TObject*TF1::DrawIntegral(Option_t* option = ""al"")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTF1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMa",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:13952,Availability,error,error,13952," 1000); virtual voidTF1::SetMaximum(Double_t maximum = -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetXY(Double_t xy)MENU ; virtu",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:14006,Availability,error,errors,14006," -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetXY(Double_t xy)MENU ; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNa",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:21300,Availability,error,errors,21300," Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*TF1::fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*TF1::fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*TF1::fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tTF1::fType(=0 for standard functions, 1 if pointer to function); Double_tfXYValue along Y (if projection X) or X (if projection Y); Double_tTF1::fXmaxUpper bounds for the range; Double_tTF1::fXminLower bounds for the range; static Bool_tTF1::fgAbsValueuse absolute value of function when computing integral; static TF1*TF1::fgCurrentpointer to current function being processed; static Bool_tTF1::fgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF12(); TF12 default constructor. TF12(const char* name, TF2* f2, Double_t xy, Option_t* option = ""x""); TF12 normal constructor.; Create a TF12 (special TF1) from a projection of a TF2; for a fix value of Y if option=""X"" or X if option=""Y""; This value may be changed at any time via TF12::SetXY(xy). ~TF12(); F2 default destructor. TF12(const TF12& f12); Copy const",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:24063,Deployability,update,updated,24063,"""); TF12 normal constructor.; Create a TF12 (special TF1) from a projection of a TF2; for a fix value of Y if option=""X"" or X if option=""Y""; This value may be changed at any time via TF12::SetXY(xy). ~TF12(); F2 default destructor. TF12(const TF12& f12); Copy constructor. void Copy(TObject& f12) const; Copy this F2 to a new F2. TF1 * DrawCopy(Option_t* option = """") const; Draw a copy of this function with its current attributes. This function MUST be used instead of Draw when you want to draw; the same function with different parameters settings in the same canvas. Possible option values are:; ""SAME"" superimpose on top of existing picture; ""L"" connect all computed points with a straight line; ""C"" connect all computed points with a smooth curve. Note that the default value is ""F"". Therefore to draw on top; of an existing picture, specify option ""SL"". Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. Computes the value of the referenced TF2 for a fix value of X or Y. Double_t EvalPar(const Double_t* x, const Double_t* params = 0); Evaluate this function at point x[0]; x[0] is the value along X if fCase =0, the value along Y if fCase=1; if params is non null, the array will be used instead of the internal TF2; parameters. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetXY(Double_t xy); set the value of the constant for the TF2; constant in X when projecting along Y; constant in Y when projecting along X; The function title is set to include the value of the constant; The current pad is updated. Double_t GetXY() const; {return fXY;}. » Author: Rene Brun 05/04/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:19491,Integrability,wrap,wrap,19491,"; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Int_tfCaseprojection along X(0), or Y(1); Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TF2*fF2pointer to the mother TF2; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum ",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:1721,Modifiability,variab,variable,1721," name, TF2* f2, Double_t xy, Option_t* option = ""x""); virtual~TF12(); voidTObject::AbstractMethod(const char* method) const; static voidTF1::AbsValue(Bool_t reject = kTRUE); virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTF1::Browse(TBrowser* b); static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0e-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f12) const; virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTF1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*TF1::DrawDerivative(O",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:20981,Modifiability,variab,variables,20981,"Stylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParM",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:18800,Performance,cache,cache,18800,"al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Int_tfCaseprojection along X(0), or Y(1); Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TF2*fF2pointer to the mother TF2; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLin",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:20336,Performance,optimiz,optimization,20336,"Stylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParM",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:4517,Testability,log,logx,4517,"bj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() c",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:4711,Testability,log,logx,4711," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetPar",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:4897,Testability,log,logx,4897,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:5091,Testability,log,logx,5091,"irtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF1::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tTF1::GetRandom(); virtual Double_tTF1::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF1::GetRange(Double_t& xmin, Double_t& xmax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tTF1::GetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF12.html:6910,Testability,log,logx,6910,"tParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tTF1::GetRandom(); virtual Double_tTF1::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF1::GetRange(Double_t& xmin, Double_t& xmax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidTF1::GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tTF1::GetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; virtual Double_tGetXY() const; TAxis*TF1::GetYaxis() const; TAxis*TF1::GetZaxis() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tTF1::Integral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 1e-12); virtual Double_tTF1::Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 1e-12); virtual Double_tTF1::Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Do",MatchSource.WIKI,root/html534/TF12.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF12.html
https://root.cern/root/html534/TF1Editor.html:4623,Availability,error,error,4623,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TF1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1Editor.html
https://root.cern/root/html534/TF1Editor.html:4707,Availability,error,error,4707,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TF1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1Editor.html
https://root.cern/root/html534/TF1Editor.html:17571,Availability,mask,mask,17571,,MatchSource.WIKI,root/html534/TF1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1Editor.html
https://root.cern/root/html534/TF1Editor.html:21234,Integrability,interface,interface,21234,"st TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TF1 editor. ~TF1Editor(); Destructor of TF1 editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the function parameters and options. void DoParameterSettings(); Slot connected to the function parameter(s) settings. void DoXPoints(); Slot connected to the number of points setting. void DoSliderXMoved(); Slot connected to the x-Slider range for function redrawing. void DoSliderXPressed(); Slot connected to the x-Slider. void DoSliderXReleased(); Slot connected to the x-Slider. void DoXRange(); Slot connected to min/max settings of the slider range. void ActivateBaseClassEditors(TClass* cl); Exclude TAttFillEditor from this interface. » Author: Ilka Antcheva 21/03/06 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TF1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF1Editor.html
https://root.cern/root/html534/TF2.html:4197,Availability,error,error,4197,"ve(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidDrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tGetContour(Double_t* levels = 0); virtual Double_tGetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:4281,Availability,error,error,4281,"::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidDrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tGetContour(Double_t* levels = 0); virtual Double_tGetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLine",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:15674,Availability,error,error,15674,"_t maximum = -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidSetNpy(Int_t npy = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:15728,Availability,error,errors,15728,"Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidSetNpy(Int_t npy = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&);",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:23233,Availability,error,errors,23233,"er of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*TF1::fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*TF1::fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*TF1::fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tTF1::fType(=0 for standard functions, 1 if pointer to function); Double_tTF1::fXmaxUpper bounds for the range; Double_tTF1::fXminLower bounds for the range; Double_tfYmaxUpper bound for the range in y; Double_tfYminLower bound for the range in y; static Bool_tTF1::fgAbsValueuse absolute value of function when computing integral; static TF1*TF1::fgCurrentpointer to current function being processed; static Bool_tTF1::fgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF2(); F2 default constructor*-*-*-*-*-*-; *-* ======================. TF2(const char* name, const char* formula, Double_t xmin = 0, Double_t xmax = 1, Double_t ymin = 0, Double_t ymax = 1); F2 constructor using a formula definition. See TFormula constructor for explanation of the formula syntax. if formula has the form ""fffffff;xxxx;yyyy"", it is assum",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:30825,Deployability,integrat,integrated,30825,"um on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF2 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the two random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function*-*-; *-* ==============================. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:21351,Integrability,wrap,wrap,21351," kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plot",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:30825,Integrability,integrat,integrated,30825,"um on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF2 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the two random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; Return range of a 2-D function*-*-; *-* ==============================. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:2642,Modifiability,variab,variable,2642,"static voidTF1::CalcGaussLegendreSamplingPoints(Int_t num, Double_t* x, Double_t* w, Double_t eps = 3.0e-11); virtual Double_tTF1::CentralMoment(Double_t n, Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tCentralMoment2(Double_t nx, Double_t ax, Double_t bx, Double_t ny, Double_t ay, Double_t by, Double_t epsilon = 0.000001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f2) const; virtual Double_tCovariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidDrawF2(const char* formula, Double_t xmi",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:22914,Modifiability,variab,variables,22914,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the ",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:20688,Performance,cache,cache,20688,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDfContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TOb,MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:22196,Performance,optimiz,optimization,22196,"la::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tfNpyNumber of points along y used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the ",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:29826,Performance,perform,performed,29826,"-* of an existing picture, specify option ""SL""; -; *. void DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); -*-*Draw formula between xmin,ymin and xmax,ymax; *-* ============================================; -. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F2 is clicked with the locator; -; *. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels*-*-; *-* =======================================; -; *-* The number of contour levels can be returned by getContourLevel; -; *. Double_t GetContourLevel(Int_t level) const; Return the number of contour levels*-*-*-*-*-; *-* ===================================. void GetMinimumXY(Double_t& x, Double_t& y); return the X and Y values corresponding to the minimum value of the function; To find the minimum on a range, first set this range via the SetRange function; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, Minuit minimization is used with starting values found by the grid search. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function shape*-; *-* ====================================================; -. void GetRandom2(Double_t& xrandom, Double_t& yrandom); Return 2 random numbers following this function shape; *-* ============================",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:5622,Testability,log,logx,5622,"onst; virtual Int_tGetContour(Double_t* levels = 0); virtual Double_tGetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Boo",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:5816,Testability,log,logx,5816," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Do",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:6002,Testability,log,logx,6002,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Dou",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:6196,Testability,log,logx,6196," Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidGetMinimumXY(Double_t& x, Double_t& y); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tGetNpy() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* params); TObject*TF1::GetParent() const; virtual Double_tTF1::GetParError(Int_t ipar) const; virtual Double_t*TF1::GetParErrors() const; virtual voidTF1::GetParLimits(Int_t ipar, Double_t& parmin, Double_t& parmax) const; virtual const char*TFormula::GetParName(Int_t ipar) const; virtual Int_tTFormula::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = ",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2.html:8115,Testability,log,logx,8115,"::GetParNumber(const char* name) const; virtual Double_tTF1::GetProb() const; virtual Int_tTF1::GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum); virtual Double_tGetRandom(); virtual Double_tGetRandom(Double_t xmin, Double_t xmax); virtual voidGetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tGetYmax() const; virtual Double_tGetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsil = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsil = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by",MatchSource.WIKI,root/html534/TF2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2.html
https://root.cern/root/html534/TF2GL.html:2132,Performance,cache,cached,2132,"icalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html534/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2GL.html
https://root.cern/root/html534/TF2GL.html:830,Testability,log,logx,830," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shap",MatchSource.WIKI,root/html534/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2GL.html
https://root.cern/root/html534/TF2GL.html:843,Testability,log,logy,843," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shap",MatchSource.WIKI,root/html534/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2GL.html
https://root.cern/root/html534/TF2GL.html:856,Testability,log,logz,856," TF2GL(); virtual~TF2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shap",MatchSource.WIKI,root/html534/TF2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF2GL.html
https://root.cern/root/html534/TF3.html:4778,Availability,error,error,4778,"x, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinear",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:4862,Availability,error,error,4862,"s() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Option_t* option = """"); virtual TObject*DrawIntegral(Option_t* = ""al""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTF1::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tTF1::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTF1::FixParameter(Int_t ipar, Double_t value); Double_tTF1::GetChisquare() const; virtual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLin",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:17308,Availability,error,error,17308,"::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:17362,Availability,error,errors,17362,"oidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&);",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:25365,Availability,error,errors,25365,"entation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fParErrors[fNpar] Array of errors of the fNpar parameters; Double_t*TF1::fParMax[fNpar] Array of upper limits of the fNpar parameters; Double_t*TF1::fParMin[fNpar] Array of lower limits of the fNpar parameters; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TObject*TF1::fParent!Parent object hooking this function (if one); TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function ; Double_t*TF1::fSave[fNsave] Array of fNsave function values; TStringTNamed::fTitleobject title; Int_tTF1::fType(=0 for standard functions, 1 if pointer to function); Double_tTF1::fXmaxUpper bounds for the range; Double_tTF1::fXminLower bounds for the range; Double_tTF2::fYmaxUpper bound for the range in y; Double_tTF2::fYminLower bound for the range in y; Double_tfZmaxUpper bound for the range in z; Double_tfZminLower bound for the range in z; static Bool_tTF1::fgAbsValueuse absolute value of function when computing integral; static TF1*TF1::fgCurrentpointer to current function being processed; static Bool_tTF1::fgRejectPointTrue if point must be rejected in a fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TF3(); F3 default constructor*-*-*-*-*-*-; *-* ======================. TF3(const char* name, const char* formula, Double_t xmin = 0, Double_t xmax = 1, Double_t ymin = 0, Double_t ymax = 1, Double_t zmin = 0, Double_t zmax = 1); F3 constructor using a formula definition*-*-*-*-; *-* ====================",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:31611,Deployability,integrat,integrated,31611,"============================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. Double_t Integral(Double_t ax, Double_t bx, D",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:23405,Integrability,wrap,wrap,23405,"FunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for pl",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:31611,Integrability,integrat,integrated,31611,"============================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp peaks, you should increase the number of; *-* points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; *-* at several points. void GetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; Return range of function*-*-*-*-; *-* ========================. Double_t GetSave(const Double_t* x); Get value corresponding to X in array of fSave values. Double_t Integral(Double_t ax, Double_t bx, D",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:3213,Modifiability,variab,variable,3213,"*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voidCopy(TObject& f3) const; virtual Double_tTF2::Covariance2XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual Double_tCovariance3XY(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual Double_tCovariance3XZ(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual Double_tCovariance3YZ(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 0.000001); virtual TH1*CreateHistogram(); virtual char*TFormula::DefinedString(Int_t code); virtual Double_tTFormula::DefinedValue(Int_t code); virtual Int_tTFormula::DefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTF1::Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative2(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; virtual Double_tTF1::Derivative3(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TF1*TF2::DrawCopy(Option_t* option = """") const; virtual TObject*DrawDerivative(Option_t* = ""al""); virtual voidTF1::DrawF1(const char* formula, Double_t xmin, Double_t xmax, Option_t* option = """"); virtual voidTF2::DrawF2(const char* formula, Do",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:25046,Modifiability,variab,variables,25046,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fP",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:22737,Performance,cache,cache,22737,al; kLess; kGreater; kLessThan; kGreaterThan; kNot; kcosh; ksinh; ktanh; kacosh; kasinh; katanh; kStringEqual; kStringNotEqual; kBitAnd; kBitOr; kLeftShift; kRightShift; kJumpIf; kJump; kexpo; kxexpo; kyexpo; kzexpo; kxyexpo; kgaus; kxgaus; kygaus; kzgaus; kxygaus; klandau; kxlandau; kylandau; kzlandau; kxylandau; kpol; kxpol; kypol; kzpol; kParameter; kConstant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TF1::fAlpha!Array alpha. for each bin in x the deconvolution r of fIntegral; TBitsTFormula::fAlreadyFound! cache for information; Double_t*TF1::fBeta!Array beta. is approximated by x = alpha +beta*r *gamma*r**2; Double_tTF1::fChisquareFunction fit chisquare; void*TF1::fCintFunc! pointer to interpreted function class; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; TArrayDTF2::fContourArray to display contour levels; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TObjArrayTFormula::fFunctionsArray of function calls to make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width,MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:24250,Performance,optimiz,optimization,24250,"o make; ROOT::Math::ParamFunctorTF1::fFunctor! Functor object to wrap any C++ callable object; Double_t*TF1::fGamma!Array gamma.; TH1*TF1::fHistogram!Pointer to histogram used for visualisation; Double_t*TF1::fIntegral![fNpx] Integral of function binned on fNpx bins; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tTF1::fMaximumMaximum value for plotting; TMethodCall*TF1::fMethodCall!Pointer to MethodCall in case of interpreted function; Double_tTF1::fMinimumMinimum value for plotting; Int_tTF1::fNDFNumber of degrees of freedom in the fit; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tTFormula::fNconstNumber of constants; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTF1::fNpfitsNumber of points used in the fit; Int_tTF1::fNpxNumber of points used for the graphical representation; Int_tTF2::fNpyNumber of points along y used for the graphical representation; Int_tfNpzNumber of points along z used for the graphical representation; Int_tTF1::fNsaveNumber of points used to fill array fSave; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncTFormula::fOptimal!pointer to optimal function; Double_t*TF1::fP",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:31031,Performance,perform,performed,31031,"-* ========================. Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*Compute distance from point px,py to a function; *-* ===============================================; *-* Compute the closest distance of approach from point px,py to this function.; *-* The distance is computed in pixels units.; -; *-* Algorithm:; -; -; *. void Draw(Option_t* option = """"); -*-*-*-*-*-*Draw this function with its current attributes; *-* ==============================================. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*Execute action corresponding to one event; *-* =========================================; *-* This member function is called when a F3 is clicked with the locator; -; *. void GetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); Return the X, Y and Z values corresponding to the minimum value of the function; on its range. To find the minimum on a subrange, use the SetRange() function first.; Method:; First, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided; into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; Then, Minuit minimization is used with starting values found by the grid search. void GetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); Return 3 random numbers following this function shape; *-* =====================================================; -; *-* The distribution contained in this TF3 function is integrated; *-* over the cell contents.; *-* It is normalized to 1.; *-* Getting the three random numbers implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which cell in the normalized integral r1 corresponds to; *-* - make a linear interpolation in the returned cell; -; -; *-* IMPORTANT NOTE; *-* The integral of the function is computed at fNpx * fNpy * fNpz points.; *-* If the function has sharp p",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:6213,Testability,log,logx,6213,"ual Int_tTF2::GetContour(Double_t* levels = 0); virtual Double_tTF2::GetContourLevel(Int_t level) const; static TF1*TF1::GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:6407,Testability,log,logx,6407," Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormu",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:6593,Testability,log,logx,6593,"st; TH1*TF1::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const TObject*TFormula::GetLinearPart(Int_t i); virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Double_tTF1::GetMaximum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMaximumStored() const; virtual Double_tTF1::GetMaximumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TMethodCall*TF1::GetMethodCall() const; virtual Double_tTF1::GetMinimum(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual Double_tTF1::GetMinimumStored() const; virtual Double_tTF1::GetMinimumX(Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; virtual voidTF2::GetMinimumXY(Double_t& x, Double_t& y); virtual voidGetMinimumXYZ(Double_t& x, Double_t& y, Double_t& z); virtual const char*TNamed::GetName() const; virtual Int_tTF1::GetNDF() const; virtual Int_tTFormula::GetNdim() const; virtual Int_tTFormula::GetNpar() const; virtual Int_tTF1::GetNpx() const; Int_tTF2::GetNpy() const; Int_tGetNpz() const; virtual Int_tTFormula::GetNumber() const; virtual Int_tTF1::GetNumberFitPoints() const; virtual Int_tTF1::GetNumberFreeParameters() const; virtual char*TF2::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTFormula::GetParameter(Int_t ipar) const; Double_tTFormula::GetParameter(const char* name) const; virtual Double_t*TFormula::GetParameters() const; virtual voidTFormula::GetParameters(Double_t* pa",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:6787,Testability,log,logx,6787,,MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TF3.html:8904,Testability,log,logx,8904," q, const Double_t* probSum); virtual Double_tTF2::GetRandom(); virtual Double_tTF2::GetRandom(Double_t xmin, Double_t xmax); virtual voidTF2::GetRandom2(Double_t& xrandom, Double_t& yrandom); virtual voidGetRandom3(Double_t& xrandom, Double_t& yrandom, Double_t& zrandom); virtual voidGetRange(Double_t& xmin, Double_t& xmax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& xmax, Double_t& ymax) const; virtual voidGetRange(Double_t& xmin, Double_t& ymin, Double_t& zmin, Double_t& xmax, Double_t& ymax, Double_t& zmax) const; virtual Double_tGetSave(const Double_t* x); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tTF1::GetX(Double_t y, Double_t xmin = 0, Double_t xmax = 0, Double_t epsilon = 1.E-10, Int_t maxiter = 100, Bool_t logx = false) const; TAxis*TF1::GetXaxis() const; virtual Double_tTF1::GetXmax() const; virtual Double_tTF1::GetXmin() const; TAxis*TF1::GetYaxis() const; virtual Double_tTF2::GetYmax() const; virtual Double_tTF2::GetYmin() const; TAxis*TF1::GetZaxis() const; virtual Double_tGetZmax() const; virtual Double_tGetZmin() const; virtual Double_tTF1::GradientPar(Int_t ipar, const Double_t* x, Double_t eps = 0.01); virtual voidTF1::GradientPar(const Double_t* x, Double_t* grad, Double_t eps = 0.01); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTF1::InitArgs(const Double_t* x, const Double_t* params); static voidTF1::InitStandardFunctions(); virtual voidTObject::Inspect() constMENU ; virtual Double_tIntegral(Double_t a, Double_t b, const Double_t* params = 0, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 0.000001); virtual Double_tIntegral(Double_t",MatchSource.WIKI,root/html534/TF3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TF3.html
https://root.cern/root/html534/TFastCgi.html:2149,Availability,error,error,2149,"tCgi(const TFastCgi&); virtual~TFastCgi(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; Int_tGetSocket() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html534/TFastCgi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFastCgi.html
https://root.cern/root/html534/TFastCgi.html:2233,Availability,error,error,2233,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char* args); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*THttpEngine::GetServer() const; Int_tGetSocket() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFro",MatchSource.WIKI,root/html534/TFastCgi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFastCgi.html
https://root.cern/root/html534/TFastCgi.html:6905,Modifiability,variab,variables,6905,"irtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfDebugMode! debug mode, may required for fastcgi debugging in other servers; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; Int_tfSocket! socket used by fastcgi; TThread*fThrd! thread which takes requests, can be many later; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFastCgi(); normal constructor. ~TFastCgi(); destructor. Bool_t Create(const char* args); initializes fastcgi variables and start thread,; which will process incoming http requests. void * run_func(void* ). TFastCgi(). Int_t GetSocket() const. » Last changed: Tue Jul 21 16:38:17 2015 » Last generated: 2015-07-21 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFastCgi.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFastCgi.html
https://root.cern/root/html534/TFcnAdapter.html:306,Integrability,interface,interface,306,". TFcnAdapter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:03; Thi",MatchSource.WIKI,root/html534/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFcnAdapter.html
https://root.cern/root/html534/TFcnAdapter.html:406,Integrability,interface,interface,406,". TFcnAdapter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:03; Thi",MatchSource.WIKI,root/html534/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFcnAdapter.html
https://root.cern/root/html534/TFcnAdapter.html:1836,Integrability,interface,interface,1836,"unction members; data members; class charts. ROOT; » MATH; » MINUIT2; » TFcnAdapter. class TFcnAdapter: public ROOT::Minuit2::FCNGradientBase. Adapt the interface used in TMinuit (and the TVirtualFitter) for; passing the objective function in a Minuit2 interface; (ROOT::Minuit2::FCNGradientBase or ROOT::Minuit2::FCNBase). Function Members (Methods); public:. TFcnAdapter(void (*)(int&, double*, double&, double*, int) fcn); TFcnAdapter(const TFcnAdapter&); virtual~TFcnAdapter(); const ROOT::Minuit2::FCNBase&Base() const; virtual boolROOT::Minuit2::FCNGradientBase::CheckGradient() const; static TClass*Class(); virtual doubleROOT::Minuit2::FCNBase::ErrorDef() const; virtual vector<double>Gradient(const vector<double>&) const; virtual TClass*IsA() const; virtual doubleoperator()(const vector<double>&) const; doubleoperator()(int npar, double* params, int iflag = 4) const; TFcnAdapter&operator=(const TFcnAdapter&); virtual voidSetErrorDef(double up); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual doubleUp() const. Data Members; private:. void (*)(int&, double*, double&, double*, int)fFCN; vector<double>fGradCache; doublefUp. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFcnAdapter(void (*fcn)(int&, double*, double&, double*, int)); {}. virtual ~TFcnAdapter(); {}. double operator()(const vector<double>& ) const. double Up() const; {return fUp; }. void SetErrorDef(double up); { fUp = up; }. std::vector<double> Gradient(const vector<double>& ) const. double operator()(int npar, double* params, int iflag = 4) const; forward interface. » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFcnAdapter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFcnAdapter.html
https://root.cern/root/html534/TFeldmanCousins.html:2602,Availability,error,error,2602,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCL() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLowerLimit() const; Double_tGetMuMax() const; Double_tGetMuMin() const; Double_tGetMuStep() const; virtual const char*TObject::GetName() const; Double_tGetNbackground() const; Double_tGetNMax() const; Double_tGetNobserved() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Doub",MatchSource.WIKI,root/html534/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFeldmanCousins.html
https://root.cern/root/html534/TFeldmanCousins.html:2686,Availability,error,error,2686,"owser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCL() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLowerLimit() const; Double_tGetMuMax() const; Double_tGetMuMin() const; Double_tGetMuStep() const; virtual const char*TObject::GetName() const; Double_tGetNbackground() const; Double_tGetNMax() const; Double_tGetNobserved() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetUpperLimit() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtua",MatchSource.WIKI,root/html534/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFeldmanCousins.html
https://root.cern/root/html534/TFeldmanCousins.html:882,Integrability,depend,depending,882,". TFeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TFeldmanCousins. class TFeldmanCousins: public TObject. TFeldmanCousins. class to calculate the CL upper limit using; the Feldman-Cousins method as described in PRD V57 #7, p3873-3889. The default confidence interval calvculated using this method is 90%; This is set either by having a default the constructor, or using the; appropriate fraction when instantiating an object of this class (e.g. 0.9). The simple extension to a gaussian resolution function bounded at zero; has not been addressed as yet -> `time is of the essence' as they write; on the wall of the maze in that classic game ... VARIABLES THAT CAN BE ALTERED. => depending on your desired precision: The intial values of fMuMin,; fMuMax, fMuStep and fNMax are those used in the PRD:; fMuMin = 0.0; fMuMax = 50.0; fMuStep= 0.005; but there is total flexibility in changing this should you desire. see example of use in $ROOTSYS/tutorials/math/FeldmanCousins.C. see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Author: Adrian Bevan, Liverpool University. Copyright Liverpool University 2001 bevan@slac.stanford.edu. Function Members (Methods); public:. TFeldmanCousins(const TFeldmanCousins&); TFeldmanCousins(Double_t newCL = 0.9, TString options = """"); virtual~TFeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ne",MatchSource.WIKI,root/html534/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFeldmanCousins.html
https://root.cern/root/html534/TFeldmanCousins.html:658,Usability,simpl,simple,658,". TFeldmanCousins. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TFeldmanCousins. class TFeldmanCousins: public TObject. TFeldmanCousins. class to calculate the CL upper limit using; the Feldman-Cousins method as described in PRD V57 #7, p3873-3889. The default confidence interval calvculated using this method is 90%; This is set either by having a default the constructor, or using the; appropriate fraction when instantiating an object of this class (e.g. 0.9). The simple extension to a gaussian resolution function bounded at zero; has not been addressed as yet -> `time is of the essence' as they write; on the wall of the maze in that classic game ... VARIABLES THAT CAN BE ALTERED. => depending on your desired precision: The intial values of fMuMin,; fMuMax, fMuStep and fNMax are those used in the PRD:; fMuMin = 0.0; fMuMax = 50.0; fMuStep= 0.005; but there is total flexibility in changing this should you desire. see example of use in $ROOTSYS/tutorials/math/FeldmanCousins.C. see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Author: Adrian Bevan, Liverpool University. Copyright Liverpool University 2001 bevan@slac.stanford.edu. Function Members (Methods); public:. TFeldmanCousins(const TFeldmanCousins&); TFeldmanCousins(Double_t newCL = 0.9, TString options = """"); virtual~TFeldmanCousins(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateLowerLimit(Double_t Nobserved, Double_t Nbackground); Double_tCalculateUpperLimit(Double_t Nobserved, Double_t Nbackground); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* ne",MatchSource.WIKI,root/html534/TFeldmanCousins.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFeldmanCousins.html
https://root.cern/root/html534/TFFTComplex.html:2628,Availability,error,error,2628,"; TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:2712,Availability,error,error,2712," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:747,Energy Efficiency,allocate,allocate,747,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:322,Integrability,interface,interface,322,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:428,Integrability,interface,interface,428,". TFFTComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplex. class TFFTComplex: public TVirtualFFT. TFFTComplex; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented.; Computes complex input/output discrete Fourier transforms (DFT); in one or more dimensions. For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointComplex() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags or sign, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTComplex(); TFFTComplex(const TFFTComplex&); TFFTComplex(Int_t n, Bool_t inPlace); TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TOb",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:9825,Integrability,depend,depending,9825,"ex(); default. TFFTComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidim. transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ~TFFTComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t sign, const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 2nd parameter: +1; Argument kind is dummy and doesn't need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output(or input) into the argument array. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; returns real and imaginary parts of the point #ipoint. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns real and imaginary parts of the point #ipoint. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Copies real and imaginary parts of",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplex.html:9551,Performance,perform,performance,9551,"ex(); default. TFFTComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplex(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidim. transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. ~TFFTComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t sign, const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 2nd parameter: +1; Argument kind is dummy and doesn't need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output(or input) into the argument array. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; returns real and imaginary parts of the point #ipoint. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns real and imaginary parts of the point #ipoint. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Copies real and imaginary parts of",MatchSource.WIKI,root/html534/TFFTComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplex.html
https://root.cern/root/html534/TFFTComplexReal.html:596,Availability,redundant,redundant,596,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:2770,Availability,error,error,2770,"); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:2854,Availability,error,error,2854," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:764,Energy Efficiency,allocate,allocate,764,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:338,Integrability,interface,interface,338,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:444,Integrability,interface,interface,444,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:9929,Integrability,depend,depending,9929,"ion; TFFTComplexReal(); default. TFFTComplexReal(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTComplexReal(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument array with the computed transform; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). void GetPointComplex(Int_t",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:9656,Performance,perform,performanc,9656,"ion; TFFTComplexReal(); default. TFFTComplexReal(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTComplexReal(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument array with the computed transform; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint; Works only for output (input array is destroyed in a C2R transform). void GetPointComplex(Int_t",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:596,Safety,redund,redundant,596,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTComplexReal.html:616,Testability,log,logically,616,". TFFTComplexReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTComplexReal. class TFFTComplexReal: public TVirtualFFT. TFFTComplexReal. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes the inverse of the real-to-complex transforms (class TFFTRealComplex); taking complex input (storing the non-redundant half of a logically Hermitian array); to real output (see FFTW manual for more details). How to use it:; 1) Create an instance of TFFTComplexReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings; 3) Set the data (via SetPoints(), SetPoint() or SetPointComplex() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints(), GetPoint() or GetPointReal() functions); 6) Repeat steps 3)-5) as needed. For a transform of the same size, but with different flags, rerun the Init(); function and continue with steps 3)-5); NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. 3) In Complex to Real transform the input array is destroyed. It cannot then; be retrieved when using the Get's methods. Function Members (Methods); public:. TFFTComplexReal(); TFFTComplexReal(const TFFTComplexReal&); TFFTComplexReal(Int_t n, Bool_t inPlace); TFFTComplexReal(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTComplexReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrow",MatchSource.WIKI,root/html534/TFFTComplexReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTComplexReal.html
https://root.cern/root/html534/TFFTReal.html:3154,Availability,error,error,3154,"FALSE); TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); virtual~TFFTReal(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im,",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:3238,Availability,error,error,3238," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(Int_t ipoint, Double_",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:10452,Availability,avail,available,10452,"e sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. Returns point #ipoint. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; For multidim.transforms. Returns point #ipoint. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Only for input of HC2R and output of R2HC. void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Only for input of HC2R and output of R2HC and for 1d. Double_t* GetPointsReal(",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:965,Energy Efficiency,allocate,allocate,965,"a members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->DST-I; DST-II<-->DST-III; DST-IV<-->DST-IV. Function Members (Methods); public:. TFFTReal(); TFFTReal(const TFFTReal&); TFFTReal(Int_t n, Bool_t inPlace = kFALSE); TFFTReal(Int_t ndim, Int_t* n,",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:310,Integrability,interface,interface,310,". TFFTReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:416,Integrability,interface,interface,416,". TFFTReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTReal. class TFFTReal: public TVirtualFFT. TFFTReal; One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes transforms called r2r in FFTW manual:; - transforms of real input and output in ""halfcomplex"" format i.e.; real and imaginary parts for a transform of size n stored as; (r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1); - discrete Hartley transform; - sine and cosine transforms (DCT-I,II,III,IV and DST-I,II,III,IV); For the detailed information on the computed; transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it:; 1) Create an instance of TFFTReal - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but of different kind (or with different flags),; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function!; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled BY:; - transform size (N) for R2HC, HC2R, DHT transforms; - 2*(N-1) for DCT-I (REDFT00); - 2*(N+1) for DST-I (RODFT00); - 2*N for the remaining transforms; Transform inverses:; R2HC<-->HC2R; DHT<-->DHT; DCT-I<-->DCT-I; DCT-II<-->DCT-III; DCT-IV<-->DCT-IV; DST-I<-->",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:10134,Integrability,depend,depending,10134,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTReal.html:9860,Performance,perform,performance,9860,"ault transformer; static TVirtualFFT*TVirtualFFT::fgFFTcurrent transformer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFFTReal(); default. TFFTReal(Int_t n, Bool_t inPlace = kFALSE); For 1d transforms; n here is the physical size of the transform (see FFTW manual for more details). TFFTReal(Int_t ndim, Int_t* n, Bool_t inPlace = kFALSE); For multidimensional transforms; 1st parameter is the # of dimensions,; 2nd is the sizes (physical) of the transform in each dimension. ~TFFTReal(); clean-up. void Init(Option_t* flags, Int_t sign, const Int_t* kind); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. 1st parameter:; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type.; 2nd parameter is dummy and doesn't need to be specified; 3rd parameter- transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DSTIII - kind=6; DSTIV - kind=7. void Transform(); Computes the transform, specified in Init() function. Option_t * GetType() const; Returns the type of the transform. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Copies the output (or input) points into the provided array, that should; be big enough. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; For 1d tranforms. ",MatchSource.WIKI,root/html534/TFFTReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTReal.html
https://root.cern/root/html534/TFFTRealComplex.html:2728,Availability,error,error,2728,"); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:2812,Availability,error,error,2812," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*TVirtualFFT::FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*TVirtualFFT::GetCurrentTransform(); static const char*TVirtualFFT::GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:825,Energy Efficiency,allocate,allocate,825,"omepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; vi",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:338,Integrability,interface,interface,338,". TFFTRealComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:444,Integrability,interface,interface,444,". TFFTRealComplex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FFTW; » TFFTRealComplex. class TFFTRealComplex: public TVirtualFFT. TFFTRealComplex. One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes a real input/complex output discrete Fourier transform in 1 or more; dimensions. However, only out-of-place transforms are now supported for transforms; in more than 1 dimension. For detailed information about the computed transforms,; please refer to the FFTW manual. How to use it:; 1) Create an instance of TFFTRealComplex - this will allocate input and output; arrays (unless an in-place transform is specified); 2) Run the Init() function with the desired flags and settings (see function; comments for possible kind parameters); 3) Set the data (via SetPoints()or SetPoint() functions); 4) Run the Transform() function; 5) Get the output (via GetPoints() or GetPoint() functions); 6) Repeat steps 3)-5) as needed; For a transform of the same size, but with different flags,; rerun the Init() function and continue with steps 3)-5). NOTE: 1) running Init() function will overwrite the input array! Don't set any data; before running the Init() function; 2) FFTW computes unnormalized transform, so doing a transform followed by; its inverse will lead to the original array scaled by the transform size. Function Members (Methods); public:. TFFTRealComplex(); TFFTRealComplex(const TFFTRealComplex&); TFFTRealComplex(Int_t n, Bool_t inPlace); TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); virtual~TFFTRealComplex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:9887,Integrability,depend,depending,9887,"ion; TFFTRealComplex(); default. TFFTRealComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTRealComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the array data with the computed transform.; Only (roughly) a half of the transform is copied (exactly the output of FFTW),; the rest being Hermitian symmetric with the first half. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the ",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:11456,Integrability,interface,interface,11456,"al part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Returns the point #ipoint.; For 1d, if ipoint > fN/2+1 (the point is in the Hermitian symmetric part), it is still; returned. For >1d, only the first (roughly)half of points can be returned; For 2d, see function GetPointComplex(Int_t *ipoint,...). void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint.; In case of transforms of more than 2 dimensions,; only points from the first (roughly)half are returned, the rest being Hermitian symmetric. Double_t* GetPointsReal(Bool_t fromInput = kFALSE) const; Returns the input array// One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void GetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0); Set the point #ipoint. void SetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); For multidimensional transforms. Set the point #ipoint. void SetPoints(const Double_t* data); Set all input points. void SetPointComplex(Int_t ipoint, TComplex& c)",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:11562,Integrability,interface,interface,11562," ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. void GetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; Returns the point #ipoint.; For 1d, if ipoint > fN/2+1 (the point is in the Hermitian symmetric part), it is still; returned. For >1d, only the first (roughly)half of points can be returned; For 2d, see function GetPointComplex(Int_t *ipoint,...). void GetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; For multidimensional transforms. Returns the point #ipoint.; In case of transforms of more than 2 dimensions,; only points from the first (roughly)half are returned, the rest being Hermitian symmetric. Double_t* GetPointsReal(Bool_t fromInput = kFALSE) const; Returns the input array// One of the interface classes to the FFTW package, can be used directly; or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. void GetPointsComplex(Double_t* re, Double_t* im, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void GetPointsComplex(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the argument arrays with the real and imaginary parts of the computed transform.; Only (roughly) a half of the transform is copied, the rest being Hermitian; symmetric with the first half. void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0); Set the point #ipoint. void SetPoint(const Int_t* ipoint, Double_t re, Double_t im = 0); For multidimensional transforms. Set the point #ipoint. void SetPoints(const Double_t* data); Set all input points. void SetPointComplex(Int_t ipoint, TComplex& c); Sets the point #ipoint (only the real part of the argument is taken). void SetPointsComplex(const Double_t* re, cons",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFFTRealComplex.html:9614,Performance,perform,performanc,9614,"ion; TFFTRealComplex(); default. TFFTRealComplex(Int_t n, Bool_t inPlace); For 1d transforms; Allocates memory for the input array, and, if inPlace = kFALSE, for the output array. TFFTRealComplex(Int_t ndim, Int_t* n, Bool_t inPlace); For ndim-dimensional transforms; Second argurment contains sizes of the transform in each dimension. ~TFFTRealComplex(); Destroys the data arrays and the plan. However, some plan information stays around; until the root session is over, and is reused if other plans of the same size are; created. void Init(Option_t* flags, Int_t , const Int_t* ); Creates the fftw-plan. NOTE: input and output arrays are overwritten during initialisation,; so don't set any points, before running this function!!!!!. Arguments sign and kind are dummy and not need to be specified; Possible flag_options:; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performanc; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. void Transform(); Computes the transform, specified in Init() function. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const; Fills the array data with the computed transform.; Only (roughly) a half of the transform is copied (exactly the output of FFTW),; the rest being Hermitian symmetric with the first half. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the input. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const; Returns the real part of the point #ipoint from the output or the point #ipoint; from the ",MatchSource.WIKI,root/html534/TFFTRealComplex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFFTRealComplex.html
https://root.cern/root/html534/TFile.html:4958,Availability,error,error,4958,"t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*GetArchive() const; Long64_tGetArchiveOffset() const; static TFile::EAsyncOpenStatusGetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusGetAsyncOpenStatus(TFileOpenHandle* handle); Int_tGetBestBuffer() const",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:5042,Availability,error,error,5042,"* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle, const size_t namesize = 0); virtual voidDelete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*GetArchive() const; Long64_tGetArchiveOffset() const; static TFile::EAsyncOpenStatusGetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusGetAsyncOpenStatus(TFileOpenHandle* handle); Int_tGetBestBuffer() const; virtual Int_tTDirectoryFile::GetBufferSize() const; virtual Long64_tGetBytesRead()",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27725,Availability,recover,recovery,27725,"CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:30296,Availability,error,error,30296,"cle = """"); Delete object namecycle.; Namecycle identifies an object in the top directory of the file; namecycle has the format name;cycle; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. Examples:; foo : delete object named foo in memory; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on disk and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories. void Draw(Option_t* option = """"); Fill Graphics Structure and Paint.; Loop on all objects (memory or file) and all subdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:34936,Availability,failure,failure,34936,"574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35247,Availability,failure,failure,35247,"At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The funct",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35596,Availability,failure,failure,35596,"50443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new di",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36190,Availability,recover,recover,36190," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36284,Availability,recover,recovered,36284,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36314,Availability,recover,recovered,36314,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36569,Availability,recover,recover,36569,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36715,Availability,recover,recovered,36715," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36965,Availability,recover,recovered,36965," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37068,Availability,recover,recovered,37068,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37140,Availability,recover,recovered,37140," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37300,Availability,recover,recovered,37300,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37500,Availability,recover,recovery,37500,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37952,Availability,failure,failure,37952,"ile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:42067,Availability,failure,failure,42067," 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested insi",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:43693,Availability,error,error,43693,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:46240,Availability,error,error,46240," clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();.",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:46472,Availability,error,error,46472,"ating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the lo",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:47892,Availability,down,downloaded,47892,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:47947,Availability,down,download,47947," may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before o",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48009,Availability,down,downloaded,48009,"e; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; spe",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49393,Availability,error,error,49393,"e plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instanc",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49806,Availability,down,downloaded,49806,"e plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support as",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49861,Availability,down,download,49861,"r expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support asynchronous open functionality. Currently, only TXNetFile; ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49923,Availability,down,downloaded,49923,"; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support asynchronous open functionality. Currently, only TXNetFile; supports it. If the functionality is not implemented, this call ac",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54825,Availability,avail,available,54825," = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EA",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36521,Deployability,update,update,36521,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:43949,Deployability,update,update,43949,"tors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executa",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:46658,Deployability,update,updated,46658,"nly the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is save",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:34989,Integrability,rout,routine,34989,"At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShor",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36657,Integrability,message,message,36657,"ffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from R",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:43699,Integrability,message,message,43699,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48471,Integrability,depend,depends,48471,"id WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFi",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:52229,Integrability,interface,interface,52229," * Open(TFileOpenHandle* handle); Waits for the completion of an asynchronous open request.; Returns the associated TFile, transferring ownership of the; handle to the TFile instance. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open(). Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close(). Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read(). Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54539,Integrability,depend,dependent,54539,"age/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:23977,Modifiability,plugin,plugin,23977,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:24938,Modifiability,plugin,plugins,24938,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:25094,Modifiability,plugin,plugins,25094,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27803,Modifiability,variab,variable,27803,"CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48320,Modifiability,plugin,plugin,48320,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48372,Modifiability,plugin,plugin,48372,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48397,Modifiability,plugin,plugin,48397,"Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is on",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:48821,Modifiability,plugin,plugin,48821,"en a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:13209,Performance,cache,cacheDir,13209,"TObject* obj, const char* keyname); virtual Int_tRecover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:13329,Performance,cache,cache,13329,"ual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t time",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:13441,Performance,cache,cache,13441,"AfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtua",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:19468,Performance,cache,cache,19468,,MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:19523,Performance,cache,cache,19523,,MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:19588,Performance,cache,cache,19588,,MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:21157,Performance,cache,cache,21157," list of the streamer infos in this file; Bool_tfInitDone!True if the file has been initialized; Bool_tfIsArchive!True if this is a pure archive file; Bool_tfIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritab",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:21412,Performance,cache,cache,21412," keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustFlush!True if the file buffers must be flushed; Int_tfNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tfNbytesFreeNumber of bytes for free segments structure; Int_tfNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tfNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tfOffset!Seek offset cache; TList*fOpenPhases!Time info about open phases; TStringfOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:22694,Performance,cache,cache,22694,"GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tfgBytesReadNumber of bytes read by all TFile objects; static Long64_tfgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tfgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:22724,Performance,cache,cached,22724,"GetPath() function; TObjArray*fProcessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tfgBytesReadNumber of bytes read by all TFile objects; static Long64_tfgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tfgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27539,Performance,perform,performed,27539,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:30254,Performance,cache,cache,30254,"hat was a file. void Delete(const char* namecycle = """"); Delete object namecycle.; Namecycle identifies an object in the top directory of the file; namecycle has the format name;cycle; name = * means all; cycle = * means all cycles (memory and keys); cycle = """" or cycle = 9999 ==> apply to a memory object; When name=* use T* to delete subdirectories also. Examples:; foo : delete object named foo in memory; foo;1 : delete cycle 1 of foo on file; foo;* : delete all cycles of foo on disk and also from memory; *;2 : delete all objects on file having the cycle 2; *;* : delete all objects from memory and file; T*;* : delete all objects from memory and file and all subdirectories. void Draw(Option_t* option = """"); Fill Graphics Structure and Paint.; Loop on all objects (memory or file) and all subdirectories. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:31093,Performance,cache,cache,31093,"ies. void DrawMap(const char* keys = ""*"", Option_t* option = """"); Draw map of objects in this file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:31179,Performance,cache,cache,31179," file. void Flush(); Synchronize a file's in-core and on-disk states. Bool_t FlushWriteCache(); Flush the write cache if active.; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this f",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:32007,Performance,cache,cached,32007,"CacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35100,Performance,cache,cache,35100,"At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 20010404/150442 At:382540 N=1849 TProfile CX = 1.65; 20010404/150442 At:384389 N=18434 TNtuple CX = 4.51; 20010404/150442 At:402823 N=307 KeysList; 20010404/150443 At:403130 N=4548 StreamerInfo CX = 3.65; 20010404/150443 At:407678 N=86 FreeSegments; 20010404/150443 At:407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShor",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35669,Performance,cache,cache,35669,":407764 N=1 END. void Paint(Option_t* option = """"); Paint all objects in the file. void Print(Option_t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening t",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35724,Performance,cache,cache,35724,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35750,Performance,cache,cache,35750,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:35792,Performance,cache,cache,35792,"t* option = """") const; Print all objects in the file. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read a buffer from the file at the offset 'pos' in the file.; Returns kTRUE in case of failure.; Compared to ReadBuffer(char*, Int_t), this routine does _not_; change the cursor on the physical file representation (fD); if the data is in this TFile's cache. Bool_t ReadBuffer(char* buf, Int_t len); Read a buffer from the file. This is the basic low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is us",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:39600,Performance,cache,cache,39600,"el. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisc",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:39695,Performance,cache,cache,39695,"el. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisc",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:39751,Performance,cache,cache,39751,"the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() con",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:39815,Performance,cache,cache,39815,"the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() con",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:39848,Performance,cache,cache,39848,"the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() con",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40019,Performance,cache,cache,40019,"gorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of ob",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40099,Performance,cache,cache,40099,"xample,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibilit",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40184,Performance,cache,cache,40184,"xample,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibilit",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40287,Performance,cache,cache,40287,"pression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t o",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40504,Performance,cache,cache,40504,"reated; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40661,Performance,cache,cache,40661,"tion action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40717,Performance,cache,cache,40717,"quish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linke",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40752,Performance,cache,cache,40752,"quish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linke",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:40795,Performance,cache,cache,40795,"ave a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (b",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:41141,Performance,cache,cache,41141,"ile. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:41191,Performance,cache,cache,41191,"ile. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:41237,Performance,cache,caches,41237,"ile. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write v",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:42148,Performance,cache,cache,42148,"d compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qual",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:42168,Performance,cache,cache,42168,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:42210,Performance,cache,cache,42210,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:42252,Performance,cache,cache,42252,"ed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (bytes 1->fBEGIN). Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0) const; One can not save a const TDirectory object. Bool_t WriteBuffer(const char* buf, Int_t len); Write a buffer to the file. This is the basic low level write operation.; Returns kTRUE in case of failure. Int_t WriteBufferViaCache(const char* buf, Int_t len); Write buffer via cache. Returns 0 if cache is not active, 1 in case; write via cache was successful, 2 in case write via cache failed. void WriteFree(); Write FREE linked list on the file.; The linked list of FREE segments (fFree) is written as a single data; record. void WriteHeader(); Write File Header. void MakeProject(const char* dirname, const char* classes = ""*"", Option_t* option = ""new""); Generate code in directory dirname for all classes specified in; argument classes If classes = ""*"" (default and currently the; only supported value), the function generates an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. F",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:45765,Performance,load,load,45765," generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:47127,Performance,load,loaded,47127,"ProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. Int_t MakeProjectParProofInf(const char* packname, const char* proofinfdir); Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'.; Called by MakeProject when option 'par' is given.; Return 0 on success, -1 on error. void ReadStreamerInfo(); Read the list of StreamerInfo from this file.; The key with name holding the list of TStreamerInfo objects is read.; The corresponding TClass objects are updated.; Note that this function is not called if the static member fgReadInfo is falsse.; (see TFile::SetReadStreamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:47868,Performance,cache,cache,47868,"eamerInfo). void SetReadStreamerInfo(Bool_t readinfo = kTRUE); static function to set fgReadInfo.; If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""fi",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:47910,Performance,cache,cache,47910,"le::ReadStreamerInfo is called; when opening the file.; It may be interesting to set fgReadInfo to false to speedup the file; opening time or in case libraries containing classes referenced; by the file have not yet been loaded.; if fgReadInfo is false, one can still read the StreamerInfo with; myfile.ReadStreamerInfo();. void ShowStreamerInfo(); Show the StreamerInfo of all classes written to this file. UShort_t WriteProcessID(TProcessID* pid); Check if the ProcessID pidd is already in the file,; if not, add it and return the index number in the local file list. void WriteStreamerInfo(); Write the list of TStreamerInfo as a single object in this file; The class Streamer description for all classes written to this file; is saved. See class TStreamerInfo. TFile * OpenFromCache(const char* name, Option_t* = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing to open a file for reading through the file; cache. The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by SetCacheFileDir(). TFile * Open(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function allowing the creation/opening of either a; TFile, TNetFile, TWebFile or any TFile derived class for which an; plugin library handler has been registered with the plugin manager; (for the plugin manager see the TPluginManager class). The returned; type of TFile depends on the file name specified by 'url'.; If 'url' is a '|'-separated list of file URLs, the 'URLs' are tried; sequentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be c",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49781,Performance,cache,cache,49781,"rned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, .",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49824,Performance,cache,cache,49824,"e plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, ...) .; To be effective, the underlying TFile implementation must be able to; support as",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:52833,Performance,cache,caches,52833,"buf, Int_t len); Interface to system write. All arguments like in POSIX write(). Long64_t SysSeek(Int_t fd, Long64_t offset, Int_t whence); Interface to system lseek. All arguments like in POSIX lseek(); except that the offset and return value are of a type which are; able to handle 64 bit file systems. Int_t SysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Return file stat information. The interface and return value is; identical to TSystem::GetPathInfo(). The function returns 0 in; case of success and 1 if the file could not be stat'ed. Int_t SysSync(Int_t fd); Interface to system fsync. All arguments like in POSIX fsync(). Long64_t GetBytesWritten() const; Return the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInte",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:53452,Performance,cache,cacheDir,53452,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:53573,Performance,cache,cache,53573,"eturn the total number of bytes written so far to the file. Long64_t GetFileBytesRead(); Static function returning the total number of bytes read from all files. Long64_t GetFileBytesWritten(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:53721,Performance,cache,cache,53721,"n(); Static function returning the total number of bytes written to all files.; Does not take into account what might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUr",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:53837,Performance,cache,cache,53837,"hat might still be in the write caches. Int_t GetFileReadCalls(); Static function returning the total number of read calls from all files. Int_t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54009,Performance,cache,cache,54009,"t GetReadaheadSize(); Static function returning the readahead buffer size. void SetReadaheadSize(Int_t bufsize = 256000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(c",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:55479,Performance,load,loading,55479,"UE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:55515,Performance,cache,cache,55515,"UE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:55625,Performance,cache,cache,55625,"ng on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy file from src to dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Read specified byte range asynchronously. Actually we tell the kernel; which blocks we are going to read so it can start loading these blocks; in the buffer cache. Int_t GetBytesToPrefetch() const; Max number of bytes to prefetch. By default this is 75% of the; read cache size. But specific TFile implementations may need to change it. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. EAsyncOpenStatus GetAsyncOpenStatus(); { return fAsyncOpenStatus; }. Long64_t DirCreateEntry(TDirectory* ); Interface for text-based TDirectory I/O. { return 0; }. Int_t DirReadKeys(TDirectory* ); { return 0; }. void DirWriteKeys(TDirectory* ); {}. void DirWriteHeader(TDirectory* ); {}. void operator=(const TFile& ). void Copy(TObject& ) const; { MayNotUse(""Copy(TObject &)""); }. TArchiveFile * GetArchive() const; { return fArchive; }. Long64_t GetArchiveOffset() const; { return fArchiveOffset; }. TArrayC * GetClassIndex() const; { return fClassIndex; }. Long64_t GetEND() const; { return fEND; }. Int_t GetFd() const; { return fD; }. const TUrl * GetEndpointUrl() const; { return &fUrl; }. TObjArray * GetListOfProcessIDs() const; {return fProcessIDs;}. TList * GetListOfFree() const; { return fFree",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:14328,Safety,timeout,timeout,14328,"he, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionAlgorithm(Int_t algorithm = 0); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidShowStreamerInfo(); static Bool_tShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSumBuffer(Int_t bufsize); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUseCache(Int_t m",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27270,Safety,detect,detect,27270," will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs ref",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27504,Safety,detect,detected,27504,"press is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27725,Safety,recover,recovery,27725,"CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. TKey* CreateKey(TDirectory* mother, const TObject",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36190,Safety,recover,recover,36190," low level read operation.; Returns kTRUE in case of failure. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is impor",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36284,Safety,recover,recovered,36284,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36314,Safety,recover,recovered,36314,"f blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36569,Safety,recover,recover,36569,"tc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootr",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36715,Safety,recover,recovered,36715," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36757,Safety,safe,safely,36757," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36965,Safety,recover,recovered,36965," single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which ca",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37068,Safety,recover,recovered,37068,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37140,Safety,recover,recovered,37140," gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set posi",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37300,Safety,recover,recovered,37300,"covered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetComp",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37500,Safety,recover,recovery,37500,"fied.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49527,Safety,timeout,timeout,49527,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:49573,Safety,timeout,timeout,49573,"equentially in the specified order until a successful open.; If the file starts with ""root:"", ""roots:"" or ""rootk:"" a TNetFile object; will be returned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may b",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54055,Safety,timeout,timeout,54055,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Re",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54075,Safety,timeout,timeout,54075,"000); { fgReadaheadSize = bytes; }. void SetFileBytesRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Re",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54114,Safety,timeout,timeout,54114,"sRead(Long64_t bytes = 0); { fgBytesRead = bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:54167,Safety,timeout,timeout,54167,"bytes; }. void SetFileBytesWritten(Long64_t bytes = 0); { fgBytesWrite = bytes; }. void SetFileReadCalls(Int_t readcalls = 0); { fgReadCalls = readcalls; }. Long64_t GetFileCounter(); { return fgFileCounter; }. void IncrementFileCounter(); { fgFileCounter++; }. Bool_t SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); Sets the directory where to locally stage/cache remote files.; If the directory is not writable by us return kFALSE. const char * GetCacheFileDir(); Get the directory where to locally stage/cache remote files. Bool_t ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); We try to shrink the cache to the desired size.; With the clenupinterval you can specify the minimum amount of time after; the previous cleanup before the cleanup operation is repeated in; the cache directory. UInt_t SetOpenTimeout(UInt_t timeout); Sets open timeout time (in ms). Returns previous timeout value. UInt_t GetOpenTimeout(); Returns open timeout (in ms). Bool_t SetOnlyStaged(Bool_t onlystaged); Sets only staged flag. Returns previous value of flag.; When true we check before opening the file if it is staged, if not,; the open fails. Bool_t GetOnlyStaged(); Returns staged only flag. Bool_t Matches(const char* name); Return kTRUE if 'url' matches the coordinates of this file.; The check is implementation dependent and may need to be overload; by each TFile implememtation relying on this check.; The default implementation checks the file name only. const TUrl * GetEndpointUrl(const char* name); Get final URL for file being opened asynchronously.; Returns 0 is the information is not yet available. void CpProgress(Long64_t bytesread, Long64_t size, TStopwatch& watch); Print file copy progress. Bool_t Cp(const char* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); Allows to copy this file to the dst URL. Returns kTRUE in case of success,; kFALSE otherwise. Bool_t Cp(const char* src, const char* dst, ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:23970,Security,access,access,23970,"s opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tfgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFile(); File default Constructor. TFile(const char* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:24358,Security,access,access,24358,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:24437,Security,access,access,24437,"har* fname, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Opens or creates a local ROOT file whose name is fname1. It is; recommended to specify fname1 as ""<file>.root"". The suffix "".root""; will be used by object browsers to automatically identify the file as; a ROOT file. If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that; will take care of opening the files using the correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:24931,Security,access,access,24931,"he correct remote file; access plugin. If option = NEW or CREATE create a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:25087,Security,access,access,25087,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:25114,Security,access,access,25114,"not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading (default).; = NET used by derived remote file access; classes, not a user callable option; = WEB used by derived remote http access; class, not a user callable option; If option = """" (default), READ is assumed. The file can be specified as a URL of the form:; file:///user/rdm/bla.root or file:/user/rdm/bla.root. The file can also be a member of an archive, in which case it is; specified as:; multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip; archive or member 1 from the archive. For more on archive file; support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any; file, i.e. also non ROOT files, using:; file.tar?filetype=raw; This is convenient because the many remote file access plugins allow; easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and; directories. There are no restrictions for the number of levels; of directories. A ROOT file is designed such that one can write in the file in pure; sequential mode (case of BATCH jobs). In this case, the file may be; read sequentially again without using the file index written; at the end of the file. In case of a job crash, all the information; on the file is therefore protected. A ROOT file can be used interactively. In this case, one has the; possibility to delete existing objects and add new ones.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAP",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:32278,Security,access,access,32278,"len); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37636,Security,access,access,37636," gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this file. void SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:27610,Testability,log,logical,27610,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of compress. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile.Recover: 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of th",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:31306,Testability,log,logical,31306,"; Return kTRUE in case of error. void FillBuffer(char*& buffer); Encode file output buffer.; The file output buffer contains only the FREE data record. Int_t GetBestBuffer() const; Return the best buffer size of objects on this file.; The best buffer size is estimated based on the current mean value; and standard deviation of all objects written so far to this file.; Returns mean value + one standard deviation. Float_t GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:31747,Testability,log,logical,31747," GetCompressionFactor(); Return the file compression factor.; Add total number of compressed/uncompressed bytes for each key.; return ratio of the two. Int_t GetErrno() const; Method returning errno. Is overriden in TRFIOFile. void ResetErrno() const; Method resetting the errno. Is overridden in TRFIOFile. TFileCacheRead * GetCacheRead(TObject* tree = 0) const; Return a pointer to the current read cache. TFileCacheWrite * GetCacheWrite() const; Return a pointer to the current write cache. Int_t GetRecordHeader(char* buf, Long64_t first, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header starting at position first.; Maxbytes bytes are read into buf the function reads nread bytes; where nread is the minimum of maxbytes and the number of bytes; before the end of file. The function returns nread.; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16. Long64_t GetSize() const; Returns the current file size. Returns -1 in case the file could not; be stat'ed. const TList * GetStreamerInfoCache(); Returns the cached list of StreamerInfos used in this file. TList * GetStreamerInfoList(); Read the list of TStreamerInfo objects written to this file.; The function returns a TList. It is the user'responsability; to delete the list created by this function. Using the list, one can access additional information,eg:; TFile f(""myfile.root"");; TList *list = f.GetStreamerInfoList();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:33323,Testability,log,logical,33323,"st();; TStreamerInfo *info = (TStreamerInfo*)list->FindObject(""MyClass"");; Int_t classversionid = info->GetClassVersion();; delete list;. void ls(Option_t* option = """") const; List File contents.; Indentation is used to identify the file tree.; Subdirectories are listed first, then objects in memory,; then objects on the file. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void MakeFree(Long64_t first, Long64_t last); Mark unused bytes on the file.; The list of free segments is in the fFree linked list.; When an object is deleted from the file, the freed space is added; into the FREE linked list (fFree). The FREE list consists of a chain; of consecutive free segments on the file. At the same time, the first; 4 bytes of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). void Map(); List the contents of a file sequentially.; For each logical record found, it prints:; Date/Time Record_Adress Logical_Record_Length ClassName CompressionFactor. Example of output; 20010404/150437 At:64 N=150 TFile; 20010404/150440 At:214 N=28326 TBasket CX = 1.13; 20010404/150440 At:28540 N=29616 TBasket CX = 1.08; 20010404/150440 At:58156 N=29640 TBasket CX = 1.08; 20010404/150440 At:87796 N=29076 TBasket CX = 1.10; 20010404/150440 At:116872 N=10151 TBasket CX = 3.15; 20010404/150441 At:127023 N=28341 TBasket CX = 1.13; 20010404/150441 At:155364 N=29594 TBasket CX = 1.08; 20010404/150441 At:184958 N=29616 TBasket CX = 1.08; 20010404/150441 At:214574 N=29075 TBasket CX = 1.10; 20010404/150441 At:243649 N=9583 TBasket CX = 3.34; 20010404/150442 At:253232 N=28324 TBasket CX = 1.13; 20010404/150442 At:281556 N=29641 TBasket CX = 1.08; 20010404/150442 At:311197 N=29633 TBasket CX = 1.08; 20010404/150442 At:340830 N=29091 TBasket CX = 1.10; 20010404/150442 At:369921 N=10341 TBasket CX = 3.09; 20010404/150442 At:380262 N=509 TH1F CX = 1.93; 20010404/150442 At:380771 N=1769 TH2F CX = 4.32; 2",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36844,Testability,test,test,36844,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:37042,Testability,test,test,37042,"r pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. The current directory (gFile) is changed to this fil",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36738,Usability,usab,usable,36738," via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument ",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:36817,Usability,usab,usable,36817,"st.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::AutoSave). If a file containing a Tree; is recovered, the last Tree header written to the file will be used.; In this case all the entries in all the branches written before writing; the header are valid entries. One can disable the automatic recovery procedure by setting; TFile.Recover 0; in the system.rootrc file. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFile.html:45229,Usability,clear,clear,45229,"ootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linked with the current executable module.; If the option ""+"" and ""nocompile"" are specified, the utility files are generated; as in the option ""+"" but they are not executed.; Example:; file.MakeProject(""demo"",""*"",""recreate++"");; - creates a new directory demo unless it already exist; - clear the previous directory content; - generate the xxx.h files for all classes xxx found in this file; and not yet known to the CINT dictionary.; - creates the build script MAKEP; - creates a LinkDef.h file; - runs rootcint generating demoProjectDict.cxx; - compiles demoProjectDict.cxx into demoProjectDict.o; - generates a shared lib demo.so; - dynamically links the shared lib demo.so to the executable; If only the option ""+"" had been specified, one can still link the; shared lib to the current executable module with:; gSystem->load(""demo/demo.so"");. The following feature is not yet enabled:; One can restrict the list of classes to be generated by using expressions like:; classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only. Int_t MakeProjectParMake(const char* packname, const char* filename); Create makefile at 'filemake' for PAR package 'pack'.; Called by MakeProject when option 'par' is give",MatchSource.WIKI,root/html534/TFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFile.html
https://root.cern/root/html534/TFileCacheRead.html:2152,Availability,error,error,2152,"SE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNoCacheBytesRead() const; virtual Int_tGetNoCacheReadCalls() const; Int_tGetNseek() const; Int_tGetNtot() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtu",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:2236,Availability,error,error,2236,"Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNoCacheBytesRead() const; virtual Int_tGetNoCacheReadCalls() const; Int_tGetNseek() const; Int_tGetNtot() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual Int_tGetReadCalls() const; virtual const ",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10517,Availability,error,error,10517,"s; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetc",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:11743,Modifiability,variab,variable,11743,", Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetch(). void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); Set the prefetching mode of this file.; if 'setPrefetching', enable the asynchronous prefetching; (using TFilePrefetch) and if the gEnv and rootrc; variable Cache.Directory is set, also enable the local; caching of the prefetched blocks.; if 'setPrefetching', the old prefetcher is enabled is; the gEnv and rootrc variable is TFile.AsyncReading. void SetEnablePrefetchingImpl(Bool_t setPrefetching = kFALSE); TFileCacheRead implementation of SetEnablePrefetching. This function is called from the constructor and should not be virtual. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. void AddNoCacheBytesRead(Long64_t len); { fNoCacheBytesRead += len; }. void AddNoCacheReadCalls(Int_t reads); { fNoCacheReadCalls += reads; }. Int_t GetBufferSize() const; { return fBufferSize; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetNoCacheBytesRead() const; { return fNoCacheBytesRead; }. Long64_t GetBytesReadExtra() const; { return fBytesRea",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:11909,Modifiability,variab,variable,11909,"; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetch(). void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); Set the prefetching mode of this file.; if 'setPrefetching', enable the asynchronous prefetching; (using TFilePrefetch) and if the gEnv and rootrc; variable Cache.Directory is set, also enable the local; caching of the prefetched blocks.; if 'setPrefetching', the old prefetcher is enabled is; the gEnv and rootrc variable is TFile.AsyncReading. void SetEnablePrefetchingImpl(Bool_t setPrefetching = kFALSE); TFileCacheRead implementation of SetEnablePrefetching. This function is called from the constructor and should not be virtual. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. void AddNoCacheBytesRead(Long64_t len); { fNoCacheBytesRead += len; }. void AddNoCacheReadCalls(Int_t reads); { fNoCacheReadCalls += reads; }. Int_t GetBufferSize() const; { return fBufferSize; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetNoCacheBytesRead() const; { return fNoCacheBytesRead; }. Long64_t GetBytesReadExtra() const; { return fBytesReadExtra; }. TFile * GetFile() const; { return fFile; }. Int_t GetNseek() const; { return fNseek; }. Int_t GetNtot() const; { return fNtot; }. Int_t GetReadCalls() const; { return fReadC",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:318,Performance,cache,cache,318,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:476,Performance,cache,cache,476,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:508,Performance,cache,cache,508,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:639,Performance,cache,cache,639,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:7798,Performance,cache,cache,7798,&); TFileCacheRead&operator=(const TFileCacheRead&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAsyncReading; Bool_tfBIsSorted; Bool_tfBIsTransferred; Int_t*fBLen; Int_tfBNb; Int_tfBNseek; Int_tfBNtot; Long64_t*fBPos; Long64_t*fBSeek; Int_t*fBSeekIndex; Int_t*fBSeekLen; Int_t*fBSeekPos; Int_tfBSeekSize; Long64_t*fBSeekSort; Int_t*fBSeekSortLen; char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferLenCurrent buffer length (<= fBufferSize); Int_tfBufferSizeAllocated size of fBuffer (at a given time); Int_tfBufferSizeMinOriginal size of fBuffer; Long64_tfBytesReadNumber of bytes read for this cache; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long,MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:8229,Performance,cache,cached,8229,&); TFileCacheRead&operator=(const TFileCacheRead&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAsyncReading; Bool_tfBIsSorted; Bool_tfBIsTransferred; Int_t*fBLen; Int_tfBNb; Int_tfBNseek; Int_tfBNtot; Long64_t*fBPos; Long64_t*fBSeek; Int_t*fBSeekIndex; Int_t*fBSeekLen; Int_t*fBSeekPos; Int_tfBSeekSize; Long64_t*fBSeekSort; Int_t*fBSeekSortLen; char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferLenCurrent buffer length (<= fBufferSize); Int_tfBufferSizeAllocated size of fBuffer (at a given time); Int_tfBufferSizeMinOriginal size of fBuffer; Long64_tfBytesReadNumber of bytes read for this cache; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long,MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:8303,Performance,cache,cached,8303,&); TFileCacheRead&operator=(const TFileCacheRead&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAsyncReading; Bool_tfBIsSorted; Bool_tfBIsTransferred; Int_t*fBLen; Int_tfBNb; Int_tfBNseek; Int_tfBNtot; Long64_t*fBPos; Long64_t*fBSeek; Int_t*fBSeekIndex; Int_t*fBSeekLen; Int_t*fBSeekPos; Int_tfBSeekSize; Long64_t*fBSeekSort; Int_t*fBSeekSortLen; char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferLenCurrent buffer length (<= fBufferSize); Int_tfBufferSizeAllocated size of fBuffer (at a given time); Int_tfBufferSizeMinOriginal size of fBuffer; Long64_tfBytesReadNumber of bytes read for this cache; Long64_tfBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long,MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:8632,Performance,cache,cache,8632,"umber of extra bytes (overhead) read by the readahead buffer; Bool_tfEnablePrefetchingreading by prefetching asynchronously ; TFile*fFilePointer to file; Bool_tfIsSortedTrue if fSeek array is sorted; Bool_tfIsTransferredTrue when fBuffer contains something valid; Int_t*fLen[fNb] Length of long buffers; Int_tfNbNumber of long buffers; Long64_tfNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tfNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tfNseekNumber of blocks to be prefetched; Int_tfNtotTotal size of prefetched blocks; Long64_t*fPos[fNb] start of long buffers; TFilePrefetch*fPrefetch!Object that does the asynchronous reading in another thread; Long64_tfPrefetchedBlocksNumber of blocks prefetched.; Int_tfReadCallsNumber of read calls for this cache; Long64_t*fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*fSeekIndex[fNseek] sorted index table of fSeek; Int_t*fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache ",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:9824,Performance,cache,cache,9824,"os[fNseek] Position of sorted blocks in fBuffer; Int_tfSeekSizeAllocated size of fSeek; Long64_t*fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base functi",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10135,Performance,cache,cache,10135,"ers; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blo",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10212,Performance,cache,cache,10212,", Int_t buffersize, TObject* tree = 0); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Close(Option_t* option = """"); Close out any threads or asynchronous fetches used by the underlying; implementation.; This is called by TFile::Close to prevent usage of the file handles; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive bloc",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10541,Performance,cache,cache,10541,"s; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetc",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10568,Performance,cache,cache,10568,"s; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetc",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:11086,Performance,cache,cache,11086,"transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetch(). void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); Set the prefetching mode of this file.; if 'setPrefetching', enable the asynchronous prefetching; (using TFilePrefetch) and if the gEnv and rootrc; variable Cache.Directory is set, also enable the local; caching of the prefetched blocks.; if 'setPrefetching', the old prefetcher is enabled is; the gEnv and rootrc variable is TFile.AsyncReading. void SetEnablePrefetchingImpl(Bool_t setPrefetching = kFALSE); TFileCacheRead implementation of SetEnablePrefetching.",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:592,Safety,avoid,avoiding,592,". TFileCacheRead. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheRead. class TFileCacheRead: public TObject. TFileCacheRead : a cache when reading files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the read cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::ReadBuffers()). When processing TTree, TChain, a specialized class TTreeCache that; derives from this class is automatically created. Function Members (Methods); public:. TFileCacheRead(); TFileCacheRead(TFile* file, Int_t buffersize, TObject* tree = 0); virtual~TFileCacheRead(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidAddNoCacheBytesRead(Long64_t len); virtual voidAddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ;",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheRead.html:10948,Safety,avoid,avoid,10948,"tes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetch(). void SetEnablePrefetching(Bool_t setPrefetching = kFALSE); Set the prefetching mode of this file.; if 'setPrefetching', enable the asynchronous prefetching; (using TFilePrefetch) and if the gEnv and rootrc; variable Cache.Directory is set, also enable the local; caching of the prefetched blocks.; if 'setPrefetching', the old prefetcher is enabled is; the gEnv and rootrc variable is TFile.AsyncReading. void SetEn",MatchSource.WIKI,root/html534/TFileCacheRead.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html
https://root.cern/root/html534/TFileCacheWrite.html:1883,Availability,error,error,1883,"eWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:1967,Availability,error,error,1967," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tFlush(); virtual Int_tGetBytesInCache() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObje",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6700,Availability,error,error,6700,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 20",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:7298,Availability,error,error,7298,"; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:322,Performance,cache,cache,322,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:480,Performance,cache,cache,480,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:512,Performance,cache,cache,512,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:644,Performance,cache,cache,644,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:753,Performance,cache,cache,753,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6097,Performance,cache,cached,6097,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6206,Performance,cache,cache,6206,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6445,Performance,cache,cache,6445,"evel, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCach",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6495,Performance,cache,cache,6495,"t::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const;",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6853,Performance,cache,cache,6853,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6911,Performance,cache,cache,6911,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT ",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6958,Performance,cache,cache,6958,"; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:7356,Performance,cache,cache,7356,"; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in the write buffer.; The function returns 1 if the buffer has been successfully entered into the write buffer.; The function returns 0 in case WriteBuffer() was recusively called via Flush().; The function returns -1 in case of error. void SetFile(TFile* file); Set the file using this cache.; Any write not yet flushed will be lost. TFileCacheWrite(const TFileCacheWrite& ). TFileCacheWrite& operator=(const TFileCacheWrite& ). Int_t GetBytesInCache() const; { return fNtot; }. » Author: Rene Brun 19/05/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:596,Safety,avoid,avoiding,596,". TFileCacheWrite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileCacheWrite. class TFileCacheWrite: public TObject. TFileCacheWrite : a cache when writing files over the network. A caching system to speed up network I/O, i.e. when there is; no operating system caching support (like the buffer cache for; local disk I/O). The cache makes sure that every I/O is done with; a (large) fixed length buffer thereby avoiding many small I/O's.; Currently the write cache system is used by the classes TNetFile,; TXNetFile and TWebFile (via TFile::WriteBuffers()). The write cache is automatically created when writing a remote file; (created in TFile::Open()). Function Members (Methods); public:. TFileCacheWrite(); TFileCacheWrite(TFile* file, Int_t buffersize); virtual~TFileCacheWrite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::E",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCacheWrite.html:6136,Safety,avoid,avoid,6136,"tStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWriteBuffer(const char* buf, Long64_t pos, Int_t len). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileCacheWrite(const TFileCacheWrite&); TFileCacheWrite&operator=(const TFileCacheWrite&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tfBufferSizeAllocated size of fBuffer; TFile*fFilePointer to file; Int_tfNtotTotal size of cached blocks; Bool_tfRecursiveflag to avoid recursive calls; Long64_tfSeekStartSeek value of first block in cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheWrite(); Default Constructor. TFileCacheWrite(TFile* file, Int_t buffersize); Creates a TFileCacheWrite data structure.; The write cache will be connected to file.; The size of the cache will be buffersize,; if buffersize < 10000 a default size of 512 Kbytes is used. ~TFileCacheWrite(); Destructor. Bool_t Flush(); Flush the current write buffer to the file.; Returns kTRUE in case of error. void Print(Option_t* option = """") const; Print class internal structure. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Called by the read cache to check if the requested data is not; in the write cache buffer.; Returns -1 if data not in write cache,; 0 otherwise. Int_t WriteBuffer(const char* buf, Long64_t pos, Int_t len); Write buffer at position pos in th",MatchSource.WIKI,root/html534/TFileCacheWrite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCacheWrite.html
https://root.cern/root/html534/TFileCollection.html:1847,Availability,error,error,1847,"Int_tAdd(const char* path); Int_tAddFromFile(const char* file, Int_t nfiles = -1, Int_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGe",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileCollection.html:1931,Availability,error,error,1931,"t_t firstfile = 1); Bool_tAddMetaData(TObject* meta); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TObjString*ExportInfo(const char* name = 0, Int_t popt = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCorruptedPercentage() const; const char*GetDefaultTreeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFilesOnServer(const char* server); TMap*GetFilesPerServer(const char* exclude = 0, Bool_t curronly = kFALSE); virtual const char*TObject::GetIconName() const; THashList*GetList(); TFileInfoMeta*GetMetaData(const char* meta = 0) const; virtual const char*TNamed::GetName() const; Long64_tGetNCorruptFiles() const; Long64_tGetNFiles() const; Long64_tGetNStagedFiles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileCollection.html:9210,Availability,error,error,9210,"he specified text file.; The file should contain one url per line; empty lines or lines starting with '#'; (commented lines) are ignored.; If nfiles > 0 only nfiles files are added, starting from file 'firstfile' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines); ""filter:[SsCc]"" invokes PrintDetailed() which prints out dataset; content in a formatted fashion by filtering on files; which ",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileCollection.html:9431,Availability,avail,available,9431,"ile' (>= 1).; The method returns the number of added files. Int_t Add(const char* path); Add all files matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines); ""filter:[SsCc]"" invokes PrintDetailed() which prints out dataset; content in a formatted fashion by filtering on files; which are (S)taged or not (s), (C)orrupted or not (c). void PrintDetailed(TString& showOnly) const. void FormatSize(Long64_t bytes, TString& um, Double_t& size) const. void SetAnchor(const char* anchor); Calls TUrl",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileCollection.html:9564,Availability,failure,failure,9564,"uses all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines); ""filter:[SsCc]"" invokes PrintDetailed() which prints out dataset; content in a formatted fashion by filtering on files; which are (S)taged or not (s), (C)orrupted or not (c). void PrintDetailed(TString& showOnly) const. void FormatSize(Long64_t bytes, TString& um, Double_t& size) const. void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for all TFileInfos. void ResetBitAll(UInt_t f); Reset the bit for all TFileInfos. const char * GetDefaultTreeName() con",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileCollection.html:9448,Deployability,update,updates,9448,"iles matching the specified pattern to the collection.; 'dir' can include wildcards after the last slash, which causes all; matching files in that directory to be added.; If dir is the full path of a file, only one element is added.; Return value is the number of added files. Int_t RemoveDuplicates(); Remove duplicates based on the UUID, typically after a verification.; Return the number of entries removed. TFileCollection * GetStagedSubset(); Creates a subset of the files that have the kStaged & !kCorrupted bit set. Long64_t Merge(TCollection* list); Merge all TFileCollection objects in li into this TFileCollection object.; Updates counters at the end.; Returns the number of merged collections or -1 in case of error. Int_t Update(Long64_t avgsize = -1); Update accumulated information about the elements of the collection; (e.g. fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize'; bytes when the size info is not available.; Also updates the meta data information by summarizing; the meta data of the contained objects.; Return -1 in case of any failure, 0 if the total size is exact, 1 if; incomplete, 2 if complete but (at least partially) estimated. void Print(Option_t* option = """") const; Prints the contents of the TFileCollection.; If option contains:; 'M' print global meta information; 'F' print all the files in the collection in compact form; (current url, default tree name|class|entries, md5); 'L' together with 'F', print all the files in the collection; in long form (uuid, md5, all URLs, all meta objects; on; many lines); ""filter:[SsCc]"" invokes PrintDetailed() which prints out dataset; content in a formatted fashion by filtering on files; which are (S)taged or not (s), (C)orrupted or not (c). void PrintDetailed(TString& showOnly) const. void FormatSize(Long64_t bytes, TString& um, Double_t& size) const. void SetAnchor(const char* anchor); Calls TUrl::SetAnchor() for all URLs contained in all TFileInfos. void SetBitAll(UInt_t f); Set the bit for ",MatchSource.WIKI,root/html534/TFileCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileCollection.html
https://root.cern/root/html534/TFileDrawMap.html:3623,Availability,error,error,3623,"(const char* method) const; virtual voidAnimateTree(const char* branches = """")MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileDrawMap.html
https://root.cern/root/html534/TFileDrawMap.html:3707,Availability,error,error,3707," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawObject()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidDumpObject()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) ",MatchSource.WIKI,root/html534/TFileDrawMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileDrawMap.html
https://root.cern/root/html534/TFileHandler.html:430,Availability,mask,mask,430," TFileHandler(int fd, int mask); virtual~TFileHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal =",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:3749,Availability,error,error,3749,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObje",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:3833,Availability,error,error,3833,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); intGetFd() const; virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() con",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:7405,Availability,mask,mask,7405,"voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Bool_tReadNotify(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(); virtual voidTSysEvtHandler::Removed()SIGNAL ; voidTObject::ResetBit(UInt_t f); virtual voidResetReadyMask(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFd(int fd); virtual voidSetInterest(Int_t mask); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadReady(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetWriteReady(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Bool_tWriteNotify().",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9352,Availability,mask,mask,9352,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9432,Availability,mask,mask,9432,"ender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9760,Availability,mask,mask,9760,"der(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum { kRead; kWrite; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void Set",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9810,Availability,mask,mask,9810,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9878,Availability,mask,mask,9878,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9940,Availability,mask,mask,9940,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:10476,Availability,mask,mask,10476," 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:10496,Availability,mask,mask,10496," 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:10505,Availability,mask,mask,10505," 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fReadyMask |= 0x2; }. Bool_t IsReadReady() const; { return (fReadyMask & 0x1) == 0x1; }. Bool_t IsWriteReady() const; { return (fReadyMask & 0x2) == 0x2; }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9838,Energy Efficiency,monitor,monitor,9838,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9899,Energy Efficiency,monitor,monitor,9899,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileHandler.html:9967,Energy Efficiency,monitor,monitor,9967,"bject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. intfFileNumFile descriptor; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; intfMaskEvent interest mask, either bit 1 (read), 2 (write) or both can be set; intfReadyMaskReadiness mask, either bit 1 (read), 2 (write) or both can be set; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileHandler(int fd, int mask); Create a file descriptor event handler. If mask=kRead then we; want to monitor the file for read readiness, if mask=kWrite; then we monitor the file for write readiness, if mask=kRead|kWrite; then we monitor both read and write readiness. Bool_t Notify(); Notify when event occured on descriptor associated with this handler. Bool_t ReadNotify(); Notify when something can be read from the descriptor associated with; this handler. Bool_t WriteNotify(); Notify when something can be written to the descriptor associated with; this handler. Bool_t HasReadInterest(); True if handler is interested in read events. Bool_t HasWriteInterest(); True if handler is interested in write events. void SetInterest(Int_t mask); Set interest mask to 'mask'. void Add(); Add file event handler to system file handler list. void Remove(); Remove file event handler from system file handler list. TFileHandler(); { }. virtual ~TFileHandler(); { Remove(); }. int GetFd() const; { return fFileNum; }. void SetFd(int fd); { fFileNum = fd; }. void ResetReadyMask(); { fReadyMask = 0; }. void SetReadReady(); { fReadyMask |= 0x1; }. void SetWriteReady(); { fRe",MatchSource.WIKI,root/html534/TFileHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileHandler.html
https://root.cern/root/html534/TFileInfo.html:1555,Availability,error,error,1555," voidTObject::AbstractMethod(const char* method) const; Bool_tAddMetaData(TObject* meta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; L",MatchSource.WIKI,root/html534/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfo.html
https://root.cern/root/html534/TFileInfo.html:1639,Availability,error,error,1639,"eta); Bool_tAddUrl(const char* url, Bool_t infront = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TUrl*FindByUrl(const char* url, Bool_t withDeflt = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TUrl*GetCurrentUrl() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TUrl*GetFirstUrl() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex() const; TMD5*GetMD5() const; TFileInfoMeta*GetMetaData(const char* meta = 0) const; TList*GetMetaDataList() const; virtual const char*TNamed::GetName() const; Int_tGetNUrls() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tT",MatchSource.WIKI,root/html534/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfo.html
https://root.cern/root/html534/TFileInfo.html:9248,Availability,error,error,9248,"e one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrlAt(Int_t i); Remove URL at given position. Returns kTRUE on success, kFALSE on error. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the list; Return kFALSE if not in the list. Bool_t SetCurrentUrl(TUrl* url); Set 'url' as current URL, if in the list; Return kFALSE if not in the list. Bool_t AddMetaData(TObject* meta); Add's a meta data object to the file info object. The object will be; adopted by the TFileInfo and should not be deleted by the user.; Typically objects of class TFileInfoMeta or derivatives should be added,; but any class is accepted.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveMetaData(const char* meta = 0); Remove the metadata obeject. If meta is 0 remove all meta data objects.; Returns kTRUE if successful, kFALSE otherwise. TFileInfoMeta * GetMetaData(const char* meta = 0) const; Get meta data object with specified name. If meta is 0; get first meta data object. Returns 0 in case no; suitable meta data object is found. Int_t Compare(const TObject* obj) const; Compare TFileInfo object by th",MatchSource.WIKI,root/html534/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfo.html
https://root.cern/root/html534/TFileInfo.html:6431,Security,access,access,6431,"fmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileInfo&operator=(const TFileInfo&); voidParseInput(const char* in). Data Members; public:. enum EStatusBits { kStaged; kCorrupted; kSortWithIndex; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; Int_tfIndexIndex to be used when sorting with index; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'fir",MatchSource.WIKI,root/html534/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfo.html
https://root.cern/root/html534/TFileInfo.html:8368,Security,hash,hashed,8368,"n ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the entry range. obj:<name>,<class>,<entries>; meta-information about a generic object in the file;; the should be in the form <subdir>/obj-name; 'class'; is the object class; 'entries' is the number of occurences; for this object. idx:<index> Index of this file if sorting with index. Multiple occurences of 'tree:' or 'obj:' can be specified.; The initializations done via the input string are superseeded by the ones by other; parameters in the constructor, if any.; If no key is given, the token is interpreted as URL(s). void SetUUID(const char* uuid); Set the UUID to the value associated to the string 'uuid'. This is; useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists; of these objects hashed on the name. Those lists need to be rebuild.; TFileCollection does that in RemoveDuplicates. TUrl * GetCurrentUrl() const; Return the current url. TUrl * NextUrl(); Iterator function, start iteration by calling ResetUrl().; The first call to NextUrl() will return the 1st element,; the seconde the 2nd element etc. Returns 0 in case no more urls. TUrl * FindByUrl(const char* url, Bool_t withDeflt = kFALSE); Find an element from a URL. Returns 0 if not found. Bool_t AddUrl(const char* url, Bool_t infront = kFALSE); Add a new URL. If 'infront' is TRUE the new url is pushed at the beginning; of the list; otherwise is pushed back.; Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrl(const char* url); Remove an URL. Returns kTRUE if successful, kFALSE otherwise. Bool_t RemoveUrlAt(Int_t i); Remove URL at given position. Returns kTRUE on success, kFALSE on error. Bool_t SetCurrentUrl(const char* url); Set 'url' as current URL, if in the l",MatchSource.WIKI,root/html534/TFileInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfo.html
https://root.cern/root/html534/TFileInfoMeta.html:1770,Availability,error,error,1770,"st = -1, Long64_t totbytes = -1, Long64_t zipbytes = -1); virtual~TFileInfoMeta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html534/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfoMeta.html
https://root.cern/root/html534/TFileInfoMeta.html:1854,Availability,error,error,1854,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClass() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TNamed::GetName() const; const char*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; Long64_tGetTotBytes() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetZipBytes() const; virtual Bool_tTObject::HandleTimer",MatchSource.WIKI,root/html534/TFileInfoMeta.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileInfoMeta.html
https://root.cern/root/html534/TFileIter.html:1195,Availability,avail,available,1195," members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size-1; (int)readObj >= 0; --readObj); {; nextObject = *readObj;; if (nextObject) {; printf("" Object \""%s\"" of class \",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:10405,Modifiability,config,config,10405,"e that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:10524,Modifiability,config,config,10524,"is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t shift). { SkipObjects(shift); return *this;}. TFileIter & operator-=(Int_t shift). { return operator+=(-shift);}. TFileIter & operator++(). { SkipObjects( 1); return *this;}. TFileIter & operator--(). { SkipObjects(-1); return *this;}. TObject * operator*() const. { return GetObject();}. inline operator int() const. { return CurrentCursorPosition(); }. int operator==(const char* name) const. { return name ? !strcmp(name,GetK",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:7981,Safety,avoid,avoid,7981,", Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDirectory.; It is too costly and it can be abused. TObject * Next(Int_t nSkip); return the pointer to the object defined by next TKey; This method is not recommended. It was done for the sake; of the compatibility with TListIter. void PurgeKeys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator i",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:9599,Safety,avoid,avoid,9599,"Keys(TList* listOfKeys); Remove the TKey duplication,; leave the keys with highest cycle number only; Sort if first. void Reset(); Reset the status of the iterator. void SetCursorPosition(const char* keyNameToFind); Find the key by the name provided. TKey * SkipObjects(Int_t nSkip = 1). Returns the TKey pointer to the nSkip TKey object from the current one; nSkip = 0; the state of the iterator is not changed. nSkip > 0; iterator skips nSkip objects in the container.; the direction of the iteration is; sign(nSkip)*kIterForward. Returns: TKey that can be used to fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}.",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:562,Testability,test,tests,562,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:786,Testability,test,test,786,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:1130,Testability,test,test,1130,"hy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now loop over all objects in inverse order < -- \n"");; for( readObj = size",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:7280,Testability,assert,assert,7280," whether this classs creates TFile on its own to delete; TDirectory*fRootFileTDirectory/TFile to be iterated over; UInt_tfRunNumbercurrent ""run number""; Bool_tTListIter::fStartediteration started. private:. TFileIter*fNestedIterator! The inner TFidrectory interator;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileIter(TFile* file = 0); Create iterator over all objects from the TFile provided. TFileIter(TDirectory* directory); Create iterator over all objects from the TDirectory provided. TFileIter(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Open ROOT TFile by the name provided;; This TFile is to be deleted by the TFileIter alone. TFileIter(const TFileIter& ); Copy ctor can be used with the ""read only"" files only.; the next statement is illegal, spotted by coverity ""Dereferencing pointer ""this->fRootFile"". (Deref happens because this is a virtual function call.); assert(!fRootFile->IsWritable());. ~TFileIter(); TFileIter dtor. void Initialize(); to be documented. Bool_t IsOpen() const; Check whether the associated ROOT TFile was open; and TFile object is healthy. TKey * GetCurrentKey() const; return the pointer to the current TKey. Int_t GetDepth() const; return the current number of the nested subdirectroies;; = 0 - means there is no subdirectories. const char * GetKeyName() const; return the name of the current TKey. TObject * GetObject() const; read the object from TFile defined by the current TKey. ATTENTION: memory leak danger !!!. This method does create a new object and it is the end-user; code responsibility to take care about this object; to avoid memory leak. Int_t GetObjlen() const; Returns the uncompressed length of the current object. Int_t TotalKeys() const; The total number of the TKey keys in the current TDirectory only; Usually this means the total number of different objects; those can be read one by one.; It does NOT count the nested sub-TDi",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:10087,Testability,log,logical,10087,"o fetch the object from the TDirectory. TKey * NextEventKey(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""). TObject * NextEventGet(UInt_t eventNumber = UInt_t(-1), UInt_t runNumber = UInt_t(-1), const char* name = ""*""); reads, creates and returns the object by TKey name that matches; the ""name"" .""runNumber"" ."" eventNumber"" schema; Attention: This method does create a new TObject and it is the user; code responsibility to take care (delete) this object to avoid; memory leak. TObject * ReadObj(const TKey* key) const; Read the next TObject from for the TDirectory by TKey provided. Int_t NextEventPut(TObject* obj, UInt_t eventNum, UInt_t runNumber, const char* name = 0); Create a special TKey name with obj provided and write it out. TString MapName(const char* name, const char* localSystemKey = 0, const char* mountedFileSystemKey = 0). MapName(const char *name, const char *localSystemKey,const char *mountedFileSystemKey). Substitute the logical name with the real one if any; 1. add a line into system.rootrc or ~/.rootrc or ./.rootrc. TFileIter.ForeignFileMap mapFile // the name of the file; to map the local name; to the global file service. If this line is omitted then TFileIter class seeks for; the default mapping file in the current directory ""io.config"". const char * GetResourceName(). {return ""ForeignFileMap"";}. const char * GetDefaultMapFileName(). {return ""io.config"";}. const char * GetLocalFileNameKey(). {return ""LocalFileSystem"";}. const char * GetForeignFileSystemKey(). {return ""MountedFileSystem"";}. Int_t CurrentCursorPosition() const. const TFile * GetTFile() const. { return GetTDirectory()->GetFile(); }. const TDirectory * GetTDirectory() const. { return fNestedIterator ? fNestedIterator->GetTDirectory() : fRootFile; }. TObject * Next(). void Rewind(). void SetCursorPosition(Int_t cursorPosition). TFileIter & operator=(const char* keyNameToFind). TFileIter & operator=(Int_t cursorPosition). TFileIter & operator+=(Int_t",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileIter.html:652,Usability,simpl,simple,652,". TFileIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TFileIter. class TFileIter: public TListIter. Class to iterate (read / write ) the events written to TFile.; The event is supposed to assign an unique ID in form of. TKey <event Id> ::= eventName ""."" run_number ""."" event_number. and stored as the TKey name of the object written. void TesTFileIter(){; // This macros tests the various methods of TFileIter class.; gSystem->Load(""libTable"");. //First create simple ROOT file; TDataSet *ds = new TDataSet(""event"");; TObject *nextObject = 0;; TRandom run;; TRandom event;; {; TFileIter outSet(""test.root"",""RECREATE"");; UInt_t totalEvent = 10;; UInt_t runNumber = 20010301;; Int_t i=0;; Int_t j=0;; for (;j < 10;j++) {; for (i = 1;i<totalEvent;i++) {; outSet.NextEventPut(ds,UInt_t(i),UInt_t(runNumber+j+10*run.Rndm()-5));; }; }; }; printf("" ----------------------> TFile has been created <--------------------\n"");; TFile *f = new TFile(""test.root"");; TFileIter readObj(f);; // the number of the object available directly from ""MyDataSet.root""; Int_t size = readObj.TotalKeys();; printf("" The total number of the objects: %d\n"",size);. //-----------------------------------------------------------------------; // Loop over all objects, read them in to memory one by one. printf("" -- > Loop over all objects, read them in to memory one by one < -- \n"");; for( readObj = 0; int(readObj) < size; ++readObj){; nextObject = *readObj;; printf("" %d bytes of the object \""%s\"" of class \""%s\"" written with TKey \""%s\"" has been read from file\n""; ,readObj.GetObjlen(); ,nextObject->GetName(); ,nextObject->IsA()->GetName(); ,(const char *)readObj; );; delete nextObject;; }; //-----------------------------------------------------------------------; // Now loop over all objects in inverse order; printf("" -- > Now lo",MatchSource.WIKI,root/html534/TFileIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileIter.html
https://root.cern/root/html534/TFileMergeInfo.html:1415,Availability,down,down,1415,"e objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TFileMergeInfo(); TFileMergeInfo(const TFileMergeInfo&); TFileMergeInfo&operator=(const TFileMergeInfo&). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(). TFileMergeInfo(const TFileMergeInfo& ). TFileMergeInfo& operator=(const TFileMergeInfo& ). TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; fUserData = 0; }. » Author: Philippe Canal May, 2011 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMergeInfo.html
https://root.cern/root/html534/TFileMergeInfo.html:379,Security,access,access,379,". TFileMergeInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFileMergeInfo. class TFileMergeInfo. TFileMergeInfo. This class helps passing information from the TFileMerger to; the objects being merged. It provides access to the output directory pointer (fOutputDirectory); to whether or not this is the first time Merge is being called in the; serie (for example for TTree, the first time we also need to Clone; the object on which Merge is called), and provides for a User Data; object to be passed along to each of the calls to Merge.; The fUserData object is owned by the TFileMergeInfo and will be; deleted when the TFileMerger moves on to the next set of objects. Function Members (Methods); public:. TFileMergeInfo(TDirectory* outputfile); virtual~TFileMergeInfo(); static TClass*Class(); virtual TClass*IsA() const; voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TFileMergeInfo(); TFileMergeInfo(const TFileMergeInfo&); TFileMergeInfo&operator=(const TFileMergeInfo&). Data Members; public:. Bool_tfIsFirstTrue if this is the first call to Merge for this series of object.; TStringfOptionsAdditional text based option being passed down to customize the merge.; TDirectory*fOutputDirectoryTarget directory where the merged object will be written.; TObject*fUserDataPlace holder to pass extra information. This object will be deleted at the end of each series of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMergeInfo(). TFileMergeInfo(const TFileMergeInfo& ). TFileMergeInfo& operator=(const TFileMergeInfo& ). TFileMergeInfo(TDirectory* outputfile); {}. virtual ~TFileMergeInfo(); { delete fUserData; }. void Reset(); { fIsFirst = kTRUE; delete fUserData; f",MatchSource.WIKI,root/html534/TFileMergeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMergeInfo.html
https://root.cern/root/html534/TFileMerger.html:1992,Availability,error,error,1992,"ss = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxOpenedFies() const; TList*GetMergeList() const; const char*GetMsgPrefix() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; const char*GetObjectNames() const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFile*GetOutputFile() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTOb",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:2076,Availability,error,error,2076,"dObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMaxOpenedFies() const; TList*GetMergeList() const; const char*GetMsgPrefix() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; const char*GetObjectNames() const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFile*GetOutputFile() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_t",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:10353,Availability,error,error,10353,"f the addition was successful. Bool_t OutputFile(const char* url, Bool_t force, Int_t compressionLevel); Open merger output file. Bool_t OutputFile(const char* url, Bool_t force); Open merger output file. Bool_t OutputFile(const char* url, const char* mode, Int_t compressionLevel); Open merger output file. 'mode' is passed to the TFile constructor as the option, it should; be one of 'NEW','CREATE','RECREATE','UPDATE'; 'UPDATE' is usually used in conjunction with IncrementalMerge. Bool_t OutputFile(const char* url, const char* mode = ""RECREATE""); Open merger output file. 'mode' is passed to the TFile constructor as the option, it should; be one of 'NEW','CREATE','RECREATE','UPDATE'; 'UPDATE' is usually used in conjunction with IncrementalMerge. void PrintFiles(Option_t* options); Print list of files being merged. Bool_t Merge(Bool_t = kTRUE); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist, Int_t type = kRegular|kAll); Merge all objects in a directory; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file (default); kIncremental : merge the input file with the (existing) content of the output file (if already exising); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function.; kOnlyListed : merge only objects listed in fObjectNames; kSkipListed : skip merging of objects listed in fObjectNames. Bool_t PartialMerge(Int_t type = kAll|kIncremental); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error.; The type is defined by the bit values in EPartialMergeType:; kRegular ",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:11256,Availability,error,error,11256,"it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error. Bool_t MergeRecursive(TDirectory* target, TList* sourcelist, Int_t type = kRegular|kAll); Merge all objects in a directory; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file (default); kIncremental : merge the input file with the (existing) content of the output file (if already exising); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function.; kOnlyListed : merge only objects listed in fObjectNames; kSkipListed : skip merging of objects listed in fObjectNames. Bool_t PartialMerge(Int_t type = kAll|kIncremental); Merge the files. If no output file was specified it will write into; the file ""FileMerger.root"" in the working directory. Returns true; on success, false in case of error.; The type is defined by the bit values in EPartialMergeType:; kRegular : normal merge, overwritting the output file; kIncremental : merge the input file with the content of the output file (if already exising) (default); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. If the type is set to kIncremental the output file is done deleted at the end of; this operation. If the type is not set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less tha",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:588,Integrability,interface,interface,588,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:7992,Integrability,message,message,7992,"};. protected:. Bool_tfCompressionChangeTrue if the output and input have different compression level (default kFALSE); TList*fExcessFiles! List of TObjString containing the name of the files not yet added to fFileList due to user or system limitiation on the max number of files opened.; Bool_tfExplicitCompLevelTrue if the user explicitly requested a compressio level change (default kFALSE); Bool_tfFastMethodTrue if using Fast merging algorithm (default); TList*fFileLista list the file (TFile*) which shall be merged; Bool_tfHistoOneGoMerger histos in one go (default is kTRUE); Bool_tfLocalMakes local copies of merging files if True (default is kTRUE); Int_tfMaxOpenedFilesMaximum number of files opened at the same time by the TFileMerger.; TList*fMergeListlist of TObjString containing the name of the files need to be merged; TStringfMsgPrefixPrefix to be used when printing informational message (default TFileMerger); Bool_tfNoTreesTrue if Trees should not be merged (default is kFALSE); TStringfObjectNamesList of object names to be either merged exclusively or skipped; TFile*fOutputFilethe outputfile for merging; TStringfOutputFilenamethe name of the outputfile for merging; Int_tfPrintLevelHow much information to print out at run time.; TStopwatchfWatchstop watch to measure file copy speed. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); Create file merger object. ~TFileMerger(); Cleanup. void Reset(); Reset merger file list. Bool_t AddFile(const char* url, Bool_t cpProgress = kTRUE); Add file to file merger. Bool_t AddFile(TFile* source, Bool_t cpProgress = kTRUE); Add the TFile to this file merger and *do not* give ownership of the TFile to this; object. Return kTRUE if the addition was successful. Bool_t AddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); Add the TFile to this file merger and give ownership of the TFile to this; object (unless kFALSE is re",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:12408,Integrability,message,message,12408,"e output file; kIncremental : merge the input file with the content of the output file (if already exising) (default); kAll : merge all type of objects (default); kResetable : merge only the objects with a MergeAfterReset member function.; kNonResetable : merge only the objects without a MergeAfterReset member function. If the type is set to kIncremental the output file is done deleted at the end of; this operation. If the type is not set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less than two, we reset it to 2 (one for the output file and one for the input file). void SetMsgPrefix(const char* prefix); Set the prefix to be used when printing informational message. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. TFile * GetOutputFile() const; { return fOutputFile; }. Int_t GetMaxOpenedFies() const; { return fMaxOpenedFiles; }. const char * GetMsgPrefix() const; { return fMsgPrefix; }. void AddObjectNames(const char* name); {fObjectNames += name; fObjectNames += "" "";}. const char * GetObjectNames() const; {return fObjectNames.Data();}. void ClearObjectNames(); {fObjectNames.Clear();}. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:13229,Integrability,interface,interface,13229," set to kIncremental, the output file is closed. Bool_t OpenExcessFiles(); Open up to fMaxOpenedFiles of the excess files. void RecursiveRemove(TObject* obj); Intercept the case where the output TFile is deleted!. void SetMaxOpenedFiles(Int_t newmax); Set a limit to the number file that TFileMerger will opened at one time.; If the request is higher than the system limit, we reset it to the system limit.; If the request is less than two, we reset it to 2 (one for the output file and one for the input file). void SetMsgPrefix(const char* prefix); Set the prefix to be used when printing informational message. TFileMerger(const TFileMerger& ). TFileMerger& operator=(const TFileMerger& ). Int_t GetPrintLevel() const; { return fPrintLevel; }. void SetPrintLevel(Int_t level); { fPrintLevel = level; }. Bool_t HasCompressionChange() const; { return fCompressionChange; }. const char * GetOutputFileName() const; { return fOutputFilename; }. TList * GetMergeList() const; { return fMergeList; }. TFile * GetOutputFile() const; { return fOutputFile; }. Int_t GetMaxOpenedFies() const; { return fMaxOpenedFiles; }. const char * GetMsgPrefix() const; { return fMsgPrefix; }. void AddObjectNames(const char* name); {fObjectNames += name; fObjectNames += "" "";}. const char * GetObjectNames() const; {return fObjectNames.Data();}. void ClearObjectNames(); {fObjectNames.Clear();}. Bool_t SetCWD(const char* ); --- file management interface. { MayNotUse(""SetCWD""); return kFALSE; }. const char * GetCWD(); { MayNotUse(""GetCWD""); return 0; }. void SetFastMethod(Bool_t fast = kTRUE); {fFastMethod = fast;}. void SetNotrees(Bool_t notrees = kFALSE); {fNoTrees = notrees;}. » Author: Andreas Peters + Fons Rademakers 26/5/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:453,Modifiability,plugin,plugins,453,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:446,Security,access,access,446,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFileMerger.html:534,Security,access,accessable,534,". TFileMerger. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » IO; » TFileMerger. class TFileMerger: public TObject. TFileMerger. This class provides file copy and merging services. It can be used to copy files (not only ROOT files), using TFile or; any of its remote file access plugins. It is therefore usefull in; a Grid environment where the files might be accessable via Castor,; rfio, dcap, etc.; The merging interface allows files containing histograms and trees; to be merged, like the standalone hadd program. Function Members (Methods); public:. TFileMerger(Bool_t isLocal = kTRUE, Bool_t histoOneGo = kTRUE); virtual~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddAdoptFile(TFile* source, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual Bool_tAddFile(TFile* source, Bool_t cpProgress = kTRUE); voidAddObjectNames(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearObjectNames(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root/html534/TFileMerger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileMerger.html
https://root.cern/root/html534/TFilePrefetch.html:1550,Availability,error,error,1550,"::AppendPad(Option_t* option = """"); Bool_tBinarySearchReadList(TFPBlock*, Long64_t, Int_t, Int_t*); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); TCondition*GetCondNewBlock() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_t",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:1634,Availability,error,error,1634,"Int_t, Int_t*); virtual voidTObject::Browse(TBrowser* b); Bool_tCheckBlockInCache(char*&, TFPBlock*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TFPBlock*CreateBlockObj(Long64_t*, Int_t*, Int_t); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBlockFromCache(const char*, Int_t); TCondition*GetCondNewBlock() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFPBlock*GetPendingBlock(); TThread*GetThread() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long64_tGetWaitTime(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msg",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:6118,Performance,cache,cache,6118,"tion = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static TThread::VoidRtnFunc_tThreadProc(void*). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TThread*fConsumerconsumer thread; TFile*fFilereference to the file; TMutex*fMutexPendingListmutex for the pending list; TMutex*fMutexReadListmutex for the list of read blocks; TCondition*fNewBlockAddedsignal the addition of a new pending block; TStringfPathCachepath to the cache directory; TList*fPendingBlockslist of pending blocks to be read; TCondition*fReadBlockAddedsignal the addition of a new red block; TList*fReadBlockslist of blocks read; TSemaphore*fSemChangeFilesemaphore used when changin a file in TChain; TSemaphore*fSemMasterWorkersemaphore used to kill the consumer thread; TSemaphore*fSemWorkerMastersemaphore used to notify the master that worker is killed; Bool_tfThreadJoinedmark if async thread was joined; TStopwatchfWaitTimetime wating to prefetch a buffer (in usec). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFilePrefetch(TFile* ); Constructor. ~TFilePrefetch(); Destructor. void WaitFinishPrefetch(); Killing the async prefetching thread. void ReadAsync(TFPBlock* , Bool_t& ); Read one block and insert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:8352,Performance,cache,cache,8352,"); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:8427,Performance,cache,cache,8427,"); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:8495,Performance,cache,cache,8495,"); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:8553,Performance,cache,cache,8553,"); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFilePrefetch.html:7984,Usability,clear,clear,7984,". void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file; When prefetching is enabled we also need to:; - make sure the async thread is not doing any work; - clear all blocks from prefetching and read list; - reset the file pointer. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TCondition* GetCondNewBlock() const; { return fNewBlockAdded; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io: » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a",MatchSource.WIKI,root/html534/TFilePrefetch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFilePrefetch.html
https://root.cern/root/html534/TFileSet.html:2035,Availability,error,error,2035," virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html534/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileSet.html
https://root.cern/root/html534/TFileSet.html:2119,Availability,error,error,2119,"ataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() const; virtual Int_tTDataSet::GetListSize() const; static TDataSet*TDataSet::GetMainS",MatchSource.WIKI,root/html534/TFileSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileSet.html
https://root.cern/root/html534/TFileStager.html:1659,Availability,error,error,1659,"tager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virt",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:1743,Availability,error,error,1743,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringGetPathName(TObject* o); virtual TList*GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tT",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:312,Integrability,interface,interface,312,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:474,Modifiability,plug-in,plug-in,474,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:6982,Modifiability,plugin,plugin,6982,"bject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileStager(const char* stager); { }. virtual ~TFileStager(); { }. TList * GetStaged(TCollection* pathlist). Bool_t IsStaged(const char* ). Int_t Locate(const char* u, TString& f). Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE). Bool_t Matches(const char* s); { return ((s && (fName == s)) ? kTRUE : kFALSE); }. Bool_t Stage(const char* , Option_t* = 0); { return kTRUE; }. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0). Bool_t IsValid() const; { return kTRUE; }. TString GetPathName(TObject* o); Extract the path name from supported object types. TFileStager * Open(const char* stager); --- Load desired plugin. » Author: A. Peters, G. Ganis 7/2/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:455,Performance,load,load,455,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFileStager.html:539,Performance,load,load,539,". TFileStager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFileStager. class TFileStager: public TNamed. TFileStager. Abstract base class defining an interface to a stager. To open a connection to a stager use the static method; Open(""<stager>""), where <stager> contains a keyword allowing to load; the relevant plug-in, e.g.; TFileStager::Open(""root://lxb6064.cern.ch""); will load TXNetFileStager and initialize it for the redirector at; lxb6046.cern.ch . Function Members (Methods); public:. TFileStager(const char* stager); TFileStager(const TFileStager&); virtual~TFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html534/TFileStager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFileStager.html
https://root.cern/root/html534/TFitEditor.html:1420,Availability,error,error,1420,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:1960,Availability,robust,robust,1960,"nd shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw fun",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:2269,Availability,error,errors,2269,"implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; val",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:2412,Availability,error,error,2412,"ed string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desir",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:2522,Availability,error,error,2522,"ent; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF option 'M' - after minimum is; found, search for a new one.; ""Add to list"" sets On/Off option '+'- add function to the list; without deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages ",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:3745,Availability,avail,available,3745,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:3798,Availability,avail,available,3798,"out deleting the previous. Draw options:; ""SAME"" sets On/Off function drawing on the same pad.; ""No drawing"" sets On/Off option '0'- do not draw function graphics.; ""Do not store/draw"" sets On/Off option 'N'- do not store the; function, do not draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQ",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:4038,Availability,toler,tolerance,4038,"draw it. Sliders settings are used if option 'R' - use range is active.; Users can change min/max values by pressing the left mouse button; near to the left/right slider edges. It is possible o change both; values simultaneously by pressing the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignal",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:9266,Availability,error,error,9266,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_t",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:9350,Availability,error,error,9350,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillFunctionList(Int_t selected = -1); voidFillMinMethodList(Int_t selected = -1); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelecte",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:24458,Availability,error,errors,24458,,MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:25224,Availability,robust,robust,25224,"CheckButton*fAdd2FuncListswitch on/off option 'add to list'; TGCheckButton*fAllWeights1switch on/off option 'all weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayout",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:25336,Availability,error,error,25336," weights=1'; Pixel_tTGFrame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayou",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:25417,Availability,mask,mask,25417,"estErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGCheckButton*fEnableRobustswitch on/off robust option; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayoutHints*fLayoutNonelayout hints of fNone radio button; TGRadioButton*fLibFumiliset",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:28404,Availability,robust,robust,28404,,MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:29429,Availability,toler,tolerance,29429,GLabel*fSelLabelcontains selected fit function; TGTextButton*fSetParamopen set parameters dialog; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGDoubleHSlider*fSliderXslider to set fit range along x-axis; TGNumberEntry*fSliderXMaxentry to set the maximum in the range; TGNumberEntry*fSliderXMinentry to set the minumum in the range; TGHorizontalFrame*fSliderXParentparent of fSliderX; TGDoubleHSlider*fSliderYslider to set fit range along y-axis; TGNumberEntry*fSliderYMaxentry to set the maximum in the range; TGNumberEntry*fSliderYMinentry to set the minumum in the range; TGHorizontalFrame*fSliderYParentparent of fSliderY; TGDoubleHSlider*fSliderZslider to set fit range along z-axis; TGHorizontalFrame*fSliderZParentparent of fSliderZ; TGStatusBar*fStatusBarstatusbar widget; vector<TF1*>fSystemFuncsfunctions managed by the fitpanel; TGTab*fTabtab widget holding the editor; TGCompositeFrame*fTabContainermain tab container; TGNumberEntryField*fTolerancecontains tolerance set for minimization; EObjectTypefTypeobject type info; TGComboBox*fTypeFitcontains the types of functions to be selected; TGTextButton*fUpdateButtonupdates data from gROOT and gDirectory; TGCheckButton*fUseGradientswitch on/off option 'use gradient'; TGCheckButton*fUseRangeswitch on/off option 'use function range'; TGTextButton*fUserButtonopens a dialog for user-defined fit method; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; TAxis*f,MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:34699,Availability,robust,robust,34699,"ted to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable fo",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:392,Integrability,interface,interface,392,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:1426,Integrability,message,message,1426,"pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weight",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:1677,Integrability,interface,interface,1677,"ation settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Chi-square"" check button sets ON/OFF option 'C' - do not; calculate Chi-square (for Linear fitter). Fit options:; ""Integral"" check button switch ON/OFF option 'I' - use integral; of function instead of value in bin center.; ""Best Errors"" sets ON/OFF option 'E' - better errors estimation; using Minos technique.; ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1,; excluding empty bins and ignoring error bars.; ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights; equal to 1, including empty bins, error bars ignored.; ""Use range"" sets ON/OFF option 'R' - fit only data within the; specified function range with the slider.; ""Improve fit results"" sets ON/OFF ",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:33110,Integrability,depend,depending,33110,"eate 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doe",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:33221,Integrability,depend,depending,33221,"nect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:36526,Integrability,depend,depending,36526,"id SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined by text or if it is an existing one. void GetRanges(ROOT::Fit::DataRange& ); Return the ranges selected by the sliders. TList* GetFitObjectListOfFunctions(); Get the list of functions previously used in the fitobject. void GetFunctionsFromSystem(); Looks for all the functions registered in the current ROOT; session. TList* GetListOfFittingFunctions(TObject* obj = 0); This function returns a TList with all the functions used in the; FitPanel to fit a given object. If the object passed is NULL,; then the object used is the currently selected one. It is; important to notice that the FitPanel is still the owner of; those functions. This means that the user SHOULD NOT delete any; of these functions, as the FitPanel will do so in the; destructor. TF1* GetFitFunction(); Get the fit function selected or declared in the fiteditor. TFitEditor(const TFitEditor& ). TFitEditor& operator=(const TFitEditor& ). » Author: Ilka Antcheva, Lorenzo Moneta, David Gon",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:23263,Modifiability,variab,variables,23263,"_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGComboBox*BuildMethodList(TGFrame* parent, Int_t id); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tCheckFunctionString(const char* str); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); voidCreateFunctionGroup(); voidCreateGeneralTab(); voidCreateMinimizationTab(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidTGFrame::DoRedraw(); virtual voidTGFrame::Draw3dRectangle(UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h); voidDrawSelection(bool restore = false); voidFillDataSetList(); TF1*FindFunction(); TF1*GetFitFunction(); TList*GetFitObjectListOfFunctions(); voidGetFunctionsFromSystem(); static Time_tTGFrame::GetLastClick(); TStringTGMainFrame::GetMWMfuncString() const; TStringTGMainFrame::GetMWMinpString() const; TStringTGMainFrame::GetMWMvalueString() const; TStringTGFrame::GetOptionString() const; voidGetRanges(ROOT::Fit::DataRange&); const TGResourcePool*TGFrame::GetResourcePool() const; virtual void*TGFrame::GetSender(); virtual const char*TQObject::GetSenderClassName() const; TF1*HasFitFunction(); voidMakeTitle(TGCompositeFrame* parent, const char* title); voidTObject::MakeZombie(); voidProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); virtual voidSetCanvas(TCanvas* c); virtual voidSetEditable(Bool_t); virtual voidTGFrame::StartGuiBuilding(Bool_t on = kTRUE). private:. TFitEditor(const TFitEditor&); TFitEditor&operator=(const TFitEditor&); voidRetrieveOptions(Foption_t&, TString&, ROOT::Math::Min",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:34273,Modifiability,variab,variables,34273," Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to addition of predefined functions. It will; insert the next selected function with a plus sign so that it; doesn't override the current content of the formula. void DoDataSet(Int_t sel); Selects the data set to be fitted. void ProcessTreeInput(TObject* objSelected, Int_t selected, TString variables, TString cuts); If the input is valid, insert the tree with the selections as an entry to fDataSet. void DoFunction(Int_t sel); Slot connected to predefined fit function settings. void DoEnteredFunction(); Slot connected to entered function in text entry. void DoLinearFit(); Slot connected to linear fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:320,Performance,perform,perform,320,". TFitEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TFitEditor. class TFitEditor: public TGMainFrame. TFitEditor. Allows to perform, explore and compare various fits. To display the new Fit panel interface right click on a histogram; or a graph to pop up the context menu and then select the menu; entry 'Fit Panel'. ""General"" Tab. The first set of GUI elements is related to the function choice; and settings. The status bar on the bottom provides information; about the current minimization settings using the following; abbreviations:; LIB - shows the current choice between Minuit/Minuit2/Fumili; MIGRAD or FUMILI points to the current minimization method in use.; Itr: - shows the maximum number of iterations nnnn set for the fit.; Prn: - can be DEF/VER/QT and shows the current print option in use. ""Predefined"" combo box - contains a list of predefined functions; in ROOT. The default one is Gaussian. ""Operation"" radio button group defines selected operational mode; between functions: NOP - no operation (default); ADD - addition; CONV - convolution (will be implemented in the future). Users can enter the function expression in a text entry field.; The entered string is checked after Enter key was pressed. An; error message shows up if the string is not accepted. The current; prototype is limited and users have no freedom to enter file/user; function names in this field. ""Set Parameters"" button opens a dialog for parameters settings. ""Fit Settings"" provides user interface elements related to the; fitter. Currently there are two method choices: Chi-square and; Binned Likelihood. ""Linear Fit"" check button sets the use of Linear fitter is it is; selected. Otherwise the option 'F' is applied if polN is selected.; ""Robust"" number entry sets the robust value when fitting graphs.; ""No Ch",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:4297,Performance,perform,performs,4297,"the left mouse button near to its; center and moving it to a new desire position. ""Minimization"" Tab. ""Library"" group allows you to use Minuit, Minuit2 or Fumili; minimization packages for your fit.; ""Minuit"" - the popular Minuit minimization package.; ""Minuit2"" - a new object-oriented implementation of Minuit in C++.; ""Fumili"" - the popular Fumili minimization package. ""Method"" group has currently restricted functionality.; ""MIGRAD"" method is available for Minuit and Minuit2; ""FUMILI"" method is available for Fumili and Minuit2; ""SIMPLEX"" method is disabled (will come with the new fitter design). ""Minimization Settings' group allows users to set values for: //; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed. Fit button - performs a fit.; Reset - resets all GUI elements and related fit settings to the; default ones.; Close - closes this window. //; /*. */. Function Members (Methods); public:. TFitEditor(TVirtualPad* pad, TObject* obj); virtual~TFitEditor(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidT",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:35608,Performance,perform,performed,35608,"near fit settings. void DoNoChi2(); Slot connected to 'no chi2' option settings. void DoRobustFit(); Slot connected to 'robust fitting' option settings. void DoNoStoreDrawing(); Slot connected to 'no storing, no drawing' settings. void DoPrintOpt(Bool_t on); Slot connected to print option settings. void DoReset(); Reset all fit parameters. void DoSetParameters(); Open set parameters dialog. void DoSliderXMoved(); Slot connected to range settings on x-axis. void DrawSelection(bool restore = false); Draws the square around the object showing where the limits for; fitting are. void DoNumericSliderXChanged(); Sincronize the numeric sliders with the graphical one. void DoSliderYMoved(); Slot connected to range settings on y-axis. void DoNumericSliderYChanged(); syncronize the numeric slider with the graphical one. void DoSliderZMoved(); Slot connected to range settings on z-axis. void DoUserDialog(); Open a dialog for getting a user defined method. void SetFunction(const char* function); Set the function to be used in performed fit. Bool_t SetObjectType(TObject* obj); Check whether the object suitable for fitting and set; its type, dimension and method combo box accordingly. void ShowObjectName(TObject* obj); Show object name on the top. Option_t * GetDrawOption() const; Get draw options of the selected object. void DoLibrary(Bool_t on); Set selected minimization library in use. void DoMinMethod(Int_t ); Set selected minimization method in use. void DoMaxIterations(); Set the maximum number of iterations. void MakeTitle(TGCompositeFrame* parent, const char* title); Create section title in the GUI. TF1* HasFitFunction(); Look in the list of function for TF1. If a TF1 is; found in the list of functions, it will be returned. void RetrieveOptions(Foption_t& , TString& , ROOT::Math::MinimizerOptions& , Int_t ); Retrieve the fitting options from all the widgets. void SetEditable(Bool_t ); Set the state of some input widgets depending on whether the fit; function can be defined",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitEditor.html:33000,Usability,clear,clear,33000,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root/html534/TFitEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitEditor.html
https://root.cern/root/html534/TFitParametersDialog.html:4835,Availability,error,error,4835,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:4919,Availability,error,error,4919,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:19323,Availability,error,error,19323,,MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:19901,Availability,mask,mask,19901,,MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:21872,Availability,error,errors,21872,l_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKOK button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TListfTextEntrieslist of text entries used for keyboard navigation; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFram,MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:8323,Deployability,update,update,8323,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:20316,Deployability,update,updated,20316,"of error values; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContStpcontainer of step values; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:22430,Deployability,update,update,22430,n**fParBndbound setting switch; TGNumberEntryField**fParErrerror values; TGCheckButton**fParFixfix setting switch; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParStpstep values; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPstporiginal patameters' step; Double_t*fPvaloriginal patameters' values; Double_tfRangexmaxmax function range; Double_tfRangexminmin function range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Int_t*fRetCodeaddress to store return code; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TListfTextEntrieslist of text entries used for keyboard navigation; TGCheckButton*fUpdateimmediate update switch; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame:,MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:25073,Deployability,update,update,25073," static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods. void HandleShiftTab(); Handle Shift+Tab key event (set focus to the previous number entry field). void HandleTab(); Handle Tab key event (set focus to the next number entry field). » Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitParametersDialog.html:25100,Integrability,depend,dependent,25100," static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Int_t* ret_code = 0); Create a dialog for fit function parameters' settings. ~TFitParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoParBound(Bool_t on); Slot related to the Bound check button. void DoParStep(); Slot related to parameter step setting. void DoParFix(Bool_t on); Slot related to the Fix check button. void SetParameters(); Set the parameter values inside the function. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void DrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. void DisconnectSlots(); Disconnect signals from slot methods. void HandleShiftTab(); Handle Shift+Tab key event (set focus to the previous number entry field). void HandleTab(); Handle Tab key event (set focus to the next number entry field). » Author: Ilka Antcheva, Lorenzo Moneta, David Gonzalez Maline 03/10/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/fitpanel:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitParametersDialog.html
https://root.cern/root/html534/TFitResult.html:1703,Availability,error,error,1703,"onst char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; doubleError(unsigned int i) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResult.html:1787,Availability,error,error,1787,"""); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; doubleROOT::Fit::FitResult::Correlation(unsigned int i, unsigned int j) const; doubleROOT::Fit::FitResult::CovMatrix(unsigned int i, unsigned int j) const; intROOT::Fit::FitResult::CovMatrixStatus() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; doubleROOT::Fit::FitResult::Edm() const; doubleError(unsigned int i) const; const vector<double>&ROOT::Fit::FitResult::Errors() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultROOT::Fit::FitResult::FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::FittedFunction() const; voidROOT::Fit::FitResult::GetConfidenceIntervals(const ROO",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResult.html:9994,Availability,error,errors,9994,"Result::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; map<unsigned int,bool>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >ROOT::Fit::FitResult::fParamBoundsparameter bounds; vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult; copy the contained TF1 pointer function if it is. void Print(Option_t* ",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResult.html:10358,Availability,error,errors,10358,"Result::fChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>ROOT::Fit::FitResult::fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; map<unsigned int,bool>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >ROOT::Fit::FitResult::fParamBoundsparameter bounds; vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult; copy the contained TF1 pointer function if it is. void Print(Option_t* ",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResult.html:11202,Availability,error,errors,11202,"tor) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >ROOT::Fit::FitResult::fParamBoundsparameter bounds; vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult; copy the contained TF1 pointer function if it is. void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. virtual ~TFitResult(); {}. double Error(unsigned int i) const; need to re-implement to solve conflict with TObject::Error. » Author: David Gonzalez Maline Tue Nov",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResult.html:11244,Availability,error,error,11244,"tor) ; TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; vector<std::string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >ROOT::Fit::FitResult::fParamBoundsparameter bounds; vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult; copy the contained TF1 pointer function if it is. void Print(Option_t* option = """") const; print result of the fit, by default chi2, parameter values and errors; if option ""V"" is given print also error matrix and correlation. TMatrixDSym GetCovarianceMatrix() const; Return the covariance matrix from fit; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TMatrixDSym GetCorrelationMatrix() const; Return the correlation matrix from fit.; The matrix is a symmetric matrix with a size N equal to; the total number of parameters considered in the fit including the fixed ones; The matrix row and columns corresponding to the fixed parameters will contain only zero's. TFitResult(int status = 0); Default constructor for I/O. TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult. virtual ~TFitResult(); {}. double Error(unsigned int i) const; need to re-implement to solve conflict with TObject::Error. » Author: David Gonzalez Maline Tue Nov",MatchSource.WIKI,root/html534/TFitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResult.html
https://root.cern/root/html534/TFitResultPtr.html:1360,Testability,assert,assert,1360," ROOT; » HIST; » HIST; » TFitResultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResultPtr.html
https://root.cern/root/html534/TFitResultPtr.html:1538,Testability,assert,assert,1538," ROOT; » HIST; » HIST; » TFitResultPtr. class TFitResultPtr. Function Members (Methods); public:. TFitResultPtr(int status = -1); TFitResultPtr(TFitResult* p); TFitResultPtr(const TFitResultPtr& rhs); virtual~TFitResultPtr(); static TClass*Class(); TFitResult*Get() const; virtual TClass*IsA() const; intoperator int() const; TFitResult&operator*() const; TFitResult*operator->() const; TFitResultPtr&operator=(const TFitResultPtr& rhs); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. TFitResult*fPointerSmart Pointer to TFitResult class ; intfStatusfit status code. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResultPtr(TFitResult* p); constructor from a TFitResult pointer. TFitResultPtr(const TFitResultPtr& rhs); copy constructor - create a new TFitResult if needed. ~TFitResultPtr(); destructor - delete the contained TFitResult pointer if needed. TFitResult& operator*() const; implement the de-reference operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResult* operator->() const; implement the -> operator to make the class acts as a pointer to a TFitResult; assert in case the class does not contain a pointer to TFitResult. TFitResultPtr & operator=(const TFitResultPtr& rhs); assignment operator; if needed copy the TFitResult object and delete previous one if existing. TFitResultPtr(int status = -1); {}. operator int() const; { return fStatus; }. TFitResult* Get() const; { return fPointer; }. » Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitResultPtr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitResultPtr.html
https://root.cern/root/html534/TFITSHDU.html:1654,Availability,error,error,1654,"); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); const TString&GetColumnName(Int_t colnum); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecor",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFITSHDU.html:1738,Availability,error,error,1738,"l voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVectorD*GetArrayColumn(UInt_t col); TVectorD*GetArrayRow(UInt_t row); const TString&GetColumnName(Int_t colnum); Int_tGetColumnNumber(const char* colname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TString&GetKeywordValue(const char* keyword); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFITSHDU::HDURecord*GetRecord(const char* keyword); Int_tGetRecordNumber() const; Int_tGetTabNColumns() const; Int_tGetTabNRows() const; TVectorD*Get",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFITSHDU.html:12941,Availability,error,error,12941,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFITSHDU.html:298,Integrability,interface,interface,298,". TFITSHDU. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » FITSIO; » TFITSHDU. class TFITSHDU: public TNamed. FITS file interface class; TFITS is a class that allows extracting images and data from FITS files and contains; several methods to manage them.; . Function Members (Methods); public:. TFITSHDU(const char* filepath_with_filter); TFITSHDU(const TFITSHDU&); TFITSHDU(const char* filepath, Int_t extension_number); TFITSHDU(const char* filepath, const char* extension_name); virtual~TFITSHDU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tChange(const char* filter); Bool_tChange(Int_t extension_number); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFITSHDU.html:10786,Integrability,depend,depending,10786,"""T"" : print column information when HDU is a table; ""T+"" : print full table (columns header and rows). TImage * ReadAsImage(Int_t layer = 0, TImagePalette* pal = 0); Read image HDU as a displayable image. Return 0 if conversion cannot be done.; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0). void Draw(Option_t* opt = """"); If the HDU is an image, draw the first layer of the primary array; To set a title to the canvas, pass it in ""opt"". TMatrixD* ReadAsMatrix(Int_t layer = 0, Option_t* opt = """"); Read image HDU as a matrix. Return 0 if conversion cannot be done; If the HDU seems to be a multilayer image, 'layer' parameter can be used; to retrieve the specified layer (starting from 0) in matrix form.; Options (value of 'opt'):; ""S"": stretch pixel values to a range from 0.0 to 1.0. TH1 * ReadAsHistogram(); Read image HDU as a histogram. Return 0 if conversion cannot be done.; The returned object can be TH1D, TH2D or TH3D depending on data dimensionality.; Please, check condition (returnedValue->IsA() == TH*D::Class()) to; determine the object class.; NOTE: do not confuse with image histogram! This function interprets; the array as a histogram. It does not compute the histogram of pixel; values of an image! Here ""pixels"" are interpreted as number of entries. TVectorD* GetArrayRow(UInt_t row); Get a row from the image HDU when it's a 2D array. TVectorD* GetArrayColumn(UInt_t col); Get a column from the image HDU when it's a 2D array. Int_t GetColumnNumber(const char* colname); Get column number given its name. TObjArray* GetTabStringColumn(Int_t colnum); Get a string-typed column from a table HDU given its column index (>=0). TObjArray* GetTabStringColumn(const char* colname); Get a string-typed column from a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const ",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFITSHDU.html:13054,Security,access,access,13054,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFITSHDU.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFITSHDU.html
https://root.cern/root/html534/TFitter.html:1344,Availability,error,error,1344,"r = 25); virtual~TFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceI",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:1428,Availability,error,error,1428,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:12128,Availability,error,errors,12128," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:12141,Availability,error,errors,12141," args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : paramet",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:12379,Availability,error,error,12379,"x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumber",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13051,Availability,error,errors,13051," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13114,Availability,error,error,13114," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13136,Availability,error,error,13136," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13162,Availability,error,error,13162," set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, D",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13428,Availability,error,error,13428,"al value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) co",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:13788,Availability,error,error,13788," * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Dou",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:15159,Availability,error,error,15159,"ouble_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:15540,Availability,error,error,15540,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:15868,Availability,error,error,15868,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16511,Availability,error,error,16511," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; Th",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:17100,Availability,error,error,17100,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:14247,Modifiability,variab,variable,14247,"globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for t",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:9599,Performance,cache,cache,9599,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFit",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:15476,Performance,cache,cache,15476,"if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for eac",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:15801,Performance,cache,cache,15801,"the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the P",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16447,Performance,cache,cache,16447," cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; Th",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:17033,Performance,cache,cache,17033,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16268,Safety,predict,predict,16268,"rameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16877,Safety,predict,predict,16877,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:10622,Testability,log,logs,10622,"eNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fCovarCovariance matrix; TMinuit*fMinuitpointer to the TMinuit object; Int_tfNlogNumber of elements in fSunLog; Double_t*fSumLogSum of logs (array of fNlog elements). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitter(Int_t maxpar = 25); default constructor*-*-; *-* ===================. ~TFitter(); default destructor*-*-*-; *-* ==================. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* option = """"); reset the fitter environment. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void FixParameter(Int_t ipar); Fix parameter ipar. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in o",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:14344,Testability,log,log,14344,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:14366,Testability,log,log,14366,"eturn the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag)",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:14893,Testability,log,loglikelihood,14893,"alue for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). void PrintResults(Int_t level, Double_t amin) const; Print fit results. void ReleaseParameter(Int_t ipar); Release parameter ipar. void SetFCN(void* fcn); Specify the address of the fitting algorithm (from the interpreter). void SetFCN(void (*)(Int_t&, Double_t*, Double_t&f, Double_t*, Int_t) fcn); Specify the address of the fitting algorithm. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content,",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16340,Testability,log,logs,16340,"* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitter.html:16949,Testability,log,logs,16949,"nt_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e, xc (bin content, error, x of center of bin); -2D : bc,e, xc,yc; -3D : bc,e, xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e, xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e, xc,xw,yc,yw; -3D : bc,e, xc,xw,yc,yw,zc,zw. TFitter(const TFitter& ). TFitter& operator=(const TFitter& ). TMinuit * GetMinuit() const; {return fMinuit;}. » Author: Rene Brun 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/minuit:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitter.html
https://root.cern/root/html534/TFitterFumili.html:1414,Availability,error,error,1414,"» TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html534/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterFumili.html
https://root.cern/root/html534/TFitterFumili.html:1498,Availability,error,error,1498,"» TFitterFumili. class TFitterFumili: public TFitterMinuit. Function Members (Methods); public:. TFitterFumili(); TFitterFumili(Int_t maxpar); TFitterFumili(const TFitterFumili&); virtual~TFitterFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFitterMinuit::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tTFitterMinuit::ExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidTFitterMinuit::FixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, ",MatchSource.WIKI,root/html534/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterFumili.html
https://root.cern/root/html534/TFitterFumili.html:11950,Integrability,interface,interface,11950,"er to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterFumili.html
https://root.cern/root/html534/TFitterFumili.html:11940,Modifiability,inherit,inherited,11940,"er to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMinimizerType ); virtual FunctionMinimum Minimize( int nfcn = 0, double edmval = 0.1) const;. void CreateChi2FCN(). void CreateChi2ExtendedFCN(). void CreateUnbinLikelihoodFCN(); {}. void CreateBinLikelihoodFCN(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterFumili.html
https://root.cern/root/html534/TFitterFumili.html:10852,Performance,cache,cache,10852,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterFumili(). TFitterFumili(Int_t maxpar). virtual ~TFitterFumili(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void CreateMinimizer(TFitterMinuit::EMini",MatchSource.WIKI,root/html534/TFitterFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterFumili.html
https://root.cern/root/html534/TFitterMinuit.html:1470,Availability,error,error,1470,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:1554,Availability,error,error,1554,"t. class TFitterMinuit: public TVirtualFitter. Function Members (Methods); public:. TFitterMinuit(); TFitterMinuit(Int_t maxpar); TFitterMinuit(const TFitterMinuit&); virtual~TFitterMinuit(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); virtual voidTVirtualFitter::GetConfidenceIntervals(Int_t n, Int_t ndim, const ",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:13662,Availability,toler,tolerance,13662,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:13720,Availability,toler,tolerances,13720,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:14593,Availability,error,error,14593,"d SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:11723,Integrability,interface,interface,11723," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:13077,Integrability,interface,interface,13077,"nst; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. voi",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:11713,Modifiability,inherit,inherited,11713," Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; intfStrategy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitterMinuit(). TFitterMinuit(Int_t maxpar). virtual ~TFitterMinuit(). Double_t Chisquare(Int_t npar, Double_t* params) const; inherited interface. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const. const char * GetParName(Int_t ipar) const. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const. Double_t GetSumLog(Int_t i). Bool_t IsFixed(Int_t ipar) const; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1. void Pri",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:10293,Performance,cache,cache,10293,"can; kFumili; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. vector<double>fCovarcached covariance matrix (NxN); intfDebug; doublefEDMVal; doublefErrorDef; boolfGradient; doublefMinTolerance; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; vector<ROOT::Minuit2::MinosError>fMinosErrors; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:14363,Performance,perform,perform,14363,"d SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFitterMinuit.html:13675,Safety,avoid,avoid,13675,"!!!!!!!!!!1. void PrintResults(Int_t level, Double_t amin) const. void ReleaseParameter(Int_t ipar). void SetFitMethod(const char* name). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh). void SetFCN(void fcn); this for CINT (interactive functions). void SetFCN(void* ). void SetMinuitFCN(ROOT::Minuit2::FCNBase* f); set FCN using Minuit interface; you pass to the class ownership of FCNBase pointer. const ROOT::Minuit2::FCNBase * GetMinuitFCN() const; { return fMinuitFCN; }. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; { return fMinimizer; }. int Minimize(int nfcn = 0, double edmval = 0.1); additional abstract methods to be implemented by derived classes. int GetStrategy(); { return fStrategy; }. int PrintLevel(); { return fDebug; }. void SetStrategy(int stra); { fStrategy = stra; }. void SetPrintLevel(int level); { fDebug = level; }. void SetMinimumTolerance(double mintol); set minimum tolerance to avoid having clients (as TGraf::Fit) setting tolerances too small. { fMinTolerance = mintol; }. double MinimumTolerance() const; { return fMinTolerance; }. void CreateMinimizer(TFitterMinuit::EMinimizerType = kMigrad); create the minimizer type (Migard or Simplex); can be re-implemented in the derived classes. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void CreateChi2FCN(); functions to create FCN - re-implemented in derived class (GFumili). void CreateChi2ExtendedFCN(). void CreateBinLikelihoodFCN(). void CreateUnbinLikelihoodFCN(); {}. ROOT::Minuit2::FunctionMinimum DoMinimization(int nfcn = 0, double edmval = 0.1); internal function to perform the actual minimization (could be implemented by derived classes). int ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& ); internal funcition to study Function minimum results; return 0 if function minimum is OK or an error code. void Initialize(). » Author: L. Moneta 10/2005 » Copyright (c) 2005 RO",MatchSource.WIKI,root/html534/TFitterMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFitterMinuit.html
https://root.cern/root/html534/TFoam.html:5966,Availability,error,error,5966," = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCarver(Int_t&, Double_t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObje",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:6050,Availability,error,error,6050,"t&, Double_t&); virtual Int_tCellFill(Int_t, TFoamCell*); virtual voidCheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDivide(TFoamCell*); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExplore(TFoamCell* Cell); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFinalize(Double_t&, Double_t&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerCel2(TFoamCell*&); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetIntegMC(Double_t&, Double_t&); virtual voidGetIntNorm(Double_t&, Double_t&); virtual voidGetMCvect(Double_t*); virtual Double_tGetMCwt(); virtual voidGetMCwt(Double_t&); virtual const char*TObject::GetName() const; virtual Long_tGetnCalls() const; virtual Long_tGetnEffev() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPrimary() ",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:12292,Availability,error,error,12292,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:21003,Availability,avail,available,21003,"-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t ,",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:23179,Availability,failure,failures,23179,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:23220,Availability,failure,failures,23220,"& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCells =nCells;}. void SetnSampl(Long_t nSampl); {fNSampl =nSampl;}. void SetnBin(Int_t nBin); {fNBin = nBin;}. void SetChat(Int_t Chat); {fChat = Chat;}. void SetOptRej(Int_t OptRej); {fOptRej =OptRej;}. void SetOptDrive(Int_t OptDrive); {fOptDrive =OptDrive;}. void SetEvPerBin(Int_t EvPerBin); {fEvPerBin =EvPerBin;}. void SetMaxWtRej(Double_t MaxWtRej); {fMaxWtRej=MaxWtRej;}. const char * GetVersion() const; Getters and Setters. {return fVersion.Data();}. I",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:813,Deployability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:1042,Deployability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:1257,Deployability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:3500,Deployability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:11862,Deployability,integrat,integration,11862,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:17271,Deployability,update,updated,17271,"alization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Inte",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:18643,Deployability,update,updated,18643,"t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used by Initialize.; It finds out number of active cells fNoAct,; creates list of active cell fCellsAct and primary cumulative fPrimAcu.; They are used during the MC generation to choose randomly an active cell. void ResetPseRan(TRandom* PseRan); User may optionally reset random number generator using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing random number generator registered in the FOAM object.; In particular such an object is created by the streamer during the disk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set the distribution object. void SetRhoInt(Double_t (*fun)(Int_t, Double_t *) ); User may use this method to set the distribution object as a global function pointer; (and not as an interpreted function). void ResetRho(TFoamIntegra",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:829,Energy Efficiency,efficient,efficient,829,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:840,Energy Efficiency,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:3561,Energy Efficiency,allocate,allocated,3561,"mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distribution, while using OptRej=0. Past versions of FOAM: August 2003, v.",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:15020,Energy Efficiency,allocate,allocated,15020,"ector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(const Char_t* ); User constructor, to be employed by the user. ~TFoam(); Default destructor; cout<<"" DESTRUCTOR entered ""<<endl;. TFoam(const TFoam& ); Copy Constructor NOT IMPLEMENTED (NEVER USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure E",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:15487,Energy Efficiency,allocate,allocated,15487,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:16670,Energy Efficiency,allocate,allocated,16670,"edu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the M",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:813,Integrability,integrat,integrate,813,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:1042,Integrability,integrat,integrator,1042,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:1257,Integrability,integrat,integrated,1257,"ic TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Camel2); // Set 2-dim distribution, included below; FoamX->SetPseRan(PseRan); // Set random number generator; FoamX->Initialize(); // Initialize simulator, takes a few seconds...; // From now on FoamX is ready to generate events according to Camel2(x,y); for(Long_t",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:3500,Integrability,integrat,integration,3500,"<<endl;; hst_xy->Fill(x,y); // fill scattergram; }// loop; Double_t mcResult, mcError;; FoamX->GetIntegMC( mcResult, mcError); // get MC integral, should be one; cout << "" mcResult= "" << mcResult << "" +- "" << mcError <<endl;; // now hst_xy will be plotted visualizing generated distribution; TCanvas *cKanwa = new TCanvas(""cKanwa"",""Canvas for plotting"",600,600);; cKanwa->cd();; hst_xy->Draw(""lego2"");; }//kanwa; Double_t sqr(Double_t x){return x*x;};; Double_t Camel2(Int_t nDim, Double_t *Xarg){; // 2-dimensional distribution for FOAM, normalized to one (within 1e-5); Double_t x=Xarg[0];; Double_t y=Xarg[1];; Double_t GamSq= sqr(0.100e0);; Double_t Dist=exp(-(sqr(x-1./3) +sqr(y-1./3))/GamSq)/GamSq/TMath::Pi();; Dist +=exp(-(sqr(x-2./3) +sqr(y-2./3))/GamSq)/GamSq/TMath::Pi();; return 0.5*Dist;; }// Camel2; Two-dim. histogram of the MC points generated with the above program looks as follows:. . Canonical nine steering parameters of FOAM. Name | default | Description. kDim | 0 | Dimension of the integration space. Must be redefined!; nCells | 1000 | No of allocated number of cells,; nSampl | 200 | No. of MC events in the cell MC exploration; nBin | 8 | No. of bins in edge-histogram in cell exploration; OptRej | 1 | OptRej = 0, weighted; OptRej=1, wt=1 MC events; OptDrive | 2 | Maximum weight reduction, =1 for variance reduction; EvPerBin | 25 | Maximum number of the effective wt=1 events/bin,; | | EvPerBin=0 deactivates this option; Chat | 1 | =0,1,2 is the ``chat level'' in the standard output; MaxWtRej | 1.1 | Maximum weight used to get w=1 MC events. The above can be redefined before calling 'Initialize()' method,; for instance FoamObject->SetkDim(15) sets dimension of the distribution to 15.; Only kDim HAS TO BE redefined, the other parameters may be left at their defaults.; nCell may be increased up to about million cells for wildly peaked distributions.; Increasing nSampl sometimes helps, but it may cost CPU time.; MaxWtRej may need to be increased for wild a distri",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:11862,Integrability,integrat,integration,11862,"t::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Double_tSqr(Double_t x) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TFoamCell**fCells[fNCells] Array of ALL cells; TRefArray*fCellsActArray of pointers to active cells, constructed at the end of foam build-up; Int_tfChatChat=0,1,2 chat level in output, Chat=1 normal level; TStringfDateRelease date of FOAM; Int_tfDimDimension of the integration/simulation space; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; TObjArray*fHistDbgHistograms of wt, for debug; TObjArray*fHistEdgHistograms of wt, one for each cell edge; TH1D*fHistWtHistogram of the MC wt; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TFoamMaxwt*fMCMonitMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptD",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:17389,Integrability,rout,routine,17389,"tion object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the pur",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:774,Modifiability,variab,variable,774,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:840,Modifiability,adapt,adaptive,840,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:21102,Modifiability,variab,variable,21102,"ribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(Double_t* MCvect); User subprogram which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; R",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:22457,Modifiability,variab,variables,22457,"program which generates MC event and returns MC weight. void GetIntegMC(Double_t& , Double_t& ); User subprogram.; It provides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable f",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:22580,Modifiability,variab,variable,22580,"ovides the value of the integral calculated from the averages of the MC run; May be called after (or during) the MC run. void GetIntNorm(Double_t& , Double_t& ); User subprogram.; It returns NORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom *",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:22818,Modifiability,variab,variable,22818,"ORMALIZATION integral to be combined with the average weights; and content of the histograms in order to get proper absolute normalization; of the integrand and distributions.; It can be called after initialization, before or during the MC run. void GetWtParams(Double_t , Double_t& , Double_t& , Double_t& ); May be called optionally after the MC run.; Returns various parameters of the MC weight for efficiency evaluation. void Finalize(Double_t& , Double_t& ); May be called optionally by the user after the MC run.; It provides normalization and also prints some information/statistics on the MC run. void SetInhiDiv(Int_t , Int_t ); This can be called before Initialize, after setting kDim; It defines which variables are excluded in the process of the cell division.; For example 'FoamX->SetInhiDiv(1, 1);' inhibits division of y-variable.; The resulting map of cells in 2-dim. case will look as follows:. . void SetXdivPRD(Int_t , Int_t , Double_t* ); This should be called before Initialize, after setting kDim; It predefines values of the cell division for certain variable iDim.; For example setting 3 predefined division lines using:; xDiv[0]=0.30; xDiv[1]=0.40; xDiv[2]=0.65;; FoamX->SetXdivPRD(0,3,xDiv);; results in the following 2-dim. pattern of the cells:. . void CheckAll(Int_t ); User utility, miscellaneous and debug.; Checks all pointers in the tree of cells. This is useful autodiagnostic.; level=0, no printout, failures causes STOP; level=1, printout, failures lead to WARNINGS only. void PrintCells(void); Prints geometry of ALL cells of the FOAM. void RootPlot2dim(Char_t* ); Debugging tool which plots 2-dimensional cells as rectangles; in C++ format readable for root. void LinkCells(); Void function for backward compatibility. TFoamIntegrand * GetRho(); {return fRho;}. TRandom * GetPseRan() const; {return fPseRan;}. void SetPseRan(TRandom* PseRan); {fPseRan=PseRan;}. void SetkDim(Int_t kDim); Getters and Setters. {fDim = kDim;}. void SetnCells(Long_t nCells); {fNCell",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:13156,Performance,optimiz,optimization,13156,"tMonitor of the MC weight for measuring MC efficiency; Double_tfMCerrorand its error; Double_tfMCresultTrue Integral R from MC series; Double_t*fMCvect[fDim] Generated MC vector for the outside user; Double_tfMCwtMC weight; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; Double_tfMaxWtRejMaximum weight in rejection for getting wt=1 events; TMethodCall*fMethodCall! ROOT's pointer to user-defined global distribution function; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Long_tfNCallsTotal number of the function calls; Int_tfNCellsMaximum number of cells; Long_tfNEffevTotal number of effective events (wt=1) in the foam buildup; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; Double_tfNevGenTotal number of the generated MC events; Int_tfNoActNumber of active cells; Int_tfOptDriveOptimization switch =1,2 for variance or maximum weight optimization; Int_tfOptPRDOption switch for predefined division, for quick check; Int_tfOptRejSwitch =0 for weighted events; =1 for unweighted events in MC; Double_t*fPrimAcu[fNoAct] Array of cumulative probability of all active cells; Double_tfPrimePrimary integral R' (R=R'<wt>); TRandom*fPseRanPointer to user-defined generator of pseudorandom numbers; Int_tfRNmaxMaximum No. of the rand. numb. requested at once; TFoamIntegrand*fRho! Pointer to the user-defined integrand function/distribution; Double_t*fRvec[fRNmax] random number vector from r.n. generator fDim+1 maximum elements; Double_tfSumOveTotal Sum of overveighted events; Double_tfSumWt; Double_tfSumWt2Total sum of wt and wt^2; TStringfVersionActual version of the FOAM like (1.01m); Double_tfWtMax; Double_tfWtMinMaximum/Minimum MC weight; TFoamVect**fXdivPRD! Lists of division values encoded in one vector per direction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoam(); Default constructor for streamer, user should not use it. TFoam(con",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:15447,Performance,perform,performs,15447,"R USED). void Initialize(TRandom* , TFoamIntegrand* ); Basic initialization of FOAM invoked by the user. Mandatory!. This method starts the process of the cell build-up.; User must invoke Initialize with two arguments or Initialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho pri",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:15710,Performance,optimiz,optimization,15710,"itialize without arguments.; This is done BEFORE generating first MC event and AFTER allocating FOAM object; and reseting (optionally) its internal parameters/switches.; The overall operational scheme of the FOAM is the following:. . This method invokes several other methods:. InitCells initializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Ini",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:17910,Performance,optimiz,optimization,17910,"rue and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used b",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:15977,Security,access,access,15977,"ializes memory storage for cells and begins exploration process; from the root cell. The empty cells are allocated/filled using CellFill.; The procedure Grow which loops over cells, picks up the cell with the biggest; ``driver integral'', see Comp. Phys. Commun. 152 152 (2003) 55 for explanations,; with the help of PeekMax procedure. The chosen cell is split using Divide.; Subsequently, the procedure Explore called by the Divide; (and by InitCells for the root cell) does the most important; job in the FOAM object build-up: it performs a small MC run for each; newly allocated daughter cell.; Explore calculates how profitable the future split of the cell will be; and defines the optimal cell division geometry with the help of Carver or Varedu; procedures, for maximum weight or variance optimization respectively.; All essential results of the exploration are written into; the explored cell object. At the very end of the foam build-up,; Finally, MakeActiveList is invoked to create a list of pointers to; all active cells, for the purpose of the quick access during the MC generation.; The procedure Explore employs MakeAlpha to generate random coordinates; inside a given cell with the uniform distribution.; The above sequence of the procedure calls is depicted in the following figure:. . void Initialize(); Basic initialization of FOAM invoked by the user.; IMPORTANT: Random number generator and the distribution object has to be; provided using SetPseRan and SetRho prior to invoking this initializator!. void InitCells(); Internal subprogram used by Initialize.; It initializes ""root part"" of the FOAM of the tree of cells. Int_t CellFill(Int_t , TFoamCell* ); Internal subprogram used by Initialize.; It initializes content of the newly allocated active cell. void Explore(TFoamCell* Cell); Internal subprogram used by Initialize.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of true and drive volume is defined/determined; Average ",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:952,Usability,simpl,simplified,952,". TFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoam. class TFoam: public TObject. FOAM Version 1.02M. Authors:; S. Jadach and P.Sawicki; Institute of Nuclear Physics, Cracow, Poland; Stanislaw. Jadach@ifj.edu.pl, Pawel.Sawicki@ifj.edu.pl. What is FOAM for?. * Suppose you want to generate randomly points (vectors) according to; an arbitrary probability distribution in n dimensions,; for which you supply your own subprogram. FOAM can do it for you!; Even if your distributions has quite strong peaks and is discontinuous!; * FOAM generates random points with weight one or with variable weight.; * FOAM is capable to integrate using efficient ""adaptive"" MC method.; (The distribution does not need to be normalized to one.); How does it work?. FOAM is the simplified version of the multi-dimensional general purpose; Monte Carlo event generator (integrator) FOAM.; It creates hyper-rectangular ""foam of cells"", which is more dense around its peaks.; See the following 2-dim. example of the map of 1000 cells for doubly peaked distribution:. . FOAM is now fully integrated with the ROOT package.; The important bonus of the ROOT use is persistency of the FOAM objects!. For more sophisticated problems full version of FOAM may be more appropriate:. ; See full version of FOAM. Simple example of the use of FOAM:. Int_t kanwa(){; gSystem->Load(""libFoam"");; TH2D *hst_xy = new TH2D(""hst_xy"" , ""x-y plot"", 50,0,1.0, 50,0,1.0);; Double_t *MCvect =new Double_t[2]; // 2-dim vector generated in the MC run; TRandom3 *PseRan = new TRandom3(); // Create random number generator; PseRan->SetSeed(4357); // Set seed; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; FoamX->SetkDim(2); // No. of dimensions, obligatory!; FoamX->SetnCells(500); // No. of cells, can be omitted, default=2000; FoamX->SetRhoInt(Ca",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoam.html:20398,Usability,simpl,simple,20398,"sk-read operation. void SetRho(TFoamIntegrand* Rho); User may use this method to set the distribution object. void SetRhoInt(Double_t (*fun)(Int_t, Double_t *) ); User may use this method to set the distribution object as a global function pointer; (and not as an interpreted function). void ResetRho(TFoamIntegrand* Rho); User may optionally reset the distribution using this method; Usually it is done when FOAM object is restored from the disk.; IMPORTANT: this method deletes existing distribution object registered in the FOAM object.; In particular such an object is created by the streamer diring the disk-read operation.; This method is used only in very special cases, because the distribution in most cases; should be ""owned"" by the FOAM object and should not be replaced by another one after initialization. void SetRhoInt(void* Rho); User may use this to set pointer to the global function (not descending; from TFoamIntegrand) serving as a distribution for FOAM.; It is useful for simple interactive applications.; Note that persistency for FOAM object will not work in the case of such; a distribution. Double_t Eval(Double_t* ); Internal subprogram.; Evaluates distribution to be generated. void GenerCel2(TFoamCell*& ); Internal subprogram.; Return randomly chosen active cell with probability equal to its; contribution into total driver integral using interpolation search. void MakeEvent(void); User subprogram.; It generates randomly point/vector according to user-defined distribution.; Prior initialization with help of Initialize() is mandatory.; Generated MC point/vector is available using GetMCvect and the MC weight with GetMCwt.; MC point is generated with wt=1 or with variable weight, see OptRej switch. void GetMCvect(Double_t* ); User may get generated MC point/vector with help of this method. Double_t GetMCwt(Double_t& ); User may get weight MC weight using this method. void GetMCwt(Double_t& ); User may get weight MC weight using this method. Double_t MCgenerate(",MatchSource.WIKI,root/html534/TFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoam.html
https://root.cern/root/html534/TFoamCell.html:1578,Availability,error,error,1578,"l(); TFoamCell(Int_t); TFoamCell(TFoamCell&); virtual~TFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGet",MatchSource.WIKI,root/html534/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamCell.html
https://root.cern/root/html534/TFoamCell.html:1662,Availability,error,error,1662,"ractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TFoamCell*, TFoamCell*, TFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TFoamCell*GetDau0() const; TFoamCell*GetDau1() const; virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); voidGetHcub(TFoamVect&, TFoamVect&) const; voidGetHSize(TFoamVect&) const; virtual const char*TObject::GetIconName() const; Double_tGetIntg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TFoamCell*GetPare() const; Double_tGetPrim() const; Int_tGetSerial() const; Int_tGetStat() const; virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html534/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamCell.html
https://root.cern/root/html534/TFoamCell.html:6948,Energy Efficiency,allocate,allocated,6948,"NotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. Double_t GetPrim() ",MatchSource.WIKI,root/html534/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamCell.html
https://root.cern/root/html534/TFoamCell.html:6742,Testability,test,tested,6742,"lic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Double_tfPrimaryPrimary integral, only for MC generation; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamCell(); Default constructor for streamer. TFoamCell(Int_t ); User constructor allocating single empty Cell. TFoamCell(TFoamCell& ); Copy constructor (not tested!). ~TFoamCell(); Destructor. TFoamCell& operator=(const TFoamCell& ); Substitution operator = (never used). void Fill(Int_t , TFoamCell* , TFoamCell* , TFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TFoamVect& , TFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double",MatchSource.WIKI,root/html534/TFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamCell.html
https://root.cern/root/html534/TFoamIntegrand.html:437,Availability,avail,available,437,". TFoamIntegrand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamIntegrand. class TFoamIntegrand: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html534/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamIntegrand.html
https://root.cern/root/html534/TFoamIntegrand.html:1457,Availability,error,error,1457," virtual~TFoamIntegrand(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; vi",MatchSource.WIKI,root/html534/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamIntegrand.html
https://root.cern/root/html534/TFoamIntegrand.html:1541,Availability,error,error,1541," const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TFoamIntegrand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamIntegrand.html
https://root.cern/root/html534/TFoamMaxwt.html:1675,Availability,error,error,1675,"(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html534/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html
https://root.cern/root/html534/TFoamMaxwt.html:1759,Availability,error,error,1759," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; voidGetMCeff(Double_t, Double_t&, Double_t&); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_t",MatchSource.WIKI,root/html534/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html
https://root.cern/root/html534/TFoamMaxwt.html:6290,Availability,toler,tolerance,6290," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run. » Last changed: root/foam:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html
https://root.cern/root/html534/TFoamMaxwt.html:6454,Availability,toler,tolerance,6454," f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TH1D*fWtHst1Histogram of the weight wt; TH1D*fWtHst2Histogram of wt filled with wt. private:. Double_tfNentNo. of MC events; Int_tfnBinNo. of bins on the weight distribution; Double_tfwmaxMaximum analyzed weight. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamMaxwt(); Constructor for streamer. TFoamMaxwt(Double_t , Int_t ); Principal user constructor. TFoamMaxwt(TFoamMaxwt& From); Explicit COPY CONSTRUCTOR (unused, so far). ~TFoamMaxwt(); Destructor. void Reset(); Reseting weight analysis. TFoamMaxwt& operator=(const TFoamMaxwt& ); substitution =. void Fill(Double_t ); Filling analyzed weight. void Make(Double_t , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; To be called at the end of the MC run. void GetMCeff(Double_t , Double_t& , Double_t& ); Calculates Efficiency= aveWt/wtLim for a given tolerance level epsilon<<1; using information stored in two histograms.; To be called at the end of the MC run. » Last changed: root/foam:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html
https://root.cern/root/html534/TFoamMaxwt.html:412,Integrability,depend,depending,412,". TFoamMaxwt. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamMaxwt. class TFoamMaxwt: public TObject. Class TFoamMaxwt. Small auxiliary class for controlling MC weight.; It provides certain measure of the ""maximum weight""; depending on small user-parameter ""epsilon"".; It creates and uses 2 histograms of the TH1D class.; User defines no. of bins nBin, nBin=1000 is recommended; wmax defines weight range (1,wmax), it is adjusted ""manually"". Function Members (Methods); public:. TFoamMaxwt(); TFoamMaxwt(TFoamMaxwt& From); TFoamMaxwt(Double_t, Int_t); virtual~TFoamMaxwt(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t); virtual TObject*TObject::FindObject(const char* name) const; virtual",MatchSource.WIKI,root/html534/TFoamMaxwt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamMaxwt.html
https://root.cern/root/html534/TFoamSampler.html:1314,Availability,error,error,1314," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:1434,Availability,error,errors,1434," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:3132,Availability,error,error,3132,"Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fOneDim(false),; fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:380,Integrability,interface,interface,380,". TFoamSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:2284,Integrability,interface,interface,2284,"rob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFoam*fFoamfoam engine class; TFoamIntegrand*fFoamDistfoam distribution interface ; const ROOT::Math::IBaseFunctionOneDim*fFunc1D1D function pointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamSampler(); fOneDim(false),; fDiscrete(false),; fHasMode(false), fHasArea(false),; fMode(0), fArea(0),. {}. ~TFoamSampler(). bool Init(const char* = """"). bool Init(const ROOT::Math::DistSamplerOptions& opt); initialize foam classes using the given algorithm. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TFoamSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:760,Modifiability,extend,extend,760," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamSampler.html:901,Modifiability,extend,extend,901," charts. ROOT; » MATH; » FOAM; » TFoamSampler. class TFoamSampler: public ROOT::Math::DistSampler. TFoamSampler class; class implementing the ROOT::Math::DistSampler interface using FOAM; for sampling arbitrary distributions. Function Members (Methods); public:. TFoamSampler(); TFoamSampler(const TFoamSampler&); virtual~TFoamSampler(); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleROOT::Math::DistSampler::Sample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidROOT::Math::DistSampler::SetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); virtual voidROOT::Math::DistSampler::SetMode(double); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed). protected:. virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. TFo",MatchSource.WIKI,root/html534/TFoamSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamSampler.html
https://root.cern/root/html534/TFoamVect.html:1446,Availability,error,error,1446," TFoamVect(); TFoamVect(Int_t); TFoamVect(const TFoamVect&); virtual~TFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virt",MatchSource.WIKI,root/html534/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamVect.html
https://root.cern/root/html534/TFoamVect.html:1530,Availability,error,error,1530," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inh",MatchSource.WIKI,root/html534/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamVect.html
https://root.cern/root/html534/TFoamVect.html:6078,Security,access,access,6078,"Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension; TFoamVect*fNextpointer for tree construction; TFoamVect*fPrevpointer for tree construction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""cout"". void PrintList(void); Printout of all member vectors in the list starting from ""this"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}. » Last changed: root/foam:$Id$ » Last generated: 20",MatchSource.WIKI,root/html534/TFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFoamVect.html
https://root.cern/root/html534/TFolder.html:4519,Availability,error,error,4519,"idTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::G",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:4603,Availability,error,error,4603,"TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFullPathName(const char* name) const; virtual const char*FindFullPathName(const TObject* obj) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetListOfFolders() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:944,Energy Efficiency,efficient,efficient,944,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:1032,Modifiability,coupling,coupling,1032,"e; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a fold",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:3337,Modifiability,variab,variable,3337,"xample, the following folders exist:; //root/Files with the list of currently connected Root files; //root/Classes with the list of active classes; //root/Geometries with active geometries; //root/Canvases with the list of active canvases; //root/Styles with the list of graphics styles; //root/Colors with the list of active colors. For example, if a file ""myFile.root"" is added to the list of files, one can; retrieve a pointer to the corresponding TFile object with a statement like:; TFile *myFile = (TFile*)gROOT->FindObject(""//root/Files/myFile.root"");; The above statement can be abbreviated to:; TFile *myFile = (TFile*)gROOT->FindObject(""/Files/myFile.root"");; or even to:; TFile *myFile = (TFile*)gROOT->FindObjectAny(""myFile.root"");; In this last case, the TROOT::FindObjectAny function will scan the folder hierarchy; starting at //root and will return the first object named ""myFile.root"". Because a string-based search mechanism is expensive, it is recommended; to save the pointer to the object as a class member or local variable; if this pointer is used frequently or inside loops. /*. */. Function Members (Methods); public:. TFolder(); TFolder(const char* name, const char* title); virtual~TFolder(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); TFolder*AddFolder(const char* name, const char* title, TCollection* collection = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:716,Security,access,access,716,". TFolder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TFolder. class TFolder: public TNamed. A TFolder object is a collection of objects and folders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; f",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFolder.html:1326,Security,access,access,1326,"ders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a folder does not own its contained objects.; NOTE that folder ownership can be set; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. Standard Root objects are automatically added to the folder hierarchy.; For example, the following folders exi",MatchSource.WIKI,root/html534/TFolder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFolder.html
https://root.cern/root/html534/TFormula.html:4930,Availability,error,error,4930,"Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tCompile(const char* expression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:5014,Availability,error,error,5014,"ression = """"); virtual voidCopy(TObject& formula) const; virtual char*DefinedString(Int_t code); virtual Double_tDefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual Double_tEvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tEvalParOld(const Double_t* x, const Double_t* params = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringGetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual const TObject*GetLinearPart(Int_t i); virtual const char*TNamed::GetName() const; virtual Int_tGetNdim() const; virtual Int_tGetNpar() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParameter(Int_t ipar) const; Double_tGetParameter(const char* name) const; virtual Double_t*GetParameters() const; virtual voidGetParameters(Dou",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:15058,Availability,error,errors,15058,"or. TFormula& operator=(const TFormula& rhs); Operator =. ~TFormula(); Formula default destructor. Bool_t AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); Check if the chain as function call. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. void Analyze(const char* schain, Int_t& err, Int_t offset = 0); Analyze a sub-expression in one formula. Expressions in one formula are recursively analyzed.; Result of analysis is stored in the object tables. Table of function codes and errors. * functions :. + 1 pow 20; - 2 sq 21; * 3 sqrt 22; / 4 strstr 23; % 5 min 24; max 25; log 30; cos 10 exp 31; sin 11 log10 32; tan 12; acos 13 abs 41; asin 14 sign 42; atan 15 int 43; atan2 16; fmod 17 rndm 50. cosh 70 acosh 73; sinh 71 asinh 74; tanh 72 atanh 75. expo 100 gaus 110 gausn (see note below); expo(0) 100 0 gaus(0) 110 0 gausn(0); expo(1) 100 1 gaus(1) 110 1 gausn(1); xexpo 100 x xgaus 110 x xgausn; yexpo 101 x ygaus 111 x ygausn; zexpo 102 x zgaus 112 x zgausn; xyexpo 105 x xygaus 115 x xygausn; yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2). landau 120 x landaun (see note below); landau(0) 120 0 landaun(0); landau(1) 120 1 landaun(1); xlandau 120 x xlandaun; ylandau 121 x ylandaun; zlandau 122 x zlandaun; xylandau 125 x xylandaun; ylandau(5) 121 5 ylandaun(5); xylandau(2) 125 2 xylandaun(2). pol0 130 x pol1 130 1xx; pol0(0) 130 0 pol1(0) 130 100; pol0(1) 130 1 pol1(1) 130 101; xpol0 130 x xpol1 130 101; ypol0 131 x yp",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2519,Deployability,update,updated,2519,"then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formu",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:24419,Integrability,depend,depend,24419," formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object names. if option contains ""p"" the returned string will contain the formula; expression with symbolic parameters, eg [0] replaced by the actual value; of the parameter. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; Return value of parameter number ipar. Double_t GetParameter(const char* name) const; Return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter. Int_t GetParNumber(const char* name) const; Return parameter number by name. Bool_t IsString(Int_t oper) const; Return true if the expression at the index 'oper' has to be treated as a string. void Print(Option_t* option = """") const; Dump this formula with its attributes. void ProcessLinear(TString& repla",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2418,Modifiability,inherit,inheriting,2418,"then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formu",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:4194,Modifiability,variab,variable,4194,,MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:13291,Modifiability,variab,variables,13291,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor. TFormula(const char* name, const char* formula); Normal Fo",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:16349,Modifiability,variab,variables,16349,"ote below); expo(0) 100 0 gaus(0) 110 0 gausn(0); expo(1) 100 1 gaus(1) 110 1 gausn(1); xexpo 100 x xgaus 110 x xgausn; yexpo 101 x ygaus 111 x ygausn; zexpo 102 x zgaus 112 x zgausn; xyexpo 105 x xygaus 115 x xygausn; yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2). landau 120 x landaun (see note below); landau(0) 120 0 landaun(0); landau(1) 120 1 landaun(1); xlandau 120 x xlandaun; ylandau 121 x ylandaun; zlandau 122 x zlandaun; xylandau 125 x xylandaun; ylandau(5) 121 5 ylandaun(5); xylandau(2) 125 2 xylandaun(2). pol0 130 x pol1 130 1xx; pol0(0) 130 0 pol1(0) 130 100; pol0(1) 130 1 pol1(1) 130 101; xpol0 130 x xpol1 130 101; ypol0 131 x ypol1 131 101; zpol0 132 x zpol1 132 1xx; ypol0(5) 131 5 ypol1(5) 131 105. pi 40. && 60 < 64; || 61 > 65; == 62 <= 66; != 63 => 67; ! 68; ==(string) 76 & 78; !=(string) 77 | 79; <<(shift) 80 >>(shift) 81; ? : 82. * constants (kConstants) :. c0 141 1 c1 141 2 etc.. * strings (kStringConst):. sX 143 x. * variables (kFormulaVar) :. x 144 0 y 144 1 z 144 2 t 144 3. * parameters :. [1] 140 1; [2] 140 2; etc. Special cases for normalized gaussian or landau distributions. the expression ""gaus"" is a substitute for; [0]*exp(-0.5*((x-[1])/[2])**2); to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; the expression ""gausn"" is a substitute for; [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); WARNING: gaus and gausn are mutually exclusive in the same expression. In the same way the expression ""landau"" is a substitute for; [0]*TMath::Landau(x,[1],[2],kFALSE); to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; the expression ""landaun"" is a substitute for; [0]*TMath::Landau(x,[1],[2],kTRUE); WARNING: landau and landaun are mutually exclusive in the same expression. Boolean optimization (kBoolOptmize) :. Those pseudo operation are used to implement lazy evaluation of; && and ||. When the left hand of the expression if false; (respectively true), the evaluation of th",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:18389,Modifiability,variab,variable,18389,"ndau and landaun are mutually exclusive in the same expression. Boolean optimization (kBoolOptmize) :. Those pseudo operation are used to implement lazy evaluation of; && and ||. When the left hand of the expression if false; (respectively true), the evaluation of the right is entirely skipped; (since it would not change the value of the expreession). && 142 11 (one operation on right) 142 21 (2 operations on right); || 142 12 (one operation on right) 142 22 (2 operations on right). * functions calls (kFunctionCall) :. f0 145 0 f1 145 1 etc.. Errors :. 1 : Division By Zero; 2 : Invalid Floating Point Operation; 4 : Empty String; 5 : invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected. /*; ; */. Special functions. By default, the formula is assigned fNumber=0. However, the following; formula built with simple functions are assigned fNumber:; ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:22417,Modifiability,variab,variable,22417,"on of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Double_t DefinedValue(Int_t code); Return value corresponding to special code. This member function is inactive in the TFormula class.; It may be redefined in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Int_t DefinedVariable(TString& variable, Int_t& action); Check if expression is in the list of defined variables. This member function can be overloaded in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of ",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:22489,Modifiability,variab,variables,22489,"on of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Double_t DefinedValue(Int_t code); Return value corresponding to special code. This member function is inactive in the TFormula class.; It may be redefined in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Int_t DefinedVariable(TString& variable, Int_t& action); Check if expression is in the list of defined variables. This member function can be overloaded in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of ",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:23442,Modifiability,variab,variables,23442,"ession is in the list of defined variables. This member function can be overloaded in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object name",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:23756,Modifiability,variab,variables,23756,",const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object names. if option contains ""p"" the returned string will contain the formula; expression with symbolic parameters, eg [0] replaced by the actual value; of the parameter. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:24089,Modifiability,variab,variables,24089,"ly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object names. if option contains ""p"" the returned string will contain the formula; expression with symbolic parameters, eg [0] replaced by the actual value; of the parameter. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; Return value of parameter number ipar. Double_t GetParameter(const char* name) const; Return value of parameter named parName. ",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:24139,Modifiability,variab,variables,24139,"e has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with the TFormula; instance. This function can be used to get an expanded version of the; expression originally assigned to the TFormula instance, i.e. that; the string returned by GetExpFormula() doesn't depend on other; TFormula object names. if option contains ""p"" the returned string will contain the formula; expression with symbolic parameters, eg [0] replaced by the actual value; of the parameter. Example:; if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))"". const TObject* GetLinearPart(Int_t i); Return linear part. Double_t GetParameter(Int_t ipar) const; Return value of parameter number ipar. Double_t GetParameter(const char* name) const; Return value of parameter named parName. const char * GetParName(Int_t ipar) const; Return name of one parameter. Int_t GetParNumber(const char* name) const; Return parameter numb",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:27287,Modifiability,variab,variables,27287,"er ipar. void SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10""); Set up to 11 parameter names. void Streamer(TBuffer& ); Stream a class object. void Convert(UInt_t fromVersion); Convert the fOper of a TFormula version fromVersion to the current in memory version. void MakePrimitive(const char* expr, Int_t pos); MakePrimitive; find TFormulaPrimitive replacement for some operands. void Optimize(); MI include. Optimize formula; 1.) Minimize the number of operands; a.) several operanands are glued togther; b.) some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); c.) maximize number of standard calls minimizing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is chosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Dou",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:28204,Modifiability,variab,variable,28204,"izing number of jumps in Eval cases; d.) variables, parameters and constants are mapped - using fOperOfssets0; Eval procedure use direct acces to data (only one corresponding case statement in eval procedure). pdata[operand={Var,Par,Const}][offset]; pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; 2.) The fastest evaluation function is chosen at the end; a.) fOptimal := pointer to the fastest function for given evaluation string; switch(GetActionOptimized(0)){; case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. Int_t PreCom",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:29022,Modifiability,variab,variables,29022,"alPrimitive3; break;}; case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; }; b.) ex. fOptimal = ::EvalPrimitive0 - if it return only variable, constant or parameter; = ::EvalParameter1 - if only one unary operation; = ::EvalPrimitive2 - if only one binary operation. Double_t EvalPrimitive(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive0(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive1(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. Int_t PreCompile(); Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code) const; { return fOper[code] >> kTFOperShift; }. Int_t GetActionParam(Int_t code) c",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2160,Performance,perform,performance,2160,"esult of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined ",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2669,Performance,perform,performant,2669,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); v",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:12535,Performance,cache,cache,12535,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor. TFormula(const char* name, const char* formula); Normal Fo",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:12906,Performance,optimiz,optimization,12906,"stant; kBoolOptimize; kStringConst; kVariable; kFunctionCall; kData; kUnary; kBinary; kThree; kDefinedVariable; kDefinedString; kPlusD; kPlusDD; kMultD; kMultDD; kBoolOptimizeOr; kBoolOptimizeAnd; kBoolSet; kFDM; kFD0; kFD1; kFD2; kFD3; kNotGlobal; kNormalized; kLinear; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBitsfAlreadyFound! cache for information; Double_t*fConst[fNconst] Array of fNconst formula constants; TString*fExpr[fNoper] List of expressions; TString*fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfFunctionsArray of function calls to make; TObjArrayfLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_tfNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*fNames[fNpar] Array of parameter names; Int_tfNconstNumber of constants; Int_tfNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNoperNumber of operators; Int_tfNparNumber of parameters; Int_tfNstringNumber of different constants character strings; Int_tfNumberformula number identifier; Int_tfNvalNumber of different variables in expression; TOperOffset*fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); G__p2memfuncfOptimal!pointer to optimal function; Double_t*fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**fPredefined![fNPar] predefined function ; TStringTNamed::fTitleobject title. private:. Int_t*fOper[fNoper] List of operators. (See documentation for changes made at version 7). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFormula(); Formula default constructor. TFormula(const char* name, const char* formula); Normal Fo",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:17166,Performance,optimiz,optimization,17166," ! 68; ==(string) 76 & 78; !=(string) 77 | 79; <<(shift) 80 >>(shift) 81; ? : 82. * constants (kConstants) :. c0 141 1 c1 141 2 etc.. * strings (kStringConst):. sX 143 x. * variables (kFormulaVar) :. x 144 0 y 144 1 z 144 2 t 144 3. * parameters :. [1] 140 1; [2] 140 2; etc. Special cases for normalized gaussian or landau distributions. the expression ""gaus"" is a substitute for; [0]*exp(-0.5*((x-[1])/[2])**2); to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; the expression ""gausn"" is a substitute for; [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); WARNING: gaus and gausn are mutually exclusive in the same expression. In the same way the expression ""landau"" is a substitute for; [0]*TMath::Landau(x,[1],[2],kFALSE); to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; the expression ""landaun"" is a substitute for; [0]*TMath::Landau(x,[1],[2],kTRUE); WARNING: landau and landaun are mutually exclusive in the same expression. Boolean optimization (kBoolOptmize) :. Those pseudo operation are used to implement lazy evaluation of; && and ||. When the left hand of the expression if false; (respectively true), the evaluation of the right is entirely skipped; (since it would not change the value of the expreession). && 142 11 (one operation on right) 142 21 (2 operations on right); || 142 12 (one operation on right) 142 22 (2 operations on right). * functions calls (kFunctionCall) :. f0 145 0 f1 145 1 etc.. Errors :. 1 : Division By Zero; 2 : Invalid Floating Point Operation; 4 : Empty String; 5 : invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 2",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:29840,Performance,perform,performance,29840," Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive2(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive3(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalPrimitive4(const Double_t* x, const Double_t* params); Evaluate primitive formula. Double_t EvalParFast(const Double_t* x, const Double_t* params); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. Int_t PreCompile(); Pre compile function. void SetMaxima(Int_t maxop = 1000, Int_t maxpar = 1000, Int_t maxconst = 1000); static function to set the maximum value of 3 parameters; -maxop : maximum number of operations; -maxpar : maximum number of parameters; -maxconst : maximum number of constants; None of these parameters cannot be less than 10 (default is 1000); call this function to increase one or all maxima when processing; very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; If you process many functions with a small number of operations/parameters; you may gain some memory and performance by decreasing these values. Int_t * GetOper() const; { return fOper; }. Short_t GetAction(Int_t code) const; { return fOper[code] >> kTFOperShift; }. Int_t GetActionParam(Int_t code) const; { return fOper[code] & kTFOperMask; }. void SetAction(Int_t code, Int_t value, Int_t param = 0). Int_t * GetOperOptimized() const; { return fOperOptimized; }. Short_t GetActionOptimized(Int_t code) const; { return fOperOptimized[code] >> kTFOperShift; }. Int_t GetActionParamOptimized(Int_t code) const; { return fOperOptimized[code] & kTFOperMask; }. void SetActionOptimized(Int_t code, Int_t value, Int_t param = 0). Double_t EvalPar(const Double_t* x, const Double_t* params = 0); {return ((*this).*fOptimal)(x,params);}. Int_t GetN",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2604,Security,access,access,2604,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); v",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2680,Security,access,access,2680,"ist of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions. Function Members (Methods); public:. TFormula(); TFormula(const TFormula& formula); TFormula(const char* name, const char* formula); virtual~TFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidAnalyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tAnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); v",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:18426,Security,access,accessible,18426,"ndau and landaun are mutually exclusive in the same expression. Boolean optimization (kBoolOptmize) :. Those pseudo operation are used to implement lazy evaluation of; && and ||. When the left hand of the expression if false; (respectively true), the evaluation of the right is entirely skipped; (since it would not change the value of the expreession). && 142 11 (one operation on right) 142 21 (2 operations on right); || 142 12 (one operation on right) 142 22 (2 operations on right). * functions calls (kFunctionCall) :. f0 145 0 f1 145 1 etc.. Errors :. 1 : Division By Zero; 2 : Invalid Floating Point Operation; 4 : Empty String; 5 : invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected. /*; ; */. Special functions. By default, the formula is assigned fNumber=0. However, the following; formula built with simple functions are assigned fNumber:; ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:1732,Testability,log,logic,1732,"at 0; expo(3) is a substitute for exp([3]+[4]*x); pol3(5) is a substitute for par[5]+par[6]*x+par[7]*x**2+par[8]*x**3; (here Pol3 stands for Polynomial of degree 3). TMath functions can be part of the expression, eg:; - TMath::Landau(x)*sin(x); - TMath::Erf(x). Comparisons operators are also supported (&&, ||, ==, <=, >=, !); Examples:; sin(x*(x<0.5 || x>1)); If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT S",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:15152,Testability,log,log,15152," chaine, Int_t& err, Int_t offset = 0); Check if the chain as function call. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. void Analyze(const char* schain, Int_t& err, Int_t offset = 0); Analyze a sub-expression in one formula. Expressions in one formula are recursively analyzed.; Result of analysis is stored in the object tables. Table of function codes and errors. * functions :. + 1 pow 20; - 2 sq 21; * 3 sqrt 22; / 4 strstr 23; % 5 min 24; max 25; log 30; cos 10 exp 31; sin 11 log10 32; tan 12; acos 13 abs 41; asin 14 sign 42; atan 15 int 43; atan2 16; fmod 17 rndm 50. cosh 70 acosh 73; sinh 71 asinh 74; tanh 72 atanh 75. expo 100 gaus 110 gausn (see note below); expo(0) 100 0 gaus(0) 110 0 gausn(0); expo(1) 100 1 gaus(1) 110 1 gausn(1); xexpo 100 x xgaus 110 x xgausn; yexpo 101 x ygaus 111 x ygausn; zexpo 102 x zgaus 112 x zgausn; xyexpo 105 x xygaus 115 x xygausn; yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2). landau 120 x landaun (see note below); landau(0) 120 0 landaun(0); landau(1) 120 1 landaun(1); xlandau 120 x xlandaun; ylandau 121 x ylandaun; zlandau 122 x zlandaun; xylandau 125 x xylandaun; ylandau(5) 121 5 ylandaun(5); xylandau(2) 125 2 xylandaun(2). pol0 130 x pol1 130 1xx; pol0(0) 130 0 pol1(0) 130 100; pol0(1) 130 1 pol1(1) 130 101; xpol0 130 x xpol1 130 101; ypol0 131 x ypol1 131 101; zpol0 132 x zpol1 132 1xx; ypol0(5) 131 5 ypol1(5) 131 105. pi 40. && 60 < 64; || 61 > 65; == 62 <= 66; != 63 => 67; !",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:2234,Usability,simpl,simple,2234,"example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and fre",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:18656,Usability,simpl,simple,18656,": invalid syntax; 6 : Too many operators; 7 : Too many parameters; 10 : z specified but not x and y; 11 : z and y specified but not x; 12 : y specified but not x; 13 : z and x specified but not y; 20 : non integer value for parameter number; 21 : atan2 requires two arguments; 22 : pow requires two arguments; 23 : degree of polynomial not specified; 24 : Degree of polynomial must be positive; 25 : Degree of polynomial must be less than 20; 26 : Unknown name; 27 : Too many constants in expression; 28 : strstr requires two arguments; 29 : interpreted or compiled function have to return a numerical type; 30 : Bad numerical expression; 31 : Part of the variable exist but some of it is not accessible or useable; 40 : '(' is expected; 41 : ')' is expected; 42 : '[' is expected; 43 : ']' is expected. /*; ; */. Special functions. By default, the formula is assigned fNumber=0. However, the following; formula built with simple functions are assigned fNumber:; ""gaus"" 100 (or gausn); ""xygaus"" 110; ""expo"" 200; ""polN"" 300+N; ""landau"" 400; ""xylandau"" 410; Note that expressions like gaus(0), expo(1) will force fNumber=0. Warning when deriving a class from TFormula. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Bool_t CheckOperands(Int_t operation, Int_t& err); Check whether the operand at 'oper-1' is compatible with the operation; at 'oper'. Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t& err); Check whether the operands at 'leftoper' and 'oper-1' are",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormula.html:23205,Usability,usab,usable,23205,"r. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. Int_t DefinedVariable(TString& variable, Int_t& action); Check if expression is in the list of defined variables. This member function can be overloaded in derived classes. If you overload this member function, you also HAVE TO; never call the constructor:. TFormula::TFormula(const char *name,const char *expression). and write your own constructor. MyClass::MyClass(const char *name,const char *expression) : TFormula(). which has to call the TFormula default constructor and whose implementation; should be similar to the implementation of the normal TFormula constructor. This is necessary because the normal TFormula constructor call indirectly; the virtual member functions Analyze, DefaultString, DefaultValue; and DefaultVariable. The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the action parameter. Double_t Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; Evaluate this formula. The current value of variables x,y,z,t is passed through x, y, z and t.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. Double_t EvalParOld(const Double_t* x, const Double_t* params = 0); Evaluate this formula. The current value of variables x,y,z,t is passed through the pointer x.; The parameters used will be the ones in the array params if params is given; otherwise parameters will be taken from the stored data members fParams. /*; ; */. TString GetExpFormula(Option_t* option = """") const; Reconstruct the formula expression from the internal TFormula member variables. This function uses the internal member variables of TFormula to; construct the mathematical expression associated with t",MatchSource.WIKI,root/html534/TFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormula.html
https://root.cern/root/html534/TFormulaPrimitive.html:2571,Availability,error,error,2571,"FormulaPrimitive* formula); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html534/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormulaPrimitive.html
https://root.cern/root/html534/TFormulaPrimitive.html:2655,Availability,error,error,2655,"irtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULon",MatchSource.WIKI,root/html534/TFormulaPrimitive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFormulaPrimitive.html
https://root.cern/root/html534/TFPBlock.html:1538,Availability,error,error,1538," TFPBlock(Long64_t*, Int_t*, Int_t); virtual~TFPBlock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; Long64_tGetCapacity() const; Long64_tGetDataSize() const; virtual Option_t*TO",MatchSource.WIKI,root/html534/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFPBlock.html
https://root.cern/root/html534/TFPBlock.html:1622,Availability,error,error,1622," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; char*GetBuffer() const; Long64_tGetCapacity() const; Long64_tGetDataSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_t*GetLen() const; Int_tGetLen(Int_t i) const; virtual const char*TObject::GetName() const; Int_tGetNoElem() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_t*GetPos() const; Long64_tGetPos(Int_t i) const; char*GetPtrToPiece(Int_t index) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtua",MatchSource.WIKI,root/html534/TFPBlock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFPBlock.html
https://root.cern/root/html534/TFractionFitter.html:4476,Availability,error,errors,4476,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:4543,Availability,error,error,4543,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:5370,Availability,error,error,5370," fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:6554,Availability,error,error,6554,"nst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:6638,Availability,error,error,6638,"ual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidConstrain(Int_t parm, Double_t low, Double_t high); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidErrorAnalysis(Double_t UP); voidExcludeBin(Int_t bin); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:7472,Availability,error,error,7472,"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tFit(); Double_tGetChisquare() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TVirtualFitter*GetFitter() const; virtual const char*TObject::GetIconName() const; TH1*GetMCPrediction(Int_t parm) const; virtual const char*TObject::GetName() const; Int_tGetNDF() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1*GetPlot(); Double_tGetProb() const; voidGetResult(Int_t parm, Double_t& value, Double_t& error) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIncludeBin(Int_t bin); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator dele",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:13502,Availability,error,error,13502," TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetR",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:13802,Availability,error,error,13802,"aration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; h",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:14181,Availability,error,error,14181," verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:14491,Availability,error,error,14491,"revious fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y bin number; high: upper Y bin number. void ReleaseRangeY(); Release restrictions on the Y range of the histogram to be used in the fit. void SetRangeZ(Int_t low, Int_t high); Set",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:16889,Availability,error,error,16889,"de the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:17168,Availability,error,error,17168," the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:13111,Integrability,message,message,13111,"ension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:1822,Performance,perform,perform,1822,"ters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }. Assumptions. A few assumptions need to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; temp",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:11577,Performance,perform,performed,11577,"double& A_ki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:16689,Performance,perform,performed,16689,"bin number. void ReleaseRangeZ(); Release restrictions on the Z range of the histogram to be used in the fit. void ExcludeBin(Int_t bin); Exclude the given bin from the fit. The bin numbering to be used is that; of TH1::GetBin(). void IncludeBin(Int_t bin); Include the given bin in the fit, if it was excluded before using ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& mi",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:17084,Performance,perform,perform,17084,"ExcludeBin().; The bin numbering to be used is that of TH1::GetBin(). bool IsExcluded(Int_t bin) const; Function for internal use, checking whether the given bin is; excluded from the fit or not. void Constrain(Int_t parm, Double_t low, Double_t high); Constrain the values of parameter number <parm> (the parameter numbering; follows that of the input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int&",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:698,Safety,predict,predictions,698,". TFractionFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TFractionFitter. class TFractionFitter: public TObject. Fits MC fractions to data histogram (a la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f). The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; cout << ""fit status: "" << status << endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""sam",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:4609,Safety,predict,prediction,4609,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:11330,Safety,predict,predictions,11330,"double& A_ki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:12322,Safety,predict,predictions,12322,"double& A_ki) const; voidGetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; boolIsExcluded(Int_t bin) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit parameters). Note that; the hi",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:17332,Safety,predict,prediction,17332,"e input template vector).; Use UnConstrain() to remove this constraint. void UnConstrain(Int_t parm); Remove the constraints on the possible values of parameter <parm>. void CheckConsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""li",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:18131,Safety,predict,prediction,18131,"on. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:19691,Safety,predict,prediction,19691,"); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" underlying distribution; <m> describing the data <n>. Since <m> is unknown, the data distribution is; used instead,; lambda = L(y;n) / L(n;n).; Note that this ratio is 1 if the fit is perfect. The chi2 value is then; computed according to; chi2 = -2*ln(lambda).; This parameter can be shown to follow a Chi-square distribution. See for; example S. Baker and R. Cousins, ""Clarification of the use of chi-square; and likelihood functions in fits to histograms"", Nucl. Instr. Meth. A221,; pp. 437-442 (1984). Int_t GetNDF() const; return the number of degrees of freedom in the fit; the fNDF parameter has been previously computed during a fit.; The number of degrees of freedom corresponds to the number of points; used in the fit minus the number of templates. Double_t GetProb() const; return the fit probability. void ComputeChisquareLambda(); Method used internally to compute the likelihood ratio chi2; See the function GetChisquare() for details. TH1* GetMCPrediction(Int_t parm) const; Return the adjusted MC template (Aji) for template (parm).; Note that the (Aji) times fractions only sum to the total prediction; of the fit if all weights are 1. » Last changed: root/hist:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:3283,Security,access,access,3283,"much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by speci",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:14255,Security,access,access,14255,"); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high: upper X bin number. void ReleaseRangeX(); Release restrictions on the X range of the histogram to be used in the fit. void SetRangeY(Int_t low, Int_t high); Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; Use ReleaseRangeY() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower Y ",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:3163,Usability,simpl,simplify,3163,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:4649,Usability,simpl,simple,4649,"stricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is carried out through; Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through; fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by; TH1* result = fit->GetPlot();. Using different histograms. It is possible to change the histogram being fitted through; fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through; fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). Errors. Any serious inconsistency results in an error. Function Members (Methods); public:. TFractionFitter(); TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); virtual~TFractionFitter(); voidTObject::AbstractMethod(const char* method) const; virtual void",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFractionFitter.html:17553,Usability,simpl,simply,17553,"nsistency(); Function used internally to check the consistency between the; various histograms. Checks are performed on nonexistent or empty; histograms, the precise histogram class, and the number of bins.; In addition, integrals over the ""allowed"" bin ranges are computed.; Any inconsistency results in a error. Int_t Fit(); Perform the fit with the default UP value.; The value returned is the minimisation status. void ErrorAnalysis(Double_t UP); Set UP to the given value (see class TMinuit), and perform a MINOS minimisation. void GetResult(Int_t parm, Double_t& value, Double_t& error) const; Obtain the fit result for parameter <parm> (the parameter numbering; follows that of the input template vector). TH1* GetPlot(); Return the ""template prediction"" corresponding to the fit result (this is not; the same as the weighted sum of template distributions, as template statistical; uncertainties are taken into account).; Note that the name of this histogram will simply be the same as that of the; ""data"" histogram, prefixed with the string ""Fraction fit to hist: "". void GetRanges(Int_t& minX, Int_t& maxX, Int_t& minY, Int_t& maxY, Int_t& minZ, Int_t& maxZ) const; Used internally to obtain the bin ranges according to the dimensionality of; the histogram and the limits set by hand. void ComputeFCN(Int_t& npar, Double_t* gin, Double_t& f, Double_t* par, Int_t flag); Used internally to compute the likelihood value. void FindPrediction(int bin, double& t_i, int& k_0, double& A_ki) const; Function used internally to obtain the template prediction in the individual bins; 'bin' <=> 'i' (paper); 'par' <=> 'j' (paper). Double_t GetChisquare() const; Return the likelihood ratio Chi-squared (chi2) for the fit.; The value is computed when the fit is executed successfully.; Chi2 calculation is based on the ""likelihood ratio"" lambda,; lambda = L(y;n) / L(m;n),; where L(y;n) is the likelihood of the fit result <y> describing the data <n>; and L(m;n) is the likelihood of an unknown ""true"" u",MatchSource.WIKI,root/html534/TFractionFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFractionFitter.html
https://root.cern/root/html534/TFrame.html:1710,Availability,error,error,1710,"voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObjec",MatchSource.WIKI,root/html534/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrame.html
https://root.cern/root/html534/TFrame.html:1794,Availability,error,error,1794,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& frame) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBox::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTWbox::DrawWbox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Color_t color = 33, Short_t bordersize = 5, Short_t bordermode = -1); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Short_tTWbox::GetBorderMode() const; Short_tTWbox::GetBorderSize() const; Int_tTWbox::GetDarkColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; Int_tTWbox::GetLightColor() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); v",MatchSource.WIKI,root/html534/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrame.html
https://root.cern/root/html534/TFrame.html:8233,Availability,down,down,8233,"CurrentStyle()MENU ; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TBox::[unnamed] { kCannotMove; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Short_tTWbox::fBorderModeBordermode (-1=down, 0 = no border, 1=up); Short_tTWbox::fBorderSizewindow box bordersize in pixels; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Bool_tTBox::fResizing!True if box is being resized; Double_tTBox::fX1X of 1st point; Double_tTBox::fX2X of 2nd point; Double_tTBox::fY1Y of 1st point; Double_tTBox::fY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFrame(); Frame default constructor. TFrame(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Frame normal constructor. TFrame(const TFrame& frame); Frame copy constructor. ~TFrame(); Frame default destructor. void Copy(TObject& frame) const; Copy this frame to frame. void Draw(Option_t* option = """"); Draw this frame with its current attributes. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a TFrame object is clicked. void Paint(Option_t* option = """"); Paint this wbox with its current attributes. void Pop(); Do not pop frame's, if allowed they would cover t",MatchSource.WIKI,root/html534/TFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrame.html
https://root.cern/root/html534/TFrameEditor.html:4655,Availability,error,error,4655,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrameEditor.html
https://root.cern/root/html534/TFrameEditor.html:4739,Availability,error,error,4739,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrameEditor.html
https://root.cern/root/html534/TFrameEditor.html:17785,Availability,mask,mask,17785,,MatchSource.WIKI,root/html534/TFrameEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFrameEditor.html
https://root.cern/root/html534/TFree.html:2009,Availability,error,error,2009," last); virtual~TFree(); voidTObject::AbstractMethod(const char* method) const; TFree*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const",MatchSource.WIKI,root/html534/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFree.html
https://root.cern/root/html534/TFree.html:2093,Availability,error,error,2093,"e*AddFree(TList* lfree, Long64_t first, Long64_t last); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFree*GetBestFree(TList* lfree, Int_t nbytes); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; Long64_tGetLast() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html534/TFree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFree.html
https://root.cern/root/html534/TFriendElement.html:1918,Availability,error,error,1918,"s); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html534/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFriendElement.html
https://root.cern/root/html534/TFriendElement.html:2002,Availability,error,error,2002," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TFile*GetFile(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTree*GetParentTree() const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree(); virtual const char*GetTreeName() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, co",MatchSource.WIKI,root/html534/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFriendElement.html
https://root.cern/root/html534/TFriendElement.html:468,Modifiability,variab,variable,468,". TFriendElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TFriendElement. class TFriendElement: public TNamed. TFriendElement. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. To add a TFriendElement to an existing TTree T, do:; T.AddFriend(""friendTreename"",""friendTreeFile"");. See TTree::AddFriend for more information. Function Members (Methods); public:. TFriendElement(); TFriendElement(TTree* tree, const char* treename, const char* filename); TFriendElement(TTree* tree, const char* treename, TFile* file); TFriendElement(TTree* tree, TTree* friendtree, const char* alias); virtual~TFriendElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TTree*Connect(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual TTree*DisConnect(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t*",MatchSource.WIKI,root/html534/TFriendElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFriendElement.html
https://root.cern/root/html534/TFTP.html:1969,Availability,error,error,1969,"ectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t p",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:2053,Availability,error,error,2053,"onst; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFreeDirectory(Bool_t print = kFALSE); voidget(const char* file, const char* localName = 0); Int_tGetBlockSize() const; const char*GetDirEntry(Bool_t print = kFALSE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetFile(const char* file, const char* localName = 0); virtual const char*TObject::GetIconName() const; Int_tGetMode() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Long64_tGetRestartAt() const; TSocket*GetSocket() const; virtual con",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8660,Availability,error,error,8660,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8686,Availability,error,error,8686,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8825,Availability,error,error,8825,"d Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of f",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9125,Availability,error,error,9125,":port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you ar",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9168,Availability,error,error,9168,"will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can forc",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9216,Availability,failure,failure,9216,"is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(con",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9747,Availability,error,error,9747," EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote dire",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9790,Availability,error,error,9790,"essage kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in c",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:9838,Availability,failure,failure,9838,"and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = ",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:10395,Availability,echo,echoed,10395," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:10456,Availability,failure,failure,10456,"otd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Re",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:10649,Availability,failure,failure,10649," file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permission",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:10823,Availability,failure,failure,10823,"nection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11018,Availability,failure,failure,11018,"esired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remot",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11143,Availability,failure,failure,11143," the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in ca",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11322,Availability,failure,failure,11322,"e remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a File",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11481,Availability,failure,failure,11481,"ure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, ",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11680,Availability,failure,failure,11680,"nt_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, biza",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11774,Availability,failure,failure,11774,"t delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:11936,Availability,error,error,11936,"e options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetResta",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:12157,Availability,error,error,12157," cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) const; Delete a remote file. Anonymous users may not delete files.; Returns 0 in case of success and -1 in case of failure. Int_t ChangePermission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii)",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8944,Energy Efficiency,power,power,8944,"el = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() i",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:348,Integrability,protocol,protocol,348,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:7486,Integrability,protocol,protocol,7486,"Zombie(). private:. TFTP(); TFTP(const TFTP&); voidInit(const char* url, Int_t parallel, Int_t wsize); voidoperator=(const TFTP&); voidPrintError(const char* where, Int_t err) const; Int_tRecv(Int_t& status, EMessageTypes& kind) const; voidSetMode(Int_t mode). Data Members; public:. enum { kDfltBlockSize; kDfltWindowSize; kBinary; kAscii; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBlockSizesize of data buffer used to transfer; Long64_tfBytesReadnumber of bytes received; Long64_tfBytesWritenumber of bytes sent; TStringfCurrentFilefile currently being get or put; Bool_tfDirIndicates if a remote directory is open; TStringfHostFQDN of remote host; Int_tfLastBlocklast block successfully transfered; Int_tfModebinary or ascii file transfer mode; Int_tfParallelnumber of parallel sockets; Int_tfPortport to which to connect; Int_tfProtocolrootd protocol level; Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t ",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8495,Integrability,message,message,8495," Long64_tfRestartAtrestart transmission at specified offset; TSocket*fSocket! connection to rootd; TStringfUserremote user; Int_tfWindowSizetcp window size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; ",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8673,Integrability,depend,depending,8673,"dow size used; static Long64_tfgBytesReadnumber of bytes received by all TFTP objects; static Long64_tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* lo",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:8788,Integrability,message,message,8788,"tfgBytesWritenumber of bytes sent by all TFTP objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); Open connection to host specified by the url using par parallel sockets.; The url has the form: [root[s,k]://]host[:port].; If port is not specified the default rootd port (1094) will be used.; Using wsize one can specify the tcp window size. Normally this is not; needed when using parallel sockets.; An existing connection (TSocket *sock) can also be used to establish; the FTP session. void Init(const char* url, Int_t parallel, Int_t wsize); Set up the actual connection. ~TFTP(); TFTP dtor. Send close message and close socket. void Print(Option_t* opt = """") const; Print some info about the FTP connection. void PrintError(const char* where, Int_t err) const; Print error string depending on error code. Int_t Recv(Int_t& status, EMessageTypes& kind) const; Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of er",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:10332,Integrability,message,message,10332," not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = """") const; List remote directory. With cmd you specify the options and directory; to be listed to ls. Returns 0 in case of success and -1 in case of; failure. Int_t PrintDirectory() const; Print path of remote working directory. Returns 0 in case of succes and; -1 in cse of failure. Int_t RenameFile(const char* file1, const char* file2) const; Rename a remote file. Anonymous users may not rename files.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteFile(const char* file) cons",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:322,Performance,perform,performant,322,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:444,Performance,perform,performance,444,". TFTP. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TFTP. class TFTP: public TObject. TFTP. This class provides all infrastructure for a performant file; transfer protocol. It works in conjuction with the rootd daemon; and can use parallel sockets to improve performance over fat pipes. Function Members (Methods); public:. TFTP(const char* url, Int_t parallel = 1, Int_t wsize = kDfltWindowSize, TSocket* sock = 0); virtual~TFTP(); voidTObject::AbstractMethod(const char* method) const; Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); voidAscii(); voidascii(); voidbin(); voidBinary(); virtual voidTObject::Browse(TBrowser* b); voidbye(); voidcd(const char* dir) const; Int_tChangeDirectory(const char* dir) const; Int_tChangePermission(const char* file, Int_t mode) const; voidchmod(const char* file, Int_t mode) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; Int_tClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteDirectory(const char* dir) const; Int_tDeleteFile(const char* file) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:12543,Security,access,access,12543,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:12577,Security,access,access,12577,"rmission(const char* file, Int_t mode) const; Change permissions of a remote file. Anonymous users may not; chnage permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFTP.html:12624,Security,access,access,12624,"ge permissions. Returns 0 in case of success and -1 in case; of failure. Int_t Close(); Close ftp connection. Returns 0 in case of success and -1 in case of; failure. Bool_t OpenDirectory(const char* name, Bool_t print = kFALSE); Open a directory via rootd.; Returns kTRUE in case of success.; Returns kFALSE in case of error. void FreeDirectory(Bool_t print = kFALSE); Free a remotely open directory via rootd. const char * GetDirEntry(Bool_t print = kFALSE); Get directory entry via rootd.; Returns 0 in case no more entries or in case of error. Int_t GetPathInfo(const char* path, FileStat_t& buf, Bool_t print = kFALSE); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists, Bool_t print = kFALSE); Returns kFALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. TFTP(); { }. TFTP(const TFTP& ). void operator=(const TFTP& ). void SetMode(Int_t mode); { fMode = mode; }. Int_t GetBlockSize() const; { return fBlockSize; }. void SetRestartAt(Long64_t at); { fRestartAt = at; }. Long64_t GetRestartAt() const; { return fRestartAt; }. Int_t GetMode() const; { return fMode; }. Bool_t IsOpen() const; { return fSocket ? kTRUE : kFALSE; }. void Binary(); { SetMode(kBinary); }. void Ascii(); { SetMode(kAscii); }. TSocket * GetSocket() const; { return fSocket; }. void put(const char* file, const char* remoteName = 0); standard ftp equivalents... { PutFile(file, remoteName); }. void get(const char* file, const char* localName = 0); { GetFile(file, localName); }. void cd(const char* dir) const; { ChangeDirectory(dir); }. void mkdir(const char* dir) const; { MakeDirectory(dir); }. void rmdir(const char* dir) const; { DeleteDirectory(dir); }. void ls(Option_t* cmd = """") const; { ListDi",MatchSource.WIKI,root/html534/TFTP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFTP.html
https://root.cern/root/html534/TFumili.html:971,Availability,error,errors,971,". TFumili. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumili. class TFumili: public TVirtualFitter. FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. ; FUMILI minimization package; FUMILI is used to minimize Chi-square function or to search maximum of; likelihood function.; Experimentally measured values $F_i$ are fitted with theoretical; functions $f_i({\vec x}_i,\vec\theta\,\,)$, where ${\vec x}_i$ are; coordinates, and $\vec\theta$ -- vector of parameters.; For better convergence Chi-square function has to be the following form; $$; {\chi^2\over2}={1\over2}\sum^n_{i=1}\left(f_i(\vec; x_i,\vec\theta\,\,)-F_i\over\sigma_i\right)^2 \eqno(1); $$; where $\sigma_i$ are errors of measured function.; The minimum condition is; $$; {\partial\chi^2\over\partial\theta_i}=\sum^n_{j=1}{1\over\sigma^2_j}\cdot; {\partial f_j\over\partial\theta_i}\left[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expressi",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:2200,Availability,down,down,2200,"ft[f_j(\vec; x_j,\vec\theta\,\,)-F_j\right]=0,\qquad i=1\ldots m\eqno(2); $$; where m is the quantity of parameters.; Expanding left part of (2) over parameter increments and; retaining only linear terms one gets; $$; \left(\partial\chi^2\over\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k\left(\partial^2\chi^2\over\partial\theta_i\partial\theta_k\right)_{; \vec\theta={\vec\theta}^0}\cdot(\theta_k-\theta_k^0); = 0\eqno(3); $$; Here ${\vec\theta}_0$ is some initial value of parameters. In general; case:; $$; {\partial^2\chi^2\over\partial\theta_i\partial\theta_k}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k} +; \sum^n_{j=1}{(f_j - F_j)\over\sigma^2_j}\cdot; {\partial^2f_j\over\partial\theta_i\partial\theta_k}\eqno(4); $$; In FUMILI algorithm for second derivatives of Chi-square approximate; expression is used when last term in (4) is discarded. It is often; done, not always wittingly, and sometimes causes troubles, for example,; if user wants to limit parameters with positive values by writing down; $\theta_i^2$ instead of $\theta_i$. FUMILI will fail if one tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:4794,Availability,error,error,4794,"; virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ip",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:4878,Availability,error,error,4878,"(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tEval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Double_tEvalTFN(Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExecuteSetCommand(Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); virtual voidFitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidTVirtualFitter::GetConfidenceIntervals(TObject* obj, Double_t cl = ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:15634,Availability,error,errors,15634,"ble_tfGTExpected function change in next iteration; Double_t*fGr[fMaxParam] Gradients of objective function; Int_tfINDFLG[5]internal flags;; Int_tfLastFixedLast fixed parameter number; Bool_tfLogLikeLogLikelihood flag; Int_tfMaxParam; Int_tfNED1Number of experimental vectors X=(x1,x2,...xK); Int_tfNED12fNED1+fNED2; Int_tfNED2K - Length of vector X plus 2 (for chi2); Int_tfNfcnNumber of FCN calls;; Int_tfNlimMulfNlimMul - after fNlimMul successful iterations permits four-fold increasing of fPL; Int_tfNlog; Int_tfNmaxIterfNmaxIter - maximum number of iterations; Int_tfNparfNpar - number of parameters; Int_tfNstepDecfNstepDec - maximum number of step decreasing counter; Bool_tfNumericDerivatives; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vec",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:16470,Availability,error,errors,16470,"ves; Double_t*fPL[fMaxParam] Limits for parameters step. If <0, then parameter is fixed; Double_t*fPL0[fMaxParam] Step initial bounds; Double_t*fParamError[fMaxParam] Parameter errors; Double_t*fR[fMaxParam] Correlation factors; Double_tfRPPrecision of fit ( machine zero on CDC 6000) quite old yeh?; Double_tfSfS - objective function value (return); Double_t*fSumLog[fNlog]; Bool_tfWARNwarnings; Double_t*fZ[fMaxParam2] Invers fZ0 matrix - covariance matrix; Double_t*fZ0[fMaxParam2] Matrix of approximate second derivatives of objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:18279,Availability,error,errors,18279,"; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar paramete",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:19070,Availability,error,error,19070," nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; us",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:19394,Availability,error,error,19394,": command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:19699,Availability,error,errors,19699," Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Opti",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:20955,Availability,error,error,20955,"ar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:21189,Availability,error,errors,21189,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:21234,Availability,error,errors,21234,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:21278,Availability,error,errors,21278,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:21343,Availability,error,errors,21343,"rs. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:21786,Availability,error,error,21786,"de data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization func",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:22366,Availability,error,error,22366,"- print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bi",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:22951,Availability,error,error,22951,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23276,Availability,error,error,23276," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23916,Availability,error,error,23916,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:24502,Availability,error,error,24502,"in content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:22503,Deployability,release,released,22503,"; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Li",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:24751,Integrability,wrap,wrapper,24751,"in content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:17013,Modifiability,variab,variable,17013,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:17062,Modifiability,variab,variable,17062,"ance; Inherited Members; Includes; Libraries. Function documentation; TFumili(Int_t maxpar = 25); maxpar is the maximum number of parameters used with TFumili object. void BuildArrays(). Allocates memory for internal arrays. Called by TFumili::TFumili. ~TFumili(). TFumili destructor. Double_t Chisquare(Int_t npar, Double_t* params) const; return a chisquare equivalent. void Clear(Option_t* opt = """"). Resets all parameter names, values and errors to zero. Argument opt is ignored. NB: this procedure doesn't reset parameter limits. void DeleteArrays(). Deallocates memory. Called from destructor TFumili::~TFumili. void Derivatives(Double_t* , Double_t* ). Calculates partial derivatives of theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:19946,Modifiability,variab,variable,19946,"otalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following valu",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:20239,Modifiability,variab,variable,20239,"_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors a",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:13274,Performance,cache,cache,13274,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. Double_t*fA[fMaxParam] Fit parameter array; Double_tfAKAPPA; Double_t*fAMN[fMaxParam] Minimum param value; Double_t*fAMX[fMaxParam] Maximum param value; TString*fANames[fMaxParam] Parameter names; Double_t*fCmPar[fMaxParam] parameters of commands; TStringfCwordCommand st",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:17730,Performance,perform,performs,17730,"f theoretical function. Input:; fX - vector of data point; Output:; DF - array of derivatives. ARITHM.F; Converted from CERNLIB. Int_t Eval(Int_t& npar, Double_t* grad, Double_t& fval, Double_t* par, Int_t flag); Evaluate the minimisation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user. Inside FCN user has to define Z-matrix by means TFumili::GetZ; and TFumili::Derivatives,; set theoretical function by means of TFumili::SetUserFunc,; but first - pass number of parameters by TFumili::SetParNumber. Later values are determined by Fumili as it searches for the minimum; or performs whatever analysis is requested by the user. The default function calls the function specified in SetFCN. Double_t EvalTFN(Double_t* , Double_t* ); Evaluate theoretical function; df: array of partial derivatives; X: vector of theoretical function argument. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). Execute MINUIT commands. MINImize, SIMplex, MIGrad and FUMili all; will call TFumili::Minimize method. For full command list see; MINUIT. Reference Manual. CERN Program Library Long Writeup D506. Improvement and errors calculation are not yet implemented as well; as Monte-Carlo seeking and minimization.; Contour commands are also unsupported. command : command string; args : array of arguments; nargs : number of arguments. Int_t ExecuteSetCommand(Int_t ). Called from TFumili::ExecuteCommand in case; of ""SET xxx"" and ""SHOW xxx"". void FixParameter(Int_t ipar); Fixes parameter number ipar. Double_t * GetCovarianceMatrix() const; return a pointer t",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:22888,Performance,cache,cache,22888,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23210,Performance,cache,cache,23210," ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poiss",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23853,Performance,cache,cache,23853,"int the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // W",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:24436,Performance,cache,cache,24436,"in content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23674,Safety,predict,predict,23674,"arded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:24280,Safety,predict,predict,24280,"a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:3423,Testability,log,logarithm,3423,"sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dra",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:20042,Testability,log,log,20042,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:20064,Testability,log,log,20064,"(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; Get various ipar parameter attributs:. cname: parameter name; value: parameter value; verr: parameter error; vlow: lower limit; vhigh: upper limit; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; Return errors after MINOs; not implemented. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void Prin",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:22157,Testability,log,loglikelihood,22157,"arameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:23746,Testability,log,logs,23746,"uble_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:24352,Testability,log,logs,24352,"in content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitLikelihoodI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. TFumili(Int_t maxpar = 25); TF1 *fTFNF1; //Pointer to theoretical function; void (*fFCN) (Int_t &, Double_t *, Double_t &f, Double_t *, Int_t);; //wrapper function to calculate functional value, gradients and Z-matrix; Double_t (*fTFN)(Double_t *, Double_t *, Double_t*); // Wrapper function for TFN. Double_t* GetPL0() const; { return fPL0;}. Double_t* GetZ() const; { return fZ;}. void SetParNumber(Int_t ParNum); { fNpar = ParNum;}. » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumili.html:3193,Usability,simpl,simple,3193,"ne tries; minimize $\chi^2 = g^2(\vec\theta)$ where g is arbitrary function.; Approximate value is:; $${\partial^2\chi^2\over\partial\theta_i\partial\theta_k}\approx; Z_{ik}=; \sum^n_{j=1}{1\over\sigma^2_j}{\partial f_j\over\theta_i}; {\partial f_j\over\theta_k}\eqno(5); $$; Then the equations for parameter increments are; $$\left(\partial\chi^2\over\partial\theta_i\right)_{\vec\theta={\vec\theta}^0}; +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) = 0,; \qquad i=1\ldots m\eqno(6); $$; Remarkable feature of algorithm is the technique for step; restriction. For an initial value of parameter ${\vec\theta}^0$ a; parallelepiped $P_0$ is built with the center at ${\vec\theta}^0$ and; axes parallel to coordinate axes $\theta_i$. The lengths of; parallelepiped sides along i-th axis is $2b_i$, where $b_i$ is such a; value that the functions $f_j(\vec\theta)$ are quasi-linear all over; the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; $$; \theta_i^{\rm min}\le\theta_i\le\theta^{\rm max}_i\eqno(7); $$; They form parallelepiped $P$ ($P_0$ may be deformed by $P$).; Very similar step formulae are used in FUMILI for negative logarithm; of the likelihood function with the same idea - linearization of; function argument. Function Members (Methods); public:. TFumili(Int_t maxpar = 25); TFumili(const TFumili&); virtual~TFumili(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuildArrays(); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* opt = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArrays(); voidDerivatives(Double_t*, Double_t*); virtual In",MatchSource.WIKI,root/html534/TFumili.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumili.html
https://root.cern/root/html534/TFumiliMinimizer.html:5561,Availability,error,errors,5561,"gned int ivar, double upper); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7894,Availability,error,errors,7894," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8723,Availability,error,error,8723,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8733,Availability,error,error,8733,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8803,Availability,error,errors,8803,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:9042,Availability,error,errors,9042,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7843,Deployability,update,update,7843," there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. dou",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:387,Integrability,interface,interface,387,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:6512,Integrability,interface,interface,6512,"sminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, cons",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:6762,Integrability,interface,interface,6762," doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. b",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:6846,Integrability,interface,interface,6846,"d by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7037,Integrability,interface,interface,7037,"Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:460,Modifiability,plug-in,plug-in,460,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:478,Modifiability,plug-in,plug-in,478,". TFumiliMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » FUMILI; » TFumiliMinimizer. class TFumiliMinimizer: public ROOT::Math::Minimizer. TFumiliMinimizer class implementing the ROOT::Math::Minimizer interface using; TFumili.; This class is normally instantiates using the plug-in manager; (plug-in with name Fumili or TFumili); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TFumiliMinimizer(int dummy = 0); virtual~TFumiliMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::Minimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings&) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; virtual boolROOT::Math::Minimizer::IsFixedVariable(unsigned int ivar) const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7372,Modifiability,variab,variable,7372,"ivate). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of f",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7503,Modifiability,variab,variable,7503,"passing a function object implement the; basic multi-dim Function interface. In this case the derivatives will be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is t",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7588,Modifiability,variab,variable,7588,"ll be; calculated by Fumili. void SetFunction(const ROOT::Math::IMultiGradFunction & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7660,Modifiability,variab,variable,7660," & func); Set the objective function to be minimized, by passing a function object implement the; multi-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8467,Modifiability,variab,variables,8467,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8564,Modifiability,variab,variables,8564,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:8956,Modifiability,variab,variable,8956,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:9014,Modifiability,variab,variables,9014,"& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const. return covariance matrix status. » Author: L. Moneta Wed Oct 25 16:28:55 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/fumili:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:7693,Performance,perform,perform,7693,"ulti-dim gradient Function interface. In this case the function derivatives are provided; by the user via this interface and there not calculated by Fumili. void Fcn(int& , double* , double& f, double* , int ); implementation of FCN static function used internally by TFumili.; Adapt IMultiGenFunction interface to TFumili FCN static function. double EvaluateFCN(const double* x, double* g); function callaed to evaluate the FCN at the value x; calculates also the matrices of the second derivatives of the objective function needed by FUMILI. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int ivar, double val); set the variable value. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return fEdm; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and er",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFumiliMinimizer.html:5578,Security,validat,validated,5578,"gned int ivar, double upper); virtual boolSetVariableValue(unsigned int ivar, double val); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. static doubleEvaluateFCN(const double* x, double* g); static voidFcn(int&, double*, double& f, double*, int). private:. TFumiliMinimizer(const TFumiliMinimizer&); TFumiliMinimizer&operator=(const TFumiliMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; doublefEdm; vector<double>fErrors; TFumili*fFumili; doublefMinVal; unsigned intfNFree; vector<double>fParams; static TFumili*fgFumilistatic instance (used by fcn function) ; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>*fgFunc; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>*fgGradFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFumiliMinimizer(int dummy = 0); Constructor for TFumiliMinimier class. ~TFumiliMinimizer(); Destructor implementation. TFumiliMinimizer(const TFumiliMinimizer& ); Implementation of copy constructor (it is private). void SetFunction(const ROOT::Math::IMultiGenFunction & func); Set the objective function to be minimized, by passing a function object implement the; basic multi-",MatchSource.WIKI,root/html534/TFumiliMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFumiliMinimizer.html
https://root.cern/root/html534/TFunction.html:1607,Availability,error,error,1607,"nction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunction.html:1691,Availability,error,error,1691,"t char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfMethodArgs(); virtual const char*GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tGetNargs() const; Int_tGetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetPrototype() co",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunction.html:8278,Availability,error,error,8278,"fault TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". std::string GetReturnTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunction.html:8393,Availability,error,error,8393,"fault TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". std::string GetReturnTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunction.html:8024,Integrability,interface,interface,8024,"fault TFunction ctor. TFunctions are constructed in TROOT via; a call to TCint::UpdateListOfGlobalFunctions(). TFunction(const TFunction& orig); Copy operator. TFunction& operator=(const TFunction& rhs); Assignment operator. ~TFunction(); TFunction dtor deletes adopted CINT MethodInfo. TObject * Clone(const char* newname = """") const; Clone method. void CreateSignature(); Using the CINT method arg information to create a complete signature string. const char * GetSignature(); Return signature of function. TList * GetListOfMethodArgs(); Return list containing the TMethodArgs of a TFunction. const char * GetReturnTypeName() const; Get full type description of function return type, e,g.: ""class TDirectory*"". std::string GetReturnTypeNormalizedName() const; Get the normalized name of the return type. A normalized name is fully; qualified and has all typedef desugared except for the 'special' typedef; which include Double32_t, Float16_t, [U]Long64_t and std::string. It; also has std:: removed [This is subject to change]. Int_t GetNargs() const; Number of function arguments. Int_t GetNargsOpt() const; Number of function optional (default) arguments. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void * InterfaceMethod() const; Return pointer to the interface method. Using this pointer we; can find which TFunction belongs to a CINT MethodInfo object.; Both need to have the same InterfaceMethod pointer. const char * GetMangledName() const; Returns the mangled name as defined by CINT, or 0 in case of error. const char * GetPrototype() const; Returns the prototype of a function as defined by CINT, or 0 in; case of error. » Author: Fons Rademakers 07/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunction.html:484,Security,access,accessible,484,". TFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TFunction. class TFunction: public TDictionary. Global functions class (global functions are obtaine from CINT).; This class describes one single global function.; The TROOT class contains a list of all currently defined global; functions (accessible via TROOT::GetListOfGlobalFunctions()). Function Members (Methods); public:. TFunction(MethodInfo_t* info = 0); TFunction(const TFunction& orig); virtual~TFunction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html534/TFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunction.html
https://root.cern/root/html534/TFunctionParametersDialog.html:4777,Availability,error,error,4777,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:4861,Availability,error,error,4861,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:19617,Availability,mask,mask,19617,,MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:21479,Availability,error,errors,21479,::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y positi,MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:8265,Deployability,update,update,8265,"nt_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTGFrame::GetOptions() const; const TGWindow*TGWindow::GetParent() const; static const TGGC&TGFrame::GetShadowGC(); TGDimensionTGFrame::GetSize() const; Int_tTGCompositeFrame::GetState(TGFrame* f) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; static const TGGC&TGFrame::GetWhiteGC(); static Pixel_tTGFrame::GetWhitePixel(); UInt_tTGFrame::GetWidth() const; const char*TGMainFrame::GetWindowName() const; voidTGMainFrame::GetWMPosition(Int_t& x, Int_t& y) const; voidTGMainFrame::GetWMSize(UInt_t& w, UInt_t& h) const; voidTGMainFrame::GetWMSizeHints(UInt_t& wmin, UInt_t& hmin, UInt_t& wmax, UInt_t& hmax, UInt_t& winc, UInt_t& hinc) const; EInitialStateTGMainFrame::GetWMState() const; Int_tTGFrame::GetX() const; Int_tTGFrame::GetY() const; virtual Bool_tTGMainFrame::HandleButton(Event_t* event); virtual voidHandleButtons(Bool_t update); virtual Bool_tTGMainFrame::HandleClientMessage(Event_t* event); virtual Bool_tTGFrame::HandleColormapChange(Event_t*); virtual Bool_tTGFrame::HandleConfigureNotify(Event_t* event); virtual Bool_tTGCompositeFrame::HandleCrossing(Event_t*); virtual Bool_tTGFrame::HandleDNDDrop(TDNDData*); virtual Atom_tTGFrame::HandleDNDEnter(Atom_t*); virtual Bool_tTGFrame::HandleDNDFinished(); virtual Bool_tTGFrame::HandleDNDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:20032,Deployability,update,updated,20032,"class name; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*fContFixcontainer of fix settings; TGCompositeFrame*fContMaxcontainer of max range values; TGCompositeFrame*fContMincontainer of min range values; TGCompositeFrame*fContNamcontainer of parameter names; TGCompositeFrame*fContSldcontainer of sliders; TGCompositeFrame*fContValcontainer of parameter values; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TVirtualPad*fFpadpad where the function is drawn; TF1*fFuncfunction passed to this dialog; Bool_tfHasChangeskTRUE if function was redrawn;; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tfImmediateDrawkTRUE if function is updated on run-time; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; const TGWindow*TGTransientFrame::fMainwindow over which to popup dialog; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); Int_tfNPnumber of function parameters; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawk",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:21976,Deployability,update,update,21976,dow used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; TGTextButton*fOKCancel button; UInt_tTGFrame::fOptionsframe options; TGCheckButton**fParFixfix setting check buttons; TGNumberEntryField**fParMaxmax range values; TGNumberEntryField**fParMinmin range values; TGTextEntry**fParNamparameter names; TGTripleHSlider**fParSldtriple sliders; TGNumberEntry**fParValparameter values; const TGWindow*TGWindow::fParentParent window; Double_t*fPerroriginal patameters' errors; Double_t*fPmaxmax limits of patameters range; Double_t*fPminmin limits of patameters range; Double_t*fPvaloriginal patameters' values; Double_tfRXmaxoriginal max range; Double_tfRXminoriginal min range; Double_tfRangexmaxmax limits of patameters range; Double_tfRangexminmin limits of patameters range; TGTextButton*fResetReset button; TStringTGMainFrame::fResourceNameWM resource name; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fUpdateImmediate update check button; UInt_tTGMainFrame::fWMHeightWM height; UInt_tTGMainFrame::fWMHeightIncWM height increments; EInitialStateTGMainFrame::fWMInitStateWM initial state; UInt_tTGMainFrame::fWMMaxHeightWM max height; UInt_tTGMainFrame::fWMMaxWidthWM max width; UInt_tTGMainFrame::fWMMinHeightWM min height; UInt_tTGMainFrame::fWMMinWidthWM min width; UInt_tTGMainFrame::fWMWidthWM width; UInt_tTGMainFrame::fWMWidthIncWM width increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTG,MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:24463,Deployability,update,update,24463,"Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. » Author: Ilka Antcheva 08/05/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TFunctionParametersDialog.html:24490,Integrability,depend,dependent,24490,"Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFunctionParametersDialog(const TGWindow* p, const TGWindow* main, TF1* func, TVirtualPad* pad, Double_t rmin, Double_t rmax); Create the parameters' dialog of currently selected function 'func'. ~TFunctionParametersDialog(); Destructor. void CloseWindow(); Close parameters' dialog. void DoCancel(); Slot related to the Cancel button. void DoFix(Bool_t on); Slot related to the Fix check button. void DoOK(); Slot related to the OK button. void DoApply(); Slot related to the Preview button. void DoReset(); Slot related to the Reset button. void DoSlider(); Slot related to the parameters' value settings. void DoParValue(); Slot related to the parameter value settings. void DoParMinLimit(); Slot related to the minumum parameter limit settings. void DoParMaxLimit(); Slot related to the maximum parameter limit settings. void RedrawFunction(); Redraw function graphics. void HandleButtons(Bool_t update); Handle the button dependent states in this dialog. » Author: Ilka Antcheva 08/05/06 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TFunctionParametersDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TFunctionParametersDialog.html
https://root.cern/root/html534/TG16ColorSelector.html:784,Availability,down,down,784,". TG16ColorSelector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TG16ColorSelector. class TG16ColorSelector: public TGCompositeFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TG16ColorSelector(const TGWindow* p = 0); virtual~TG16ColorSelector(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual",MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TG16ColorSelector.html:4773,Availability,error,error,4773,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDef",MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TG16ColorSelector.html:4857,Availability,error,error,4857,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFram",MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TG16ColorSelector.html:17338,Availability,mask,mask,17338,,MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TG16ColorSelector.html:18104,Integrability,message,messages,18104,"ame*fCe[16]matrix of color cells; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*fMsgWindowwindow handling container messages; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedB",MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TG16ColorSelector.html:19817,Integrability,message,messages,19817,"me::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TG16ColorSelector(const TGWindow* p = 0); TG16ColorSelector constructor.; The TG16ColorSelector is a composite frame with 16 TGColorFrames. ~TG16ColorSelector(); TG16ColorSelector destructor. void SetActive(Int_t newat); Set active color frame. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for TG16ColorSelector. TGColorFrame& operator=(const TG16ColorSelector& ). TG16ColorSelector(const TG16ColorSelector& ). Int_t GetActive(); { return fActive; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-13 19:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TG16ColorSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TG16ColorSelector.html
https://root.cern/root/html534/TGApplication.html:3918,Availability,error,error,3918,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:4002,Availability,error,error,4002,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virt",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:4146,Availability,error,error,4146,"); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; v",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:8007,Availability,error,error,8007,"Libs(); Bool_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const c",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:8128,Availability,error,error,8128,"tual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTApplication::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTApplication::SetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); voidTApplication::SetReturnFromRun(Bool_t ret); virtual vo",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:11187,Availability,error,error,11187,"t_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; const char*TApplication::WorkingDirectory() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGApplication(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTApplication::Help(const char* line); virtual voidLoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelet",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGApplication.html:12106,Availability,avail,available,12106,"; static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TGClient*fClientpointer to the client environment; char*fDisplaydisplay server to connect to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGApplication(const char* appClassName, Int_t* argc, char** argv, void* options = 0, Int_t numOptions = 0); Create a GUI application environment. Use this class if you only; want to use the ROOT GUI and no other services. In all other cases; use either TApplication or TRint. ~TGApplication(); TGApplication dtor. void LoadGraphicsLibs(); Load shared libs necessary for GUI. void GetOptions(Int_t* argc, char** argv); Handle command line arguments. Arguments handled are removed from the; argument array. Currently only option ""-display xserver"" is considered. TGApplication(); { }. ",MatchSource.WIKI,root/html534/TGApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGApplication.html
https://root.cern/root/html534/TGaxis.html:3726,Availability,error,error,3726,"nst TObject* obj) const; virtual voidTLine::Copy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTLine::GetBBox(); virtual TPointTLine::GetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:3810,Availability,error,error,3810,"Object::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTLine::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTLine::GetBBox(); virtual TPointTLine::GetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction() const; Float_tGetGridLength() const; virtual const char*TObject::GetIconName() const; Int_tGetLabelColor() const; Int_tGetLabelFont() const; Float_tGetLabelOffset() const; Float_tGetLabelSize() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; static Int_tGetMaxDigits(); virtual const char*GetName() const; Int_tGetNdiv() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:21780,Modifiability,inherit,inherited,21780,"tripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeOffset(Double_t toffset, Option_t* option = ""local""); Change the time offset.; If option =",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:19246,Performance,optimiz,optimization,19246,"k mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:19290,Performance,optimiz,optimized,19290,"tered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary d",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:19323,Performance,optimiz,optimization,19323,"divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer values for the labels. Input parameters:. A1,A2 : Old WMIN,WMAX .; binLow,binHigh : New WMIN,WMAX .; nold : Old NDIV (primary divisions); nbins : New NDIV . void LabelsLimits(const ",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:15043,Testability,log,logarithmic,15043,"axis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, const char* funcname, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); TGaxis constructor with a TF1 to map axis values. See explanation of parameters in PaintAxis; Instead of the wmin,wmax arguments of the normal constructor, the; name of a TF1 function can be specified. This function will be used; by TGaxis::PaintAxis to map the user coordinates to the axis values; and ticks.; Examples:; void gaxis3a(); {; gStyle->SetOptStat(0);. TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();. TF1 *f1=new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();. TF1 *f2=new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();. TF1 *f3=new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }. /*; ; */. TGaxis(const TGaxis& ); Copy constructor. TGaxis& operator=(const TGaxis& ); Assignement operator. ~TGaxis(); TGaxis default destructor. void CenterLabels(Bool_t center = kTRUE); If center = kTRUE axis labels are centered in the center of the bin.; The default is to center on the primary tick marks.; This option does not make sense if there are more bins than tick marks. void CenterTitle(Bool_t center = kTRUE); If center = kTRUE axis title will be centered.; The default is right adjusted. void DrawAxis(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax, Double_t wmin, Double_t wmax, Int_t ndiv = 510, Option_t* chopt = """", Double_t gridlength = 0); Draw this axis with new attributes. Int_t GetMaxDigits(); Static function returning fgMaxDigits (See SetMaxDigits). void ImportAxisAttributes(TAxis* axis); Copy TAxis attributes to",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:19117,Testability,log,log,19117," adjusted on tick mark.; (default is centered); chopt='L': labels are Left adjusted on tick mark.; chopt='C': labels are Centered on tick mark.; chopt='M': In the Middle of the divisions. Format of labels. Blank characters are stripped, and then the; label is correctly aligned. the dot, if last; character of the string, is also stripped,; unless the option ""."" (a dot, or period) is specified.; if SetDecimals(kTRUE) has been called (bit TAxis::kDecimals set).; all labels have the same number of decimals after the "".""; The same is true if gStyle->SetStripDecimals(kFALSE) has been called. In the following, we have some parameters, like; tick marks length and characters height (in percentage; of the length of the axis (WC)); The default values are as follows:. Primary tick marks: 3.0 %; Secondary tick marks: 1.5 %; Third order tick marks: .75 %; Characters height for labels: 4%. Labels offset: 1.0 %. optional grid. chopt='W': cross-Wire; In case of a log axis, the grid is only drawn for the primary tick marks; if the number of secondary and tertiary divisions is 0. Axis bining optimization. By default the axis bining is optimized . chopt='N': No bining optimization; chopt='I': Integer labelling. Maximum Number of Digits for the axis labels. See the static function TGaxis::SetMaxDigits. Time representation. Axis labels may be considered as times, plotted in a defined time format.; The format is set with SetTimeFormat().; wmin and wmax are considered as two time values in seconds.; The time axis will be spread around the time offset value (set with; SetTimeOffset() ). Actually it will go from TimeOffset+wmin to; TimeOffset+wmax.; see examples in tutorials timeonaxis.C and timeonaxis2.C. chopt='t': Plot times with a defined format instead of values. void AdjustBinSize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BinWidth); Axis labels optimisation. This method adjusts the bining of the axis; in order to have integer valu",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGaxis.html:21684,Testability,log,log,21684,"etDecimals(Bool_t dot = kTRUE); Set the Decimals flag; By default, blank characters are stripped, and then the; label is correctly aligned. The dot, if last character of the string,; is also stripped, unless this option is specified.; One can disable the option by calling axis.SetDecimals(kTRUE).; Note the bit is set in fBits (as opposed to fBits2 in TAxis!). void SetFunction(const char* funcname = """"); Specify a function to map the axis values. void SetMaxDigits(Int_t maxd = 5); Static function to set fgMaxDigits for axis.; fgMaxDigits is the maximum number of digits permitted for the axis; labels above which the notation with 10^N is used.; For example, to accept 6 digits number like 900000 on an axis; call TGaxis::SetMaxDigits(6). The default value is 5.; fgMaxDigits must be greater than 0. void SetName(const char* name); Change the name of the axis. void SetMoreLogLabels(Bool_t more = kTRUE); Set the kMoreLogLabels bit flag.; When this option is selected more labels are drawn when in log scale; and there is a small number of decades (<3).; Note that this option is automatically inherited from TAxis. void SetNoExponent(Bool_t noExponent = kTRUE); Set the NoExponent flag.; By default, an exponent of the form 10^N is used when the label values; are either all very small or very large.; One can disable the exponent by calling axis.SetNoExponent(kTRUE). void SetOption(Option_t* option = """"); To set axis options. void SetTitle(const char* title = """"); Change the title of the axis. void SetTimeFormat(const char* tformat); Change the format used for time plotting.; The format string for date and time use the same options as the one used; in the standard strftime C function, i.e. :; for date :; %a abbreviated weekday name; %b abbreviated month name; %d day of the month (01-31); %m month (01-12); %y year without century. for time :; %H hour (24-hour clock); %I hour (12-hour clock); %p local equivalent of AM or PM; %M minute (00-59); %S seconds (00-61); %% %. void SetTimeO",MatchSource.WIKI,root/html534/TGaxis.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGaxis.html
https://root.cern/root/html534/TGButton.html:2205,Availability,avail,available,2205,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGButton(const TGWindow* p = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtu",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:6719,Availability,error,error,6719,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::Ge",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:6803,Availability,error,error,6803,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObjec",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:19372,Availability,mask,mask,19372,,MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:20420,Availability,down,down,20420,element; TGButtonGroup*fGroupbutton group this button belongs to; UInt_tTGFrame::fHeightframe height; Pixel_tfHighColorhighlight color; Handle_tTGObject::fIdX11/Win32 Window identifier; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC,MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:21562,Deployability,release,released,21562,s from this object; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tfNormGCgraphics context used for drawing button; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStatefStatebutton state; Bool_tfStayDowntrue if button has to stay down; UInt_tfStylebutton style (modern or classic); UInt_tfTHeightbutton height; UInt_tfTWidthbutton width; TGToolTip*fTiptool tip associated with button; void*fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tfgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:1931,Integrability,message,message,1931,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:738,Performance,perform,perform,738,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:628,Security,access,access,628,". TGButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButton. class TGButton: public TGFrame, public TGWidget. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button ",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButton.html:1406,Testability,log,logical,1406," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html534/TGButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButton.html
https://root.cern/root/html534/TGButtonGroup.html:2047,Availability,down,down,2047," ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetD",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:7078,Availability,error,error,7078,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCom",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:7162,Availability,error,error,7162,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGButton*Find(Int_t id) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TGButton*GetButton(Int_t id) const; TGClient*TGObject::GetClient() const; Int_tGetCount() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGGroupFrame::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGGroupFrame::GetDefaultGC(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBack",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:16309,Availability,down,down,16309,"t(UInt_t emask); virtual voidTGGroupFrame::Rename(const char* title)MENU ; virtual voidTGFrame::ReparentWindow(const TGWindow* p, Int_t x = 0, Int_t y = 0); virtual voidTGWindow::RequestFocus(); voidTObject::ResetBit(UInt_t f); virtual voidTGFrame::Resize(TGDimension size); virtual voidTGFrame::Resize(UInt_t w = 0, UInt_t h = 0); virtual voidTGObject::SaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); virtual voidTGCompositeFrame::SavePrimitiveSubframes(ostream& out, Option_t* option = """"); voidTGFrame::SaveUserColor(ostream& out, Option_t*); virtual voidTGFrame::SendMessage(const TGWindow* w, Long_t msg, Long_t parm1, Long_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBorderDrawn(Bool_t enable = kTRUE); virtual voidSetButton(Int_t id, Bool_t down = kTRUE); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidSetExclusive(Bool_t flag = kTRUE); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidSetLayoutHints(TGLayoutHints* l, TGButton* button = 0); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWi",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:21117,Availability,mask,mask,21117,,MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:25778,Availability,down,down,25778,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:25826,Availability,down,down,25826,"yle"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as their parent widget. An exception is when you want custom; identifiers instead of the default 1, 2, 3 etc. The button is assigned the identifier id or an automatically; generated identifier. It works as follows: If id > 0, this; identifier is assigned. If id == -1 (default), the identifier is; equal to the number of buttons in the group+1. If id is any other; negative integer, for instance -2, a unique identifier (negative; integer <= -2) is generated. Inserting several buttons with id = -1 assigns the identifiers 1,; 2, 3, etc. void Remove(TGButton* button); Removes a button from the button group. TGButton * Find(Int_t id) const; Finds and returns a pointer to the button with the specifi",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:798,Deployability,toggle,toggle,798,". TGButtonGroup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGButtonGroup. class TGButtonGroup: public TGGroupFrame. The TGButtonGroup widget organizes TGButton widgets in a group. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is e",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:2164,Deployability,release,released,2164,"parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TStrin",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:25139,Deployability,toggle,toggle,25139," column. TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); Constructor. Layout defined by TGMatrixLayout:; r = number of rows; c = number of columns; s = interval between frames; h = layout hints. void Init(); Default init. ~TGButtonGroup(); Destructor, we do not delete the buttons. void DoRedraw(); Redraw the group frame. Need special DoRedraw() since we need to; redraw with fBorderWidth=0. void DrawBorder(); Draw border of around the group frame. if frame is kRaisedFrame - a frame border is of ""wall style"",; otherwise of ""groove style"". void SetBorderDrawn(Bool_t enable = kTRUE); Makes border to be visible/invisible. void SetExclusive(Bool_t flag = kTRUE); Sets the button group to be exclusive if enable is kTRUE,; or to be non-exclusive if enable is kFALSE.; An exclusive button group switches off all other toggle buttons when; one is switched on. This is ideal for groups of radio-buttons; A non-exclusive group allow many buttons to be switched on at the same; time. The default setting is kFALSE. void SetRadioButtonExclusive(Bool_t flag = kTRUE); If enable is kTRUE, this button group will treat radio buttons as; mutually exclusive, and other buttons according to IsExclusive().; This function is called automatically whenever a TGRadioButton; is inserted, so you should normally never have to call it. void SetState(Bool_t state = kTRUE); Sets the state of all the buttons in the group to enable or disable. void SetButton(Int_t id, Bool_t down = kTRUE); Sets the button with id to be on/down, and if this is an; exclusive group, all other button in the group to be off/up. Int_t Insert(TGButton* button, int id = -1); Inserts a button with the identifier id into the button group.; Returns the button identifier. It is not necessary to manually insert buttons that have this button; group as the",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:1378,Modifiability,inherit,inherits,1378,"roup. A button group widget makes it easier to deal with groups of buttons.; A button in a button group is associated with a unique identifier.; The button group emits a Clicked() signal with this identifier when; the button is clicked. Thus, a button group is an ideal solution; when you have several similar buttons and want to connect all their; Clicked() signals, for example, to one slot. An exclusive button group switches off all toggle buttons except; the one that was clicked. A button group is by default non-exclusive.; All radio buttons that are inserted, will be mutually exclusive even; if the button group is non-exclusive. There are two ways of using a button group:. The button group is a parent widget of a number of buttons,; i.e. the button group is the parent argument in the button; constructor. The buttons are assigned identifiers 1, 2, 3 etc.; in the order they are created or you can specify button id in ; the button constructor. A TGButtonGroup can display a frame and; a title because it inherits from TGGroupFrame. Example:. vertical frame without border and title; TGVButtonGroup *bg = new TGVButtonGroup(main_frame);. create text button with id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widg",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:2520,Modifiability,inherit,inherits,2520,"th id=1; TGTextButton *button1 = new TGTextButton(bg,""some text"");. create another text button with id=2; TGTextButton *button2 = new TGTextButton(bg,""another text"");. map all buttons; bg->Show();. NOTE: there is no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendP",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGButtonGroup.html:2733,Modifiability,inherit,inherits,2733,"no need to call AddFrame() since the buttons are; automatically added with a default layout hint to their parent,; i.e. the buttongroup. To override the default layout hints use the; SetLayoutHints() method. ButtonGroup Signals:. Pressed(Int_t id) --> is emitted when a button in the group is; pressed down. The id argument is the; button's identifier.; Released(Int_t id) --> is emitted when a button in the group is; released. The id argument is the button's; identifier.; Clicked(Int_t id) --> is emitted when a button in the group is; clicked. The id argument is the button's; identifier. The TGHButtonGroup widget organizes TGButton widgets in a group; with one horizontal row. TGHButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. The TGVButtonGroup widget organizes TGButton widgets in a group; with one vertical column. TGVButtonGroup is a convenience class that; offers a thin layer on top of TGButtonGroup. It inherits from; TGButtonGroup. Function Members (Methods); public:. TGButtonGroup(const TGWindow* parent = 0, const TString& title = """", UInt_t options = kChildFrame|kVerticalFrame, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); TGButtonGroup(const TGWindow* parent, UInt_t r, UInt_t c, Int_t s = 0, Int_t h = 0, const TString& title = """", GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), Pixel_t back = GetDefaultFrameBackground()); virtual~TGButtonGroup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtua",MatchSource.WIKI,root/html534/TGButtonGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGButtonGroup.html
https://root.cern/root/html534/TGCanvas.html:5256,Availability,error,error,5256,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() ",MatchSource.WIKI,root/html534/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCanvas.html
https://root.cern/root/html534/TGCanvas.html:5340,Availability,error,error,5340,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TGFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::GetDro",MatchSource.WIKI,root/html534/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCanvas.html
https://root.cern/root/html534/TGCanvas.html:16876,Availability,mask,mask,16876,,MatchSource.WIKI,root/html534/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCanvas.html
https://root.cern/root/html534/TGCanvas.html:19474,Integrability,message,message,19474,":fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGCanvas(const TGWindow* p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create a canvas object. ~TGCanvas(); Delete canvas. void MapSubwindows(); Map all canvas sub windows. void AddFrame(TGFrame* f, TGLayoutHints* l = 0); Adding a frame to a canvas is actually adding the frame to the; viewport container. The viewport container must be at least a; TGCompositeFrame for this method to succeed. void DrawBorder(); Draw canvas border. void Layout(); Create layout for canvas. Depending on the size of the container; we need to add the scrollbars. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle message generated by the canvas scrollbars. Int_t GetHsbPosition() const; Get position of horizontal scrollbar. Int_t GetVsbPosition() const; Get position of vertical scrollbar. void SetHsbPosition(Int_t newPos); Set position of horizontal scrollbar. void SetVsbPosition(Int_t newPos); Set position of vertical scrollbar. void SetScrolling(Int_t scrolling); Set scrolling policy. Use values defined by the enum: kCanvasNoScroll,; kCanvasScrollHorizontal, kCanvasScrollVertical, kCanvasScrollBoth. void ClearViewPort(); Clear view port and redraw content. void SavePrimitive(ostream& out, Option_t* option = """"); Save a canvas widget as a C++ statement(s) on output stream out. TGContainer& operator=(const TGCanvas& ). TGHScrollBar * GetHScrollbar() const. TGVScrollBar * GetVScrollbar() const. TGFrame * GetContainer() const; { return fContainer; }. void SetContainer(TGFrame* f). TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fHeight); }. TGCanvas(const TGCanvas& )",MatchSource.WIKI,root/html534/TGCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCanvas.html
https://root.cern/root/html534/TGCheckButton.html:2208,Availability,avail,available,2208,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGCheckButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p = 0, const c",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:7188,Availability,error,error,7188,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:7272,Availability,error,error,7272,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDDa",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:21648,Availability,mask,mask,21648,,MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:23387,Availability,down,down,23387,tButton::fMTopmargin top; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*fOffbutton OFF picture; const TGPicture*fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:24859,Deployability,release,released,24859, window; EButtonStatefPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static const TGFont*TGTextButton::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static const TGGC*fgDefaultGC; static const TGGC*TGButton::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGButton::fgHibckgndGC; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static Window_tTGButton::fgReleaseBtnthe last released button; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel.,MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:1934,Integrability,message,message,1934,"""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Method",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:741,Performance,perform,perform,741,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:631,Security,access,access,631,". TGCheckButton. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGCheckButton. class TGCheckButton: public TGTextButton. TGButton, TGTextButton, TGPictureButton, TGCheckButton,; TGRadioButton and TGSplitButton. This header defines all GUI button widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- butt",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGCheckButton.html:1409,Testability,log,logical,1409," widgets. TGButton is a button abstract base class. It defines general button; behaviour. TGTextButton and TGPictureButton yield an action as soon as they are; clicked. These buttons usually provide fast access to frequently; used or critical commands. They may appear alone or placed in a; group. The action they perform can be inscribed with a meaningful tooltip; set by SetToolTipText(const char* text, Long_t delayms=400). The text button has a label indicating the action to be taken when; the button is pressed. The text can be a hot string (""&Exit"") that; defines the label ""Exit"" and keyboard mnemonics Alt+E for button; selection. A button label can be changed by SetText(new_label). Selecting a text or picture button will generate the event:; kC_COMMAND, kCM_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked",MatchSource.WIKI,root/html534/TGCheckButton.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGCheckButton.html
https://root.cern/root/html534/TGClient.html:3721,Availability,error,error,3721,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:3805,Availability,error,error,3805,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceRedraw(); voidFreeColor(Pixel_t color) const; voidFreeFont(const TGFont* font); voidFreeGC(const TGGC* gc); voidFreeGC(GContext_t gc); voidFreePicture(const TGPicture* pic); Bool_tGetColorByName(const char* name, Pixel_t& pixel) const; Colormap_tGetDefaultColormap() const; const TGWindow*GetDefaultRoot() const; UInt_tGetDisplayHeight() const; UInt_tGetDisplayWidth() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGFont*GetFont(const TGFont* font); TGFont*GetFont(const char* font, Bool_t fixedDefault = kTRUE); FontStruct_tGetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; TGFontPool*GetFontPool() const; TGGC*GetGC(GCValues_t* values, Bool_t rw = ",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:14676,Availability,error,error,14676," is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_co",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:15456,Availability,error,error,15456,"d FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHand",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:17045,Availability,down,down,17045," Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. void RemoveUnknownWindowHandler(TGUnknownWindowHandler* h); Remove handler for unknown (i.e. unregistered) windows. void AddIdleHandler(TGIdleHandler* h); Add handler for idle events. void RemoveIdleHandler(TGIdleHandler* h); Remove handler for idle events. TGWindow * GetWindowById(Window_t sw) const; Find a TGWindow via its handle. If window is not found return 0. TGWindow * GetWindowByName(const char* name) const; Find a TGWindow via its name (unique name used in TGWindow::SavePrimitive).; If window is not found return 0. ~TGClient(); Closing down client: cleanup and close X connection. Bool_t ProcessOneEvent(); Process one event. This method should only be called when there is; a GUI event ready to be processed. If event has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the win",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:18395,Availability,mask,masked,18395," more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& opera",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:18528,Availability,mask,masked,18528,"s input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForce",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:18567,Availability,mask,masked,18567,"cessed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event has been processed.; Used in TRecorder. void RegisteredWindow(Window_t w); Emits a signal when a Window has been registered in TGClient.; Used in TRecorder. TGClient(const TGClient& ). TGClient& operator=(const TGClient& ). Bool_t IsEditable() const; { return fRoot != fDefaultRoot; }. void ForceRedraw(); { fForceRedraw = kTRUE; }. EGEventType GetWaitForEvent() const; { return fWaitForEvent;}. W",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:13079,Integrability,message,message,13079,"odern or classic); TList*fUWHandlerslist of event handlers for unknown windows; EGEventTypefWaitForEventevent to wait for; Window_tfWaitForWindowwindow in which to wait for event; Pixel_tfWhitewhite color index; THashList*fWlistlist of frames; Int_tfXfdfile descriptor of connection to server; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGClient(const char* dpyName = 0); Create a connection with the display sever on host dpyName and setup; the complete GUI system, i.e., graphics contexts, fonts, etc. for all; widgets. const TGWindow * GetRoot() const; Returns current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. const TGWindow * GetDefaultRoot() const; Returns the root (i.e. desktop) window. Should only be used as parent; for frames that will never be embedded, like popups, message boxes,; etc. (like TGToolTips, TGMessageBox, etc.). void SetRoot(TGWindow* root = 0); Sets the current root (i.e. base) window. By changing the root; window one can change the window hierarchy, e.g. a top level; frame (TGMainFrame) can be embedded in another window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(G",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:14389,Integrability,interface,interface,14389,"nother window. void SetStyle(const char* style); Set the button style (modern or classic). UInt_t GetDisplayWidth() const; Get display width. UInt_t GetDisplayHeight() const; Get display height. const TGPicture * GetPicture(const char* name); Get picture from the picture pool. Picture must be freed using; TGClient::FreePicture(). If picture is not found 0 is returned. const TGPicture * GetPicture(const char* name, UInt_t new_width, UInt_t new_height); Get picture with specified size from pool (picture will be scaled if; necessary). Picture must be freed using TGClient::FreePicture(). If; picture is not found 0 is returned. void FreePicture(const TGPicture* pic); Free picture resource. TGGC * GetGC(GCValues_t* values, Bool_t rw = kFALSE); Get graphics context from the gc pool. Context must be freed via; TGClient::FreeGC(). If rw is true a new read/write-able GC; is returned, otherwise a shared read-only context is returned.; For historical reasons it is also possible to create directly a; TGGC object, but it is advised to use this new interface only. void FreeGC(const TGGC* gc); Free a graphics context. void FreeGC(GContext_t gc); Free a graphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get ",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:15468,Performance,load,loaded,15468,"raphics context. TGFont * GetFont(const char* font, Bool_t fixedDefault = kTRUE); Get a font from the font pool. Fonts must be freed via; TGClient::FreeFont(). Returns 0 in case of error or if font; does not exist. If fixedDefault is false the ""fixed"" font; will not be substituted as fallback when the asked for font; does not exist. TGFont * GetFont(const TGFont* font); Get again specified font. Will increase its usage count. void FreeFont(const TGFont* font); Free a font. void NeedRedraw(TGWindow* w, Bool_t force = kFALSE); Set redraw flags. void CancelRedraw(TGWindow* w). Bool_t GetColorByName(const char* name, Pixel_t& pixel) const; Get a color by name. If color is found return kTRUE and pixel is; set to the color's pixel value, kFALSE otherwise. FontStruct_t GetFontByName(const char* name, Bool_t fixedDefault = kTRUE) const; Get a font by name. If font is not found, fixed font is returned,; if fixed font also does not exist return 0 and print error.; The loaded font needs to be freed using TVirtualX::DeleteFont().; If fixedDefault is false the ""fixed"" font will not be substituted; as fallback when the asked for font does not exist. Pixel_t GetHilite(Pixel_t base_color) const; Return pixel value of hilite color based on base_color. Pixel_t GetShadow(Pixel_t base_color) const; Return pixel value of shadow color based on base_color.; Shadow is 60% of base_color intensity. void FreeColor(Pixel_t color) const; Free color. void RegisterWindow(TGWindow* w); Add a TGWindow to the clients list of windows. void UnregisterWindow(TGWindow* w); Remove a TGWindow from the list of windows. void RegisterPopup(TGWindow* w); Add a popup menu to the list of popups. This list is used to pass; events to popup menus that are popped up over a transient window which; is waited for (see WaitFor()). void UnregisterPopup(TGWindow* w); Remove a popup menu from the list of popups. void AddUnknownWindowHandler(TGUnknownWindowHandler* h); Add handler for unknown (i.e. unregistered) windows. v",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:18232,Performance,queue,queue,18232," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGClient.html:18256,Security,expose,expose,18256," has been processed; kTRUE is returned. If processing of a specific event type for a specific; window was requested kFALSE is returned when specific event has been; processed, kTRUE otherwise. If no more pending events return kFALSE. Bool_t ProcessIdleEvent(); Process one idle event. Bool_t HandleInput(); Handles input from the display server. Returns kTRUE if one or more; events have been processed, kFALSE otherwise. void WaitFor(TGWindow* w); Wait for window to be destroyed. void WaitForUnmap(TGWindow* w); Wait for window to be unmapped. void ResetWaitFor(TGWindow* w); reset waiting. Bool_t ProcessEventsFor(TGWindow* w); Like gSystem->ProcessEvents() but then only allow events for w to; be processed. For example to interrupt the processing and destroy; the window, call gROOT->SetInterrupt() before destroying the window. Bool_t DoRedraw(); Redraw all windows that need redrawing. Returns kFALSE if no redraw; was needed, kTRUE otherwise.; Only redraw the application's windows when the event queue; does not contain expose event anymore. Bool_t HandleEvent(Event_t* event); Handle a GUI event. Bool_t HandleMaskEvent(Event_t* event, Window_t wid); Handle masked events only if window wid is the window for which the; event was reported or if wid is a parent of the event window. The not; masked event are handled directly. The masked events are:; kButtonPress, kButtonRelease, kKeyPress, kKeyRelease, kEnterNotify,; kLeaveNotify, kMotionNotify. void ProcessLine(TString cmd, Long_t msg, Long_t parm1, Long_t parm2); Execute string ""cmd"" via the interpreter. Before executing replace; in the command string the token $MSG, $PARM1 and $PARM2 by msg,; parm1 and parm2, respectively. The function in cmd string must accept; these as longs. Bool_t IsEditDisabled() const; Returns kTRUE if edit/guibuilding is forbidden. void SetEditDisabled(Bool_t on = kTRUE); If on is kTRUE editting/guibuilding is forbidden. void ProcessedEvent(Event_t* event, Window_t wid); Emits a signal when an event h",MatchSource.WIKI,root/html534/TGClient.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGClient.html
https://root.cern/root/html534/TGColorDialog.html:5163,Availability,error,error,5163,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; st",MatchSource.WIKI,root/html534/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorDialog.html
https://root.cern/root/html534/TGColorDialog.html:5247,Availability,error,error,5247,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); TGColorPalette*GetCustomPalette() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeF",MatchSource.WIKI,root/html534/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorDialog.html
https://root.cern/root/html534/TGColorDialog.html:20272,Availability,mask,mask,20272,,MatchSource.WIKI,root/html534/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorDialog.html
https://root.cern/root/html534/TGColorDialog.html:24787,Integrability,message,messages,24787,"UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGColorDialog(const TGWindow* p = 0, const TGWindow* m = 0, Int_t* retc = 0, Pixel_t* color = 0, Bool_t wait = kTRUE); Color selection dialog constructor.; The TGColorDialog presents a full featured color selection dialog.; It uses 2 TGColorPalette's and the TGColorPick widgets. ~TGColorDialog(); TGColorDialog destructor. void SetCurrentColor(Pixel_t col); Change current color. void ColorSelected(Pixel_t ); Emit signal about selected color. void AlphaColorSelected(ULong_t ); Emit signal about selected alpha and color. void CloseWindow(); Called when window is closed via window manager. void UpdateAlpha(Pixel_t* c); Upadate Opacity text entry with alpha value of color c. void UpdateRGBentries(Pixel_t* c); Update RGB text entries with RGB values of color c. void UpdateHLSentries(Pixel_t* c); Update HLS text entries with HLS values of color c. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for the color selection dialog. void SetColorInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Set the color info in RGB and HLS parts. void DoPreview(); Slot method called when Preview button is clicked. TGColorPalette& operator=(const TGColorDialog& ). TGColorDialog(const TGColorDialog& ). TGColorPalette * GetPalette() const; { return fPalette; }. TGColorPalette * GetCustomPalette() const; { return fCpalette; }. » Author: Bertrand Bellenot + Fons Rademakers 22/08/02 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-05 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TGColorDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorDialog.html
https://root.cern/root/html534/TGColorFrame.html:760,Availability,down,down,760,". TGColorFrame. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TGColorFrame. class TGColorFrame: public TGFrame. TGColorFrame, TG16ColorSelector, TGColorPopup and TGColorSelect. The TGColorFrame is a small frame with border showing a specific; color. The TG16ColorSelector is a composite frame with 16 TGColorFrames. The TGColorPopup is a popup containing a TG16ColorSelector and a; ""More..."" button which popups up a TGColorDialog allowing custom; color selection. The TGColorSelect widget is like a checkbutton but instead of the; check mark there is color area with a little down arrow. When; clicked on the arrow the TGColorPopup pops up. Selecting a color in this widget will generate the event:; kC_COLORSEL, kCOL_SELCHANGED, widget id, pixel.; and the signal:; ColorSelected(Pixel_t color). Function Members (Methods); public:. TGColorFrame(const TGWindow* p = 0, Pixel_t c = 0, Int_t n = 1); virtual~TGColorFrame(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connec",MatchSource.WIKI,root/html534/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorFrame.html
https://root.cern/root/html534/TGColorFrame.html:4563,Availability,error,error,4563,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragTyp",MatchSource.WIKI,root/html534/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorFrame.html
https://root.cern/root/html534/TGColorFrame.html:4647,Availability,error,error,4647,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject::GetDrawOption() const; virtual Int_tTGFrame::Ge",MatchSource.WIKI,root/html534/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorFrame.html
https://root.cern/root/html534/TGColorFrame.html:15873,Availability,mask,mask,15873,,MatchSource.WIKI,root/html534/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorFrame.html
https://root.cern/root/html534/TGColorFrame.html:16419,Integrability,message,messages,16419,,MatchSource.WIKI,root/html534/TGColorFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorFrame.html
https://root.cern/root/html534/TGColorPalette.html:4704,Availability,error,error,4704,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPalette.html
https://root.cern/root/html534/TGColorPalette.html:4788,Availability,error,error,4788,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; Pixel_tGetColorByIndex(Int_t ix) const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPalette.html
https://root.cern/root/html534/TGColorPalette.html:16785,Availability,mask,mask,16785,,MatchSource.WIKI,root/html534/TGColorPalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPalette.html
https://root.cern/root/html534/TGColorPick.html:4683,Availability,error,error,4683,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetD",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
https://root.cern/root/html534/TGColorPick.html:4767,Availability,error,error,4767,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Pixel_tGetCurrentColor() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGFrame::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() const; virtual Option_t*TObject:",MatchSource.WIKI,root/html534/TGColorPick.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TGColorPick.html
