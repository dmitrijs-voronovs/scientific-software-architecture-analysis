quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"@hdrake's point references Huang (2005), who point out that a reference state (associated with z* in Winters et al 1995) may not be easily or uniquely definable for seawater with a nonlinear equation of state that depends on salinity, temperature, and pressure:. ![image](https://user-images.githubusercontent.com/15271942/117912548-2d4b3080-b28c-11eb-8693-3805190dd52b.png). In practical terms I think the issue here is determine the ""adiabatic rearrangement"" mentioned by Winters et al. 2005. For a nonlinear equation of state like TEOS-10 where the buoyancy field `b` in the code _depends on depth / hydrostatic pressure_, the adiabatic rearrangement of the water column may not be obtained simply by sorting. However, @hdrake points out that an iterative procedure in which parcels are sorted, their buoyancy recalculated at the new depth, and then sorted again, may eventually converge to an adiabatic reference state.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661:214,depend,depends,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-839400661,2,['depend'],['depends']
Integrability,@iuryt https://github.com/iuryt/Bioceananigans.jl looks like an awesome start!!! 🚀 . @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ? . Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point? . Note -. 1. in the end both Eulerian and Lagrangian formulations of biogeocheminanigans/biogeochemonanigans/Bioceananigans/Bichemoceananigans style stuff end up as mostly pointwise functions. So a number of bits of an API framework could be common across Eulerian and Lagrangian I think. . 2. On the fluid solver side the API could also support reactive and passive transport in an atmosphere (i.e. work with atmoscheminanigans 😄 ),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522:211,interface,interface,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522,1,['interface'],['interface']
Integrability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:432,interface,interface,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,2,['interface'],['interface']
Integrability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:83,integrat,integration,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['integrat'],['integration']
Integrability,@liuchihl Have you tried running on the CPU to see if you get a more useful error message?. I think; ```; Reason: unsupported call to an unknown function (call to jl_f_getfield); ```; could just be the result of a typo in an expression like `a.b`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2429559746,1,['message'],['message']
Integrability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:325,integrat,integration,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['integrat'],['integration']
Integrability,@matinraayai I quickly looked at your work on PencilFFTs and it looks awesome. I'd be happy to merge it in some form. My main reservation is that I'd rather not include CUDA and AMDGPU as hard dependencies. I guess this can be easily corrected using the new package extensions on Julia 1.9. Feel free to open a PR over at PencilFFTs and we can continue the discussion there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982:193,depend,dependencies,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1466277982,1,['depend'],['dependencies']
Integrability,"@navidcy , yes, that looks great. However, when I click on the link I don't think I can execute the commands, but maybe I was too quick to close the page. I created a notebook for the 1D diffusion problem by basically copying and pasting what you have in the example. My markdown is a bit rusty but luckily you had all the right syntax there already. I was going to attach it to this message here but it seems that notebook are unsupported. It is nothing fancy but I do think that if there was an open to open the notebook and run it that would make it a bit easlier than copying and pasting. @glwagner that sounds like a great way to run the script, which is certainly what you want to do. Personally, when learning what a script is doing it's nice to execute it line by line to get to know the process. After you've seen it once then you definitely want to the entire example. Anyhow, my 2 cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454:384,message,message,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1164#issuecomment-724718454,1,['message'],['message']
Integrability,"@navidcy @glwagner this should superceded all previous enzyme prs (including compatbwlper), which I've gone ahead and closed just now. Some non enzyme tests had a nondeterministic ci failure about a directory not being empty, but otherwise all pass (incl enzyme tests). Once landed we should add a lot more integration test cases like @jlk9 your flux boundary",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317:307,integrat,integration,307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618#issuecomment-2195453317,1,['integrat'],['integration']
Integrability,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:490,message,message,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495,1,['message'],['message']
Integrability,"@navidcy and @glwagner, I created this halo test branch from your tracer advection branch the day before yesterday, prior to its merger with the main. Given that the tracer advection, along with other branches, was integrated into the main branch yesterday, this branch started displaying numerous reverse changes. To address this, I merged the main branch into this one, resolved the conflicts manually by accepting the incoming changes. This process led to several commits. I will close this PR and create a fresh branch from the main. I will then push my commits. Please bear with me for a few minutes while I do this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401:215,integrat,integrated,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3277#issuecomment-1728121401,1,['integrat'],['integrated']
Integrability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:857,synchroniz,synchronizes,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['synchroniz'],['synchronizes']
Integrability,"@navidcy may be referring to a couple of places / messages where ""no units"" is assumed to mean ""SI units"". I don't think we support explicit units though. It seems overkill to wrap every float for the purpose of a few messages. We could maybe attach some metadata to `Simulation`. What kind of API would be ""easy"" @navidcy ? Is it `Clock` that needs to know dimensions, or just things that print messages?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354:50,message,messages,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1778#issuecomment-869736354,4,"['message', 'wrap']","['messages', 'wrap']"
Integrability,"@navidcy thanks, I was able to bring the branch up to date to a more reasonable delta.; @glwagner I think there's no need to separate ROCm support and multi-GPU support, since multi-GPU support was mostly dependent on modifications in PencilFFTs.jl.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937:205,depend,dependent,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949#issuecomment-1450982937,1,['depend'],['dependent']
Integrability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:422,wrap,wrapped,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['wrap'],['wrapped']
Integrability,@sangeethasankar01 if you post the whole error message that you get with the stack trace we will understand more which line triggered this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356:47,message,message,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2018666356,1,['message'],['message']
Integrability,"@simone-silvestri `DistributedComputations` is imported before models here:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Oceananigans.jl#L221-L224. What was ""enable overlapping communication"" intended to support? Is there something that depends on whether `isnothing(mpi_requests)`? Perhaps more direct specification of this feature would help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750:284,depend,depends,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3314#issuecomment-1749703750,1,['depend'],['depends']
Integrability,@simone-silvestri and I think there is a missing synchronization for one of the boundary updates,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511:49,synchroniz,synchronization,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427297511,1,['synchroniz'],['synchronization']
Integrability,"@simone-silvestri discussed a bit the user interface for building models with a z* vertical coordinate. Here's a prototype design we came up with:. ```julia; reference_levels = exponential_z_faces(Nz=40, depth=6000). Nx = 1440; Ny = 600; Nz = length(reference_levels) - 1. grid = LatitudeLongitudeGrid(arch;; size = (Nx, Ny, Nz),; halo = (7, 7, 7),; z = ZStarVerticalCoordinate(reference_levels),; latitude = (-75, 75),; longitude = (0, 360)); ```. We like this because with z*, the znodes, and zspacings are always changing. We think this makes that semantically clear. Note there are some challenges for output that we have to solve, because the grid has to be updated to do computations. But I think we can solve these with `FieldTimeSeries`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-2400477009,2,['interface'],['interface']
Integrability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:475,depend,dependencies,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,4,['depend'],"['dependencies', 'dependency']"
Integrability,"@simone-silvestri do you have any formula for computing the local energy dissipation rate due to numerical viscosity? For the global dissipation I think evaluating the time evolution of the total KE is a good route, but I'm less sure the best method for obtaining the local dissipation rate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906:209,rout,route,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404146906,1,['rout'],['route']
Integrability,"@simone-silvestri if we want to unify the user interface across all models, we could introduce the type `AdvectionScheme` (which will be rather trivial now, but we can update it in the future). Then we can have syntax like. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. Or,. ```julia; model = NonhydrostaticModel(; grid, advection=WENO5()); ```. which the model constructor interprets as. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=WENO5(grid)); ```. (this is nice too, because we can build `WENO5` on the grid under the hood). We could also _always_ ""regularize"" the advection scheme with `grid`, so that. ```julia; advection = AdvectionScheme(momentum=WENO5(), tracers=UpwindBiasedThirdOrder()); model = NonhydrostaticModel(; grid, advection); ```. translates to. ```julia; advection = AdvectionScheme(momentum=WENO5(grid), tracers=UpwindBiasedThirdOrder()); ```. under the hood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113:47,interface,interface,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454#issuecomment-1130036113,1,['interface'],['interface']
Integrability,"@simone-silvestri suggests removing `topology` as an argument from the `MultiArch` constructor. `MultiArch` now uses `topology` to construct `RankConnectivity` (ie the mapping between ranks). But in @simone-silvestri's words ""connectivity is a grid thing"". I'm not 100% sure how to solve it though. One possibility is to 1) rebuild `MultiArch` in the grid constructor adding connectivity information. Or we can 2) introduce a wrapper for grids on distributed domains or 3) add `connectivity` to all grids, set to `nothing` when not distributred. I think 1) is easiest but maybe not the cleanest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896:426,wrap,wrapper,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121059896,1,['wrap'],['wrapper']
Integrability,@simone-silvestri we should probably remove this explicit dependency if it isn't needed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705:58,depend,dependency,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705,1,['depend'],['dependency']
Integrability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:264,depend,depending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['depend'],['depending']
Integrability,"@tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886:103,depend,depend,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886,1,['depend'],['depend']
Integrability,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:336,interface,interface,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998,1,['interface'],['interface']
Integrability,"@tomchor I think your solution might help RK3, but as you noted there is _also_ a problem with AB2:. > In this particular MWE if I switch the time-stepper to Adams-Bashforth the issue seemingly goes away (even though there's an initial jump in the pressure that I wouldn't expect), but it does persist (albeit more mildly) in more complex simulations. There's an issue somewhere in. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Simulations/run.jl#L41-L56. I'm also wondering if one issue is that we need to change the line. ```julia; aligned_Δt = schedule_aligned_Δt(sim, aligned_Δt); ```. and maybe instead have an interface where callbacks return the next time of actuation. `TimeInterval` may also need to be redesigned... the fact that we compute the next actuation time b. https://github.com/CliMA/Oceananigans.jl/blob/fb2c670626e38e3bffe298c485f95625fb1d83be/src/Utils/schedules.jl#L65. maybe invites round-off error. To start working on this I think we need an MWE. Mabye that's easy, just a simulation with constant time-step and output on `TimeInterval` which should, in theory, work perfectly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147:662,interface,interface,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103294147,1,['interface'],['interface']
Integrability,"@tomchor and I added a `BuoyancyModel` type (can't call it `Buoyancy` since that would conflict with the module name, name is up for debate) to store the gravity unit vector and the buoyancy model. Seems to work with `BuoyancyTracer` from @tomchor's simulations!. I guess what we weren't sure about is the user interface. Right now tilting gravity is done via e.g. ```julia; θ = 45; g = (0, sind(θ), cosd(θ)); model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=BuoyancyTracer(), gravitational_unit_vector=g); ); ```. so now `model.buoyancy` is a `BuoyancyModel`. ---. But what should the user interface look like for not tilting gravity?. We could enforce explicit construction of a `BuoyancyModel` in every script, which may be seen as adding boilerplate, e.g. ```julia; model = IncompressibleModel(...; buoyancy = BuoyancyModel(model=SeawaterBuoyancy()); ); ```. or we could continue allowing. ```julia; model = IncompressibleModel(...; buoyancy = SeawaterBuoyancy(); ); ```. and the model constructor can convert `SeawaterBuoyancy` to a `BuoyancyModel`. This is less boilerplate but maybe somewhat implicit. I'm leaning towards the more implicit second solution of allowing just `buoyancy = SeawaterBuoyancy()`, but might be good to decide on one.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664:311,interface,interface,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-791775664,2,['interface'],['interface']
Integrability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:521,depend,dependent,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['depend'],['dependent']
Integrability,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:881,depend,dependent,881,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['depend'],['dependent']
Integrability,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454,1,['interface'],['interface']
Integrability,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:949,interface,interface,949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['interface'],['interface']
Integrability,"@vchuravy thank you that is very helpful! I don't think it will be too difficult to build up a small test suite for AMD. We can start with unit tests and a handful of cheap integration tests. @fluidnumerics-joe we don't have any current plans to get AMD GPU resources, but that could change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799:173,integrat,integration,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1937323799,1,['integrat'],['integration']
Integrability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:181,depend,depends,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['depend'],['depends']
Integrability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:265,interface,interface,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['interface'],['interface']
Integrability,"A few ideas:. 1) If we're doing an euler step, zero out the `G⁻` tendencies beforehand. 2) Put an if statement in to take `euler_step!` rather than `ab2_step!`. The problem with 2) is that we haven't figured out how to abstract the stepping interface to handle different models. Basically, we don't really have an generic PDE time-stepper. Instead we have manually implemented time-stepping schemes for the different models; for example:. https://github.com/CliMA/Oceananigans.jl/blob/383e5b60ca8d3bfb3c8497b11b6be30946a25728/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L14-L36. Thus to achieve 2) we'll probably have to write an `euler_step!` for the hydrostatic free surface model. Maybe not a problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764:241,interface,interface,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046338764,1,['interface'],['interface']
Integrability,"A few more thoughts:. 1) It's probably simplest to use a native time-stepping schemes to advance particle trajectories. The third-order Runge-Kutta scheme seems like a fine choice. 2) I think it makes sense to launch one kernel to compute particle trajectories. ""One kernel per thread"" is a simple paradigm. Up to ""one particle per grid point"", we know this method will work well. 3) A few challenges that I see are: i) writing functions that linearly interpolate the velocity field to the particle location, and ii) dealing with boundaries. Enforcing boundary conditions, presumably, requries launching an additional kernel after a time-step is complete that checks the location of each particle and adjusts it if the particle location lies outside the domain. Enforcing periodic conditions presumably requires a cyclic shift of the particle location. I'm less sure how to deal with solid boundaries: perhaps reflecting the particle position (an elastic collision?) is a good model?. 4) I think tackling the problem of determining particle trajectories is a big enough challenge for now. I think once we have the ability to interpolate fields to the particle location, it may not be difficult to introduce ""auxiliary fields"" for each particle, with user-specified RHS that depend on local tracer and velocity fields at the particle position.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271:1274,depend,depend,1274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-694869271,1,['depend'],['depend']
Integrability,"A few other things that this PR inspired me to think about:. 1. I think it'd be nice if `FieldBoundaryConditions` accepted a positional argument to specify the ""default"" boundary condition in `Bounded` directions. This would simplify scripts where every boundary is no-slip (for example) since we could write. ```julia; no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(no_slip); ```. Since the positional argument specifies the default we can also override it:. ```julia; u_bcs = FieldBoundaryConditions(no_slip, top=FluxBoundaryCondition(nothing)); ```. to have no-slip on all boundaries except the top, where we have free-slip / zero flux. 2. I think we do really need a convenience constructor for drag boundary conditions because a) this is friendly for a very common case and b) the drag boundary condition involves uncertain free parameters (Von Karman, roughness...) which we may want to calibrate via ParameterEstimocean and c) similar to the last point, it's crucial that these parameters are obviated in user scripts for reproducibility; defining an interface for drag will help. I think some simple struct called `QuadraticDrag`, which `regularize_boundary_condition` knows how to deal with (since it knows `field_name`, we know how to treat the different velocity components), will suffice for this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638:1080,interface,interface,1080,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1101540638,2,['interface'],['interface']
Integrability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:191,wrap,wrapping,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['wrap'],['wrapping']
Integrability,"A possible implementation of `QuadraticallyStretchedFaces` with the ""z faces interface"" might allow syntax like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z_faces = QuadraticallyStretchedFaces()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815961732,1,['interface'],['interface']
Integrability,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:210,synchroniz,synchronize,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,6,['synchroniz'],['synchronize']
Integrability,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:374,integrat,integrated,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145,1,['integrat'],['integrated']
Integrability,"Adding a Manifest + Project toml files in each validation scripts directory is a good idea!; However, if we do it while we are working on them in a PR, then the Manifest comes with an Oceananigans dependency that points to the branch, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/1c2a6f8752b6425bf30d856f8ba0aa681c0ab818/validation/stokes_drift/Manifest.toml#L1202. and the branch gets deleted after the PR is merged. . So what one would need to do is to make another PR with a Manifest pointing to the specific commit on `main` or to the next tagged release? Sounds like too much work to be sustainable...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915:197,depend,dependency,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076#issuecomment-1891870915,1,['depend'],['dependency']
Integrability,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:368,depend,dependencies,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,6,['depend'],"['dependencies', 'dependency']"
Integrability,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:84,message,message,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801,1,['message'],['message']
Integrability,"Agree we need another name, perhaps a variant of shenanigans. On Thu, Jan 30, 2020, 3:31 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I think its a fine idea to merge, though it is interesting that the code; > will still be called Oceananigans :-D; >; > I'm not sure I understand point 4 completely. The ocean model also has the; > concept of a model ""state""; for example, ghost cell values and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:436,depend,depend,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['depend'],['depend']
Integrability,"Ah Julia installed Oceananigans v0.5.1 (an extremely ancient version), probably due to conflicts between dependency versions. The latest release is Oceananigans v0.57.1. To grab the latest version you can try to explicitly update by typing `] add Oceananigans@0.57.1` in the REPL. There may be conflicts with some other packages like CUDA v3.1.0. Oceananigans is still depending on CUDA v2 so you might have to `] rm CUDA` to be able to `] add Oceananigans@0.57.1`. This might also explain the weird error you reported in #1635. PS: You might encounter issues when using Oceananigans.jl with Julia 1.6 right now. It still requires Julia 1.5 for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603:105,depend,dependency,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-832291603,2,['depend'],"['dependency', 'depending']"
Integrability,"Ah interesting. `SubArray` is what `view` returns. I'm hazy about why you see what you see, but we do know that _singly_ wrapped containers get special treatment. Possibly there have been some improvements for double+ wrapped containers like `view` of `OffsetArray`. As a sanity you could try removing `interior(r)` and just pass `r` instead... :-O. However, I believe this is a bug with CUDA so that would just be a workaround rather than a legitimate solution. Can you reproduce the bug with a simple code that tries to reduce to a `view` of `CuArray`? In other words use the same code as above but reduce to a view of `a` rather than a view of `o`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494:121,wrap,wrapped,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845608494,4,['wrap'],['wrapped']
Integrability,"Ah ok I see, you still have to merge main. Then synchronization problems will be fixed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516:48,synchroniz,synchronization,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514622516,1,['synchroniz'],['synchronization']
Integrability,"Ah ok so I think this is just an issue with running `makedocs` multiple times after each other without cleaning up what `makedocs` has done before. So it's complaining that when it ran the `jldoctest` a second time it got this message:. ```; more_fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!; ```. so the output is different. I guess we have 3 possible automated fixes (manual fix being to remove the files manually):; 1. We can clean up and remove these files as part of `make.jl`.; 2. Using `NetCDFOutputWriter` in `jldoctest` we should use the `mode = ""c""` kwarg to avoid the info/warning message.; 3. `jldoctest` blocks should remove files at the end of the block (and there should be a way to hide this from the docs but not 100% sure right now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994:227,message,message,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455#issuecomment-796853994,2,['message'],['message']
Integrability,"Ah sorry, should have read your earlier message. I was able to reproduce the error locally with. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid); NetCDFOutputWriter(model, fields(model), filepath=""test.nc"", schedule=IterationInterval(1)); ```. <details><summary>Stacktrace</summary><p>. ```; Error showing value of type NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}:; ERROR: MethodError: no method matching short_show(::FieldSlicer{Colon,Colon,Colon}); Closest candidates are:; short_show(::AveragedTimeInterval) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/windowed_time_average.jl:209; Stacktrace:; [1] show(::IOContext{REPL.Terminals.TTYTerminal}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X},IterationInterval,FieldSlicer{Colon,Colon,Colon},UnionAll}) at /home/alir/tmp/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:490; [2] show(::IOContext{REPL.Terminals.TTYTerminal}, ::MIME{Symbol(""text/plain"")}, ::NetCDFOutputWriter{NCDatasets.NCDataset{Nothing},Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825:40,message,message,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787496825,1,['message'],['message']
Integrability,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:212,message,messages,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674,1,['message'],['messages']
Integrability,Ah that looks quite nice. Would it make sense to try and integrate `DiskTimeSeries` with a `DimensionalData.DimArray` to get named axis behavior?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801:57,integrat,integrate,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-801936801,1,['integrat'],['integrate']
Integrability,"Ah, I foolishly assumed it was running in CPUs but do see it's running on GPUs. I gather it's slow because the GPU I have on my desktop is poor. Maybe I'll kill it and run it on a CPU as that maybe faster on my local machine. One thing that should be changed, sometime, is the only output I see is a warning message. ```; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. ; │ Don't hesitate to help validate ImmersedBoundaryGrid by reporting any bugs ; │ or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues; └ @ Oceananigans.ImmersedBoundaries ~/software/Second_Oceananigans/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:73; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735:308,message,message,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-867923735,1,['message'],['message']
Integrability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:257,depend,depends,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['depend'],['depends']
Integrability,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:474,interface,interface,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439,2,['interface'],['interface']
Integrability,"Ah, but the ""cape"" is oriented in x --- it sticks out from the southern boundary with unit 1 and tapers to 0 as x -> -infty and +infty. If the flow comes in from the west, it would impinge on the cape. Right?. Note that y < exp(-x^2) is true along the entire southern boundary where `y=0` and `x` varies from `-10` to `+10`. So imposing an inflow along the southern boundary will be masked out, I believe, depending on the order of operations in `update_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265:406,depend,depending,406,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852778265,1,['depend'],['depending']
Integrability,"Ali, can I think of this as a shallow water model that knows about reduced; gravity? John. On Wed, Apr 21, 2021, 1:45 PM Ali Ramadhan ***@***.***> wrote:. > This PR adds an eddying aquaplanet validation experiment that's still a; > work-in-progress (early stage PR).; >; > The idea is to force a HydrostaticFreeSurfaceModel on a CubedSphereGrid; > with a ""tradewind-like"" zonal wind stress pattern akin to Marshall et al.; > (2007); > <https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml>.; >; > This is figure 3 from the paper:; >; > [image: i1520-0469-64-12-4270-f03]; > <https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif>; >; > and this is the analytic formula I'm using to mimic it:; >; > [image: image]; > <https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png>; >; > We integrate τ to obtain a streamfunction for the wind stress which we; > then use to diagnose the surface; > momentum fluxes on the cubed sphere. *I think I got the magnitude wrong; > so I fixed it with a scaling factor...*; >; > I tried adding a lot of noise to the initial velocities but the wind; > stress smoothed it away.; > cubed_sphere_eddying_aquaplanet.mp4; >; > @christophernhill <https://github.com/christophernhill> suggested adding; > some random noise to the wind stress as well. And we probably also need a; > mechanism to remove energy otherwise the wind stress keeps accelerating the; > fluid until the model blows up. Maybe we need some bottom drag even though; > we only have one vertical level?; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1602; > Commit Summary; >; > - Regularize cubed sphere boundary conditions; > - First draft of eddying aquaplanet; > - Run with diffusion for 7 days and copy paste plotting script; >; > File Changes; >; > - *M* src/CubedSpheres/CubedSphere",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767:896,integrat,integrate,896,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602#issuecomment-824303767,1,['integrat'],['integrate']
Integrability,"All that's really needed is to define. https://github.com/CliMA/Oceananigans.jl/blob/0415938fa0fbd9cb581e3301b31083e064519b06/src/Coriolis/hydrostatic_spherical_coriolis.jl#L33-L34. for other `coriolis` schemes. Probably it needs to dispatch on both `FPlane` / `BetaPlane` and `AbstractRectilinearGrid`. The code should be restructured a bit. If we do that, the only that makes coriolis ""spherical"" or not is the dependence of `f` on `i, j`. So we should put the definition of the Sabourny stencils in a new file.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159:413,depend,dependence,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873641159,1,['depend'],['dependence']
Integrability,Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646:111,depend,dependent,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2396162646,1,['depend'],['dependent']
Integrability,"Also this doesn't blow up, right? I think with increasing energy, eventually nonlinearities and numerical diffusion would kick in. The integrated KE might exhibit oscillatory behavior on long time-scales. (The example in the OP only blows up because the `TimeStepWizard` increases the time step too much.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762:135,integrat,integrated,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1445270762,1,['integrat'],['integrated']
Integrability,"Also we get some deprecation warnings. E.g., for. ```; SpecifiedTimes(times::Vararg{<:Number}) = SpecifiedTimes(sort([Float64(t) for t in times]), 0); ```. we get. ```; Wrapping `Vararg` directly in UnionAll is deprecated (wrap the tuple instead).; ```. I don't understand what that means tho.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601:169,Wrap,Wrapping,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566849601,2,"['Wrap', 'wrap']","['Wrapping', 'wrap']"
Integrability,Also wondering why there isn't a test that catches this? Does it depend on the size of the problem?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639,1,['depend'],['depend']
Integrability,"An “edge” is the case in which 2 of Lx, Ly, or Lz are “interface”. We just; don’t need special notation. This method of specifying locations in a cube; is simpler, but also more general. On Sat, Mar 9, 2019 at 8:52 AM Ali Ramadhan <notifications@github.com>; wrote:. > Ah yes I remember @jm-c <https://github.com/jm-c>'s concern now! Yes,; > just ""face"" and ""edge"" are ambiguous.; >; > So your proposed solution will make it explicit exactly which interface; > the field is being interpolated from and to, which will be nice.; >; > —; > You are receiving this because you were assigned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-471178907>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AOkIBlzM_EBoVLsfUYqw-V_v_Pe2admmks5vU7yqgaJpZM4bEKew>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-471179020,2,['interface'],['interface']
Integrability,And all tests pass! Great! Ignore my messages!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383:37,message,messages,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091221383,1,['message'],['messages']
Integrability,"And right, for thin aspect ratios (H/L << 1), we typically neglect the dependence on `w` for two reasons: (1) `w` is small (eg `w ~ u * H/L`), and (2) `w` is non-zero only on side-walls, which make a negligible contribution to the overall flux, because side-wall areas are O(H/L) smaller than vertical-normal areas. For this example, we can either use a hydrostatic-specific drag, or we can use a more general formulation and comment on how it could be simplified using an assumption of thin-aspect ratio (which is also the basis for the hydrostatic approximation). In the context of Oceananigans, it turns out to be _simpler_ to specify a 3D drag. So the ""simplification"" for thin-aspect ratio isn't as important as it is, for example, for analytical / theoretical calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370:71,depend,dependence,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1607565370,2,['depend'],['dependence']
Integrability,"Another PhD student working with me ran into this problem of very long initialization times too. He was using a Windows laptop and, like @jagoosw, I have been able to reproduce it using an apple silicon mac. Also, we are using JLD2 instead of NetCDF, so I don't think the problem is specific to apple silicon or NetCDF. Also, the problem goes away when I downgrade to Oceananigans v0.85.0. Wrapping the output in Field() as @zhihua-zheng suggested does seem to help, but even when doing that, the startup is quite slow using v0.90.1 when complex diagnostics are calculated. Downgrading to v0.85.0 downgrades other dependencies, so its hard to tell where the problem is arising. In case its useful, here is the list of packages that are downgraded when I go from 0.90.1 to 0.85.0:; ⌅ [052768ef] ↓ CUDA v5.1.0 ⇒ v4.4.1; ⌅ [0c68f7d7] ↓ GPUArrays v9.1.0 ⇒ v8.8.1; ⌅ [61eb1bfa] ↓ GPUCompiler v0.25.0 ⇒ v0.21.4; ⌅ [85f8d34a] ↓ NCDatasets v0.13.1 ⇒ v0.12.17; ⌃ [9e8cae18] ↓ Oceananigans v0.90.1 ⇒ v0.85.0; ⌅ [0e08944d] ↓ PencilArrays v0.19.2 ⇒ v0.18.1; ⌅ [4ee394cb] ↓ CUDA_Driver_jll v0.7.0+0 ⇒ v0.5.0+1; ⌅ [76a88914] ↓ CUDA_Runtime_jll v0.10.0+1 ⇒ v0.6.0+0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786:390,Wrap,Wrapping,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1806910786,2,"['Wrap', 'depend']","['Wrapping', 'dependencies']"
Integrability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,2,['interface'],['interface']
Integrability,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:91,interface,interfaces,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,3,['interface'],"['interface', 'interfaces']"
Integrability,"Another non-function example is this piece of code from the wind mixing case:. ```julia; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m s⁻¹, surface temperature flux. # Finally, we impose a temperature gradient `dTdz` both initially and at the; # bottom of the domain, culminating in the boundary conditions on temperature,. dTdz = 0.01 # K m⁻¹. T_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); ```. This should work on the GPU. The reason is that `Qᵀ` and `dTdz` are not referenced in functions. Instead, they end up inside the data structures `model.tracers.T.boundary_conditions.top.condition` and `model.tracers.T.boundary_conditions.bottom.condition`. Likewise, this code is valid too:. ```julia; @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m s⁻¹; nothing # hide. # where `S` is salinity. We use an evporation rate of 1 millimeter per hour,. evaporation_rate = 1e-3 / hour # m s⁻¹. # We build the `Flux` evaporation `BoundaryCondition` with the function `Qˢ`,; # indicating that `Qˢ` depends on salinity `S` and passing; # the parameter `evaporation_rate`,. evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); ```. because `evaporation_rate` enters into `Qˢ` in its 5th argument. It does not need to be, and should not be, `const`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306:1068,depend,depends,1068,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306,1,['depend'],['depends']
Integrability,Another place I think we need to change is particle advection:; https://github.com/CliMA/Oceananigans.jl/blob/f3113c492f309846f026e0ac150dc8480f96e0f2/src/LagrangianParticleTracking/update_particle_properties.jl#L157-L161. Because currently background velocity fields don't get integrated which I think is wrong? At least in the case I was using them for I had to add the background velocities manually.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094:278,integrat,integrated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1482931094,1,['integrat'],['integrated']
Integrability,"Another possibility is to write some tests using `HydrostaticFreeSurfaceModel` with `ExplicitFreeSurface`, which is entirely explicit and thus requires only halo filling via MPI (with no PencilArrays dependency)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447#issuecomment-1105468942,1,['depend'],['dependency']
Integrability,Any code using threading is eventually just going to hang on M1. My point is that Oceanigans should not be working around this for the user since it declares an unecessary dependency for everyone else. Users can pin mpich_jll locally if needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087:172,depend,dependency,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087,1,['depend'],['dependency']
Integrability,"Apologies for confusing the nomenclature, I should have said `exterior_cell` (I named it this to contrast with the function `interior`). Though ""exterior"" and ""interior"" strictly aren't mutually exclusive, they are loosely connected... > So external_cell is just a special case external_node, correct?. Correct, `exterior_cell` is identical to `exterior_node` evaluated at tracer cell centers. > It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. No, there is no assumption. The notion of `exterior_cell` is independent of the immersed boundary implementation. There are `exterior_cell`s for any grid `Bounded` in one or more direction. The implementation for underlying grids is here:. https://github.com/CliMA/Oceananigans.jl/blob/glw/immersed-bcs/src/Grids/exterior_node.jl. Differences between ""full cell"" immersed boundary methods and other types of methods manifest in the way grid metrics are modified (spacing, areas, and vectors normal to cell interfaces). All immersed boundary methods will both define `external_cell` and any boundary-specific modifications to metrics. We'll also need an interface for specifying the face normal vector, since those normals won't lie along the cardinal directions anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563:982,interface,interfaces,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751563,2,['interface'],"['interface', 'interfaces']"
Integrability,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:30,interface,interface,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['interface'],['interface']
Integrability,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:26,interface,interface,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,14,['interface'],"['interface', 'interfaces']"
Integrability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:509,interface,interface,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['interface'],['interface']
Integrability,"As discussed elsewhere, it might be most convenient for users if an interface to applying moving averages is provided within the constructor for an output writer, rather than creating a wrapper object like `TimeAveragedOutputWriter`. An example of this would be. ```julia; U = HorizontalAverage(model.velocities.u); V = HorizontalAverage(model.velocities.v). statistics_writer = JLD2OutputWriter(model, (U=U, V=V), time_interval=1hour, time_averaging_window=1minute); ```. The advantage of this syntax is that deciding to time-average output is as simple as adding a keyword argument to an existing output writer. This may be easier to user than previously proposed interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748:68,interface,interface,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/501#issuecomment-673085748,3,"['interface', 'wrap']","['interface', 'interfaces', 'wrapper']"
Integrability,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:631,depend,dependent,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,1,['depend'],['dependent']
Integrability,"As far as I can tell the main purpose of `CLIMAParameters` is to provide a central / global place to specify common parameters found in different model components. For example, `HydrostaticFreeSurfaceModel` has a `gravitational_acceleration` for both `buoyancy` and `free_surface`. On the other hand, it turns out that it's sometimes convenient for these to be different for testing and experimentation, which may impose additional requirements on `CLIMAParameters` that were not part of the original design. One possible solution might be to build a global `CLIMAParameters` instance in `Oceananigans` that's referenced in model constructors for default parameter values (but we can still let users change parameters when instantiating various model components if they want). A possible goal of CLIMAParameters is to _restrict_ the user interface so that users ""can't mess up""; eg users can't accidentally set `gravitational_acceleration` in `free_surface` and erroneously expect that this also changes `gravitational_acceleration` for buoyancy. Food for thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111:838,interface,interface,838,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1427#issuecomment-791482111,1,['interface'],['interface']
Integrability,"As for a slip velocity that depends on buoyancy, one method uses `Callback`:. ```julia; # Define slip field with impenetrable boundary conditions; w_slip_bcs = FieldBoundaryConditions(grid, top=OpenBoundaryCondition(), bottom=OpenBoundaryCondition()); w_slip = ZFaceField(grid). # Build AdvectiveForcing; slip_forcing = AdvectiveForcing(w = w_slip). # later...; b = BuoyancyField(model) # or just model.tracers.b for BuoyancyTracer(); b_particle = 1e-4 # define particle ""buoyancy"". Requires reference fluid buoyancy / knowledge of initial condition.; particle_radius = 1e-3; molecular_viscosity = 1e-6. # Define an AbstractOperation that computes the slip velocity:; slip_velocity_op = 2/9 * (b_particle - b) / molecular_viscosity * particle_radius^2. function compute_slip_velocity!(sim); compute!(b) # compute buoyancy if it's a function of T, S; w_slip .= slip_velocity_op; Oceananigans.BoundaryConditions.fill_halo_regions!(w_slip); return nothing; end. simulation.callbacks[:compute_slip_velocity] = Callback(compute_slip_velocity!); ```. It's also possible not to use `Callback` if the forcing is written manually with the `discrete_form`. That requires a bit more work and more knowledge of Oceananigans internals though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083758705,1,['depend'],['depends']
Integrability,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2Ω`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:188,interface,interface,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354,2,['interface'],['interface']
Integrability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"Awesome! Yes unfortunately the code has changed a lot recently and the docs have become stale in many places, we're hoping to revise them soon. > Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Yeah for sure. I think one of our goals with Oceananigans.jl is to eventually make it so users never have to think about the staggered grid. Most examples use functions to initialize fields like. ```julia; random_noise(x, y, z) = rand(); set!(model, u=random_noise, v=random_noise); ```. which will work no matter the size of the field, but in the 2D turbulence example we wanted the noise to have zero mean so we had to use arrays. Perhaps it can be revised to use functions. Either way we can keep this issue open until the docs (or the examples) are revised.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531:199,interface,interface,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839735531,1,['interface'],['interface']
Integrability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:224,interface,interface,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['interface'],['interface']
Integrability,Before I updated and induced the problem I was getting O(seconds) initialisation time on M1 Mac so I think you're experiencing the problem with both versions @navidcy . I tried using JLD2 and got the same slow initialisation. Do they have a common dependency that does something to the field?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775:248,depend,dependency,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805861775,1,['depend'],['dependency']
Integrability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:196,depend,depends,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,1,['depend'],['depends']
Integrability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:254,depend,dependencies,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['depend'],['dependencies']
Integrability,"But Oceananigans doesn't really output time in ""seconds"", does it? The time unit is arbitrary, or depends on user inputs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380:98,depend,depends,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791008380,1,['depend'],['depends']
Integrability,But since all tests run on a computer at MIT the time it takes also depends on how many tests are running (eg how many prs were just open) and other random factors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402:68,depend,depends,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-877432402,1,['depend'],['depends']
Integrability,"But still, I think that you first derive the equation for \eta (after the time discretization) and then integrate in volume. In the end it is still a derivative of a derivative (Following the docs from mitgcm https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html). So the \partial x on the LHS should be correct. You 'll see that the term that doesn't cancel (as you derived above) is contained in the integral of the area. On the other hand, I think we should change the batropic pressure gradient correction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966:104,integrat,integrate,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966,1,['integrat'],['integrate']
Integrability,"But the way @tomchor wrote the example, is `outputs_yavg` dependent on `outputs_full`? Seems like it... E.g.,. ```julia; outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full)); ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497:58,depend,dependent,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436095497,1,['depend'],['dependent']
Integrability,"By the way, an alternative route to getting ""automatic"" dimensioning for `NetCDFOutputWriter` could be to define a `default_dimensions(output::WindowedSpatialAverage, grid, field_slicer)` that does the right thing. You can put the location `X, Y, Z` in `WindowedSpatialAverage` without making the object subtype `AbstractField` (which will cause various issues with time-averaging as noted).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623:27,rout,route,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783575623,1,['rout'],['route']
Integrability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['depend'],"['dependencies', 'dependency']"
Integrability,Can I pin specific versions of dependencies to try out?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120:31,depend,dependencies,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1677#issuecomment-845428120,1,['depend'],['dependencies']
Integrability,Can we keep these features in separate PRs? The output interface really is distinct from the lower-level features needed for the NetCDFOutputWriter.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393855771,1,['interface'],['interface']
Integrability,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:13,wrap,wrapper,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,1,['wrap'],['wrapper']
Integrability,"Can you print the whole warning message? I can't see what file / function the warning is coming from because it's cut off, I only see `-@-> /home/fpoulin/software/Oceananigans.jl/src/Grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500:32,message,message,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843328500,1,['message'],['message']
Integrability,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:145,message,message,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,2,['message'],['message']
Integrability,"Can't reproduce that @navidcy . ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 160 already precompiled. julia> grid = RectilinearGrid(size=(2, 3, 4), x=(0, 1), y=(0, 1), z=(0, 1));. julia> c = CenterField(grid); 2×3×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 6×9×10 OffsetArray(::Array{Float64, 3}, -1:4, -2:6, -2:7) with eltype Float64 with indices -1:4×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c .= rand(size(c)...);. julia> v = view(c, :, 2:3, 1:2); 2×2×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, 2:3, 1:2); └── data: 6×2×2 OffsetArray(view(::Array{Float64, 3}, :, 5:6, 4:5), -1:4, 2:3, 1:2) with eltype Float64 with indices -1:4×2:3×1:2; └── max=0.943733, min=0.11545, mean=0.571896. julia> size(v); (2, 2, 2). julia> v[2, 2, 2] == c[2, 2, 2]; true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942:98,depend,dependency,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2091185942,1,['depend'],['dependency']
Integrability,"ComplexF64, CUDA.CUFFT.cCuFFTPlan{ComplexF64, 1, true, 3}, Float64}, Oceananigans.Solvers.Backward, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Int64, Bounded, Int64, NamedTuple{(:forward, :backward), Tuple{CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}}}, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, Nothing, NamedTuple{(:a,), Tuple{Int64}}}; dependencies::CUDAKernels.CudaEvent); @ Oceananigans.Models.NonhydrostaticModels ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:88; [16] calculate_interior_tendency_contributions!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:46 [inlined]; [17] calculate_tendencies!; @ ~/OC.jl/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:27 [inlined]; [18] #apply_regionally!#46; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; [19] apply_regionally!; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:115 [inlined]; [20] macro expansion; @ ~/OC.jl/src/Utils/multi_region_transformation.jl:197 [inlined]; [21] time_step!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:29871,depend,dependencies,29871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"Cool. Getting to the finish line will be a bit of work I guess. I think we usually want to integrate downwards so that's annoying. Not sure if that exists exactly, or we have to implement some lazy version of `reverse` to achieve it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202:91,integrat,integrate,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2098991202,1,['integrat'],['integrate']
Integrability,"Correction to my last message, I accidentally included a second prime. The form of the Stokes drift is actually:. $u^s(x,y,z)=f(x)g(y)h′(z)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626:22,message,message,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1813531626,1,['message'],['message']
Integrability,Correction: `InterfaceImmersedCondition` and `CenterImmersedCondition` might still useful during construction because they inform where the bottom height will be.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975:13,Interface,InterfaceImmersedCondition,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2402229975,1,['Interface'],['InterfaceImmersedCondition']
Integrability,"Definitely agree the two interfaces should be consistent. I'd be okay with either, although still slightly favor the current interface in case we will want to pass two sets of kwargs in the future. Would you support merging this PR and we can open an issue to discuss the best interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312:25,interface,interfaces,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2340922312,3,['interface'],"['interface', 'interfaces']"
Integrability,"Dependencies between fields are supposed to be accounted for. For example if we write. ```julia; wc = Field(w * c); wc_average = Field(Average(wc, dims=1)); ```. then . ```julia; compute!(wc_average); ```. should first call `compute!(wc)`. For example:. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field_reductions.jl#L72-L77. where `reduction.operand === `wc` in the above example. Thus this calls. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/AbstractOperations/computed_field.jl#L64-L72. Note that `compute_at!` should always compute if needed because. https://github.com/CliMA/Oceananigans.jl/blob/c929676bcce7fc19c3f96faafd459371935a6eba/src/Fields/field.jl#L451-L462",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967:0,Depend,Dependencies,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1436096967,1,['Depend'],['Dependencies']
Integrability,"Did you test it? :). I think providing a string as a closure doesn't even make it to the new error message you added so you get a MethodError from `with_tracers`!. ```Julia; julia> using Oceananigans, Test; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 129 already precompiled. julia> grid = RectilinearGrid(CPU(), size=(2, 2, 2), extent=(1, 2, 3)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.5; ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-3.0, 0.0] regularly spaced with Δz=1.5. julia> closure = ""not a closure""; ""not a closure"". julia> NonhydrostaticModel(; grid, closure); ERROR: MethodError: no method matching with_tracers(::Tuple{}, ::String). Closest candidates are:; with_tracers(::Any, ::Nothing, Any...; kwargs...); @ Oceananigans ~/Research/OC11.jl/src/Utils/with_tracers.jl:44; with_tracers(::Any, ::Oceananigans.TurbulenceClosures.TwoDimensionalLeith{FT}) where FT; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl:61; with_tracers(::Any, ::ScalarBiharmonicDiffusivity{F, N}) where {F, N}; @ Oceananigans ~/Research/OC11.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl:85; ... Stacktrace:; [1] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{}, closure::String, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, hydrostatic_pressure_anomaly::Oceananigans.Models.NonhydrostaticModels.DefaultHydrostaticPressureAnomaly, nonhydrostatic_pressure::Field{…}, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@Na",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269:99,message,message,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325306269,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:143,rout,route,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['rout'],['route']
Integrability,"Do you have an example? . If you have a grid with `Nx = 10` and `Ny = 10` and set `h = 1.0` (and `fill_halo_regions!`) then the `h.data` will be 1 from `0:11, 0:11` and 0.0 elsewhere. Is this what you are referring to?. If x and y directions are bounded, points at `-2:-1, -2:-1` (and respective points above Nx and Ny) are never touched because both advection and diffusion are second order near the boundary. (You might want to use branch #2603 to make sure this is the case). So, for (2), I don't think we need it because those halo points should not be touched anyways.; For (1): I do not think there is an easy way to do that that does not involve writing some kernels, but you maybe reutilize the previous flux BC implementation and write something like this. ```; @kernel function _fill_height_west_and_east!(h, H, N); j, k = @index(Global, NTuple). @unroll for i in 1:H; @inbounds h[1-i, j, k] = h[i, j, k]; @inbounds h[N+i, j, k] = h[N+1-i, j, k]; end; end. @kernel function _fill_height_south_and_nort!(h, H, N); i, k = @index(Global, NTuple). @unroll for j in 1:H; @inbounds h[i, 1-j, k] = h[i, j, k]; @inbounds h[i, N+j, k] = h[i, N+1-j, k]; end; end. fill_height_west_and_east!(h, arch, dep, grid) = launch!(arch, grid, :yz, _fill_height_west_and_east!, h, grid.Hx, grid.Nx; dependencies=dep); fill_height_south_and_north!(h, arch, dep, grid) = launch!(arch, grid, :xz, _fill_height_south_and_north!, h, grid.Hy, grid.Ny; dependencies=dep); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814:1288,depend,dependencies,1288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814,2,['depend'],['dependencies']
Integrability,Do you know why the manual `synchronize` is needed?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987:28,synchroniz,synchronize,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1722074987,1,['synchroniz'],['synchronize']
Integrability,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:241,depend,dependency,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,1,['depend'],['dependency']
Integrability,"Does it have to do with output? Do you know what the time-step is when this happens? I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649:273,integrat,integrated,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2102989649,1,['integrat'],['integrated']
Integrability,Doesn't `string(typeof(scheme).name.wrapper)` return something similar for all advection schemes? Or am I misunderstanding what you're saying?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987:36,wrap,wrapper,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986790987,1,['wrap'],['wrapper']
Integrability,"EDIT: This has nothing to do with Oceananigans.jl per se. Better pursued on LambertW.jl. I agree with https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904990127 . This part of the stack trace suggests that it is the `@warn` that is causing the problem. It should be possible to remove that somehow. Better would be to remove the `@warn` entirely and instead return the result along with info on the convergence. And maybe convenience interface for people who want to ignore it. That's a more robust interface for other reasons as well. I don't know anything about running on GPUs. Does `@warn` cause failure if it is anywhere in the package being compiled? or anywhere in the function being called? Or does execution have to hit the `@warn` so that io is attempted at run time?. EDIT: I missed this above:; >> Do you get a warning during CPU execution ?. > Nope. Everything seems to run pretty smoothly:. So it seems that execution does not have to hit the `@warn` for the reported failure. Also the stack trace indicates that the error happens when the macro is expanded. EDIT: so the following comment may be relevant, but perhaps not. It would be nice if there were a way to redirect io or send it to dev null or otherwise disable everywhere when running on a GPU. ```; Reason: unsupported call to an unknown function (call to jl_f__call_latest); Stacktrace:; [1] #invokelatest#2; @ ./essentials.jl:816; [2] invokelatest; @ ./essentials.jl:813; [3] macro expansion; @ ./logging.jl:381; [4] lambertw_root_finding; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:188; [5] lambertw_branch_zero; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:117; [6] _lambertw; @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:93; [7] lambertw (repeats 2 times); @ /glade/work/tomasc/.julia/packages/LambertW/tom9a/src/LambertW.jl:73; [8] W; @ /glade/derecho/scratch/tomasc/twake4/headland_simulations/mwe.jl:9; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945:452,interface,interface,452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1910836945,2,['interface'],['interface']
Integrability,"EDIT: there were a number of mistakes in the original post here. I've updated it. As for the _profiles_, there are some interesting differences between the ""Brevik"" and ""Lenain"" formulations. In particular, the Lenain profile depends on the _air_ friction velocity `u★`, while the Brevik does not. This is because Lenain divide the spectrum into saturation and equilibrium ranges, and the transition wavenumber between the two _depends on the friction velocity_ (it scales with `1 / u★^2`. Lenain also introduce an ""isotropic wavenumber"", which is an upper cutoff above which short waves do not contribute to the net Stokes drift. This isotropic wavenumber also scales with `1 / u★^2`. In all cases the Lenain model has strong shear at the surface. The effect is less pronounced on a (relatively coarse) grid with dz = 1 m, but still significant. The shear is also not monotonic in `u★`, possibly because the lower-frequency components start to contribute more at higher wind speeds, reducing the shear relative to the surface value of the Stokes drift. Check out the results:. ![image](https://user-images.githubusercontent.com/15271942/156649792-02639f67-5d0d-47f3-93f7-e1faa7ad92f9.png). Code:. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; Cᵝ = 0.105 # Toba's constant; Cʳ = 9.7e-3 # Transition wavenumber parameter, Lenain and Pizzo 2020 eq 4; Cⁱ = 0.072 # Cutoff / isotropic wavenumber parameter; # exp(π/2 - θ₀) / γ) from Lenain and Pizzo 2020 Appendix A; Cᴮ = 7e-3 # Saturation constant; g = 9.81 # m s⁻², gravitational acceleration; ρʷ = 1024 # kg m⁻³, water density; ρᵃ = 1.225 # kg m⁻³, air density. #####; ##### Stokes drift profile from Brevik et al 2016; #####. T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))); brevik(k, z) = T₁(k, z) - T₂(k, z). #####; ##### Stokes drift profile from Lenain and Pizzo 2020; #####. kⁿ(u★) = Cʳ * g / u★^2 # Transition wavenumber; kⁱ(u★) = Cⁱ * g / u★^2 # Isotropic wavenumber / upper wav",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264:226,depend,depends,226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058221264,1,['depend'],['depends']
Integrability,"Extrinsic is what we decide. When we use the cubed sphere we want to use geographic coordinates. But vector fields on the c-grid have their own coordinate system dictated by the structure of the grid. Except for `LatitudeLongitudeGrid`, the geographic coordinate system does not coincide with the ""other"" coordinate system (I called it intrinsic above, but if this is confusion we need another name) that's associated with the grid. What language would you like to use to describe (1) the coordinate system that we would like to impose on the grid for the user interface and 2) the coordinate system that the raw vector fields use (I'm trying to avoid the language I proposed to ask this question).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309:561,interface,interface,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3625#issuecomment-2187115309,1,['interface'],['interface']
Integrability,"Float32 global simulations are near!. This is the u-velocity at the surface of a simple baroclinic adjustment case: left -> Float64, center -> Float32 right -> difference (u64 - u32). https://github.com/CliMA/Oceananigans.jl/assets/33547697/4ed0e547-416f-4597-8e2c-a38de7cb9fa5. integrated KE energy time series. ![ke](https://github.com/CliMA/Oceananigans.jl/assets/33547697/941883a9-84a8-4e92-90b0-277fdc2a2063). more in-depth statistics from @milankl incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168:279,integrat,integrated,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1670259168,2,['integrat'],['integrated']
Integrability,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:52,integrat,integrated,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715,1,['integrat'],['integrated']
Integrability,"For completeness I think the same grid could be generated with the current interface using. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; zF = k -> cos(π * (2k - 1) / 2Nz)); ```. I suppose the main difference is that the syntax with `z_stretching` makes the bounds of the domain explicit, whereas when using `zF` a code-reader has to compute the domain bounds by plugging `k = 1` and `k = Nz + 1` into the generating function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232:75,interface,interface,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814466232,1,['interface'],['interface']
Integrability,"For face indexing convention, 1 is the interface forming left boundary of the domain and N+1 is the interface forming the right boundary. For center indexing, the first cell on the left is 1 and the last cell on the right is N. I'm not 100% sure what you are asking but this is the definition of the indices. I think if you set N+1 for right-sided open boundaries, you should set 1 for left-sided open boundaries. If you set N+2 for the right side, then you would set 0 for the left side. Maybe there is a bug somewhere else?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825:39,interface,interface,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2386242825,2,['interface'],['interface']
Integrability,"For small scale testing we could use JuliaGPUs buildkite. On Wed, Sep 4, 2024 at 12:32 PM Simone Silvestri ***@***.***>; wrote:. > Right, I think the problem is the availability of AMD GPUs to run tests.; > If we find one, I can revamp this.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328512985>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XVCEUJNTZHWDD36KDZU3OVLAVCNFSM6AAAAABDHAZB6GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMRYGUYTEOJYGU>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255:620,Message,Message,620,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328706255,1,['Message'],['Message']
Integrability,"For sure, that is always an option. After a lot of searching it seemed that the problem was indeed the synchronization of the boundary conditions that still was not fixed. . this PR should be ready to merge, I ll do the last check of the comments I maybe missed and then merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231:103,synchroniz,synchronization,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231,1,['synchroniz'],['synchronization']
Integrability,"For the GPU case, again for 128x128 (still rather coarse and results will depend on resolution I suspect). ```; scheme ratio; ====== ===; C2 1.2; U3 1.5; C4 2.4; U5 1.5; W5 7.0. ```. In general the scalings tend to be better on GPUs vs CPUs (on this coarse grid). It does seem that `WENO5` does much worst, relatively speaking. . Benchmarks that I did with @ali-ramadhan found that on GPUs vs CPUs, shallow water model could be faster by a factor of `170`, which was for `U5`. With `WENO5` it was double that. I guess the moral of the story is that `WENO5` is very different and sometimes much better and sometimes much worst. I should say that the difference from the first run to the second sometimes differed by a factor of `10`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677:74,depend,depend,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816776677,1,['depend'],['depend']
Integrability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1679,wrap,wrapper,1679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['wrap'],['wrapper']
Integrability,"GPU error messages are a little iffy because the CPU and GPU are not synchronized. ; The error appears in the pressure solver because it is the first location in the code where the GPU is synchronized (in this case through a memory copy).; ; There are a couple of ways to catch errors/debug, in general, what I recommend is to ; 1. use `--check-bounds=yes` this will allow you to pinpoint better the issue; 2. run a breaking code on the CPU, everything is easier there!; if this is not possible you can use the `-g 2` flag to allow GPU debugging but it is still a little more difficult than just migrating the code on CPU and making sure it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979:10,message,messages,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753896979,3,"['message', 'synchroniz']","['messages', 'synchronized']"
Integrability,Good catch. This should be made very clear as it has confused us in the past... I'll make sure to address this issue on the (increasingly stale =/) `ar/integrate-vs-grid` branch...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523:152,integrat,integrate-vs-grid,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/696#issuecomment-597581523,1,['integrat'],['integrate-vs-grid']
Integrability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:105,interface,interface,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['interface'],['interface']
Integrability,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1195,Inject,Injection,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['Inject'],['Injection']
Integrability,Good! I wonder if we can add a test here too to wrap this up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711:48,wrap,wrap,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711,1,['wrap'],['wrap']
Integrability,"Great job! Though I have not looked at the code, I have two comments:. 1. I am surprised that the choice of `regularization` affects the convergence rate. I will think about it more.; 2. The rate of convergence depends on the distribution of eigenvalues of the preconditioned linear operator. I have a piece code of that outputs the preconditioned linear operator as a dense `Matrix`, which can be useful for testing the convergence rate and new algorithms without invoking `Oceananigans`. It can be helpful for testing why `FlatExtrapolationOpenBoundaryCondition` results in a much slower convergence. Besides, I have found that grids with better symmetry have faster convergence because the resulting Laplacian operators have more repeated eigenvalues. In theory, the number of iterations required for the CG method to get the exact solution is the number of unique eigenvalues. ```Julia; using LinearAlgebra; using Oceananigans; using Oceananigans.Models.NonhydrostaticModels: ImmersedPoissonSolver; using Oceananigans.ImmersedBoundaries: active_cells_map, immersed_cell, mask_immersed_field!; using Oceananigans.Solvers: solve!; using Statistics: norm, mean. using Oceananigans.Solvers: precondition!. ENV[""JULIA_DEBUG""] = ""Solvers"". # ---------------------------------------------------------------------- #; # Define Parameters. # Numerical Technic; const arch = CPU(). # Grid; const Nx = 10; const Ny = 10; const Nz = 10; const Lx = 1.0; const Ly = 1.0; const Lz = 1.0. const Δz = Lz / 2 # elevation difference at the top. # ---------------------------------------------------------------------- #; # Define Utils. # Height at Top; @inline function z_top(y::R) where {R<:Real}; # return Lz - Δz * sin(π/2 * y/Ly) - Δz * 0.2; return Lz - Δz; end. # ---------------------------------------------------------------------- #; # Define the Simulation. # Grid; ib_grid = begin; underlying_grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (-Lx / 2, Lx / 2),; y = (0.0, Ly),; z = (0.0, Lz),; t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611:211,depend,depends,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3848#issuecomment-2420373611,1,['depend'],['depends']
Integrability,"Greg, is this something to be be done now? Let's get what we have now; completed and out to the community, get feedback etc. Development will; continue but we need to engage users. John. On Fri, Oct 25, 2019, 1:25 AM Gregory L. Wagner <notifications@github.com>; wrote:. > We need better and more stable time-steppers. One option is to implement; > by hand a 3rd-order low storage Runge Kutta scheme.; >; > Another interesting avenue is to figure out how to integrate with; > DifferentialEquations.jl, which would give us access to a large number of; > new time-steppers.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/506?email_source=notifications&email_token=AKXUEQROLPK63OJDILUPELLQQI4IFA5CNFSM4JE5AV32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HUIGFOQ>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRRJKIBWQ77UVXKGZDQQI4IFANCNFSM4JE5AV3Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327:458,integrat,integrate,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506#issuecomment-546217327,1,['integrat'],['integrate']
Integrability,"Ha, @rabernat beat me to it. I just wanted to mention that I am also available for questions and maybe clarify one more point of confusion that seems to stem from our current docs (working on improving that with @tomchor s input). . There are two parts in the NetCDF output that would make the integration with xgcm smooth: ; - Proper metadata for the dimensions (as mentioned by @rabernat above); - Output of grid metrics, which are distances, areas and cell volume of the grid. An important detail there is that each of the metrics should describe properties of the *surrounding cell*. So if you have a tracer value on the point `xT` and the cell bounds are given by a staggered coordinate `xC`, the distance (lets call it `dx`) for each `xT` point should describe the distance between the two surrounding `xC` points (and have `xC` as coordinate, so it can be matched correctly by xgcm). Currently the user has to input these manually but it might be convenient to add the [cf-attribute `cell_measures`](http://cfconventions.org/cf-conventions/cf-conventions.html#cell-measures), which we might support in the future with a more complete support for cf-metadata (see e.g. https://github.com/xgcm/xgcm/issues/127)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849:294,integrat,integration,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777081849,1,['integrat'],['integration']
Integrability,"Happy to try these. The first one failed in the same way as before. The second one failed because the syntax does not seem right with clock. I instead tried this. ```; model = IncompressibleModel(architecture=GPU(), advection=WENO5(), clock=Clock{Float64}(0,0,1), grid=grid); ```; and that also had an error, with what seems to be the same message. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388:340,message,message,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870707388,1,['message'],['message']
Integrability,"Heh, I agree that says nothing!. Do you have any thoughts about a preferred user interface, among the options I give above (or perhaps you have ideas for another design)? That's the first design question to answer before writing any code. Once we settle on an interface I think the code-writing will be fairly straightforward in this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247:81,interface,interface,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389662247,2,['interface'],['interface']
Integrability,"Hello @sam12396 , I am glad you have been able to run Oceananigans on GPUs. That could speed things up a great deal, depending on what you are trying to do. Oceananigans has been written in such a way that the user does not need to do anything different in terms of setting up a problem on CPUs vs GPUs. To illustrate my point, consider the shallow water Bickley jet example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/). The default is set up to run on CPUs but if you want to run it on GPUs, then it's easy. Where you define the model you need to add one line,. ```; model = ShallowWaterModel(; architecture=GPU(),; timestepper=:RungeKutta3,; advection=WENO5(),; grid=grid,; gravitational_acceleration=g,; coriolis=FPlane(f=f),; ); ``` ; When you make that one change (setting the architecture in the second line above), then the code will use GPUs. The producing of the data and reading and writing is then all done with GPUs. There is nothing else for you to do. In particular, if you define your forcing and initial conditions using functions, as the examples tend to do, then nothing needs to change. If you want to use Oceananigans.jl, are you sure you need to program things differently?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777:117,depend,depending,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509#issuecomment-808453777,1,['depend'],['depending']
Integrability,"Here's a clue: this fixes the issue. ```julia; Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). progress_cb = simulation.callbacks[:progress]; @show actuations = progress_cb.schedule.actuations. # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); progress_cb = simulation.callbacks[:progress]; progress_cb.schedule.actuations = actuations; run!(simulation, pickup=checkpoint); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650:173,message,message,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246088650,1,['message'],['message']
Integrability,"Here's a couple more thoughts:. * `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. * A very important usage of `Average`, however, is using it to reduce ""lazily evaluated data"". This is the case of taking an average of a ""`Computation`"". To take the average of a `Computation`, we have to trigger the generation of the data to be averaged. To support this functionality we have permitted `Average.field` to be defined as a `Computation`, and dispatched on this special case to ensure that the data is generated before the average is invoked. * One way to normalize these user-interfaces is to generalize the concept of an `AbstractField` to be ""lazy"" in general. There is one special case that does *not* require computation --- the ordinary case of a `Field`. But we can create an infrastructure where all `AbstractField`s are expected to have a function like `compute!` (or perhaps `evaluate!`). In that framework, we would always call `evaluate!` on `Average.field` before averaging it. Because `evaluate!(::Field) = nothing`, we preserve the basic functionality of `Average` when it acts on a basic `Field` and its data does not need to be generated. * Note that currently `Computation` data is stored in bare `Array`s. However, it should probably be stored as `Field`, and interacting with a `Computation` should feel the same as interacting with a field (with functions like `data`, `interior`, `getindex`, etc). We may also want to change the name of `Computation` to something that reflects its behavior a little more clearly. Perhaps `ComputedField`, or something. * `Average` itself should *also* subtype `AbstractField` within this framework. An `Average` is just a special type of computation that requires eva",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391:855,interface,interfaces,855,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674389391,1,['interface'],['interfaces']
Integrability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:41,depend,dependence,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,4,['depend'],"['dependence', 'dependent']"
Integrability,"Here's a new 1D validation case that tests a ""buoyant particle"" model using a dynamic slip velocity that depends on buoyancy. The particle concentration field migrates to it's neural buoyancy (here in the center of the domain), until the particle concentration reaches a steady-state in a competition between diffusion and buoyant slippage. https://user-images.githubusercontent.com/15271942/161167309-bfedffdb-6f2b-4552-8f49-1ec23ce7b4ed.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172:105,depend,depends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1085241172,1,['depend'],['depends']
Integrability,"Here's a screenshot of the top row from the final time-step:. ![image](https://user-images.githubusercontent.com/15271942/160630444-6b07529f-cf8b-4d03-8421-a6027153298e.png). showing significantly more small scale features on the left. The difference (the key to this PR) is using the velocity field in the smoothness metric for vorticity reconstruction, rather than the vorticity field. The ordinary WENO algorithm uses the smoothness of the field being reconstructed to produce weights for the candidate stencils. This method is therefore an innovation, since we are using the _velocity_ field to evaluate smoothness for reconstructing _vorticity_. The velocity field is smoother than vorticity, so this generally leads to less-dissipative stencils (but still ""enough"" dissipation to stabilize the simulation). @simone-silvestri definitely has more plots showing differences in spectra and time-series of integrated enstrophy, perhaps he will share!. I'm also going to paste an example of using this scheme in the code once I figure that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042:907,integrat,integrated,907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081922042,1,['integrat'],['integrated']
Integrability,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:725,interface,interface,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['interface'],['interface']
Integrability,"Here's the main differences:. 1. `FunctionOperation` is not backed by data; eg it doesn't allocate memory (its just a wrapper for a function); 2. `KernelComputedField` requires a `KernelAbstractions` `@kernel`. `FunctionOperation` requires a function of `i, j, k, grid, fields..., parameters)`. It's a subtle but real distinction. Sometimes defining `@kernel` may be more convenient / more readable.; 3. The `kernel` in `KernelComputedField` cannot be reduced on the fly (unless this is supported by `KernelAbstractions` someday, somehow, eg https://github.com/JuliaGPU/KernelAbstractions.jl/issues/234, but we don't know what this would look like yet). Taking the vertical vorticity for curvilinear / cubed sphere grids as an example, usage is. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᵃ # called with signature ζ₃ᶠᶠᵃ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = FunctionOperation(Face, Face, Center, ζ₃ᶠᶠᵃ, grid, computed_dependencies=(u, v)). ζ = ComputedField(ζ_op) # identical to `VerticalVorticityField`. barotropic_ζ = AveragedField(ζ_op, dims=3); ```. On the CubedSphere, `ζ₃ᶠᶠᵃ` cannot be expressed in terms of `AbstractOperations` due to the need to treat corners in a special manner.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910:118,wrap,wrapper,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623#issuecomment-827858910,1,['wrap'],['wrapper']
Integrability,"Hi @EavenW hope it wasn't too hard to get started (the documentation needs some more work, sorry about that). Not totally sure what you mean by a flux boundary condition with two components (sounds like the u and v velocity fields might be further coupled via this boundary condition?). Sounds like you're trying to impose a (time-dependent?) surface flux boundary condition which can be done a few different ways.; * If it's independent of time then [imposing a flux BC with a 2D array](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Creating-individual-boundary-conditions-1) is one option.; * If it's time-dependent then [imposing the flux BC as a function](https://climate-machine.github.io/Oceananigans.jl/stable/model_setup/boundary_conditions/#Specifying-boundary-conditions-with-functions-1) is probably the way to go. The function signature for boundary conditions is `f(i, j, grid, t, U, C, params)` so the boundary condition can depend on time `t`, the velocity fields `U = (u, v, w)` and any tracer quantity in `C`.; * If you can write your surface flux BC as a function of only (x, y, t) then a [`BoundaryFunction`](https://github.com/climate-machine/Oceananigans.jl/blob/master/src/BoundaryConditions/boundary_function.jl) can simplify the setup a little. I just realized this isn't showing up in the documentation but the docstring in the file I linked to has an example of how to use it. PS: Not sure which version you're running but we've been making some improvements to the user interface lately which may break certain things if you upgrade to v0.21 or v0.22. Please don't hesitate to ping us if you have any questions or if something isn't working. We're more than happy to help.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085:331,depend,dependent,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/629#issuecomment-586708085,4,"['depend', 'interface']","['depend', 'dependent', 'interface']"
Integrability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:350,message,messages,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,3,['message'],['messages']
Integrability,"Hi @jhdong2016, thanks for your interest in Oceananigans! . Personally I find it very difficult to help out without something that I can run and reproduce your results. Could you post your script somewhere also for making the plots. Something I can copy/paste in the REPL or just write `include(""jhdong_script.jl"")`?. It's often useful to post the version of Oceananigans you are using (and the rest of dependencies). E.g., post the output of `using Pkg; Pkg.status()`. Do I understand correctly or is it my impression that you have depth in the horizontal axis?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944:403,depend,dependencies,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560#issuecomment-2076765944,1,['depend'],['dependencies']
Integrability,"Hi folks. I just saw this issue. We are very glad that you're working to support interoperability btw oceananigans and xgcm! 🎉 We'd love to help however we can. Ideally you would not have to really do much here other than use CF conventions in your netCDF output and things would ""just work."" That's the beauty of standards. Unfortunately, CF conventions don't quite provide the right vocabulary to describe the curvilinear geometry of staggered grid models compactly (see https://github.com/cf-convention/discuss/issues/5). In the meantime, every modeling center seems to have their own preference for how to encode this (e.g. [comodo conventions](https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html) [now offline] used by ROMS and NEMO, [S-grid](https://github.com/sgrid/sgrid), [mosaics](https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf) from GFDL). . With xgcm, we decided to use the Comodo conventions (rather than invent yet another new convention). In retrospect, this was maybe the wrong choice, since the pycomodo project seems to have totally disappeared. 🤦 However, if you put the [right metadata](https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes) in your attributes, xgcm should be able to figure out your grid. Whatever you do, please try your best to squeeze your data into existing standard file formats and metadata conventions. ; Don't invent something new. MITgcm did this with the mds data format and it has been endless headaches for our community. I don't know what JLD2 is, but it sounds like you could be going down that route... If you have any questions, please ask! I'll try to respond.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134:81,interoperab,interoperability,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134,2,"['interoperab', 'rout']","['interoperability', 'route']"
Integrability,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:156,interface,interface,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,4,"['interface', 'wrap']","['interface', 'wrappers']"
Integrability,"Hi; I think I found another bug related to that. . The following code works fine. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), ∂x(b) / f); vz .= vz_op; ```. but it returns error if I put a plus sign. ```julia; using Oceananigans. grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)). b = CenterField(grid); f = 1. vz = Field{Face, Center, Center}(grid). vz_op = @at((Face, Center, Center), + ∂x(b) / f); vz .= vz_op; ```. no problem with the minus sign. Error message:. ```julia; TaskFailedException. nested task error: MethodError: no method matching getindex(::Tuple{DataType, DataType, DataType}, ::Int64, ::Int64, ::Int64); Closest candidates are:; getindex(::Tuple, ::Int64) at tuple.jl:29; getindex(::Tuple, ::Real) at tuple.jl:30; getindex(::Tuple, ::Colon) at tuple.jl:33; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812:613,message,message,613,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1098667812,1,['message'],['message']
Integrability,"Hm... I see both your points. The boundary layer is indeed pronounced in the buoyancy or buoyancy dissipation. But indeed for Ra=1e8 the boundary layer is most probably well-resolved. The boundary layer thickness, however, scales with Ra^{-1/5} or Ra^{-1/4} (depending on the flow regime)... Thus, for the Ra value in the example you are right: no modification is needed. But if one wants to take this up to higher Ra values then higher vertical resolution near the top will help. Perhaps we close this issue (as, I agree, is not really an _issue_ of the code). Or convert to discussion?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629:259,depend,depending,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629,1,['depend'],['depending']
Integrability,"Hm.... what version of Oceananigans did you try the quick_start example with? I'd bet you used a very old version, e.g., a version _before_ the breaking release [v0.90.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.90.0)?. The quick start example works on `main` for me:. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 12 seconds. 160 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z. julia> model = NonhydrostaticModel(; grid, advection=WENO()); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── advection scheme: WENO reconstruction order 5; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> ϵ(x, y) = 2rand() - 1; ϵ (generic function with 1 method). julia> set!(model, u=ϵ, v=ϵ). julia> simulation = Simulation(model; Δt=0.01, stop_iteration=100); Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── Next time step: 10 ms; ├── Elapsed wall time: 0 seconds; ├── Wall time per iteration: NaN days; ├── Stop time: Inf days; ├── Stop iteration : 100.0; ├── Wall time limit: Inf; ├── Callbacks: OrderedDict with 4 entries:; │ ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1); │ ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1); │ ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1); │ └─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613:351,depend,dependency,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551#issuecomment-2051288613,1,['depend'],['dependency']
Integrability,"Hmm yes we might need extensions to provide that functionality. Another possibility is to use plot recipes: https://docs.makie.org/stable/documentation/recipes/. That page says. > If you're a package developer, it's possible to add recipes without adding all of Makie.jl as a dependency. Instead, you can use the MakieCore package, which is a lightweight package which provides all the necessary elements to create a recipe, such as the @recipe macro, convert_arguments and convert_attribute functions, and even some basic plot type definitions. I'm not sure the stuff on `Imaginocean.jl` can be implemented with plot recipes, but if it can then perhaps that is a better approach?. Otherwise I agree that we should investigate extensions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865:276,depend,dependency,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-1629233865,1,['depend'],['dependency']
Integrability,"Hmm yes. We can implement a custom constructor. Or we can capture the additional info needed for the ""constructor"" `S` in a closure. We can also add constructors to `Krylov` with a more generic interface based on `similar` or `deepcopy` with a ""template array"". We do this for our solvers to achieve some generality even within the concept of `Field` (Field requires not only the size, but also ""locations"" on the staggered grid). https://github.com/CliMA/Oceananigans.jl/blob/45838a57dd5ebc1153c2c827f83cb848d20e4c92/src/Solvers/conjugate_gradient_solver.jl#L87-L89. I think using a closure is simpler though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436:194,interface,interface,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2388817436,2,['interface'],['interface']
Integrability,"Hmm, well `ρg` is literally the force density exerted by the weight of the fluid. On Wikipedia, 'buoyancy' is the force induced when you displace fluid; therefore the buoyancy of a solid object is equal to . gravitational acceleration x (volume of object x density of displaced fluid - mass of the object). which gives the forcing acting on the body (positive upwards due to the sign of the terms). Here we deal in densities, so the buoyant forced defined in the same manner would essentially be . gravitational acceleration x ( reference density - density of the buoyant fluid ) . which of course is precisely `-ρ' g`, since `ρ' = ρ - ρ0`. I think that from its usage the meaning of `buoyancy_perturbation` is clear. . Something to keep in mind as we continue to discuss this topic outside this PR is that atmospheric scientists go even a step further and define 'buoyancy' as `-(ρ' - <ρ'>) g / -ρ0`, where `<>` is a horizontal average --- thus omitting the z-dependent, horizontally uniform part of the 'total' buoyancy that does not contribute to dynamics (because it is balanced by a static component of pressure). Thus using `buoyancy_perturbation` to denote a quantity which, for them, comprises even non-dynamic, irrelevant components of `-ρ' g / -ρ0` could seem a bit odd.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079:961,depend,dependent,961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-533129079,1,['depend'],['dependent']
Integrability,"Hmm, well it looks like we do compute arguments:. https://github.com/CliMA/Oceananigans.jl/blob/abd447980898bcbfe099d71258d4e52f3cf090f9/src/AbstractOperations/kernel_function_operation.jl#L75. But if the arguments are themselves wrapped inside a `NamedTuple` --- or any other object --- then they won't be computed. In other words `compute!(perturbation_velocities)` does not compute the elements of `perturbation_velocities`. We could add a method `compute!(tup::Tuple) = Tuple(compute!(t) for t in tup)` and also for `NamedTuple`. But I'm not sure this is the best API. Maybe it's better to require that arguments that need to be computed should be included directly as arguments. Seems like its up for debate. PS it does seem to test this correctly then we need to further evaluate . ```julia; f_perturbation = Field(f_perturbation_op); compute!(f_perturbation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508:230,wrap,wrapped,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1927373508,1,['wrap'],['wrapped']
Integrability,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:636,integrat,integrate,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"Hmm. I think its value as a validation experiment really does depend on keeping it up to date with the current version of Oceananigans. What's really useful to people is the validation script that works for current Oceananigans that people can edit and modify, I think... otherwise it's more a discussion that second-order finite volume / difference methods can reproduce the driven cavity, I suppose. I understand the point though that this work has value and it's a shame to hide it away. I think it might be nice to have a separate repository of ""cool setups"", each of which links to the specific Oceananigans version that it works with...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415:62,depend,depend,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872347415,1,['depend'],['depend']
Integrability,Hmm... there's a function in `CUDA.jl` called `partial_mapreduce_grid` that might contain logic that depends on the size of the kernel (not sure): https://github.com/JuliaGPU/CUDA.jl/blob/92f1001861641cb173af49454b05c91728cbfc3d/src/mapreduce.jl#L91,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699:101,depend,depends,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684#issuecomment-845597699,1,['depend'],['depends']
Integrability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:737,message,message,737,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['message'],['message']
Integrability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:139,depend,depends,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['depend'],['depends']
Integrability,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,inject,injected,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768,1,['inject'],['injected']
Integrability,"Hmmm, I don't know if many log levels will be that helpful. I guess for debug messages we'll want to have the file name and line number, but for user-facing info messages maybe we should remove the file name and line number and instead a custom log level like `DIAGNOSTIC` or `MODEL_SETUP` will be useful. I think one place that logging can hugely improve user experience is in setting up large models, especially on the GPU, where you could be waiting for several minutes while all of Julia, CUDA, and Oceananigans compiles, model is being set up, memory is allocated, etc. We know it takes time but most users will think that something is wrong if Julia is silent for 5 minutes. In this context info messages can be useful and reassure the user that Oceananigans is working properly. It's well known that progress indicators improve user experience, e.g.: https://www.nngroup.com/articles/progress-indicators/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192:78,message,messages,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/478#issuecomment-546952192,3,['message'],['messages']
Integrability,"Hmmm, I guess the immediate issue is that `LatitudeLongitudeGrid` doesn't have a 1-location `xnodes` functions:. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/Grids/latitude_longitude_grid.jl#L635-L656. But it shouldn't as x will depend on longitude and latitude. Probably most users will want output in longitude and latitude though. The bigger issue is that the `NetCDFOutputWriter` is not aware of the `LatitudeLongitudeGrid`. As this is covered by issue #2248 I'll close this issue as a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939:275,depend,depend,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775#issuecomment-2340897939,1,['depend'],['depend']
Integrability,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:190,message,message,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367,3,['message'],"['message', 'messages']"
Integrability,"How do we deal with errors of this kind in the doctests?:. ```;   | │;   | │ diff =;   | │ ┌ Warning: The behavior of `gravity_unit_vector` changed in version 0.80.0.;   | │ │ Prior to this version, `gravity_unit_vector` indicated the direction _opposite_ to gravity.;   | │ │ After version 0.80.0, `gravity_unit_vector` indicates the direction of the gravitional acceleration;   | │ └ @ Oceananigans.BuoyancyModels ~/repos/Oceananigans.jl/src/BuoyancyModels/buoyancy.jl:44;   | │ ~/builds/tartarus-13/clima/oceananigans/src/BuoyancyModels/buoyancy.jl:48; ...; ```. i.e. when the warning message is the same but it's thrown in a different machine to the path to the warning-generation line is different. I remember there was a relatively simple way to deal with this, but I can't find it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603:588,message,message,588,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460567603,2,['message'],['message']
Integrability,"Huh, so its the difference between. https://user-images.githubusercontent.com/15271942/165942956-f73c2f7c-88dd-4c1a-9775-c209a2007894.mp4. where the hydrostatic pressure is treated _explicitly_ (via RK3 in this example) by integrating buoyancy, and. https://user-images.githubusercontent.com/15271942/165942854-8061b8fe-a254-4ed0-8f66-d6283415fd8a.mp4. where pressure is treated implicitly with an elliptic solve and fractional step (at every RK3 stage...). I tested reducing the time-step and don't see any convergence with time-step. Reducing the time-step and running 5 times as long produces. https://user-images.githubusercontent.com/15271942/165946791-6cb90b71-f361-42d9-82db-b16baaf6c3db.mp4. On `main` the same does:. https://user-images.githubusercontent.com/15271942/165952404-00e93a46-65a2-4b9b-a617-43a424f455b1.mp4. Note also these results depend on resolution (which I'm not showing). So it seems both are wrong but one is more so and it's O(1) in time. I also tested WENO5 advection (no difference) and high resolution (seems to make a difference).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950:223,integrat,integrating,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1114810950,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,"I agree that `z_faces` is clearer! I just wanted to be sure we were talking about the same changes. I believe that specifying the grid with `z_faces` does indeed require knowledge of the number of grid points, because the user specification depends on the vertical _index_. The case of a uniform grid illustrates this point: `z_faces = k -> (k - 1) * Lz / (Nz + 1)` for `z = (0, Lz)`. Note that the keyword argument `z` is redundant, since it can be inferred from `z_faces` (by evaluating `z_faces(1)` and `z_faces(Nz+1)`. Thus I am not sure I agree that we should require the `z` keyword argument when `z_faces` is supplied. I think it'd be nice to have both a ""discrete"" interface that uses the `z_faces` or `z_cell_interfaces` keyword argument, as well as a ""continuous"" interface that accepts a ""mapping"" or ""stretching"" function as I described above. With a ""continuous"" interface, the interval kwarg `z` is required because it cannot be inferred from `z_stretching` or `z_map` (whichever we prefer).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490:241,depend,depends,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815159490,8,"['depend', 'interface']","['depends', 'interface']"
Integrability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:454,interface,interface,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,1,['interface'],['interface']
Integrability,I also don't like `calc_nonlinear_κᶜᶜᶜ`. I hope we can come up with a better interface for defining LES closures in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168:77,interface,interface,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419779168,1,['interface'],['interface']
Integrability,"I am a little perplexed, because it seemed that tests on the PR passed (except for documentation, which is mysteriously broken right now due to a dependency that's getting updated during `dev ..` in the docs build). ![image](https://user-images.githubusercontent.com/15271942/114247433-ed6df200-9949-11eb-8649-f270ee7e12c7.png). ![image](https://user-images.githubusercontent.com/15271942/114247449-f5c62d00-9949-11eb-96af-02532bde76ef.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193:146,depend,dependency,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566#issuecomment-817010193,1,['depend'],['dependency']
Integrability,"I am also doubting our regression data. For sure it is a synchronization problem, but it is difficult to understand wether it's on the data (generated long time ago) or in the current code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971:57,synchroniz,synchronization,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1427950971,1,['synchroniz'],['synchronization']
Integrability,"I am copying this out from `immersed_grid_metrics.jl` since it seems a little ofset above, and switching i's for k's, since it is the vertical direction. ```; Immersed Fluid; ----------- ...........; | ∘ | ∘; f c f c; k-1 k-1 k k; ```; My understanding was that in `GridFittedBottom` we had a transition from solid to fluid at `f_k`. If that's the case then I thought the partial cell would be the one above with `c_k` in the itnerior. That's why I thought `c_{k-1}` is immersed and `c_k` is at the interface. Agreed?. The grid fitted problem as a special case where the height in the immersed cell is 0, where as in partial cells it can be anything above zero and up to the top of that cell (or within a tolerance). I hope that we can use the same functions for both, otherwise, much more confusion can arise and I am glad we are having this discussion. Thank you @jm-c for the comment. I will now change the default to 0.1, since that's what is currently used. I presume this means we don't don't want to have partial cells that are in the bottom 20% of the cell or the top 20% of the cell as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924:499,interface,interface,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1043031924,1,['interface'],['interface']
Integrability,"I am glad that we are talking about this and I'm also happy to help if I can. One thing that I noticed on the docs is that we say we are using the finite volume method but then we never actually integrate the PDEs to obtain the equations in terms of the cell averaged quantities. I think this would be helpful to the user as it would point out the differences between the value at a point and the cell average of that quantity. I don't think there needs to be a lot but integrating the tracer equation first, since that's easier, and the integrating the momentum equation would add someting which at that moment I don't think is present. What do you think @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269:195,integrat,integrate,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873594269,3,['integrat'],"['integrate', 'integrating']"
Integrability,I am in the JLD2 camp since it has less dependencies and is easier to get working ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873:40,depend,dependencies,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1261#issuecomment-740673873,1,['depend'],['dependencies']
Integrability,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:314,wrap,wrap,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906,1,['wrap'],['wrap']
Integrability,"I am open to either option, depending on which is possible at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267:28,depend,depending,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2930#issuecomment-1557910267,1,['depend'],['depending']
Integrability,"I am trying to get back to the validation script and when I try accessing the data it gives me an error. Is this a known problem? @glwagner @simone-silvestri ?. ```; ┌ Info: Downloading; │ source = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2""; │ dest = ""/u/fpoulin/.julia/scratchspaces/124859b0-ceae-595e-8997-d05f6a7a8dfe/datadeps/quarter_degree_near_global_lat_lon/tau_x-1440x600-latitude-75.jld2""; │ progress = NaN; │ time_taken = ""0.07 s""; │ time_remaining = ""NaN s""; │ average_speed = ""3.493 MiB/s""; │ downloaded = ""250.411 KiB""; │ remaining = ""∞ B""; └ total = ""∞ B""; ERROR: HTTP.Exceptions.StatusError(404, ""GET"", ""/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/tau_x-1440x600-latitude-75.jld2"", HTTP.Messages.Response:; """"""; HTTP/1.1 404 Not Found; Server: GitHub.com; Date: Thu, 20 Jun 2024 13:36:59 GMT; Content-Type: text/html; charset=utf-8; Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept-Encoding, Accept, X-Requested-With; Cache-Control: no-cache; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload; X-Frame-Options: deny; X-Content-Type-Options: nosniff; X-XSS-Protection: 0; Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin; Content-Security-Policy: default-src 'none'; base-uri 'self'; child-src github.com/assets-cdn/worker/ gist.github.com/assets-cdn/worker/; connect-src 'self' uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com api.githubcopilot.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com/v1/engines/github-completion/completions *.a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454:901,Message,Messages,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-2180730454,1,['Message'],['Messages']
Integrability,"I applaud @vchuravy suggestion. On a different note, @fluidnumerics-joe you need to resolve the dependencies in Manifest; see. https://buildkite.com/clima/oceananigans/builds/14348#018d8bb7-22a8-4a33-9839-626ade95f3c8/18-36. I tried to do it but I don't have push rights on your fork.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967:96,depend,dependencies,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935371967,1,['depend'],['dependencies']
Integrability,"I checked and `interpolate(field, x, y, z)` isn't used anywhere in the source code but in a few validation experiment. It basically does the same thing, but extracts the fields location and grid. I've tried changing it to just be a wrapper for `interpolate(field, LX, LY, LZ, grid, x, y, z)` like:; ```julia; @inline interpolate(field::AbstractField{LX, LY, LZ, G, T, N}, x, y, z) where {LX, LY, LZ, G, T, N} = interpolate(field, LX(), LY(), LZ(), G, x, y, z); ```; but this fails as a dynamic funciton invocation. I also tried changing it to:; ```; @inline function interpolate(field, x, y, z); LX, LY, LZ = location(field); grid = field.grid; return interpolate(field, LX(), LY(), LZ(), grid, x, y, z); end; ```. but this errors with `Reason: unsupported call to an unknown function (call to jl_f_getfield)`, so I'm not sure its going to be straight forward or worthwhile trying to make the high level version work on GPU. Also, if we want to test interpolation, it always fails on GPU because of scalar indexing if called directly, but if wrapped in a kernel function is fine:; ```julia; @kernel function test!(field, grid, res, x, y, z); n = @index(Global); LX, LY, LZ = location(field); @inbounds res[n] = interpolate(field, Center(), Center(), Center(), grid, x[n], y[n], z[n]); end; ```; (If I put `grid = field.grid ` in the kernel function it also fails like above).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689:232,wrap,wrapper,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1367924689,2,['wrap'],"['wrapped', 'wrapper']"
Integrability,"I checked the help and indeed there is!. ```; help?> nameof; search: nameof. nameof(m::Module) -> Symbol. Get the name of a Module as a Symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> nameof(Base.Broadcast); :Broadcast. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(t::DataType) -> Symbol. Get the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> module Foo; struct S{T}; end; end; Foo; ; julia> nameof(Foo.S{T} where T); :S. ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. nameof(f::Function) -> Symbol. Get the name of a generic Function as a symbol. For anonymous functions, this is a compiler-generated name. For; explicitly-declared subtypes of Function, it is the name of the function's type. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606:404,wrap,wrapped,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986842606,1,['wrap'],['wrapped']
Integrability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:504,interface,interface,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['interface'],['interface']
Integrability,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:187,depend,dependency,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,1,['depend'],['dependency']
Integrability,I copied the whole line above in the initial message. . But to answer your question it's coming from `automatic_halo_sizing.jl`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666#issuecomment-843331768,1,['message'],['message']
Integrability,"I didn't make a suggestion except the extremely Holy Principle that the default _absolutely must work_. Otherwise the code is just broken and honestly, when I encounter this in other packages I often decide not to use them. It wouldn't be unreasonable to use VectorInvariant as the default for the hydrostatic model honestly. But if we want to have a flux form default then yes it has to depend on the grid to satisfy Holy Principle 1.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091:388,depend,depend,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2400243091,1,['depend'],['depend']
Integrability,"I didn't quite understand what the bug in AMD was. Was it important?. (Asking because one of your commits contained a bugfix for AMD, according to the message)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973:151,message,message,151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1062413973,1,['message'],['message']
Integrability,"I do not mean that. I think it should be a major change. When I wrote down that sentence, I did not realize that `compat` in `Project.toml` can prevent using newer versions of dependencies with breaking changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825:176,depend,dependencies,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3153#issuecomment-1608583825,1,['depend'],['dependencies']
Integrability,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:121,message,message,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539,1,['message'],['message']
Integrability,I do! I'll send a message on slack.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1097521696,1,['message'],['message']
Integrability,"I don't have very much to offer, but I believe that compiler behavior / execution can differ on different machines due to difference in underlying packages and compiler dependencies, even when the julia packages are identical. If someone else has encountered the same issue then maybe we can make progress?. It'll be nice if upgrading to 1.6 (#1514) solves this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610:169,depend,dependencies,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625#issuecomment-828136610,1,['depend'],['dependencies']
Integrability,"I don't know a good reference for everything... To start with, our object is to calculate advective fluxes across cell interfaces. For this purpose we need to know the velocity field and the advected quantity (usually a tracer or velocity component) at the cell interfaces. The tracer schemes are simple, because by construction the velocity field is located at cell interface and no interpolation is required for the velocity field. Only the tracer field is interpolated. In this case the advection scheme corresponds to the interpolation method. The interpolation method ""reconstructs"" the value of the tracer field at cell interfaces, given knowledge of the _cell-averaged tracer values_ on a regularly spaced grid. It's important that the stencils are specific to reconstruction using cell-averaged values (ie, a finite volume distribution) rather than tracer values at nodes. `CenteredSecondOrder` just averages the cell-averaged tracer values on either side of the interface. `UpwindBiasedThirdOrder` incorporates an addition cell in the upwind direction. `CenterdFourthOrder` uses a fourth order stencil for a cell-averaged finite volume representation. `UpwindBiasedFifthOrder` uses 5 cells around the cell interface, biased in the upwind direction. `WENO5` combines three third-order stencils using a smoothness indicator that biases the stencil away from discontinuities and rapid changes in the underlying tracer distribution. The advection scheme for momentum is more complicated because both the advected quantity and advecting velocity field have to be interpolated. For this we use symmetric interpolation (even-ordered interpolation) of the advecting velocity, and the same interpolation scheme used for tracers for the advected quantity. For a centered advection scheme (`CenteredSecondOrder`, `CenteredFourthOrder`) the symmetric interpolation for advecting velocities is identical to interpolation used for advected quantities. For an upwind-biased advection scheme (`UpwindBiasedTh",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724:119,interface,interfaces,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873429724,10,['interface'],"['interface', 'interfaces']"
Integrability,"I don't know how the spherical hydrostatic model does this but I agree this would be nice to have for the rectilinear model as well. From what I recall from Sadourny (1975) you can have either energy or enstrophy conserving schemes, depending on how you do the averaging. When I played around with them I found that the enstrophy conserving scheme managed to prevent a numercial instability that can occur, but the energy conserving scheme did not. But getting either one (or both) working would be great!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735:233,depend,depending,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818#issuecomment-873595735,1,['depend'],['depending']
Integrability,"I don't know this fits here, but I was thinking about a way to have a separate repository for examples from community that doesn't affect the test running time of the main repo. . The repo could generate a wiki-like page with the examples. We could give a code template for the simulations. For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. What do you guys think? . I know this can get messy.. but it could be a nice way to avoid people reinventing the wheel while making their own simulations. With enough time, almost any experiment will have some others similar.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801:380,depend,dependencies,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062498801,1,['depend'],['dependencies']
Integrability,"I don't think ""child"" is used in standard way here. Usually ""child"" refers to a processes that is dependent on another process. That's not the relationship between `Distributed` and `CPU`... https://www.computerhope.com/jargon/p/parechil.htm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820:98,depend,dependent,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3716#issuecomment-2297210820,1,['depend'],['dependent']
Integrability,"I don't think I understand how this is ill-posed? It is over specified so will not produce physical results but I thought that without a radiating condition this should still not NaN straight away there should just be a lot of reflections from the boundaries?. Here is a simplified version of my code: https://github.com/jagoosw/OpenBoundaries.jl/blob/main/validation/bug_mwe.jl. I am using a matching scheme that advects the perturbation component (defined as the boundary adjacent minus imposed velocity) out of the domain, and relaxes to the imposed velocity at different rates depending on if it is an inflow or outflow (for the v component the timescale is Inf for outflows to allow it to maximally transmit information out). I can run it with no matching scheme but it needs tiny timesteps because the noise at the boundaries becomes massive. When I use the default pressure solver it kind of works. There are some bugs, for example, there is this weird jet generation on the southern inflowing boundary. I think these would be solved with relaxing regions. . https://github.com/user-attachments/assets/a85e66e2-3da7-402a-b546-57a3860cef9c. If I run with the CG solver it NaNs ""immediately"" and is doing ~800 iterations. If I restrict the iterations it doesn't NaN as fast, but generates very high velocities in a random place:. https://github.com/user-attachments/assets/d7ea836e-f69c-4f3a-9559-c64216e95cb0. I think there is also an issue with my model that its not respecting when a boundary adjacent cell is immersed so I'll fix that and get back to you. Perhaps the ""immediate"" NaNs are actually just from the timestep not being small enough as the reflections and bathymetry interactions make some very high velocities (in my case ~40x higher than the inflows)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283:581,depend,depending,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2411422283,2,['depend'],['depending']
Integrability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:412,interface,interface,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,2,['interface'],"['interface', 'interfaces']"
Integrability,I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806:39,depend,dependency,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806,1,['depend'],['dependency']
Integrability,"I don't want to initialize MPI when importing the module because you might import the module but not use MPI routines. ; This might lead to errors/confusion. For example, the initialization is implicit when constructing the architecture which hasd to use MPI routines (for example `MPI.Comm_rank(MPI.COMM_WORLD)`. If you want to explicitly use MPI routines in the script (as the example above), it makes sense you initialize MPI and not hide the initialization somewhere else. If you want you can introduce an API for calculating the rank and the size that internally initializes MPI, although I don't really deem it necessary to have our own take on MPI as MPI is already very standardized.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033:109,rout,routines,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894736033,3,['rout'],['routines']
Integrability,I find that the code for boundary conditions for particles cannot deal with unusually large velocity \(when $u\Delta t$ has the order of the domain size\). Fixing the related code \(Yixiao-Zhang/Oceananigans.jl@95f68a1\) enables running the script that I posted previously in this page. Do we need an additional test for such cases?. One remaining question is why the log shows that the error occurs from the pressure solver. Can we do anything to improve the accuracy of error messages?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918:478,message,messages,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1753799918,1,['message'],['messages']
Integrability,"I found a similar problem \(see #3320\), but I am not sure whether it is related or not. I do not know whether `synchronize(device(architecture(model)))` will solve my problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431:112,synchroniz,synchronize,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1751498431,1,['synchroniz'],['synchronize']
Integrability,"I get the same problem, and it looks like the boundary condition is added correctly:. ```julia; julia> model.velocities.u; 1×1×32 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×32 ImmersedBoundaryGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Value, immersed: ImmersedBoundaryCondition; └── data: 1×1×38 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:35) with eltype Float64 with indices 1:1×1:1×-2:35; └── max=-0.0857023, min=-0.972122, mean=-0.393485; ```. I think `FluxBoundaryCondition` is tested here:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/test/test_boundary_conditions_integration.jl#L231-L241. (though only for `NonhydrostaticModel`)... Might make sense to build up those boundary condition integration tests for `HydrostaticFreeSurfaceModel` and also for `ValueBoundaryCondition` and `GradientBoundaryCondition`. @simone-silvestri is this broken because we are now using ""boundary-aware"" derivatives?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317:927,integrat,integration,927,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3208#issuecomment-1660104317,1,['integrat'],['integration']
Integrability,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:76,depend,dependency,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,1,['depend'],['dependency']
Integrability,"I guess `partition` would take the place of `ranks`. I think it makes sense to delay building `connectivity` (ie we only build connectivity when we build fields and their boundary conditions) --- because we can construct connectivities if we have 1) grid and 2) the partition. But we still have to store the partition in either `grid` or `grid.architecture`, correct?. One approach could produce code like. ```julia; arch = MPIArchitecture() # note no arguments; grid = RectilinearGrid(arch, grid_kw..., partition=XPartition()); ```. internally, the constructors maybe take the form. ```julia; function RectilinearGrid(arch, size, other_grid_kw, architecture_kwargs...); arch = rebuild_arch(arch; architecture_kwargs...); # etc; end; ```. That's possibility (1). Possibility (2) is to use a wrapper for MPI jobs, perhaps completely eliminating `MPIArchitecture` altogether:. ```julia; arch = CPU(); grid = RectilinearGrid(arch, kw...); grid = MultiProcessGrid(grid, partition=XPartition()); ```. Possibilty (3) is to change all the `struct` definitions for grids so they have additional information pertinent to multi-process stuff, which is set to `nothing` when unused. The downside to (2) is that it introduces yet another level of indirection, on top of both `ImmersedBoundaryGrid` and `MultiRegionGrid`. If we wanted to do MPI-distribued, multi-region simulations in complex domains, we have 4 (!) levels of wrapping. Hmm...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724:791,wrap,wrapper,791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1121094724,2,['wrap'],"['wrapper', 'wrapping']"
Integrability,"I guess if you have a (julia) function that takes a particle time-step, given a velocity field (ie 3D array), then you can use PlanktonIndividuals.jl online with Oceananigans now, using the `Callback` Oceananigans feature that's designed for integration with other models. So maybe it already works in fact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871:242,integrat,integration,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871,1,['integrat'],['integration']
Integrability,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108,1,['wrap'],['wrapped']
Integrability,"I guess there are two questions here; one regards user interface and the other regards how we determine defaults internally. It's worth pointing out from the outset that we may have too many defaults right now; we should try to tackle that. On user interfaces, we haven't converged on a way to set parameters like ""radius of the Earth"" and ""gravitational acceleration"". One philosophy could be to never use defaults. Unfortunately that is not very friendly / convenient, but on the upside it would help users ensure that these constants are always consistent. I guess we have to decide on an approach for the user interface first; then the internal code will follow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341:55,interface,interface,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492630341,3,['interface'],"['interface', 'interfaces']"
Integrability,"I guess to have a continuous diffusion function that has the same features of the discrete version (with field dependency and parameters), we could implement something very similar to the `ContinuousForcing.` That would require a regularization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624:111,depend,dependency,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2401764624,1,['depend'],['dependency']
Integrability,"I guess when we made it so auxiliary fields can be field dependencies for forcings we a) only tested on nonhydrostatic models, and b) didn't implement for functional boundary conditions. I also have no idea how this didn't cause OceanBioME models I've run on HydrostaticFreeSurface models to error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292:57,depend,dependencies,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755897292,1,['depend'],['dependencies']
Integrability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:54,interface,interface,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['interface'],['interface']
Integrability,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,1,['depend'],['dependency']
Integrability,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:99,depend,depend,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['depend'],['depend']
Integrability,"I just checked the time evolution of the velocity field in this case. It seems to me that shear instability occurs when running the script on a GPU. However, the flow is steady when running the script on a CPU. Does CUDA introduce floating-point error that has x-dependence? Perhaps from the pressure solver?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559:263,depend,dependence,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1772918559,1,['depend'],['dependence']
Integrability,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:228,depend,dependent,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382,2,['depend'],['dependent']
Integrability,"I just noticed this:. ```julia; julia> x = range(1, stop=10, step=1.0); 1.0:1.0:10.0. julia> y = reshape(x, 10, 1, 1); 10×1×1 reshape(::StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}, 10, 1, 1) with eltype Float64:; [:, :, 1] =; 1.0; 2.0; 3.0; 4.0; 5.0; 6.0; 7.0; 8.0; 9.0; 10.0. julia> typeof(y); Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}; ```. So the reshaped ranges do not convert to arrays / `collect` elements --- they are still ranges, with a wrapper (which means that we don't have to do anything special for GPU). I don't think there's any downside to reshape the ranges for convenience in this case. This will slightly simplify the `xnodes`, etc functions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364:558,wrap,wrapper,558,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/348#issuecomment-520479364,1,['wrap'],['wrapper']
Integrability,"I know it's documented in the code but also: https://github.com/CliMA/Oceananigans.jl/blob/bf04295910ef02ca3d4105bee801070deef99175/src/OutputReaders/field_time_series_reductions.jl#L17. Would something simple like this work?. ```julia; function reduce_4d(spatial_reduction::Function, temporal_reduction::Function, f::Function, fts::FTS4D; dims, kw...); reduced_snapshots = [; spatial_reduction(f, fts[n]; dims=filter(d -> d != 4, dims), kw...); for n in 1:length(fts.times); ]; return temporal_reduction(reduced_snapshots); end; ```. I guess we might want a similar interface to the 3D reductions but this should work for all the reductions in `field_time_series.jl`: `(:sum, :maximum, :minimum, :all, :any, :prod)`. It wouldn't work for things like `median` or `quantile` which need to act on the entire 4D array at once, but maybe these aren't _actually_ reductions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151:567,interface,interface,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144#issuecomment-2322107151,2,['interface'],['interface']
Integrability,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:42,message,message,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,1,['message'],['message']
Integrability,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:905,depend,depend,905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690,1,['depend'],['depend']
Integrability,"I mean the new user interface for `ImmersedBoundaryCondtion`. Previously, I tried to do a simulation with heating distributed on an irregular bottom, and I found that I had to use `ImmersedBoundaryCondition(top = the_bottom_heating)` instead of `ImmersedBoundaryCondition(bottom = the_bottom_heating)` after some testing. I felt this strange and reported this behavior to Simone. Then he opened this issue, because it affects his simulations as well. I am sorry for confusing you, since you did not know Simone and I had some discussion on issue before.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782:20,interface,interface,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3141#issuecomment-1583286782,1,['interface'],['interface']
Integrability,"I moved it to Diagnostics, but it's not compiling yet because it depends on OutputWriters, which is compiled right after Diagnostics. Compiling OutputWriters before Diagnostics doesn't work also because there are some dependencies there too. I think the `define_output_variable!` part could be moved towards `OutputWriters` (since it's only used by the NetCDF writer), but the annoying thing is that I'm also using `slice_parent` in the very definition of the average, which is defined in `field_slicer.jl`. Let me know what you think, but I actually think stuff related to `FieldSlicer` could be moved to outside of `OutputWriters` since it has found other uses outside of the NetCDF output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497:65,depend,depends,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784610497,2,['depend'],"['dependencies', 'depends']"
Integrability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:119,depend,dependent,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['depend'],['dependent']
Integrability,"I prefer `HorizontalDirections` to `XYDirections`. ""Horizontal"" is more meaningful when we're on a spherical shell. I understand that gravity can be rotated, but I think ""horizontal directions"" will be primarily used with models that are not rotated. The same issue plagues `XYZDirection` --- its a Cartesian / Rectilinear centric view. The situation makes even less sense on a cubed sphere, where ""x"" and ""y"" are arbitrary and pointed in different directions depending on the location on the sphere. How do others feel?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594:460,depend,depending,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1047374594,1,['depend'],['depending']
Integrability,I proposed `domain_depth` to distinguish it from the already existing `depth` interface that tracks the `depth` as a function of `k` which is used in the turbulence closure module. I think `domain_depth` communicates the idea of a total static depth.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139:78,interface,interface,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418731139,1,['interface'],['interface']
Integrability,"I ran a few tests using the [Bickley Jet](https://github.com/CliMA/Oceananigans.jl/blob/glw-vw/grid-fitted-incompressible-model/validation/immersed_boundaries/immersed_bickley_jet.jl) with an immersed top wall from the validation script. . ### Surface Normal Velocity; We can easily look at the surface normal velocity of the immersed wall (which should be zero) with increased resolution and see that it is converging nicely, as this method should be exact except for the pressure correction, which will scale. ![Bickley_normal](https://user-images.githubusercontent.com/67593861/122986244-2e807a80-d36d-11eb-924a-074ca0ad127c.png). ### Tracer Conservation; We can also look at tracer conservation. The initial concentration is sinusoidal, so the area integrated concentration is zero over the domain initially. I've plotted both the IBM and non-IBM (lighter colors) results to see the differences. This one is on a log plot. You can see that leakage is happening in the IBM versions. It's hard to say how bad the leakage is here, and it'll probably be better to consider an initial constant concentration rather than sinusoidal to see how much leakage is occurring due to the immersed solid. ![volint_Concentration_log](https://user-images.githubusercontent.com/67593861/122986580-a058c400-d36d-11eb-9a7c-e3e8d2a7367e.png). It might be easier to see what is going on in the IBM cases without the log scaling:. ![volint_Concentration](https://user-images.githubusercontent.com/67593861/122989251-984e5380-d370-11eb-88cc-ccf4444fb331.png). ### Integrated Boundary Stress; Finally, I looked at the integrated boundary stress along the top wall. The error between the nonIBM and IBM versions at these same grid sizes are below. Unfortunately this is not getting better with increased resolution. This could be due to base state changes causing the stress to change and not necessarily something wrong with the method. It might take better refinement than 256 x 256 to really see a trend here. ![Bickley_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588:753,integrat,integrated,753,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866285588,1,['integrat'],['integrated']
Integrability,"I ran this using the latest version and I got no error. @Sumanshekhar17 can you please confirm the version? If the version is 0.58.2, can you please post the full code?. I got the code below from a slack message and it ran with no problems:. ```julia; using Random; using Printf; using Oceananigans; using Oceananigans.Units: minute, minutes, hour; Lz=32; Nz=32; S = 1.1 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (32, 32, 32), ; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=8e-4)); Qʰ = 200 # W m⁻², surface _heat_ flux; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; cᴾ = 3991 # J K⁻¹ s⁻¹, typical heat capacity for seawater; Qᵀ = Qʰ / (ρₒ * cᴾ) # K m⁻¹ s⁻¹, surface _temperature_ flux; dTdz = 0.01 # K m⁻¹; T_bcs = TracerBoundaryConditions(computational_grid,; top = FluxBoundaryCondition(Qᵀ),; bottom = GradientBoundaryCondition(dTdz)); u₁₀ = 10 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻²; u_bcs = UVelocityBoundaryConditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:204,message,message,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"I realized I can see from the error message that the grid is `Bounded` in all directions. I've never used this feature but I think you aren't specifying the tracked fields correctly. It needs to be something like. ```julia; # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T); ```. In other words, the values of the NamedTuple are themselves fields. So you have to build `tracers` before constructing the model. Something like this may work:. ```julia; tracers = (T=CenterField(grid), S=CenterField(grid)). # Define tracked fields as a NamedTuple; tracked_fields = (; T=tracers.T). model = NonhydrostaticModel(; grid, tracers, ...); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060:36,message,message,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609#issuecomment-2136262060,1,['message'],['message']
Integrability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:17,interface,interface,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:433,depend,depend,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,1,['depend'],['depend']
Integrability,I see `domain_depth`. What is the proposed interface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001:43,interface,interface,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2418064001,1,['interface'],['interface']
Integrability,"I see it like this: Tartarus is a shared system with very small limitations so it is quite difficult to prevent people from running on GPU 0 (I do not think we have the ability to implement a scheduler), so there is more possibility to incur in downtime due to users running on GPU 0. The Caltech cluster might be slower but is much more reliable because it has a professionally maintained slurm scheduler that prevents these types of problems. I tend to prefer having reliability over a modest speedup for these cases, but I am ok with other solutions. One solution would be to routinely kill the jobs on tartarus running on GPU 0 without warning, that would be possible only for people with access on tartarus though. I am ok following that route (I just killed a couple of jobs now 😅). It would be nice to find a more permanent solution though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587:579,rout,routinely,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356610587,2,['rout'],"['route', 'routinely']"
Integrability,"I see the interest of creating a handler of all the outputs of the model. Is the idea to make a wrapper depending on parsing a preexisting writers i.e. `NetCDFOutputWriter`, `JLD2OutputWriter`, and `Checkpointer`. Or do you plan to make a new structure that handles all of them? . I agree that keeping a simple way to create `Checkpointer`s and `OutputWriter`s should be a priority, particularly in the case when the user needs to restart the simulation multiple times in an HPC, keeping in mind manageable file sizes, wall times, and chunks. Currently, this can be handle by the user creating unique output folders or changing the name of the output file for each resubmission of the simulation. Unfortunately, this makes more complex the processing of the output. I think the best solution with outputs and checkpoints will be to automatically append to the last output file from the previous simulation resubmission (currently not supported). I agree that the initialisation of the writer should not create a file, I find that quite confusing. I believe it will be simple to change by only executting the `initialize_nc_file!` and `initialize_jld2_file!` once the model is running, instead of two times, once the writers are initialised and in run time (`write_output!`). . Despite the implementation of this, I still see value in having a flag `overwrite_existing`, likely set up to `false` as default (I will comment in the discussion about this), and ensure that we do not change this flag on run time, since it may result in issues and data loss. . Regarding my changes in this PR, the function `is_output_splitted!` may still be useful, since it returns the last file to then append the output, necessary to handle file splitting in a general output function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283:96,wrap,wrapper,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391694283,4,"['depend', 'wrap']","['depending', 'wrapper']"
Integrability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:465,depend,dependent,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,2,['depend'],['dependent']
Integrability,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:127,message,message,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989,2,['message'],['message']
Integrability,"I think I have answered my own question. If you think of the momentum equation in terms fo the stress tensor, then in vector form it is. ``; ∂ₜuᵢ - ∂ⱼ⋅σᵢⱼ= 0,; ``. where the second term is the divergence of the stress tensor. If we integrate this over the volume, and divide by the volume then we get upon using **Gauss' Divergence Theorem**. ``; ∂ₜūᵢ =1/Vfcc∭ ∂ⱼ⋅σᵢⱼ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS; ``. In the case of an idea fluid we have `σᵢⱼ=-pδᵢⱼ` and therefore our equation above becomes. ``; ∂ₜūᵢ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS = - 1/Vfcc ∬ p δᵢⱼ⋅ n̂ⱼ dS = - 1/Vfcc ∬ p n̂ᵢ dS; ``. This shows that the desired result follows from application of Gauss' Divergence Theorem on the stress tensor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916:232,integrat,integrate,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916,1,['integrat'],['integrate']
Integrability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:176,integrat,integrate,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['integrat'],['integrate']
Integrability,"I think `base_grid` is a good name. ""underlying"" is also a little long and ""base"" helps with that. . Note we also should change the name of this abstract type if we use a different name than `underlying`:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/Grids.jl#L86-L92. Another possibility that comes to mind now is `parent_grid`, which is used throughout Julia to indicate a ""wrapped"" object:. ```julia; help?> parent; search: parent parentmodule parentindices. parent(A). Return the underlying ""parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> A = [1 2; 3 4]; 2×2 Matrix{Int64}:; 1 2; 3 4. julia> V = view(A, 1:2, :); 2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:; 1 2; 3 4. julia> parent(V); 2×2 Matrix{Int64}:; 1 2; 3 4; ```. (And there's also `parentmodule`, etc.) Perhaps that docstring is partly inspiration for referring to things as ""underlying"" (elsewhere we also have descriptions of ""underlying data"" for fields. But I like either `parent` or `base` better than `underlying`, with maybe a preference for `parent` now that I see its fairly widespread. As a side note (issue creep...) we also don't need `AbstractRectilinearGrid`, since there's only one:. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/Grids/rectilinear_grid.jl#L8. eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177:428,wrap,wrapped,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2095#issuecomment-985536177,2,['wrap'],['wrapped']
Integrability,I think an issue is a good place to discuss interface design. I can open one if you want!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579:44,interface,interface,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814262579,1,['interface'],['interface']
Integrability,"I think even 1D would be ok. On the question of interpolation of velocities: to compute fluxes we need to _reconstruct_ the fields at the cell interfaces. The velocity field is _staggered_ with respect to the tracer field, such that we can trivially reconstruct the velocity field by using the cell-averaged velocity component that's centered on the location it's needed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209:143,interface,interfaces,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-873779209,1,['interface'],['interfaces']
Integrability,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:29,depend,depend,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023,2,['depend'],['depend']
Integrability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:35,depend,dependency,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['depend'],['dependency']
Integrability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:16,depend,depends,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,1,['depend'],['depends']
Integrability,"I think it's good to go. The only thing that doesn't quite make sense to me is why. ```julia; fill_size = fill_halo_size(field, regular_fill_function, indices, boundary_conditions, loc, grid); ```. depends on `regular_fill_function`, since. ```julia; fill_function, regular_fill_function = get_open_halo_filling_functions(loc) ; ```. and `loc` is an argument to both functions. It doesn't seem that from a purely logical point of view we need `regular_fill_function` at all here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293:198,depend,depends,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2379279293,1,['depend'],['depends']
Integrability,"I think its a fine idea to merge, though it is interesting that the code will still be called `Oceananigans` :-D. I'm not sure I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:276,depend,depend,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['depend'],['depend']
Integrability,"I think maybe you were interpreting ""field dependency"" as meaning ""a dependency of `KernelComputedField`"", rather than ""a dependency that _itself_ is a field""... ? It's the latter definition that I was thinking of; that's why we call `compute!` on its elements.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426:43,depend,dependency,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769384426,3,['depend'],['dependency']
Integrability,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:34,Integrat,Integrated,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305,1,['Integrat'],['Integrated']
Integrability,"I think so, either that or we cannot depend on FFTW.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271:37,depend,depend,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708#issuecomment-2339385271,1,['depend'],['depend']
Integrability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"I think that name makes sense!. For the light attenuaiton model, I'm not sure how it would work without making it a property of the model? If it is a parameter then the update state would need to check if there is a parameter before which might be more ambiguous to set up? . I've rewritten it a little bit to make the integration a nothing operation when the user doesn't specify a model but not sure what the best solution might be here. Perhaps we could make it more generic so users can call any kind of update state operation?. But either way, happy for you to fix these issues!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587:319,integrat,integration,319,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335069587,1,['integrat'],['integration']
Integrability,"I think the alternative is to build `clock` inside the constructor. In that case users can only change `clock.time` and `clock.iteration` after constructing the model, rather than passing in a custom `Clock` via this kwarg. The choice depends on what features you want to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641:235,depend,depends,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1710#issuecomment-849802641,1,['depend'],['depends']
Integrability,"I think the difficult part is finding z*; this is what Huang 2005 seems to be discussing. I'm hazy on the details (maybe @hdrake can chime in) but I think the point is that while an adiabatic rearrangement into a stable density profile may exist, it may not be obtainable by a single sorting procedure due to the pressure dependence of the equation of state. Some of the subtleties of the Boussinesq approximation for seawater are discussed in http://pordlabs.ucsd.edu/wryoung/reprintPDFs/SeawaterBoussinesq.pdf",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340:322,depend,dependence,322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297#issuecomment-841583340,1,['depend'],['dependence']
Integrability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:295,interface,interface,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['interface'],['interface']
Integrability,"I think the hard part on giving instructions for running it on HPCs is that it all depends on the distribution, permissions, jobs manager etc.. . It is hard to generalize, unless there is an easy way to do so that I haven't thought. I thought about creating a Docker image that could simply run for Julia with all dependencies, but Chris warned on how tricky it is to make Docker work with the GPU efficiently. So I just think this is not applicable. I am trying to install Julia with the main packages and Oceananigans dependencies on the HPCs that I have access and this is not being easy. Sometimes Julia is outdated, or it doesn't precompile packages properly etc. . Python's Conda is very handy for these situations, but It might just be the case I am too new in Julia for the things I am trying to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328:83,depend,depends,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312#issuecomment-1062495328,6,['depend'],"['dependencies', 'depends']"
Integrability,"I think the main downside of a separate package is that we have to maintain two CI pipelines, two docs, etc. The advantages are pretty clear though. It could make sense until there's some external interest in using the solvers in a standalone manner. Then we have both motivation and help to take on the work. The code is already modular with few circular dependencies so I don't think splitting up the repo would be difficult from a purely typing standpoint. I think it's fine if the solvers are specific to `Field` and `AbstractGrid`. One could envision an ecosystem of packages for finite volume calculations on staggered grids:. * `StaggeredVolumes.jl` or maybe `StaggeredFields.jl` (`Oceananigans.Grids, Oceananigans.Operators, Oceananigans.Fields, Oceananigans.AbstractOperations`); * `StaggeredEllipticSolvers.jl` (`Oceananigans.Solvers`) Note that these are both Poisson solvers and Helmholtz solvers.; * We may also want to put the `Simulation` infastructure in a standalone package, because this could be used by any model (not just ocean-specific models); * Anything else?. Then `Oceananigans.jl` is mainly just the physics, models, and time-steppers for ocean problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149:356,depend,dependencies,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815043149,2,['depend'],['dependencies']
Integrability,"I think the main issue here is that there is too much code, reflecting the fact that an interface for defining closures has emerged over time rather than being designed from the ground up. It could possibly benefit from a rethink. It's not as much an issue of the names of things in my opinion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507:88,interface,interface,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507,1,['interface'],['interface']
Integrability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:172,depend,depends,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,1,['depend'],['depends']
Integrability,I think the proposed error message is more helpful and would encourage such a change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418:27,message,message,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269#issuecomment-1047867418,1,['message'],['message']
Integrability,"I think the simulation is ready and physically/numerically correct. I ran a high-reynolds-number version of this simulation and results look like those from the original paper (even quantitatively). Here's what the v-velocity and the y-vorticity look like (in this current resolution):. https://user-images.githubusercontent.com/13205162/138630652-3c1f3180-793a-42f4-8402-8ad2a921e2d7.mp4. https://user-images.githubusercontent.com/13205162/138630663-abcc59cd-0334-4037-ae92-1ece165a3536.mp4. Now the question is what to do with this. My idea was to transform this into a docs example, but I can also leave it as a validation. If it were a docs example I think this would then teach users how to:. - use the `Buoyancy()` constructor with a specified vertical direction; - use `ConstantCoriolis`, also with a specified vertical direction (these last two are mostly useful for tilted domains I think); - Possibly also how to use NetCDF output writers, which no example does for now. A few ideas that I had for the docs example which might be controversial are. - Use Oceanostics.jl for the progress messenger and a couple of diagnostics (basically this would teach users that we can use external tools). If we can use some functionality of LESbrary.jl it would be nice too (although probably not possible here, since this isn't an LES).; - Use Python/xarrray to read and plot the data. The major downside of these (especially the python one) is that it would add dependencies to the docs environment. Eager to hear some thoughts. CC: @glwagner @navidcy @francispoulin @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676:1461,depend,dependencies,1461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-950502676,1,['depend'],['dependencies']
Integrability,"I think the size dependence has to do with how `mapreduce` works; it breaks the reduction into chunks and (10, 10, 10) might be just one chunk.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482:17,depend,dependence,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1894889482,1,['depend'],['dependence']
Integrability,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:179,depend,dependencies,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320,1,['depend'],['dependencies']
Integrability,"I think this PR Is becoming too big. I’m thinking to wrap it up here with the ConformalCubedSphere grid plus tracer halo filling, add tests and then open another one to continue on cubed sphere tasks. What do you reckon @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790:53,wrap,wrap,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1483785790,1,['wrap'],['wrap']
Integrability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:385,interface,interfaces,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,1,['interface'],['interfaces']
Integrability,"I think to support inserting `Value` or `Gradient` directly into abstract operations would essentially entail an independent implementation from the current `AbstractOperation`, because while this is certainly feasible on the CPU, I suspect we will run into limitations on the GPU fairly quickly. I think if people are interested in direct numerical simulation in complex domains that would benefit from that kind of thing then this is a worthwhile endeavor and could even be prototyped in an independent repository (magic of Julia). Supporting correct boundary evaluation for non-immersed boundaries is straightforward via rules for filling halo regions. Thus despite the trade-offs, it makes sense to provide such a ""bonus"" feature: it's enabling for quite a few applications without a great cost (at least _yet_, because we don't have a user interface or great support for distributed computations). Support for operations across immersed boundaries is a more complex endeavor. Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Especially due to finite resources for software development, many of our decisions are compromises. We don't aim to be perfect, we aim to be good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897:845,interface,interface,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690236897,1,['interface'],['interface']
Integrability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:95,rout,route,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,3,"['interface', 'rout']","['interface', 'route']"
Integrability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:182,interface,interface,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['interface'],['interface']
Integrability,"I think we should improve the docstring for `Distributed`:. https://github.com/CliMA/Oceananigans.jl/blob/8f55656812e4ad7968ff37fccdb3bd1974ef393b/src/DistributedComputations/distributed_architectures.jl#L174-L205. A few comments:. * Can we explain ""synchronized communication"" better? This is confusing --- I think it actually has to do with the algorithm a model uses (very far away from building the architecture). We have to explain that this concept is irrelevant unless we are using a model that has an asychronous algorithm. Or otherwise more specifically explain what this means.; * The entry for `devices` is missing a period a the end. In general more explanation of the keyword arguments that is as local to the concept of grids as possible. The docstring makes vague references to ""support for partitioning"". But this refers to models, not grids. It doesn't really make sense in this context. Also we need examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748:250,synchroniz,synchronized,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2265666748,1,['synchroniz'],['synchronized']
Integrability,"I think we'll want a ""community repo"" for cases eventually. Something like https://github.com/FluxML/model-zoo if I understand the purpose of that correctly. > For instance, all simulations must inform and check the version of Oceananigans and it's dependencies. Or maybe containing a yml equivalent for Julia project. Isn't an ordinary Julia environment enough? For the community repo I think either . 1. There is one repo-wide `Project.toml` and all examples are kept up to date or; 2. Each example has it's own `Project.toml`. As I understand the flux model zoo takes approach 1 (this is in principle better, because otherwise the examples grow stale and cease to be useful). However, that requires maintenance and substantial effort. . I think we will still want in-house examples in addition to an external community repo.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545:249,depend,dependencies,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309#issuecomment-1062527545,1,['depend'],['dependencies']
Integrability,I think wrapping `Base.Broadcast.materialize!` in https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24 around `@apply_regionally` for multi region fields might do the job,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101:8,wrap,wrapping,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2092913101,1,['wrap'],['wrapping']
Integrability,"I think you can define in `ImmerdsedBoundaries`; ```; return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); ```; and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings); ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630:207,depend,depend,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630,1,['depend'],['depend']
Integrability,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:303,Integrat,Integrated,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534,1,['Integrat'],['Integrated']
Integrability,"I thought everything should be synchronized correctly actually. . If you are running on the GPU, the kernels run on a single stream at the moment (we still have to implement asynchronicity), so if you want to synchronize with the CPU you have to call `synchronize(device(arch))`, but that should happen automatically if you have a memory copy from device to host or vice-versa. . On the CPU, the launch is synchronized ; see KernelAbstraction.jl:; (this is the kernel launch wrapped in `@sync`; ``` ; @sync for tid in 1:Nthreads; Threads.@spawn __thread_run(tid, len, rem, obj, ndrange, iterspace, args, dynamic); end; ```; and, therefore `synchronize` does not do much; ```; synchronize(::CPU) = nothing; ```. where do you see this problem? Are you trying to look at GPU quantities from the CPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269:31,synchroniz,synchronized,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514616269,7,"['synchroniz', 'wrap']","['synchronize', 'synchronized', 'wrapped']"
Integrability,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:123,message,message,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783,1,['message'],['message']
Integrability,"I tried to run `benchmark_incompressible_model.jl` with advection=WENO5() and the error shown below occurred as it was benchmarking the first GPU case with grid size being 32 x 32 x 32. I'm running all benchmark cases with Float64. Many other error messages of a similar format were also outputted, but this one was the earliest one I can retrieve. My Oceananigans.jl was up to date with the latest merge #1790.; I also tried running it without specifying an advection and it ran fine. @francispoulin is experiencing the same problem. ```; Reason: unsupported use of an undefined name (use of 'pow'); Stacktrace:; [1] overdub; @ C:\Users\henry\.julia\packages\KernelAbstractions\X5hOr\src\backends\cuda.jl:264; [2] right_biased_αz₁(::Int64, ::Int64, ::Int64, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [3] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:113; [4] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:187; [5] right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [6] overdub; @ C:\Users\henry\.julia\packages\Oceananigans\t50Gi\src\Advection\weno_fifth_order.jl:228; [7] _right_biased_interpolate_zᵃᵃᶠ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, ::WENO5, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}); @ C:\Users\henry\.julia\pack",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335:249,message,messages,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-871687335,1,['message'],['messages']
Integrability,"I tried to update Oceananigans version in ClimaOceanBiogeochemistry as:; ```; Oceananigans v0.92.0 `https://github.com/CliMA/Oceananigans.jl#glw/tuples-with-catke`; ```; Then I ran CATKE together with horizontal closure:; ```; catke = CATKEVerticalDiffusivity(); horizontal_closure = HorizontalScalarDiffusivity(ν=1e3); model = HydrostaticFreeSurfaceModel(; grid,; closure = (catke, horizontal_closure),; ...); ```; It still returns an error message:; `ERROR: type Tuple has no field κe`. Is it indicating the problem is still unresolved, or am I testing in an incorrect way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814:442,message,message,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3805#issuecomment-2386577814,1,['message'],['message']
Integrability,I understand why `FluxBoundaryCondition`s can't be enforced with `closure=nothing` since they depend on a diffusivity. But why can't `Gradient` and `Value` BCs be enforced?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337:94,depend,depend,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-831542337,1,['depend'],['depend']
Integrability,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:224,integrat,integrate,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407,6,['integrat'],"['integrate', 'integration']"
Integrability,"I was a little bit bothered by the high dissipation of `WENOVectorInvariant`. If you see, especially for a coarse grid (`64²`) enstrophy is almost completely destroyed and the solution looks quite different from the other resolutions (for example compare it to the neighbouring `128²` and `512²`).; The third scheme has a somewhat better conservation of enstrophy (not as good as `VectorInvariant` which is by construction a `EnstrophyConserving` scheme). You can verify it looking at integrated enstrophy below. Blue, red, green and black lines stand for `64², 128², 256², 512²` while dashed-dotted lines are `VectorInvariant`, dashed are `WENOVectorInvariant` and solid are `WENOVectorInvarianZVEL`; ![enstrophy](https://user-images.githubusercontent.com/33547697/157750026-d4ecb5fb-fba1-4e6a-8aaf-6df541e9c513.png). the same plot for integrated energy is a little bit noisy; ![energy](https://user-images.githubusercontent.com/33547697/157750068-467d6799-9fc3-4e3a-af5d-849bb22292d7.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583:485,integrat,integrated,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064480583,2,['integrat'],['integrated']
Integrability,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/0aee96a429332a48fc4b6252f450bf8b35137129/validation/elliptic_solvers/preconditioned_poisson_solver.jl)). When the initial guess is all 0s the `precondition!` method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here](https://www.netlib.org/templates/templates.pdf) so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1175761857,1,['depend'],['depending']
Integrability,"I was looking at the errors on `cpu-solver_tests` and found the message below, followed by a bunch of other errors on the lines below. Does someone know why this is failing? I can take a look at it but thought I'd check to see whether this is understood or not. ```; Vertically stretched Poisson solver [FACR, CPU, (Flat, Bounded, Bounded)]: Error During Test at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:272;   | Test threw exception;   | Expression: vertically_stretched_poisson_solver_correct_answer(Float64, arch, topo, 8, 8, 1:8);   | ArgumentError: length(size) must be 2.;   | Stacktrace:;   | [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:24;   | [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/input_validation.jl:48;   | [4] VerticallyStretchedRectilinearGrid(::Type{T} where T; architecture::CPU, size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, zF::UnitRange{Int64}, halo::Tuple{Int64,Int64,Int64}, topology::Tuple{DataType,DataType,DataType}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/src/Grids/vertically_stretched_rectilinear_grid.jl:50;   | [5] vertically_stretched_poisson_solver_correct_answer(::Type{T} where T, ::CPU, ::Tuple{DataType,DataType,DataType}, ::Int64, ::Int64, ::UnitRange{Int64}) at /storage7/buildkite-agent/builds/tartarus-mit-edu-7/clima/oceananigans/test/test_poisson_solvers.jl:140;   | [6] top-level scope at /storage7/buil",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114:64,message,message,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1560#issuecomment-819603114,1,['message'],['message']
Integrability,"I went that route before, that would be prohibitive memory-wise also on moderately small grids, especially if you try to do it on 3D settings. You can sparsify the vectors if you want to alleviate it. Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I remember @sandreza had a good trick to calculate a matrix from a linear operation without having to calculate it on all the unit vectors. To sparsify the matrix you can use the utils in matrix_solver_utils.jl because, unfortunately, the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239:12,rout,route,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109625239,1,['rout'],['route']
Integrability,"I will let @jm-c approve this one but wanted to say I looked ti over and it looks good to me. As for the name, when you say spherical Coriolis, I thought you meant the Coriolis parameter that depends on spherical coordinates, which is not the case. Thsi clearly is a linear, hydrostatic beta-plane that works in curvilinear coordinates, if I understand this correctly. Would `HydrostaticCurvilinearCoriolis` be appropriate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154:192,depend,depends,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782160154,2,['depend'],['depends']
Integrability,"I would first of all do _nothing_ that's intended to support `AnisotropicBiharmonicDiffusivity`. Instead we should delete this closure in favor of `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (or more appropriately, simply replace the existing `AnisotropicBiharmonicDiffusivity` with `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity`). See #2113 and a few other issues referenced there. Since `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` uses `diffusive_flux_x` (unlike `AnisotropicBiharmonicDiffusivity` --- one of its many problems), there are no spurious _fluxes_ across immersed boundaries:. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/TurbulenceClosures/turbulence_closure_implementations/horizontally_curvilinear_anisotropic_biharmonic_diffusivity.jl#L67. https://github.com/CliMA/Oceananigans.jl/blob/80c7064b42a47e68c90690d7ab32db187bbdf26a/src/ImmersedBoundaries/conditional_fluxes.jl#L48. But I think the point here is that the fluxes are calculated using ""wrong gradients"". Note that `conditional_flux_fcc` doesn't shut down fluxes within ""X"" cells of a boundary. It shuts down fluxes _across_ an immersed boundary. I think this issue is proposing to use `conditional_flux_fcc` for a _different_ purpose than what it's used for now --- to nullify fluxes for biharmonic diffusion in a buffer region around the boundary. The reason is that biharmonic fluxes are not correct on interfaces within one cell width of an immersed boundary, because they involve second order operators?. It's a little unclear to me what the right thing to do here is --- @simone-silvestri can you clarify what mathematical model you would like to implement when we have biharmonic diffusion in the presence of immersed boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708:1467,interface,interfaces,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209#issuecomment-1027537708,2,['interface'],['interfaces']
Integrability,"I would like to start working on this. Note that in terms of maintenance burden, the docs already depend extensively on plotting. So I'm not sure a plotting extension will increase CI significantly. On the contrary we can start with a minimalist approach that simply uses the examples to test the functionality in the extension. I'd like to discuss design before starting. I think the basic functionality we need is to support automatically plotting of 2D fields. Basically we want to be able to write `heatmap!(ax, c)` and have it work automatically, eg if `c` is two-dimensional, then the non-trivial dimensions are automatically detected and appropriate node values inserted. I think this should work even if the dimensions are not `Flat`, so basically we just want to take a look at `size(c)`. We can also support `lines!` and `scatter!` and `scatterlines!` for 1D fields. Is there a streamlined way to do this for all situations, or do we need to add support for each method like `heatmap!`, `contour!`, `contourf!`, etc, individually?. A second question is how to support inspection of 3D fields. I think this is pretty hard. @Sbozzolo has some experience with this so he might have some valuable input.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591:98,depend,depend,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178#issuecomment-2271718591,2,['depend'],['depend']
Integrability,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:118,Integrat,IntegrateField,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613,1,['Integrat'],['IntegrateField']
Integrability,"I would suggest sticking with PAR rather than light.  PAR is very common in biogeochemistry and it is made up of specific bands of light and hence “light” and PAR aren’t exactly equivalent.  Calling it “light” could cause confusion if someone calculates PAR from the incoming solar radiation (light).; On Nov 18, 2022 at 3:07 PM +0000, Jago Strong-Wright ***@***.***>, wrote:; > @jagoosw commented on this pull request.; > In test/test_biogeochemistry.jl:; > > + wait(device(model.architecture), par_calculation); >; > +end; >; > +; >; > +biogeochemistry_parameters = (; >; > + growth_rate = 1/day,; >; > + light_limit = 3.5,; >; > + mortality_rate = 0.1/day,; >; > +; >; > + water_light_attenuation_coefficient = 0.12,; >; > + phytoplankton_light_attenuation_coefficient = 0.06,; >; > + phytoplankton_light_attenuation_exponent = 0.6,; >; > + surface_PAR = t -> 100*max(0.0, sin(t*π/(12hours))); >; > +); >; > +; >; > +biogeochemistry = SomethingBiogeochemistry(tracers = :P,; >; > + auxiliary_fields = :PAR,; >; > Makses sense, after I started I realised it was a bigger challenge than I thought it would be!; > I'll try and make these changes later.; > PAR stands for photosynthetically available radiation, perhaps it would be more clear to call it light here.; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513:1391,Message,Message,1391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1320161513,1,['Message'],['Message']
Integrability,"I'd be on board with assuming `AbstractField` elements must be lazily evaluated with `::Field` being a special no-op case. And with renaming `Computation` to `ComputedField`. > There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. Right I was referring to the `Average` methods defined in `AbstractOperations`. > For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. Yeah I considered this as it seems like the most sensible solution but then instead of a useful error, users could end up allocating huge 3D arrays and run out of GPU memory (at which point it might be hard for them to figure out what they did wrong). > `Average` requires some kind of view or pointer to the data that needs to be average. Currently this object is called `Average.field`. The basic idea behind `Average` is that a reduction is triggered on `Average.field` every so often (currently specified though `time_interval` and `iteration_interval`) and stored in `result`. Hmmm, does it make sense to rename the `Average.field` property to `Average.kernel` in line with `WindowedTimeAverage` in PR #856?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622:763,interface,interface,763,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674794622,1,['interface'],['interface']
Integrability,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:1586,message,message,1586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971,1,['message'],['message']
Integrability,"I'm getting this error when trying to run my code on multiple GPUs (it works fine on CPUs):. ```julia; ERROR: LoadError: BoundsError: attempt to access Tuple{Vector{CuStream}} at index [2]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] (::Oceananigans.Architectures.var""#3#6"")(); @ Oceananigans.Architectures /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:26; [3] lock(f::Oceananigans.Architectures.var""#3#6"", l::ReentrantLock); @ Base ./lock.jl:185; [4] next_stream; @ /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Architectures.jl:24 [inlined]; [5] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 36)}, KernelAbstractions.NDIteration.StaticSize{(36, 1)}, typeof(Oceananigans.BoundaryConditions.gpu_fill_periodic_south_and_north_halo!)})(::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, ::Tuple{Int64, Int64}, ::typeof(Oceananigans.BoundaryConditions.fill_periodic_south_and_north_halo!), ::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{Int64}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185:936,depend,dependencies,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310681185,1,['depend'],['dependencies']
Integrability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:114,depend,depend,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['depend'],['depend']
Integrability,"I'm not sure of the latest approaches/versions of POM and ROMS with the sigma coordinates, but the approach in our paper is similar in the sense that it is based on a general vertical coordinate change. But where ROMS and POM have a fixed distribution of points on a vertical (except for the effect of surface movement which moves points but not their relative position on the vertical), our approach allowed to move the points at any moment up or down depending on local features for example to increase resolution near the moving thermocline and differently for different horizontal positions. .As a special case you can of course have the original POM or ROMS version.; Hope it makes sense.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947:453,depend,depending,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839754947,1,['depend'],['depending']
Integrability,"I'm not sure that this kind of function should be defined for all closures (not all closures even have a diffusivity). If we want to have a more uniform interface, I'd focus on `AbstractScalarDiffusivity` which is specific to closures with a single scalar diffusivity. I think there is already an interface there too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686:153,interface,interface,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686,2,['interface'],['interface']
Integrability,I'm okay with the warning message that we have and closing this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1636#issuecomment-851493436,1,['message'],['message']
Integrability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:80,interface,interface,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,2,['interface'],['interface']
Integrability,"I'm seeing some significant slow down with the boundary condition. ```julia; # Monin-Obukhov drag coefficient; z₀ = 1e-4 # Charnock roughness; κ = 0.4 # Von Karman constant; Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2. @inline bottom_drag_u(x, y, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2); @inline bottom_drag_u(x, y, z, t, u, w, Cᴰ) = - Cᴰ * u * sqrt(u^2 + w^2); @inline bottom_drag_w(x, y, z, t, u, w, Cᴰ) = - Cᴰ * w * sqrt(u^2 + w^2). Δz = 1 / Nz; Δx = 2π / Nz; u_drag_bc = FluxBoundaryCondition(bottom_drag_u, field_dependencies=(:u, :w), parameters=Cᴰ(Δz)); w_drag_bc = FluxBoundaryCondition(bottom_drag_w, field_dependencies=(:u, :w), parameters=Cᴰ(Δx)); u_bcs = FieldBoundaryConditions(bottom=u_drag_bc, immersed=u_drag_bc); w_bcs = FieldBoundaryConditions(immersed=w_drag_bc); ```. This is the basic way to implement a quadratic drag from the interface in this PR. In this case what happens under the hood is that we create 4 `ContinuousBoundaryFunction` for the relevant faces of boundary-adjacent cells (the other 2 faces are normal to the given velocity component, so receive a no-penetration boundary condition). So there could be a type instability compiling all of those (which have been notoriously fickle to compile in the past). We clearly need to hard code quadratic drag though, because for stretched grids and partial cells (and other types of immersed boundaries in the future) we have to do precompute the logarithm of the grid metrics (to use in a Monin-Obukhov-type model) in each direction independently, as well as the logarithm of the roughness. It's too much for this PR though, so I think we should just document how to specify no-slip on immersed boundaries (which appears to be performant), and add a few tests. Then in a future PR we can add a `QuadraticDrag` utility (I have a prototype for this object; others are welcome to collaborate on implementing the necessary functions to support it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081:909,interface,interface,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1104673081,2,['interface'],['interface']
Integrability,"I'm sort of glad to see @glwagner is verifying the issues we first discussed last year. My 2 cents: . - Small errors in the BC eventually propagating to the whole simulation is unavoidable; this is a well mixed flow. Checking on integrated quantities, such as maintaining conserved properties or matching the expected global dissipation rate, is a more achievable and important goal. ; - Using a test case with some stronger pressure gradients along the boundary would be good as well since this induces much of the error. The circle @wenegrat suggests is the classic, but you might be able to find a more subtle case which is more relevant to your application. Perhaps turbulent flow in a wavy-wall channel? Linking the amplitude of the waves to the change in turbulent statistics seems pretty well aligned with your application (though I could be wrong).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669:229,integrat,integrated,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-855362669,1,['integrat'],['integrated']
Integrability,"I'm still trying to figure out exactly how to go from cell value to cell-averaged value and back again. The forward approach is the quadrature scheme that we use to integrate on our cells. The backwards approach is the reconstructor. The standard choices that I've seen are to assume that the function is constant, linear and parabolic on each cell. If it's constant then the two coincide and there is nothing to worry about, but I presume this yields a lower order of accuracy. ; On top of what , we then have another choice on how to choose the flux based on the advection scheme. . Can you help me figure out what we are using as a reconstruction?. Everything else you suggest sounds good to me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864:165,integrat,integrate,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874270864,1,['integrat'],['integrate']
Integrability,"I'm thinking maybe that we should not allow `BasicBiogeochemistry` to have an update state or update tracers function. This will help enforce the notion that this object is really for ""truly basic"" situations; for more advanced functioality people need to use the lower level interface (which will produce much more reusable and modular code, so is very much in our interest).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213:276,interface,interface,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1335295213,1,['interface'],['interface']
Integrability,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:19,integrat,integration,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590,1,['integrat'],['integration']
Integrability,"I'm trying to integrate a scalar in time (the scalar itself being a volume-integrated `Field`). Pretty much what's being done here: https://github.com/tomchor/Oceanostics.jl/blob/main/test/test_budgets.jl. I can probably come up with a way to do it without auxiliary fields. I just assumed `auxiliary_fields` could also be scalars since fields is written as ""fields"" in the docs, rather than ""`Fields`"". (Although I'm not sure what you mean by a ""parameter"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696:14,integrat,integrate,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482889696,2,['integrat'],"['integrate', 'integrated']"
Integrability,"I'm wondering if it might be a bit much to put docstrings on every single `AbstractGridMetric` for this experimental feature? They aren't exported so not user-facing (I think we may end up using this internally only for things like `IntegratedField` down the line). But I can copy paste the PR comment into the docstring for \Delta z as an example. Note that `GridMetricOperation` is used internally only, it's really the instances `\Delta z`, etc that are meant to be combined in `AbstractOperations`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063:233,Integrat,IntegratedField,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607#issuecomment-826007063,1,['Integrat'],['IntegratedField']
Integrability,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:246,depend,depends,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814,2,['depend'],['depends']
Integrability,I've added `TracerBasedBiogeochemistry` and an example both using and not using it and they both seem to work now:; ![npd_example](https://user-images.githubusercontent.com/26657828/201384805-32bd6dfe-8838-44c8-a838-e3b841845812.png); I am slightly concerned with how I've setup the forcing for `TracerBasedBiogeochemistry` because I assume the weird stuff going on with the interpolation stuff in `ContinuousForcing` is there for a reason (and we can't use the normal continuous forcing stuff because it relies on the index of the tracer which we don't have as the model isn't finished when we setup the biogeochemical model). I'll have a go at adding an example with PAR integration to check its straightforward to add to a model later.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054:673,integrat,integration,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311916054,1,['integrat'],['integration']
Integrability,"I've already made sure the forcing function doesn't reference anything outside the function (reduces clarity unfortunately) and pasted the benchmarks using the script from PR #370 at the bottom. Did not try changing the function signature to `FT(grid, u, v, w, T, S, i, j, k)` as that would make implementing #25 more difficult. Also, I was kind of lazy. Adding `@inbounds` seems to help a lot. Went from being 2.1x slower to being 1.3x slower. Still a significant slowdown considering that these forcing functions aren't as computationally demanding as the rest of the right-hand-side calculation. But good enough for me right now. It can be a very powerful feature (essentially replacing the MITgcm RBCS package, for one example) so would be good to get maximum performance out of the forcing functions. But it will probably always depend on exactly how you write them. So might make sense to have guidelines on writing ""performant forcing functions"" in the documentation. ---; Attempt 1:; ```julia; @inline function Fu(grid, U, Φ, i, j, k); if k == 1; return -2*0.1/grid.Δz^2 * (U.u[i, j, 1] - 0); elseif k == grid.Nz; return -2*0.1/grid.Δz^2 * (U.u[i, j, grid.Nz] - 0); else; return 0; end; end. @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); ```; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Forcing function benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 59.9s / 0.41% 7.38GiB / 0.36% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 128×128×128 with forcing (GPU, Float64) 10 166ms 68.2% 16.6ms 13.8MiB 51.2% 1.38MiB; 128×128×128 no forcing (GPU, Float64) 10 77.4ms 31.8% 7.74ms 13.1MiB 48.8% 1.31MiB; ──────────────────────────────────────────────────────────────────────────────────────────────────; ```; ---; Attempt 2:; ```julia. @inline function Fu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208:834,depend,depend,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365#issuecomment-525326208,1,['depend'],['depend']
Integrability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:106,integrat,integrate,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['integrat'],['integrate']
Integrability,"I've been trying different open boundaries and have found that making $U_b$ the mean cross boundary velocity seems to be more stable in some cases (I think when estimating it can vary rapidly when the flow switches from out to in which causes problems). From this review https://doi.org/10.1002/fld.1650181006 it seems like for the normal velocity component it is actually common to user specify $U_b$ by hand to make it stable for a particular simulation, or to make it the mean boundary velocity which they say is stable until ~30% of the flow is inflow. . The other advantage of these schemes is they don't depend on the tendencies so will be more straight forward to setup. They also suggest that just setting the gradient to zero on the boundary is fine for the other tracers/velocity components which does seem to end up with similar results. Given the illposedness of all of these solutions for the normal velocity component it seems like it might be better if we didn't commit to a particular formulation. I'm not sure what the best user interface for this might be but it might be easiest to just not call any `OpenBoundaryCondition` and instead e.g. `MeanChannelOutflowBoundaryCondition`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795:610,depend,depend,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1976639795,2,"['depend', 'interface']","['depend', 'interface']"
Integrability,"I've been wanting to clean up this interface a bit but haven't gotten to do it. ; The `grid` argument is used to compute coefficients for stretched advection; if it is not passed, we use uniform spacing coefficients. ; Some time ago, we disabled using stretched coefficients for `Centered` and `Upwind` because it seemed they would make the simulation less stable, but there was no rigorous study to check this. The grid is a kwarg to allow doing stuff like ; ```; WENO(); ```. I think the idea is to move to an interface where every element requires the grid as a positional argument so if this is the idea, we could introduce a keyword argument like `stretched_coefficients` which would make the interface clearer",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529:35,interface,interface,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3857#issuecomment-2432769529,6,['interface'],['interface']
Integrability,"I've got the mode-1 internal wave case working now. Axes are in units of depth (h) and k is set to $\pi$/h, top panel is `u`, middle is `w`, and bottom is `b`. First the periodic case:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/324a7a29-097e-4732-b324-afce808b752e. As expected numerical error reflects off the boundary if we just prescribe the boundary values:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/738bd33f-b813-45f7-b96a-74a25dd631cb. And with quite a small sponge (red lines in top plot) this is pretty much resolved:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/d1af93fb-8efc-47a3-abdc-463224e366db. Note/update:. Following discussion with @johnryantaylor we noticed that it seems the energy increases in all three of these (the velocity clips the colormap which is set to the analytical amplitudes) before it decays. I've checked and this is timestep length dependant and goes away with a small timestep. I guess this is a shortfall of the CFL analysis when there are fast waves. We also noticed that there is an error growing from the top and bottom boundaries, particularly clearly in the buoyancy. We think this is a spatial resolution dependant numerical error which is suppressed by increased vertical resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794:912,depend,dependant,912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2004485794,4,['depend'],['dependant']
Integrability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:453,depend,dependence,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,8,"['depend', 'integrat', 'interface']","['dependence', 'integrated', 'integrating', 'interface']"
Integrability,"I've just thought, in the same vein as using total velocities, should `fields(model)` not always return sums of prognostic and background fields?. For example if you have a function that is dependant on temperature and a background temperature, it should be given the sum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885:190,depend,dependant,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323#issuecomment-1755972885,1,['depend'],['dependant']
Integrability,I've now had a play trying to wrap VkFFT with https://github.com/JuliaInterop/Clang.jl/tree/master but it is proving difficult given my inexperience with C. . Does anyone working on Oceananigans have experience doing that sort of thing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954:30,wrap,wrap,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1735298954,1,['wrap'],['wrap']
Integrability,"I've played more with this now and think the way we can do this with the minimum code changes is as follows. The only other way I can see is for the boundary to store the previous timestep of the boundary adjacent points but since Fields depends on BoundaryConditions that isn't really possible. The key problem really is that previous solutions to this problem have been written in codes that store at least two time levels which we don't have. So, if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a quest",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:238,depend,depends,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['depend'],['depends']
Integrability,"I've worked out where my problem is coming from. For the wall-normal velocity: first, we compute and apply the tendencies from 1:N face points, then compute the pressure correction at 1:N center points, then fill the boundary points at 1 and N+1, and apply it at 1:N face points (except the gradient is zero across the 1 face point so this doesn't do anything to the boundary. The N+1 boundary point is fine because we can just set it to anything, or time integrate something at the point since nothing else effects its value. The same is true if we prescribe a value at the 1 face point because (even though we redundantly integrate the tendencies there) it just gets reset to whatever we want. The problem is if we try to integrate something like a radiation condition there then we actually end up with $u(1, j, k) = \int (G_u + B_u) dt$ where $B_u$ is whatever integration we're trying to do at the boundary. On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that than to think of a different way todo it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695:456,integrat,integrate,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2387806695,5,['integrat'],"['integrate', 'integration']"
Integrability,"If it's urgent, I suggest creating a new branch that merges master and whatever other branch has an important feature and depending on that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004:122,depend,depending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-872310004,1,['depend'],['depending']
Integrability,If this will be important then we should streamline the user interface for changing to Float32. Ideally everything should take `eltype` from the grid I think without requiring tons of manual intervention.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856:61,interface,interface,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856,1,['interface'],['interface']
Integrability,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:913,rout,routines,913,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683,1,['rout'],['routines']
Integrability,"If we check after the coordinate is created, we may only need to check once (the check is the same for all user input and the message is the same: the coordinate must be increasing)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882:126,message,message,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751826882,1,['message'],['message']
Integrability,If we use `\nabla \cdot (\nu h \nabla u)` then the dissipation term is ` - \nu h | nabla u |^2`. This is accepted and has the nice property that the dissipation depends on the depth. If we use `\nabla \cdot (\nu \nabla u)` then we don't have the right units as we are evolving `h u`. . `\nabla \cdot (\nu \nabla (h u) )` does not give you a negative definite form as you would get ` - \nu \nabla u \nabla (hu)`.; P.S. How do you include latex here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835:161,depend,depends,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1090319835,1,['depend'],['depends']
Integrability,"If you want to integrate with the Julia ""progress bar"" system, you could put in something like:; ```julia; @debug ""this is a short description of my loop"" progress=iteration/length_of_loop; ```. This works in Juno, and with MicroLogging.jl in the REPL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872:15,integrat,integrate,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432#issuecomment-536805872,1,['integrat'],['integrate']
Integrability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:515,interface,interface,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,1,['interface'],['interface']
Integrability,"In some way this comes back to the fundamental question of: What is the point of KernelAbstractions CPU support. I originally intended it only for making debugging easier... But folks seem to be depending on it as a performance solution... I think it is feasible to get there, but it would require quite a bit of time and effort",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331:195,depend,depending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481464331,1,['depend'],['depending']
Integrability,"In this example the sponge on the inflow probably isn't necessary, but for more complicated inflows, it probably is needed.  Probably not a bad thing to keep it in the example, but I don’t have a strong view either way. On Mar 28, 2024, at 12:01 PM, Jago Strong-Wright ***@***.***> wrote:﻿. @jagoosw sorry to be dropping into this discussion a bit late, but I don't quite understand why the sponge is needed at the inflow in the example above. Shouldn't the prescribed inflow BC be enough?. You are probably right it shouldn't be necessary here!. —Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925:662,Message,Message,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2025902925,1,['Message'],['Message']
Integrability,"Indeed, I don't think drag is so relevant physically for this problem but it should demonstrate the interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1606264607,1,['interface'],['interface']
Integrability,"Instead of `validate_biogeochemistry`, maybe. ```julia; required_biogeochemical_tracers(::NutrientsPlanktonDetritus) = (:N, :P, :D); ```. is a better syntax. Then users don't have to write their own error messages (we'll handle that in Oceananigans). It also gives us flexibility regarding the choice between 1) automagically adding the biogeochemical tracers or 2) requiring the user to add tracers themselves. We starting to use tracers for a few important things (TKE, biogeochemistry, buoyancy models). We may also need to come up with a system for handling ""name clashes"" gracefully. For example, someone might introduce a biogeochemistry model with tracer `e`, not realizing that this would prevent them from using the biogeochemistry model with CATKE. There's a tension between simplicity and readability (which we get with short, intuitive tracer names like `e`, `T`, `S`), and catastrophic ""name clashes"" that will inevitably occur as model complexity increases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390:205,message,messages,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305838390,2,['message'],['messages']
Integrability,"Integer, [-1,268]:Integer, [-1,269]:Integer, [-1,270]:Integer, [-1,271]:Integer, [-1,272]:Float@double, [-1,280]:Float@double, [-1,288]:Float@double, [-1,296]:Float@double, [-1,304]:Integer, [-1,305]:Integer, [-1,306]:Integer, [-1,307]:Integer, [-1,308]:Integer, [-1,309]:Integer, [-1,310]:Integer, [-1,311]:Integer, [-1,312]:Integer, [-1,313]:Integer, [-1,314]:Integer, [-1,315]:Integer, [-1,316]:Integer, [-1,317]:Integer, [-1,318]:Integer, [-1,319]:Integer, [-1,320]:Integer, [-1,321]:Integer, [-1,322]:Integer, [-1,323]:Integer, [-1,324]:Integer, [-1,325]:Integer, [-1,326]:Integer, [-1,327]:Integer, [-1,328]:Float@double, [-1,336]:Float@double, [-1,344]:Float@double, [-1,352]:Float@double, [-1,360]:Float@double, [-1,368]:Float@double, [-1,376]:Integer, [-1,377]:Integer, [-1,378]:Integer, [-1,379]:Integer, [-1,380]:Integer, [-1,381]:Integer, [-1,382]:Integer, [-1,383]:Integer, [-1,384]:Integer, [-1,385]:Integer, [-1,386]:Integer, [-1,387]:Integer, [-1,388]:Inte...; ```. Farther down the error message says:. ```; Cannot deduce type of insertvalue ins %138 = insertvalue { { i64, i64, i64, i64, i64, i64, double, double, double, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, double, double, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] }, { { [2 x double], [2 x double], i64, i64 }, [1 x i64] } }, { {} addrspace(10)*, [3 x i64] }, {} addrspace(10)* } %134, { {} addrspace(10)*, [3 x i64] } %unbox2.i.unpack286435, 1, !dbg !20 size: 32 TT: {}. Caused by:; Stacktrace:; [1] #60; @ ./tuple.jl:461; [2] afoldl; @ ./operators.jl:545; [3] filter_rec; @ ./tuple.jl:461; [4] filter; @ ./tuple.jl:464; [5] filter; @ ./tuple.jl:0; within MethodInstance for filter(::Oceananigans.Fields.var""#87#91"", ::Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Period",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:10495,message,message,10495,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['message'],['message']
Integrability,"Interesting that this works. in the `ShallowWaterModel` we define our functions to be `(x,y,z)` because that's what I thought we had to do. But this example above suggests that in the spherical case we can define `(x,y)`. Does this mean we might be able to define functions in `ShallowWaterModel` that don't depend on `z`, or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676:308,depend,depend,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838662676,1,['depend'],['depend']
Integrability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:128,depend,depend,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['depend'],['depend']
Integrability,"Interesting. I disagree that fig 1 does not have an obvious trend, the trend is quite clear away from the wall:. <img width=""391"" alt=""image"" src=""https://github.com/user-attachments/assets/b1bc556f-4a82-47b3-acd8-c27e83c32591"">. Both Lagrangian schemes have larger coefficients than their planar-averaged counter parts. Also scale dependence increases the Lagrangian coefficient. But still, I was referring to the eddy viscosity, not the coefficient. It would be interesting to me if the Lagrangian scheme was consistently more diffusive. But that might actually also be consistent with convergence at lower resolution, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069:332,depend,dependence,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2448751069,2,['depend'],['dependence']
Integrability,Interesting. I noticed that there were some unnecessary test dependencies and removed those. That seems to have helped.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042:61,depend,dependencies,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362562042,1,['depend'],['dependencies']
Integrability,"Is it so hard to update the validation scripts too? Hopefully that should be easy and it doesn't really matter what you do first. We use the validation scripts to test the user interface. You'll be changing them no matter what, in either case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357:177,interface,interface,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1915263357,1,['interface'],['interface']
Integrability,Is that message going to display _every_ time a model is created?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239:8,message,message,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2963#issuecomment-1460612239,1,['message'],['message']
Integrability,"Is this extra simplicity in the user interface worth the extra code to maintain?. I personally think it's nice to have all IC signatures, etc., the same independently of grid topology. It makes it easy to catch newbie mistakes when reviewing code. I also think a user can easily infer that `z` in the signature can be ignored if they just defined a grid with a `Flat` z topology, so I think the added user-friendliness is minor. (Maybe even negative since the signatures now can change based on `topology(grid)`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776250680,2,['interface'],['interface']
Integrability,"Isn't that a way to obtain the reverse cumulative integration by simply adding something?; Something like `cumint[end] - cumint + cumint[1]` ; I don't remember exactly, but I think that there is a way to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343:50,integrat,integration,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2099027343,2,['integrat'],['integration']
Integrability,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:3,depend,depends,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903,1,['depend'],['depends']
Integrability,"It just helps to ensure that the discrete continuity equation (and thus discrete conservation of mass) is handled correctly. It's possible that it's not necessary (but it's the reason that the vertically integrated lateral face areas pop up in the numerics). Here are some notes:. <img width=""955"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165295054-4f3205c2-bf71-46b2-947a-b1c23241328e.png"">. <img width=""954"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165296417-38c25dde-5636-40c0-8ed3-6059f9f95740.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687:204,integrat,integrated,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687,1,['integrat'],['integrated']
Integrability,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:87,message,message,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678,1,['message'],['message']
Integrability,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:456,depend,dependence,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953,1,['depend'],['dependence']
Integrability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:212,wrap,wrapping,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,1,['wrap'],['wrapping']
Integrability,"It might be possible to design an interface that uses a continuous map from a regular to stretched coordinate, rather than a generator function that specifies the location of cell interfaces.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775:34,interface,interface,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813820775,2,['interface'],"['interface', 'interfaces']"
Integrability,"It seems natural to me to have a function of 3 arguments, `x, L, N`, as those are all needed to define the grid. There are other ways of doing it I'm sure, and I am open to other options. I agree with you that given the current setup using `zF`, we do need the number of interfaces. This other option would not as we are passing functions instead. I very much like the examples you set up and think that would be very attractive from the user perspective. . Another option that I think should be included in these functions, like the two you have above, is an argument saying where the center (or something else) is in the stretched grid. It could be the left boundary, right boundary, center or anywhere else. The physics should be the guide on where to concenrate the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071:271,interface,interfaces,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815675071,2,['interface'],['interfaces']
Integrability,"It seems reasonable to add `architecture` to `AbstractField`. I think we actually might need this to make `AbstractOperations` work generically on distributed systems (in particular, `AbstractOperations` that depend on `Field`s or `ComputedField`s).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709:209,depend,depend,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484#issuecomment-800549709,1,['depend'],['depend']
Integrability,"It seems to have failed already so I will revert to what we had before. The error message is copied below. ```; [ Info: Populate: populating indices.; --;   | ERROR: LoadError: `makedocs` encountered an error. Terminating build;   | Stacktrace:;   | [1] error(::String) at ./error.jl:33;   | [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Builder.jl:255;   | [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Utilities/Selectors.jl:170;   | [4] #2 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:249 [inlined];   | [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104;   | [6] #makedocs#1 at /storage7/buildkite-agent/.julia-1687/packages/Documenter/bFHi4/src/Documenter.jl:248 [inlined];   | [7] top-level scope at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | [8] include(::Function, ::Module, ::String) at ./Base.jl:380;   | [9] include(::Module, ::String) at ./Base.jl:368;   | [10] exec_options(::Base.JLOptions) at ./client.jl:296;   | [11] _start() at ./client.jl:506;   | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-4/clima/oceananigans/docs/make.jl:145;   | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366:82,message,message,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802268366,1,['message'],['message']
Integrability,"It seems we have designed the solver interface (ie, the function signature to `precondition!`) to include the guess / solution at the current iteration. This does seem useful for some preconditioners, right? Eg, if the preconditioner is an asymptotic solution that depends on the current guess, this may be useful. I think. It's not necessary for the _specific_ case of the diagnoally dominant preconditioner though -- I agree with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326,2,"['depend', 'interface']","['depends', 'interface']"
Integrability,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:499,Depend,Depending,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067,1,['Depend'],['Depending']
Integrability,It'd be easy as an intermediate step to discontinue GPU support only I suppose. Depends how much we want to simplify the code... Also this is a reason not to eliminate `LatitudeLongitudeGrid` because it seems like it will always have fewer parameters than `OrthogonalSphericalShellGrid`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031:80,Depend,Depends,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3693#issuecomment-2276886031,1,['Depend'],['Depends']
Integrability,"It'll probably need to store N arrays under the hood where N is the number of faces. Right now we use 6 faces but if you're doing cubed sphere + MPI you might end up doing 1 < N < 6 faces on each rank. Otherwise I think the abstraction should enable users to use the cubed sphere grid like they would any other grid. So things like `set!` should just work. Right now it's more about making sure the backend all works with `CubedSphereData` then a nice user interface can be built on top of it. There are some decisions to make like should `interior(::Field{..., <:CubedSphereData})` return a 4D array? But we can decide on those as they come up. It'll be nice if the output writers knew how to write `CubedSphereData` to disk, although this can come later and many users may want the fields interpolated onto a regular lat-lon grid which is a different discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379:457,interface,interface,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1583#issuecomment-819670379,1,['interface'],['interface']
Integrability,It's also always preferred to use a function (which represents a user interface) rather than directly referencing a `struct` implementation (eg referencing `.name.wrapper`) that's subject to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790:70,interface,interface,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986847790,2,"['interface', 'wrap']","['interface', 'wrapper']"
Integrability,"It's also worth noting that right now many calculations are done more than once in each timestep. For example for each component of $M_{ij}$ I'm calculating the whole strain rate tensor modulus in addition to the strain rate tensor component needed:. https://github.com/CliMA/Oceananigans.jl/blob/25cc34e6c395e210e0aecf8181919c25435d7919/src/TurbulenceClosures/turbulence_closure_implementations/scale_invariant_smagorinsky.jl#L241-L257. This is done for legibility of the code, but it may be necessary to forfeit that in favor of doing fewer calculations. (Also note that I'm using a weird way to define function names here, so lmk if you guys think I should change it.). Another thing to note that it's common to update dynamic Smagorinsky coefficients once every 5 or so time-steps only, since they can be pretty expensive. afaik this is generally done for the scale-dependent versions, which have two test filters instead of the one needed in this PR, but I wouldn't be surprised if it's occasionally necessary for the scale-invariant versions as well.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403:870,depend,dependent,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2212664403,1,['depend'],['dependent']
Integrability,"It's as @simone-silvestri said, more broadly it seems that we need to think of boundary conditions differently between `Face` fields and `Center` fields. `Face` fields have nodes on the boundary (sometimes we call those ""peripheral nodes""), so we simply impose boundary values to satisfy boundary conditions, eg for determining wall-normal velocities. `Center` fields have nodes within and outside, but not on the boundary. This is the core of the discussion @simone-silvestri and I had about tracer boundary conditions: we can choose either to set the tracer halos to produce a result when tracers are reconstructed _on_ the boundary (that's how `Value` and `Gradient` boundary conditions work -- the halos are determined by extrapolation). Or, we can set the tracer halos as if the halo region is part of some other prognostic state (which is what I envisioned `Open` should do). Finally as @simone-silvestri says the tracer halos are `0, N+1` while wall-normal velocity points _on_ the boundary are `1` and `N+1`. I think its fine to pass additional arguments to `fill_halo_regions!`, and use these for open boundary conditions. In fact, `DiscreteBoundaryCondition` and `ContinuousBoundaryCondition` appear to already be designed to accomodate additional arguments that are unused by those user interfaces (note the `args...`):. https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/discrete_boundary_function.jl#L45 . https://github.com/CliMA/Oceananigans.jl/blob/643b484e81e0aeb038b3038266912ad051bce9b8/src/BoundaryConditions/continuous_boundary_function.jl#L136-L137",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075:1298,interface,interfaces,1298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972507075,2,['interface'],['interfaces']
Integrability,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:66,wrap,wrapped,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191,2,['wrap'],['wrapped']
Integrability,"It's because the two fields use the same data:. ```julia; u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); ```. therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269:265,depend,dependent,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269,1,['depend'],['dependent']
Integrability,"It's not the geometry that allows a two-argument function, it's because the free surface in `HydrostaticFreeSurfaceModel` is a `ReducedField`. `set!` with a function now uses `FunctionField` and then broadcasting:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/set!.jl#L29-L33. and `FunctionField` at reduced locations are now called with reduced arguments:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L60-L62. where `call_func` is invoked in `getindex` for `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Fields/function_field.jl#L64-L65. which in turn uses `node`. The length of the tuple return by `node` depends on how many locations are `Nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/4482ea951c925e67f034ea4b20ada1283726176d/src/Grids/grid_utils.jl#L158-L168. @francispoulin what is the vertical location of fields in `ShallowWaterModel`? I think if you use `Nothing` for vertical location, you'll obtain this behavior.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622:794,depend,depends,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1646#issuecomment-838798622,1,['depend'],['depends']
Integrability,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:144,wrap,wrapped,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706,2,['wrap'],['wrapped']
Integrability,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:352,message,message,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017,2,"['depend', 'message']","['depends', 'message']"
Integrability,It's very little coding work! Most of the work is designing the interface. That's true we don't use `tracer_fields`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978:64,interface,interface,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156#issuecomment-1017111978,1,['interface'],['interface']
Integrability,It's very plausible that it depends on CUDA and also Julia version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135:28,depend,depends,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135,1,['depend'],['depends']
Integrability,"Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718:191,depend,depending,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082411718,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"Joes PR adding integration tests (which now passes and we should merge, if you can review), I think needs 12 to pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514:15,integrat,integration,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3607#issuecomment-2136854514,1,['integrat'],['integration']
Integrability,"Just a clue from https://github.com/jipolanco/PencilArrays.jl/issues/49:. I think it's likely we need to use some `PencilArrays` interface to set up / partition the eigenvalues, rather than attempting to manually hack together a partition. Also by the way, it looks like we might be able to use ""pencil"" decomposition with the non-hydrostatic model now too: . https://github.com/jipolanco/PencilArrays.jl/issues/42#issuecomment-1029766858. previously we could not because PencilFFTs required FFTs to be performed along dimension 1. Since we can't decompose in ""z"" (because at least right now there are vertical integrals in `NonhydrostaticModel` --- this should also be relaxed), this only left the `y` dimension for partitioning. It feels like we might be relatively straightforward to solve if we become proficient with PencilArrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302:129,interface,interface,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1101627302,1,['interface'],['interface']
Integrability,"Just a minor comment here, default minimum fraction might be 0.2 but we more often use; a smaller value (e.g., 0.1 or smaller). On Wed, Feb 16, 2022 at 06:18:05PM -0800, Gregory L. Wagner wrote:; > > Maybe another doubt, what do we do if the ?? is larger than half (or even 3/4) of a cell in terms of masking? we still do not mask a cell which is (mostly) solid?; > ; > We don't mask the partial cells at all. We only mask cells that are fully immersed.; > ; > There is also a parameter that controls the ""minimum fractional height"" of a cell. MITgcm uses 0.2 for this parameter, which means that the partial cell has to be at least 20% fluid; otherwise, it becomes immersed.; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042500683; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118:897,Message,Message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042517118,1,['Message'],['Message']
Integrability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:709,depend,depends,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,2,['depend'],"['dependent', 'depends']"
Integrability,"Just added BitInformation to the Project.toml, due to dependency on `StatsBase` and `Distributions` this also adds; ```; Updating `~/git/Oceananigans.jl/Project.toml`; [de688a37] + BitInformation v0.6.1; Updating `~/git/Oceananigans.jl/Manifest.toml`; [66dad0bd] + AliasTables v1.1.2; [de688a37] + BitInformation v0.6.1; [49dc2e85] + Calculus v0.5.1; [31c24e10] + Distributions v0.25.108; [fa6b7ba4] + DualNumbers v0.6.8; [1a297f60] + FillArrays v1.11.0; [34004b35] + HypergeometricFunctions v0.3.23; [77ba4419] + NaNMath v1.0.2; [90014a1f] + PDMats v0.11.31; [1fd47b50] + QuadGK v2.9.4; [79098fc4] + Rmath v0.7.1; [2913bbd2] + StatsBase v0.34.3; [4c63d2b9] + StatsFuns v1.3.1; [f50d1b31] + Rmath_jll v0.4.0+0; ```; also why is the Manifest.toml committed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873:54,depend,dependency,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599#issuecomment-2109010873,1,['depend'],['dependency']
Integrability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:621,rout,routinely,621,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['rout'],['routinely']
Integrability,"Just for completion, I realized I posted a bug in the first message but not the code that generates it. Sorry! So below is a way to reproduce it. The error emerges because some routine in output writers tries to access the grid's method/attribute `xC`, which doesn't exist for vertically stretched grids. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid_ver = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz),; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,). model = IncompressibleModel(grid_ver = grid_ver,; ). wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=2,; stop_iteration=10,; ); #----. fields = model.velocities; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath = ""wenegrat2020.nc"",; schedule = TimeInterval(5minutes),; mode = ""c""). run!(simulation); ```. and the error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::Vertically",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:60,message,message,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,"['message', 'rout']","['message', 'routine']"
Integrability,"Just opened a PR with this, we can discuss what's the best approach. > Would users still have to define all three for two-dimensional domains?. Ideally no. I can modify `RegularCartesianGrid` to take this into account. > I understand the benefit in terms of being explicit, but I'm worried there are a lot of use cases in which the origin of the domain is simply unimportant, and the only relevant parameter is the domain extent. The legacy constructor `RegularCartesianGrid(N, L)` can still be used in this case. > Is there any concern about confusion between specifying the domain in terms of bounding cell faces versus cell centers?. I don't think so. When specifying the domain size, you are in effect specifying the location of the first and last face. All cell centers are located strictly between the first and last cell interface. I don't think it makes sense to specify the domain via the cell centers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091:828,interface,interface,828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/413#issuecomment-541309091,1,['interface'],['interface']
Integrability,"Just some comments at this point:; * At this point, we have the HydrostaticFreeSurface model working with the split explicit free surface. It would be great to find some time later on to figure out what was going on with the implicit free surface on AMD GPUs (is the issue isolated only to that architecture??) and get this resolved.; * To get everything moved over to KernelAbstractions would constitute a rather large change, something I think @glwagner expressed an interest in avoiding. I'd vote in favor of pushing this change off for future PR's.; * I'm wrapping up a profiling report that includes MI210 and A100 GPU performance; this report will include some recommendations should we be interested in performance improvements on GPU hardware (AMD and Nvidia). This kind of work could also constitute PR's further down the road.; * The main outstanding issue seems to be that we need a platform for testing on AMD GPUs. . It appears the CliMA fork `Project.toml` and `Manifest.toml` have diverged; I'll take a look to see if I can fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147:560,wrap,wrapping,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1997632147,1,['wrap'],['wrapping']
Integrability,"Just to be clear, the auxiliary field I'm using in my example has nothing to do with the forcing. The forcing is needed for physical reasons and I was using the auxiliary field (together with a callback) as a way to integrate something in time for a budget. Since that worked for CPU I assumed it was supposed to work for GPUs as well. But since that's not the case and scalars aren't supported, I'll close this issue. Thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482933583,2,['integrat'],['integrate']
Integrability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:217,wrap,wrapper,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,2,['wrap'],"['wrapper', 'wrappers']"
Integrability,Just to clarify that the output was expected (z^aac is an OffsetArray that includes halo points). But I agree a warning would be nice if the length of a coordinate's interfaces does not match the requested cells + 1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496:166,interface,interfaces,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496,1,['interface'],['interfaces']
Integrability,"Just to follow on from what @francispoulin wrote, we normally use MPI_Init() at the start and MPI_Finalize() at the end. All code that calls MPI needs to be between these statements. To your question about whether you can call MPI_Init() within MultiArch (or MultiArchitecture), I think the question is whether it would ever be useful to use an MPI routines before calling MultiArch. For example, you can't find out the local rank until you call MPI_Init(). Also, it is good practice to use both MPI_Init() and MPI_Finalize(), so if MPI_Init() is in MultiArch, it leaves the question of where MPI_Finalize() should be. This might be an argument for having them both outside of MultiArch where they are visible to the user.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676:349,rout,routines,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349#issuecomment-1067065676,1,['rout'],['routines']
Integrability,"Just want to confirm some final steps with @navidcy and @glwagner here to wrap up this PR. At the moment, I believe we just need to put in a method that throws an error for `validate_free_surface` when the architecture is the AMD GPU and the free surface type is implicit free surface. I'm working on putting this in through the extensions (I believe this is the correct spot) and testing this out. Is there anything else, you want to see to get this merged into main ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656:74,wrap,wrap,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1967096656,1,['wrap'],['wrap']
Integrability,Let's regularize the advection schemes in the model constructor and compute grid-dependent parts there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055:81,depend,dependent,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055,1,['depend'],['dependent']
Integrability,"Let's start here with documentation: a three letter superscript indicates the _location_ at which a function or object is defined. There is one letter for each direction x, y, z, in that order. And there are three locations:. * `ᶠ`: stands for ""face"" or ""interface"" with respect to a tracer cell.; * `ᶜ`: stands for ""center"" with respect to a tracer cell; * `ᵃ`: stands for ""any"", which means the operator / object is valid at either faces or interfaces. For example, the x-velocity `u` is located at `Face, Center, Center`. So the grid area (with `x`-normal) defined at `u` locations is `Axᶠᶜᶜ`. Another example is `Δyᶠᶜᵃ`, which is the _grid spacing in y_ defined at `Face, Center, Any`. Such a grid spacing arises in grids that are vertically rectilinear but horizontally-curvilinear (eg a horizontally-curvilinear that is extruded in the `z` direction). A spacing like `Δyᶠᶜᵃ(i, j, k, grid)` returns the distance from the cell center north of the `y`-node at `Face, Center, Any`, to the cell center south of the `y`-node at `Face, Center, Any`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537:255,interface,interface,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1471#issuecomment-799768537,2,['interface'],"['interface', 'interfaces']"
Integrability,"Let's try to deal with #3238. There are some glitches with the interface that, e.g., @djlikesdjs and @siddharthabishnu have been stumbling upon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615:63,interface,interface,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1748709615,1,['interface'],['interface']
Integrability,"Looking at the code for `DistributedIncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L8-L36. suggests to me that it's important to include `architecture` when constructing `grid`, even for grids that are _device_ independent. Specifically, our `architecture` object combines information about the memory layout and the device that's used for computation (CPU or GPU). `RegularRectilinearGrid` is _device_ independent, but, apparently, is in practice not `architecture` in dependent (because we need to restrict ourselves to knowledge of just a ""local"" grid for local computations). One complication is that, apparently, the pressure solver requires the global grid:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Distributed/distributed_incompressible_model.jl#L40-L41. We'll have to look into that in more detail to understand what needs to be done for that, and for other solvers like the `PreconditionedConjugateGradientSolver`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796:585,depend,dependent,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-880834796,1,['depend'],['dependent']
Integrability,"Looking at this PR, I think we should make a few structural changes:; * Move `AbstractSchedule` to `Simulations`. This is where it belongs? (not `Utils`); * Make schedules a function of `Simulation`, not `model`. I don't think users really care --- it's just more logical I think this way. It's about homogenizing the Simulation/AbstractModel interface I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799:343,interface,interface,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015#issuecomment-1482862799,1,['interface'],['interface']
Integrability,"Looks good to me. My only question is about the derivation of ``wˢ``, which results from a vertical integration of the analytical functions. Currently this integral is performed under the assumption that ``wˢ`` is zero at large depths, which I clarified in the code:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L213-L215. **Is this the correct assumption here?** It effectively means that ``wˢ`` and its gradients are a maximum at the surface under a depth-decaying Stokes drift, so any horizontal convergence/divergence of Stokes drift manifests a local change in sea surface height:; https://github.com/CliMA/Oceananigans.jl/blob/06f6ac746742d08c78b3cfed0bd40f7df4392819/src/StokesDrifts.jl#L248-L250. An alternative would be to set ``wˢ`` to zero at the surface, which would cause ``wˢ`` and its horizontal gradients to reach a maximum at large depths, as the occurrences of ``ûˢ(z)`` above would become ``( ûˢ(z) - ûˢ(0) )``. Essentially, horizontal convergence/divergence would manifest as downwelling/upwelling (rather than SSH changes in the current case). I feel like this approach makes sense for LES setups, but it could cause problems for simulations of the full water column where you don't want direct Stokes drift effects deep in the ocean interior. I'm happy to go forward with this example as is, but the above would be a useful question to answer in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292:100,integrat,integration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3425#issuecomment-1891314292,1,['integrat'],['integration']
Integrability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:18,interface,interface,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['interface'],['interface']
Integrability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:96,depend,dependency,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,1,['depend'],['dependency']
Integrability,"Maybe just to help you could explain the reason why `Models` should depend on `Distributed`?. In reality I think models shouldn't know anything about `architecture`. I think ideally we write architecture-agnostic code, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129:68,depend,depend,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129,1,['depend'],['depend']
Integrability,"Maybe the following papers might interest you. We implemented an ALE type of grid but where the regridding is wrapped into the definition of the ""vertical"" velocity (actually velocity relative to the moving grid). In this way it is very ""easy"" to keep conservation valid and if desired be close to isopycnal calculations (keeping w small). https://orbi.uliege.be/handle/2268/4295; https://orbi.uliege.be/handle/2268/8322; https://orbi.uliege.be/handle/2268/92087",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324:110,wrap,wrapped,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-839672324,1,['wrap'],['wrapped']
Integrability,Might make sense to include a diffusive term too? The second-order fluxes are crucial and usually mediate how boundary conditions are prescribed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564:98,mediat,mediate,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874238564,1,['mediat'],['mediate']
Integrability,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:66,interface,interface,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722,1,['interface'],['interface']
Integrability,"My issue with changing the code (if I understand what you guys are proposing) is that it negatively impacts other aspects of the code. For example, right now this plays nice with the Coriolis parameter definition on a tilted/rotated domain. Currently we can model a domain tilt with. ```julia; buoyancy = Buoyancy(model=BuoyancyTracer(), gravity_unit_vector=ĝ); coriolis = ConstantCartesianCoriolis(f=params.f₀, rotation_axis=ĝ); ```; which makes for a really seamless and simple user interface. It wouldn't be as nice if we flipped the unit vector for buoyancy in the code. Also we'd need to define another direction in addition to `ZDirection()` that would replace it as the default for the unit vector. It'd probably be something more verbose like `NegativeZDirection()` or `AntiparallelZDirection()`. (The default for `ConstantCartesianCoriolis` would still be `ZDirection()` though.). By changing `gravity_unit_vector` to `buoyancy_unit_vector` (or whatever other word we decide) we only need to change one thing and it doesn't add any verbosity to the code/interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028:487,interface,interface,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1069316028,4,['interface'],['interface']
Integrability,"My mistake, we can remove this dependency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898:31,depend,dependency,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898,1,['depend'],['dependency']
Integrability,"My statement is somewhat misleading. I should say that I expect the model to abort itself AFTER NaNs appear. It does not have to abort immediately at the first occurrence of NaN, but it needs to abort before an out-of-bounds error. Ideally, we do not want a model to crash due an out-of-bounds error. Instead, it should abort with a error message, and a detailed solution can be found in the document. Does this answer your question?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645:339,message,message,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1771787645,1,['message'],['message']
Integrability,"My two cents:. > TODO list (some we might want to address before merging, some we probably should open issues about):; > ; > 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. In this PR!. > 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. Soon. > 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. The file should provide this. > 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... Let's come up with an abstraction for vectors and use this for `HydrostaticFreeSurfaceModel`. > 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. Yes. > 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. Seems easy, but setting boundary conditions will require an abstraction for vectors and coordinate system transformations. > 8. Add the cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333:447,integrat,integrating,447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-818046333,2,['integrat'],['integrating']
Integrability,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:213,integrat,integration,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720,1,['integrat'],['integration']
Integrability,"Nice! We usually use \nu for viscosity and \kappa for diffusivity --- so should we use \kappa here? You can allow it to depend on x, y, z by writing \nabla \cdot (\kappa \nabla c) without loss of generality (it's also nice to see the divergence operator show up twice I think). Thanks for putting this together...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919:120,depend,depend,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874259919,1,['depend'],['depend']
Integrability,"No worries @jagoosw ! This is a neat application!. It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804:355,rout,routine,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804,1,['rout'],['routine']
Integrability,"Normalizing the different grids would definitely be good if we can do it. I would also add the grid properties. Right now there's also e.g. `grid.Δx` and `grid.Δλᶜᶜᵃ`. > After starting to use `RegularLatitudeLongitudeGrid`, I see that the defualts are quite different, you need to specify latitude, longitude, and z. I guess the main limitation is that the different grids use different coordinates (which have different names). Not sure I see a way around this besides calling `longitude` `x` and `latitude` `y` etc. > Also, there is no topology option at all. Yeah for the `RegularLatitudeLongitudeGrid` the topology depends on the `longitude` bounds. I thought it made sense to make y and z `Bounded` and only make x `Periodic` if `longitude = (-180, 180)`. So then not sure what would happen if a user passes an inconsistent `topology`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833:619,depend,depends,619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1506#issuecomment-805955833,1,['depend'],['depends']
Integrability,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.Δxᵃᵃᶜ` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791,1,['interface'],['interface']
Integrability,"OK, I think we wrap up this PR and merge it. The advection tests and what not can be another PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753:15,wrap,wrap,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1646559753,1,['wrap'],['wrap']
Integrability,"OK, I'll close this for now then and leave the issue open to remind us to heal the duplicate `R_Earth` that appear in Oceananigans... I like the approach that users should set their constants depending on whatever choices they like. E.g., simulating an ocean in Europe or a fish tank on the top of Everest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033:192,depend,depending,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492632033,1,['depend'],['depending']
Integrability,OK. How about we close this PR and open another on in which we:; - drop the MPICH_jll direct dependency; - add a remark in the docs for how people need to work around that for julia 1.7 + Mac M1s,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261:93,depend,dependency,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261,1,['depend'],['dependency']
Integrability,"OK. Sorry for not chiming in earlier @francispoulin, but indeed you are correct. The derivation you have for the advective terms of the tracer equation requires, e.g., u at the cell's interfaces. But we don't have those values, as you point out. In a finite volume formulation we only have the cell-averages of u around cells with centers the cell interfaces. But there is a way to reconstruct the value of u @ the interface from knowledge of the cell-averages of ū. This is usually referred as ""Reconstruction"" (section 2 of Shu 2009). I guess the best way to reconstruct u @ interface from all ū's is to take u as the cell average of ū at the particular cell? Have to think a bit on that (and wait for the coffee to kick in), but I guess this holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290:184,interface,interfaces,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874312290,4,['interface'],"['interface', 'interfaces']"
Integrability,"Obukhov-compliant bottom drag. I couldn't reproduce the simulation perfectly (for example, they use a pseudo-spectral scheme in the horizontal directions, force their drag with a horizontal average, and modify the `SmagLilly` constant slightly) so the results are a bit different from what's in their paper, but I think that's okay. Let me know if anyone thinks otherwise. Importantly, the `ScaleInvSmag` shows an improvement over the `SmagLilly`, with the later being expectedly overly diffusive and pretty much killing any turbulence at this resolution:. https://github.com/user-attachments/assets/6440450d-52f4-43ef-9ad5-0f8fcd9993d5. For reference, this is what similar plots from the paper look like (the equivalent for us here would be SMAG and PASI):. ![image](https://github.com/user-attachments/assets/5607d340-d4b4-4405-a0a6-67ed43bfd274). Some quick notes:. - Many tests are failing become I made an ad-hoc modification for now which passes the velocities to `DiffusivityFields()`. I did that because otherwise it was hard to make the model performant and simulations were taking way too long. We can (and should) review this and either come up with a better way to construct the `diffusivity_fields` or make this change separately in another PR, which will require changing the other models too.; - I'm updating the dynamic model once every 5 time steps only (this is user-defined). This is common practice for dynamic models since their cost is significantly higher than that of constant Smag or even AMD. With that practice, the dynamic model is taking about 3 times longer to run than the constant Smagorinsky. It does take significantly longer to compile (I haven't timed it). I believe there might be some optimizations still on the table though.; - I also found that the precise value of the Smag coefficient calculated via the dynamic procedure is dependent on the advection scheme, with WENO generally leading to smaller values. In hindsight, I think that's not surprising though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667:3137,depend,dependent,3137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2417879667,2,['depend'],['dependent']
Integrability,Oh no problem. I think there could even be more than one PR. First we just want to show that we can build a latitude longitude grid using OSSG. next we can test dynamics on OSSG and make sure its identical (that's a better test than just visualizing a splash). Then we can design a user interface that makes it easy to build latitdue longitude grid or any other grid on OSSG. Then we can deprecate latitude longitude grid. So there's a lot of ways to break it up. I just thought if OSSG works it'd be nice to demonstrate by running a case on lat lon grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519:287,interface,interface,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3230#issuecomment-1697313519,1,['interface'],['interface']
Integrability,"Ok @hdrake @liuchihl I have added the option to include or not the background field when computing closure fluxes. They are noit included by default. If you want to include them you need to build the `BackgroundFields` explicitly by writing something like. ```julia; background_fields = BackgroundFields(; background_closure_fluxes=true, b=B); ```. where `B` is the background buoyancy field as before. Then pass this to the model constructor instead of passing a `NamedTuple`. Let me know if this seems like a good interface and also if it works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954:516,interface,interface,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204097954,1,['interface'],['interface']
Integrability,"Ok I have a new proposal:. Eliminate the `Buoyancy` wrapper, and instead implement a new ""optional"" wrapper called ""RotatedBuoyancy"" or something like that, which is _only_ used when buoyancy is rotated. I think this is nice because for the majority of users who don't want to rotate buoyancy, they don't have to deal with the extra layer of indirection that `Buoyancy` currently introduces. For those users who want to rotate gravity, well, they know what they are doing. This is a better API because users get out what they put in (ie the keyword `buoyancy = ...` corresponds to `model.buoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982:52,wrap,wrapper,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982,2,['wrap'],['wrapper']
Integrability,"Ok better idea. The _first_ time that time-step wizard is called as a callback, it can call into a function like `validate_CFL(model, cfl)`. . Then model developers can implement that function if they would like to warn users. Since it's called at iteration 0, the warning is prominent. Moreover, the warning can be made specific depending on the type of model and time-stepper being used, so we can be more sure that we are giving accurate and relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830:330,depend,depending,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697334830,1,['depend'],['depending']
Integrability,Ok two PRs that this depends on now: #3311 and #3314 . I'll mark as draft to indicate that this is on hold for a little,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602:21,depend,depends,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308#issuecomment-1751137602,1,['depend'],['depends']
Integrability,"Ok you convinced me with the `print`. Better to use @navidcy's solution. On the other hand it feels a little clunky, so maybe we can define a `nameof` function which returns `string(typeof(scheme1).name.wrapper)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289:203,wrap,wrapper,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986811289,1,['wrap'],['wrapper']
Integrability,"Ok, I was a bit unsure which CFL definition is the best, so I checked the 2D stability and I got a slightly better proof. ; Let's start with the discretized version of the 2D advection equation (forward euler and 2nd order centered finite volume on a staggered regular cartesian grid) ; $$\frac{c^{n+1} - c^n}{\Delta t} = u \left( \frac{c^n_i - c^n_{i-1}}{\Delta x}\right) + v \left( \frac{c^n_j - c^n_{j-1}}{\Delta y}\right)$$ ; Let's assume that c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; T",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:476,depend,depending,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,2,['depend'],"['dependent', 'depending']"
Integrability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:38,interface,interface,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['interface'],['interface']
Integrability,"Ok, fixed an issue dispatching on a grid with partial cells in the hydrostatic pressure integral (turns out things go very wrong if we naively integrate to find hydrostatic pressure with partial cells!) here: https://github.com/CliMA/Oceananigans.jl/pull/2306/commits/9cc91dafe140ce4d5124a4d80e8a35496e45ad7e. Things look ok now, and a resting ocean remains at rest:. <img width=""598"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/166724316-df8cd89e-aed3-4027-b0fa-60cec7ad44ac.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307:143,integrat,integrate,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306#issuecomment-1117542307,1,['integrat'],['integrate']
Integrability,"Ok, good to know. But I think the strategy we use to distribute work should depend specifically on how much each example costs. So the optimal strategy for this code might be different than on the other PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547:76,depend,depend,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3139#issuecomment-1583216547,1,['depend'],['depend']
Integrability,"Ok, let me take a look. That synchronize should not be necessary. Also this seems weird as . https://github.com/JuliaGPU/KernelAbstractions.jl/blob/5a30f7332e5190247742fa671a01724ae2ef254a/src/cpu.jl#L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231:29,synchroniz,synchronize,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514637231,1,['synchroniz'],['synchronize']
Integrability,"Ok, then we need to think about the user interface. We could add a keyword argument `output_grid` to the output writer, or perhaps a positional argument as in. ```julia; JLD2OutputWriter(model, outputs, grid; kw...); ```. I think a feature that might be useful for implementing this feature is an `InterpolatedField`, which looks something like. ```julia; struct InterpolatedField; grid; data; interpoland; end. function compute!(interp::InterpolatedField); compute!(interp.interpoland); interpolate!(interp, interp.interpoland); return interp; end; ```. Then we could use this feature in `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/output_construction.jl. and maybe elsewhere. This is a chunk of work of course. I don't need it right now personally.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033135677,1,['interface'],['interface']
Integrability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:366,depend,depend,366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['depend'],['depend']
Integrability,"Okay so indeed I think this issue only happens due to poor resolution of the initial noise. I cooked up a MWE where I fixed the random seed, then used that to sprinkle 256 Gaussians (that are also horizontally periodic) throughout the domain. I did this because I wanted to have the ""same noise"", but change it from being under-resolved to well-resolved. I ran this for a few cases ranging from poorly resolved (1 to 2 grid-points per gaussian) to well-resolved (about 8 grid-points per gaussian). I'm plotting three of the animations I got in order or increasing resolution (2, 4, and 8 grid-points per gaussian):. https://user-images.githubusercontent.com/13205162/224089407-ee82f95f-1c71-4857-b69b-745ae20749f6.mp4. https://user-images.githubusercontent.com/13205162/224089438-a49d7c94-391c-4f5d-b4ac-fb658ea672c3.mp4. https://user-images.githubusercontent.com/13205162/224089523-5e485a2b-b7b4-4eb6-b793-e1123345eebc.mp4. We can clearly see that the odd behavior decreases and then finally goes away as we start resolving the initial fluctuations more and more. Some things caught my eye here though. Firstly, this is an example of the long-time solution depending on the initial conditions, which is really odd to me. Although I guess I shouldn't be so surprised, since this isn't physical turbulence, it's something else (and it's poorly resolved), but still I think it's interesting. Also as the time progresses, even in the most resolved simulation, some grid-scale noise starts to emerge (which probably has to do with the advection scheme?). However, this grid-scale noise, contrary to the _initial_ grid-scale noise, doesn't cause any trouble. I wonder why... In any case, @glwagner please feel free to convert this issue to a discussion and thanks for the help!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712:1158,depend,depending,1158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1462387712,2,['depend'],['depending']
Integrability,"Okay, here's my MWE which includes running the first simulation to generate the checkpoint file:. ```julia; using Oceananigans; using Printf. """""" Set up a simple simulation to test picking up from a checkpoint. """"""; function test_simulation(stop_time, Δt, δt); grid = RectilinearGrid(size=(), topology=(Flat, Flat, Flat)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt, stop_time). progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = false). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. rm(""test_iteration*.jld2"", force=true). Δt = 1 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = 2 # progress message frequency. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt); run!(simulation, pickup=checkpoint); ```. This reproduces the issue because I get. ```julia; julia> include(""test.jl""); [ Info: Initializing simulation...; [ Info: Iter: 0, time: 0 seconds; [ Info: ... simulation initialization complete (2.697 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (5.721 seconds).; [ Info: Iter: 2, time: 2 seconds; [ Info: Simulation is stopping after running for 8.786 seconds.; [ Info: Simulation time 4 seconds equals or exceeds stop time 4 seconds.; [ Info: Iter: 4, time: 4 seconds; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (529.973 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (575.447 μs).; [ Info: Iter: 5,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310:936,message,message,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657#issuecomment-2246064310,2,['message'],['message']
Integrability,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:507,integrat,integrate,507,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793,2,['integrat'],['integrate']
Integrability,"On Julia < 1.9 you need requires [which is standard practice by extension packages], if Oceananigans enforces 1.9+, it's not necessary. Wasn't sure so added both here, and you can remove the requires dependency if desired.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748:200,depend,dependency,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1755997748,1,['depend'],['dependency']
Integrability,"On a different note, if a `BackgroundField` is time dependent then evaluating it at every time step makes sense. But if it's time independent, as in this case, then it's working a lot more than it should. Would it be of interest to have an option for it to not compute it at every time? I am not suggesting this be done for this problem, but thinking more in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687:52,depend,dependent,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-875002687,1,['depend'],['dependent']
Integrability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:12,interface,interface,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,2,['interface'],['interface']
Integrability,"One remaining question is a user interface for extracting viscosities and diffusivities, especially when we have closure tuples. I think we want a function based interface. Take for example the case. ```julia; closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=1.05e-6, κ=1e-7)); ```. We could have some API functions that look like. ```julia; viscosity(model) # returns 1.05e-6 + νₑ; diffusivity(model, :b) # returns 1e-7 + κₑ; diffusivities(model) # returns a named tuple with all tracer diffusivities; ```. This could work if _all_ closures are _either_ `AbstractScalarDiffusivity` or `AbstractBiharmonicDiffusivity`. For models with heterogeneous closures we need a bit more. For example with. ```julia; closure = (HorizontalScalarBiharmonicDiffusivity(ν=1e2, κ=1e1), CATKEVerticalDiffusivity()); ```. we might have something like. ```julia; viscosity(closure[1], model); viscosity(closure[2], model); ```. which returns the viscosity associated with `closure[n]` (here, either biharmonic diffusivity or CATKE's nonlinear diffusivity). The issue is that we don't want users picking apart `model.diffusivity_fields` since this will make scripts more fragile, prone to breakage when code changes, and difficult to understand. (I also think we need to change this to `closure_fields` at some point). . Thoughts or other ideas? @navidcy @tomchor @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050:33,interface,interface,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295#issuecomment-1064160050,2,['interface'],['interface']
Integrability,"Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088:150,message,message,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088,1,['message'],['message']
Integrability,"Or perhaps write a separate `euler_step!` that does not depend on special values of `χ`. Not sure if that would have an extra GPU cost. But even if so, it'll only be for one time-step, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516:56,depend,depend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2259#issuecomment-1046318516,1,['depend'],['depend']
Integrability,Or we can rename the grid metric operation to `dx`? Just want to make sure we consider all options. I think in our original discussion we voted for `xspacings` in the user interface for verbosity. If that's priority 1 then I agree it motivates also replacing `Δx` with `xspacing`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924:172,interface,interface,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842#issuecomment-1468307924,1,['interface'],['interface']
Integrability,"Ouch! Maybe we should fix the seed. And reduce the time step to 0.1 or something so it doens't fall exactly on the bleeding edge of possibility, depending on the whims of `rand`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846:145,depend,depending,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3538#issuecomment-2038116846,1,['depend'],['depending']
Integrability,"PU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1994,depend,depends,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"Pasting the error message would be helpful for debugging this issue. One way around that should work for `VerticallyStretchedRectilinearGrid` and also curvilinear grids is to use `accurate_cell_advection_timescale`. `TimeStepWizard` accepts the `cell_advection_timescale` function as a keyword argument in its constructor. So. ```julia; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. wizard = TimeStepWizard(cell_advection_timescale = accurate_cell_advection_timescale, other_kwargs...); ```. might work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333:18,message,message,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-862688333,1,['message'],['message']
Integrability,"Perhaps I can chime in here to give some context. Something in the Oceananigans/KA/Enzyme/etc setup was breaking our integration test of the advection-diffusion (https://github.com/CliMA/Oceananigans.jl/pull/3480) which was blocking us for making progress for some time. Eventually Joe successfully minimized it down to this point as a minimal error (effectively just testing successful AD of Oceanigans.Utils.launch!, which was failing). We later determined the root cause of the issue to be a problem in KA (https://github.com/JuliaGPU/KernelAbstractions.jl/pull/476). The purpose of this is not to specifically act as a unit test for the individual KA issue, but to be a small unit test for Oceananigans modified launching infrastructure. That way if something else comes up as a bug in a future integration test, we can quickly find the root cause without weeks of debugging from the whole integration test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020:117,integrat,integration,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2106054020,3,['integrat'],['integration']
Integrability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:167,depend,depend,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,2,['depend'],['depend']
Integrability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:300,interface,interface,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,2,['interface'],['interface']
Integrability,"Please could someone rerun the failed tests, I don't think they've actually failed from what I can tell from the error messages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485:119,message,messages,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2019249485,1,['message'],['messages']
Integrability,"Posted from a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:582,depend,depends,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depends']
Integrability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:633,depend,depended,633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['depend'],['depended']
Integrability,"Probably the easiest thing to do is to fork `LambertW.jl` and remove that warning. The rest seems ok, though a max iterations of 1000 seems a bit high if you want performance. It depends what you want, but as a hack you can return a NaN upon non-convergence rather than throwing a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244:179,depend,depends,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438#issuecomment-1904993244,1,['depend'],['depends']
Integrability,"Profiling is a very good idea. It probably makes sense to use an integrated / application profiler (rather than simply timing functions), because WENO5 is itself composed of many small functions and we don't know which one is the bottleneck. I have never tried profiling on the GPU, but there's some info here: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/. Specifically I think we need to install NSight: https://juliagpu.gitlab.io/CUDA.jl/development/profiling/#NVIDIA-Nsight-Systems",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956:65,integrat,integrated,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868829956,2,['integrat'],['integrated']
Integrability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:37,interface,interface,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,1,['interface'],['interface']
Integrability,Reading through the error message again I'm not sure its what I thought.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853:26,message,message,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1752624853,1,['message'],['message']
Integrability,"Reductions on FieldTimeSeries are performed individually for each element by constructing two Fields and reducing one into another. Probably, the construction of the individual field is what is causing the loss in performance?; We do not necessarily need to do that, we can just wrap the data in a `ConditionalOperation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413:279,wrap,wrap,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750#issuecomment-2322204413,1,['wrap'],['wrap']
Integrability,"Registration pull request created: [JuliaRegistries/General/32030](https://github.com/JuliaRegistries/General/pull/32030). After the above pull request is merged, it is recommended that a tag is created on this repository for the registered package version. This will be done automatically if the [Julia TagBot GitHub Action](https://github.com/marketplace/actions/julia-tagbot) is installed, or can be done manually through the github interface, or via:; ```; git tag -a v0.53.1 -m ""<description of version>"" 7682a3df3c65a1a7e1df2bb05d86a8ce033a91ff; git push origin v0.53.1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332:436,interface,interface,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473#issuecomment-799772332,1,['interface'],['interface']
Integrability,"Right, we cannot form operations with reductions. To operate on reductions, we have to wrap them in a `Field`, so that they can be computed, stored, and _then_ used via the stored result. You can write. ```julia; U = Field(Average(model.velocities.u)); U / 2; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713:87,wrap,wrap,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347470713,1,['wrap'],['wrap']
Integrability,"Say if we wanted to further modify the forcing function to have second derivatives so that the forcing function looks something like:. $$; (\mu_{0}\exp(z/\lambda) - m)\partial_x(\frac{\partial_y(P)}{T}); $$. where $T$ is possibly dependent on $x$ and $y$, would the code look something like this?. ```; using Oceananigans.Operators: ℑxᶜᵃᵃ, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ, ∂yᶜᶠᶜ. function growing_and_grazing(i, j, k, grid, clock, fields, params) ; z = znode(Center(), Center(), Center(), i, j, k, grid); return (params.μ₀ * exp(z / params.λ) - params.m) * ℑxᶜᵃᵃ(i, j, k, grid, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ(i, j, k, grid, ∂yᶜᶠᶜ, fields.P)/fields.T); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558:230,depend,dependent,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558,1,['depend'],['dependent']
Integrability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:204,interface,interface,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,2,['interface'],"['interface', 'interfaces']"
Integrability,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:143,integrat,integration,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089,2,['integrat'],['integration']
Integrability,Should we open an issue to discuss interfaces to stretched grids?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312:35,interface,interfaces,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814216312,1,['interface'],['interfaces']
Integrability,"Since the code is just a few lines, it's easy to figure out what's going on in the REPL. The top of the error message says:. ```; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; ```. So let's go look at this line. It is:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L35. Ok. Does `background_fields` have the property `u`? At the REPL, using the MWE, I find:. ```julia; julia> background_fields.u; ERROR: type BackgroundFields has no field u; Stacktrace:; [1] getproperty(x::Oceananigans.Models.NonhydrostaticModels.BackgroundFields{true, @NamedTuple{…}, @NamedTuple{…}}, f::Symbol); @ Base ./Base.jl:37; [2] top-level scope; @ REPL[7]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Ok, we found the error. But where is `u`? writing `julia> background_fields.` and pressing TAB yields. ```julia; julia> background_fields.; tracers; velocities; ```. Ok, so maybe we want `background_fields.velocities.u`. Looking into the source code for background fields:. https://github.com/CliMA/Oceananigans.jl/blob/f89445dcc802341d5361c2f241fe48e483dbd9ff/src/Models/NonhydrostaticModels/background_fields.jl#L32-L38. confirms what we found, that `BackgroundFields.u` does not exist. Just to confirm, we go back to the REPL and try:. ```julia; julia> background_fields.velocities.u; ZeroField{Int64}; ```. so yes, using `velocities.u` should fix this particular bug. This is an easy fix. Just to go through the motions and get a hang for how this works, let's add the test first, and then make the fix.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716:110,message,message,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2433267716,1,['message'],['message']
Integrability,"Since this is such a major change in the interface, I think we should get the docs back up again before registering 0.90 (i.e. fix https://github.com/CliMA/Oceananigans.jl/issues/3191).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373:41,interface,interface,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1783617373,1,['interface'],['interface']
Integrability,"Since we don't have bitwise reproducibility, each run has random round-off errors that, if integrated into a nonlinear trajectory, can cause two solution to diverge eventually. Possibly this test case is a little too challenging (too long time integration, or too nonlinear), meaning that occasional chaotic divergence of the solution is expected?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012:91,integrat,integrated,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430089012,2,['integrat'],"['integrated', 'integration']"
Integrability,"Since we throw away any calculations that are entirely inside a solid, we usually don't care what happens there. I think that's why it's called `solid_interface` rather than `fluid_solid_interface`, but @simone-silvestri can confirm. I think we need a bit more information for boundary conditions right? We have to know the _direction_, eg. ```julia; using Oceananigans.AbstractOperations: flip; east_fluid_solid_interface(LX, LY, LZ, i, j, k, grid) = !solid_node(LX, LY, LZ, i, j, k, grid) & solid_interface(flip(LX), LY, LZ, i, j, k, grid); ```. This returns `true` when our cell is not immersed, but the eastern boundary is a fluid-solid interface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497:641,interface,interface,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047168497,1,['interface'],['interface']
Integrability,So I added a unit test showing that checks that should test its functionality. Once we get more of Oceananigans differentiated we can add some bigger integration tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531:150,integrat,integration,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3327#issuecomment-1756769531,1,['integrat'],['integration']
Integrability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:359,depend,dependencies,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependencies']
Integrability,"So depending on how we perceive the importance of this issue we could add docs and an example illustrating this workflow to users, as an alternative to changing the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015:3,depend,depending,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041158015,1,['depend'],['depending']
Integrability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:717,interface,interface,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,4,['interface'],['interface']
Integrability,"So in this I've got a load of `update_tendencies!` being called, and adding `synchronize(device(architecture(model)))` at the end appears to have fixed this. To summarise: ; - `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)` error; - Resolved by manually synchronizing the device with `synchronize(device(architecture(model)))`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808:77,synchroniz,synchronize,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721361808,3,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:144,depend,depend,144,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,2,['depend'],['depend']
Integrability,"So, I need to use `sort` on `CuArray`s to calculate [available potential energy](https://github.com/CliMA/Oceananigans.jl/issues/1297) but I just realized that it's only available starting at CUDA version 2.6, which support Julia 1.6 only. Can you guys give an ETA of long until the Julia 1.6 migration is complete? Looks like it's relatively close but depending on the answer I might need to change my research plans for now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912:353,depend,depending,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-825940912,1,['depend'],['depending']
Integrability,"So, I'm hitting some errors running the `baroclinic_adjustment` example with the ROCBackend. The only modification of this example script is the specification of the architecture as `GPU()`. It seems that this chokes on AMDGPU's `zeros`. I did not encounter this in the other work I was doing on Simone's branch; though the test we were using was not building with a recilinear grid. ```; $ julia --project=. ./bench/baroclinic_adjustment.jl ; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:640,interface,interface,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,1,['interface'],['interface']
Integrability,"Some good news is that more tests seem to be passing compared to the prevoius PR. . One of the messages I saw was there was a cancellation signal, see below. Lots of the tests just cancelled, and I'm not sure why. ```; Testing Oceananigans; # Received cancellation signal, interrupting; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877:95,message,messages,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1985730877,1,['message'],['messages']
Integrability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:313,wrap,wrap,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,1,['wrap'],['wrap']
Integrability,"Something is not right again. There is a method `validate_closure`; seems like that's the place to put the error message?. My argument is just based on intuition from the method's name. This error seems part of the validation, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749:113,message,message,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2325594749,2,['message'],['message']
Integrability,"Sorry I didn't realize I didn't get the full error message:; ```; [52922] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:129; Allocations: 618273 (Pool: 617476; Big: 797); GC: 1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2300; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:51,message,message,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"Sorry I should have been more verbose. I meant that since the Manifest you pushed doesn't seem to work then I'm not sure I can reproduce the setup you run locally to test things. And that said, I'm not sure whether some errors you point out are because of the code or from a dependency version that is different to what I have on my side etc..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477:275,depend,dependency,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3470#issuecomment-1937042477,1,['depend'],['dependency']
Integrability,Sorry but I don't quite understand the changes. Could you please post explain a little more? Maybe posting a couple of snipets showing how the interface changed is enough!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624:143,interface,interface,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813428624,1,['interface'],['interface']
Integrability,"Sorry if I jumped the gun on the merge, I thought I saw a message deciding against pseudomomentum but can't find it anymore. To be honest I don't know much about pseudomomentum, so I can't have an informed opinion. I know you can use it when talking about nonbreaking waves, but I, personally, find that nomenclature a little obscure in this context.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270:58,message,message,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-778664270,1,['message'],['message']
Integrability,"Sorry maybe there was a miscommunication. The `output!` interface does not delay creating files until `run!`. . Delaying output initialization to `run!` does not exist. I would like to implement it, however. (In another PR.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820#issuecomment-2393872882,1,['interface'],['interface']
Integrability,"Sounds great! I've had a discussion with Greg about this before, and which method you need to implement really depends on the application. ; - The ""penalty function"" boundary was the first type proposed historically, but it is completely inappropriate for unsteady flows and will really mess up a turbulent boundary layer evolution.; - Direct forcing methods and other similar approaches go in and set the value of velocity components inside the immersed solid at each time step to satisfy the velocity boundary conditions before or after the projection step. However, you have to choose between enforcing a divergence free velocity and the BC - you can't have both without modifying the pressure Poisson equation. As long as the body isn't moving, the results tend to be fine. The pressure forces will not be time accurate and so dynamic forces will suffer. ; - For fluid structure interaction problems you really need to get those forces right and therefore must modify the pressure equation. . I've attach a write-up one of my students is working on which lays this out with a few simple examples. Section 3 reviews Immersed Boundary methods and 3.1 has a simple 1D FSI example. . [Mr M Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf](https://github.com/CliMA/Oceananigans.jl/files/5370790/Mr.M.Lauber_070e4204-4db5-451e-8b61-494f2ae9eaa2_Progression_Report__9_month_pdf_7177_0.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163:111,depend,depends,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707656163,1,['depend'],['depends']
Integrability,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub(overdub_context::Cassette.Context, overdub_arguments...) in Cassette at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:595); Stacktrace:; [1] getindex at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/AbstractOperations/binary_operations.jl:34; [2] macro expansion at /glade/u/home/tomasc/.julia/packages/Oceananigans/WSSHu/src/Fields/computed_field.jl:114; [3] gpu__compute! at /glade/u/home/tomasc/.julia/packages/KernelAbstractions/mKsXc/src/macros.jl:80; [4] overdub at /glade/u/home/tomasc/.julia/packages/Cassette/Wjztv/src/overdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, int",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:5126,message,message,5126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,2,['message'],['message']
Integrability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:707,depend,dependency-tracking,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['depend'],['dependency-tracking']
Integrability,"Sure, I ran a simple test using the MWE above without picking up a checkpoint and set:. ```julia; Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); δt = .03 # progress message interval and output saving interval; # Run a simulation; simulation = test_simulation(T1, Δt, δt, true); run!(simulation); ```; I've noticed that this strange behavior occurs when δt is smaller than or equal to 0.03, but it disappears when δt is greater than 0.03 (even at 0.031). It seems there is a cutoff value of δt below which the error emerges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870:184,message,message,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2260950870,2,['message'],['message']
Integrability,"Sure. I'm now working on making plots of convergence and should be able to get that done today. One issue is that I have commented out a lot of stuff, which was there before. I've focused on making the one advection test and haven't integrated it into the other tests, yet. Not sure if this is a problem?. I will create a PR later today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704:233,integrat,integrated,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-746523704,1,['integrat'],['integrated']
Integrability,"Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out if pencil decompositions are possible. ### Local topologies. The local grid topology may need",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:1093,inject,injection,1093,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['inject'],['injection']
Integrability,"TODO list (some we might want to address before merging, some we probably should open issues about):. 1. We need a new `Connected` topology with N `Bounded` `Face`s instead of N+1. For MPI we might also need `LeftConnected` and `RightConnected`. . 2. For cubed sphere fields, re-use existing fields but with new types: `CubedSphereData` and `CubedSphereBoundaryConditions`. 3. Figure out a clean way of integrating `fill_horizontal_velocity_halos!` with the existing time-stepping. Perhaps we just need a `maybe_fill_horizontal_velocity_halos!` function that only does something on a connected cubed sphere. 4. We need values for the grid coordinates `λᶜᶠᵃ`, `λᶠᶜᵃ`, `φᶜᶠᵃ`, and `φᶠᶜᵃ` so that we can use `set!` for velocities on the cubed sphere. They are not provided by the file but we should be able to convert the available coordinates back to the cubed sphere face in (ξ, η) coordinates where -1 ≤ ξ, η ≤ 1 which forms a regular grid then interpolate in between and back to the sphere to get the other staggered grid coordinates. 5. We need to use the sine and cosine of the local angle between the grid orientation (e.g., u-velocity) and zonal west-east direction at the grid-cell centers to `set!` velocity fields. Right now we're limited to setting velocity fields from a streamfunction... 6. Should we be filling the halos of the grid metrics? Seems like they should be filled like velocity halos but without any sign changes. 7. Make sure that calling `fill_halo_regions!` on a horizontal velocity field only fills the halos with non-`CubedSphereExchange` boundary conditions. 8. Add the cubed sphere passive tracer advection and surface gravity waves validation experiments to validation CI pipeline. 9. Figure out a way to abstract and clean up `fill_horizontal_velocity_halos!` and `fill_*_halo!`... 10. Merge utils from `src/CubedSpheres/cubed_sphere_utils.jl` and `src/Distributed/distributed_utils.jl` into `Oceananigans.Grids`. 11. Figure out if the tests in `test_cubed_sphere_halo_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979:403,integrat,integrating,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522#issuecomment-816631979,2,['integrat'],['integrating']
Integrability,"Tbh I didn't give it as much thought as you may be implying with your message above :). But I just realized that the ShallowWater example talks about ""equations in conservative form"" and some users may have no idea what we are talking about... Let's see what @glwagner and @ali-ramadhan think on this. Perhaps with the current status of fast development it makes sense to hold on Docs for later..?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091:70,message,message,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798789091,1,['message'],['message']
Integrability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:162,message,message,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,1,['message'],['message']
Integrability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:501,interface,interface,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['interface'],['interface']
Integrability,"Thank you for your response. The question is: what do *you* use to trace MPI; in Julia programs? Do you use `nsys`? If so, how?. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 1:06 AM Simone Silvestri ***@***.***>; wrote:. > Using nsys it is possible to trace MPI with --trace=mpi, see:; > https://docs.nvidia.com/nsight-systems/UserGuide/index.html; > <https://urldefense.com/v3/__https://docs.nvidia.com/nsight-systems/UserGuide/index.html__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvlwu8ongn$>; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396207964__;Iw!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl3gGBEE5$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWH3753SQU2FEFPUVW3Z2I6HXAVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWGIYDOOJWGQ__;!!Mih3wA!H6UjdgIwou7PJs3BrN0sPOwBQpDzgvLSPJe4sfnC3s1yyKC4zguXAXmS7ynhe0PWPbcu93qhzzaGritvl1tQs-Dz$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871:1552,Message,Message,1552,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396865871,1,['Message'],['Message']
Integrability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:1251,depend,depending,1251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,2,['depend'],['depending']
Integrability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:355,depend,depend,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,3,['depend'],"['depend', 'depends']"
Integrability,"Thanks @glwagner for the suggestion. Yes, I agree that would be much easier as there is no need to differentiate or integrate. Will think about that. We are specifying a `BackgroundField`, so given the fact that the buoyancy is calculated at every time step and every grid point, then having it precalculated would make more sense. . It occurs to me that if we solve for the buoyancy using array operators at the beginning, then we can specify the`BackgroundField` using arrays. Should that work? I don't know if I have seen how to specify `BackgroundField` as an array but I presume it's like how the turbulence example specifies the initial conditions in terms of an array?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583:116,integrat,integrate,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826#issuecomment-874994583,1,['integrat'],['integrate']
Integrability,"Thanks @glwagner. I certainly don't want to make any changes that would either slow down code or make things harder to maintain. I can't say that I know this is the right direction to go but let me try and articulate what I want to do and maybe you can suggest a direction to proceed?. The basic idea can be found by looking at `shallow_water_Bickley_jet.jl`. In this example we define a `perturbation_norm` in line 134 that computes the norm of `v`. Then in line 158 we define an output_writer to output this norm. There is nothing special about v and I might want to use use `u` as well. To do this requires two steps:. 1. Defining a new analogous function for the perturbation norm of `u`. I'm hoping we can avoid these functions completely with `using Statistics: norm` but I don't know if that's the case.; 2. In line 161 we need to list these two norms. When I tried that there was an error message, and hence what inspired this PR. I don't think this PR needs to happen and there are probably better ways of addressing points 1 and 2. Any advice?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868:897,message,message,897,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1558#issuecomment-824937868,1,['message'],['message']
Integrability,"Thanks @jagoosw and @glwagner for your thoughts on this. @glwagner, the approach to nesting is going to be highly dependent on the particular case. The nesting strategy for a simulation with mesoscale eddies passing across the boundary will be very different from the strategy to nest an LES inside a low resolution simulation. I think that this PR should provide different types of boundary conditions (the 'ingredients') and the user will need to decide how to use them for their particular case (the 'recipe' which will rely on different combinations of the 'ingredients'). Does that make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580:114,depend,dependent,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2040092580,1,['depend'],['dependent']
Integrability,"Thanks @kburns for the suggestion. I will look at Dedalus to see what they do and learn from them. I don't think we would want to find the full spectrum unless the problem is one-dimensional, but I guess it depends on what we want it to do. Lots of potential here I'm sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860:207,depend,depends,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731280860,1,['depend'],['depends']
Integrability,"Thanks @maleadt, that's very helpful!. In this PR, we haven't directly changed any kernel function signatures. However, this PR does pass more complicated objects into kernels (a wrapper around an `OffsetArray` called a ""`Field`"", rather than simply the `OffsetArray`). The primary changes in this PR are thus 1. _not_ to extract the underlying `OffsetArray` from a `Field`, and 2. writing an `adapt_structure` method for `Field`s. I suppose the translation that's performed by `adapt_structure` increases the number or arguments to the function `ptxcall_calculate_Gu__66`?. The changes made in this PR are not strictly necessary --- they are a convenience. If manually unwrapping `Field`s (the method we previously used) is necessitated by CUDA limitations, I think we can live with that. If I understand this issue correctly, we are facing a basic trade-off between (compiler?) performance and the use of convenient but complicated abstraction objects?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987:179,wrap,wrapper,179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-655255987,1,['wrap'],['wrapper']
Integrability,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:270,depend,dependency,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140,1,['depend'],['dependency']
Integrability,"Thanks @navidcy for the reply. This is helpful. This means that when we integrate the zonal momentum equation over a volume (as part of deriving the finite volume method), we get the vertical integral in the `z` derivative and hence why we get the flux at the top minus the flux at the bottom. These should be averages over each horizontal cell and we also divide by a length scale. I presume that's why the MITgcm divides by the depth of the top cell. Interesting that they seem to use a body force but it should result in the same dynamics I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047:72,integrat,integrate,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-2135395047,1,['integrat'],['integrate']
Integrability,"Thanks @qingli411. One obvious way to introduce the concept of dynamic dependencies is to break functionality out into multiple small packages (`OceananigansPlotting`, `OceananigansOutput`, etc). @vchuravy argued that this is a good philosophy for packages; perhaps even more so for a complex project like this one: we may want to keep the core as simple as possible. This would also make the tests run faster, and might make development easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624:71,depend,dependencies,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-501712624,1,['depend'],['dependencies']
Integrability,"Thanks @simone-silvestri . I believe we found our bug!. The continuity equation (conservation of mass equation) does not change whether there is topography or not. It should always be, as follows, where `h` is the total depth:. ```; ∂ₜh + ∇⋅(h u⃗) = 0; ```. The pressure gradient, however depends only on the free surface, or if we write it in terms of the total depth we need to include the topography,. ```; ∇ η = ∇(h + b); ```. I am not sure what convention we are following, but there might be a negative in front of the `b`. . Does that make sense?. The equations you shared have some mistakes in them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538:289,depend,depends,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538,1,['depend'],['depends']
Integrability,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:262,message,message,262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638,1,['message'],['message']
Integrability,"Thanks @simone-silvestri for the quick reply! I'll work on it this work and message you on slack so we can find a time that is convenient for you for us to chat, and hopefully get this moving again.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3050#issuecomment-1808253713,1,['message'],['message']
Integrability,"Thanks for all the clarifications, @francispoulin. Just a few thoughts:. I think regardless of what interface we end up using (allowing `x` to be a constructor, or creating a separate keyword such as `z_strecthed`) it needs to be absolutely clear what each option is gonna do. For example the name `z_stretched` doesn't tell us in any way that that corresponds to face locations. As a last option we can specify this clearly in the docstring, but ideally the keyword itself should be somewhat self-explanatory. About your comment about users not caring about what kind of stretching is used: regardless of creating convenience functions or not for stretched directions, we should always allow arbitrary stretching from the user part. That's because it's not just a matter of at which depth to make the grid tighter. Take free convection for example. Some users like to define a grid that is the finest close to the boundary and monotonically stretch from there (which I guess is what you have in mind). However, many people (and I know @glwagner is one of those) prefer simulating the whole boundary layer with one uniform resolution and only stretch the grid in the thermocline, for example. This has technical advantages such as aliasing reduction, etc.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166:100,interface,interface,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813558166,2,['interface'],['interface']
Integrability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:405,depend,dependent,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['depend'],['dependent']
Integrability,"Thanks for catching that! However, that's not the issue. One of the things I did (which I discussed a few messages ago) was to move `field_slicer.jl` from OutputWriter to Diagnostics, since I couldn't compile the code in the correct order for dependencies otherwise. (Plus now that FieldSlicer is used in Diagnostics, it's no longer exclusive to OutputWriters.). The test complains that it needs `short_show(fs::FieldSlicer)` in line 490 of `netcdf_output_writer.jl`: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R490. But I'm already `using` `short_show` from `Oceananigans.Diagnostics` in line 10 of the same file: https://github.com/CliMA/Oceananigans.jl/pull/1397/files#diff-b0c6a1868ef9229398d7bef0568f8adbb7ad14c88e7a49d0e8598ccb51ea07b5R10. This appears to work in my local set-up when testing, but somehow fails on github. Any ideas?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965:106,message,messages,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-787486965,2,"['depend', 'message']","['dependencies', 'messages']"
Integrability,"Thanks for creating this @tomchor , I think this is a neat idea. To help me think about how this should look, could you help me find an example you want want to do this? . I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879:283,depend,depends,283,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879,1,['depend'],['depends']
Integrability,"Thanks for running these tests, @glwagner. They really do look like the issue in https://github.com/CliMA/Oceananigans.jl/issues/3290. > The easiest fix is to eliminate the pressure separation. Since we're waiting for the IBM-aware pressure solve, we could also just add an option to eliminate the pressure separation that would be `false` by default. That should be pretty easy. And then in the future when we're confident about the new algorithm we can eliminate the pressure separation completely (along with user interface an code simplifications that are possible with no pressure separation). > Another solution is to fix the hydrostatic pressure algorithm. Does it need fixing in this case though? The way I see it this is just a consequence of how the hydrostatic pressure is defined: a vertical integral of `b`, which doesn't play well with the assumption of a vertically-periodic domain. > We should also note that the vertical tridiagonal solve is not correct for vertically-periodic domains. But this is easily solvable (and the above 2 are as well). Cool! We should probably do that as well :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151:517,interface,interface,517,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782238151,2,['interface'],['interface']
Integrability,"Thanks for sharing this @tomchor . . Do I take that to mean that if we try and run Oceananigan on an AMD GPU then very likely the code will fail because KerelAbstractions.jl (and possibily others) will fail? . It would be great to be able to run the library on any GPU but I guess a lot of this depends on KerenAbstractions, and other libraries. Do people know what other libraries we depend on that would not necessary run on AMD GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771:295,depend,depends,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546#issuecomment-813538771,2,['depend'],"['depend', 'depends']"
Integrability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:250,depend,dependencies,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,4,['depend'],"['dependencies', 'dependency']"
Integrability,"Thanks so much @jipolanco ! And thanks for the beautiful package. > For now, PencilArrays allows broadcasting together PencilArrays and regular Arrays, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. Right! I think that's a conservative design choice and well-justified if there aren't important use cases for PencilArrays / Arrays broadcasting... It looks like the relevant docs are https://jipolanco.github.io/PencilArrays.jl/stable/Pencils/#Dimension-permutations. and based on. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/Distributed/distributed_fft_based_poisson_solver.jl#L33-L44. we want something like. ```julia; transform_space_permutation = Permutation(2, 1, 3); λx_pencil = Pencil(size(global_grid), comm; permute = transform_space_permutation); # somehow set λx_pencil data to λx; ```. Reading through the docs also suggests to me that we need tighter integration with PencilArrays overall (eg we have our own notion of grids, so we may want to make these compatible with PencilArray's grids).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255:987,integrat,integration,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102789255,2,['integrat'],['integration']
Integrability,Thanks! You're right about the periodic condition and the halo region. Switching to a `8x8x8` did the trick! Although I would have thought that the interpolation routines appropriately calculated the fields at the periodic boundary. Is this expected behavior or a bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548:162,rout,routines,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324#issuecomment-770039548,1,['rout'],['routines']
Integrability,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:317,rout,routine,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194,3,"['interface', 'rout', 'wrap']","['interface', 'routine', 'wrapper']"
Integrability,That is ironically an error in the error printer. Can you convert that to an assertion so we can see the actual error message?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710:118,message,message,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1786195710,1,['message'],['message']
Integrability,"That region doesn't exist in the domain without IBM. The fluid region starts at z=0 in all cases, but for the IBM case, z<0 is; inside the immersed solid, while for the cases without IBM functionality; it's simply outside the domain. On Mon, Mar 21, 2022, 10:36 Francis J. Poulin ***@***.***>; wrote:. > Thanks @tomchor <https://github.com/tomchor> , and very nice.; >; > What would the difference of those two curves look like in the region; > where there is no masking? Are they identicial or just similar?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1074212306>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KXCYAVHO3HLQ3KWYM3VBCXRRANCNFSM5PH5P4HA>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882:825,Message,Message,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1274324882,1,['Message'],['Message']
Integrability,That sounds like a better check that would generalize!. The `ComputedField` vs. `AbstractOperation` distinction could be a common enough mistake to warrant a user-friendly message.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229:172,message,message,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308#issuecomment-762996229,2,['message'],['message']
Integrability,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:228,depend,depends,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326,1,['depend'],['depends']
Integrability,"That's a decent minimal example! Are you sure that the error requires `advection=WENO()` and `timestepper=:RungeKutta3`? The latter cannot be necessary since its the default (so omitting it has the same effect as including it). I find I can reproduce the error without `ImmersedBoundaryGrid` at all. About the error. The top of the message says. ```; ERROR: MethodError: no method matching cpu_fourier_tridiagonal_preconditioner_rhs!; ```. This means that the kernel function `fourier_tridiagonal_preconditioner_rhs!` is being called with the wrong arguments. For example:. ```julia; julia> f(x, y) = x + y; f (generic function with 1 method). julia> f(1); ERROR: MethodError: no method matching f(::Int64). Closest candidates are:; f(::Any, ::Any); @ Main REPL[1]:1. Stacktrace:; [1] top-level scope; @ REPL[2]:1; ```. The stacktrace shows. ```; [8] compute_preconditioner_rhs!(solver::Oceananigans.Solvers.FourierTridiagonalPoissonSolver{…}, rhs::Field{…}); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/HPOLD/src/Solvers/conjugate_gradient_poisson_solver.jl:109; ```. let's look at that line:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L109-L110. This uses the Oceananigans utility `launch!` which launches the kernel `fourier_tridiagonal_preconditioner_rhs!` with the arguments `solver.storage, tridiagonal_dir, rhs`. However, looking at the function `fourier_tridiagonal_preconditioner_rhs` a few lines above. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Solvers/conjugate_gradient_poisson_solver.jl#L93. we see that the function has 4 arguments, not 3. Hence the error. To summarize the analysis method, the key is to find the function that causes the error in the source code (`fourier_tridiagonal_preconditioner_rhs`) and then identify where it is called, and how it should be called. Here's an updated MWE from your nice one @liuchihl :. ```jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576:332,message,message,332,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896#issuecomment-2453118576,1,['message'],['message']
Integrability,"That's a neat idea. We also need to checkpoint simulations rather than models, to handle cases where output is time-dependent (windowed time-averages and, in the future, time derivatives).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894:116,depend,dependent,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249#issuecomment-739538894,1,['depend'],['dependent']
Integrability,"That's right. Purely for simplicity we launch all the tendency kernels from 1:N, though for Face-fields in Bounded directions, we only require 2:N. In fact using tendencies only from 2:N could allow an optimization where we don't need to ""enforce"" no-penetration boundary conditions. It'd be hard to achieve this optimization though because users can write things like `parent(u) .= 1` so I'm not sure we can get away with this being guaranteed correct. This has never been a problem because we simply overwrite the boundary velocity and therefore simply discard the tendency at index 1. > The problem is if we try to integrate something like a radiation condition. Can you point me to where in the code this goes down?. > On bounded topology I don't think we ever want to integrate the tendency right? But it might be more complicated to do that. I think that's right that we don't need the tendency. This has been part of the algorithm since time immemorial and back in the mists of time it was indeed more complicated than worthwhile. The complication is that KernelAbstractions assumes indices start at 1... However, we now have a way of offsetting indices in kernels via our `KernelParameters`. So it's not very hard to do this anymore. I can give it a start. If we make this change, we also want to take a step back and look at all the kernels we are launching currently to make sure everything makes sense. For example, here is a question: while we don't want to integrate the velocity tendencies on boundaries, what do we do about diagnostics? Do we want to compute vorticity on the boundary, for example, if we are computing a vorticity diagnostic? It seems simpler if we don't, that way we don't have special cases...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985:618,integrat,integrate,618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388758985,6,['integrat'],['integrate']
Integrability,"The above also explains why synchronizing `mean!` doesn't help. We would need a `synchronize` at some deeper level, apparently. It is interesting that adding `sleep(0.01)` helps. 🤔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690:28,synchroniz,synchronizing,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868794690,2,['synchroniz'],"['synchronize', 'synchronizing']"
Integrability,"The answer for this, as per @glwagner's comments, is because that's the syntax for `KernelAbstractions`, which we use to compute GPU kernels:. From @glwagner :. The kernel is created here:; `diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize)`; and launched here:; `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`; the diffiusivity calculations do not depend on one another, so they are all launch simultaneously. At the end, we wait for all of them to finish here:; `wait(device(arch), MultiEvent(Tuple(events)))`. Noticeably apparently we don't use `lauch!` in this case, even though apparently we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426:373,depend,dependencies,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426,2,['depend'],"['depend', 'dependencies']"
Integrability,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:598,depend,dependent,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914,1,['depend'],['dependent']
Integrability,"The code in https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/time_average_outputs.jl is a utility / user-convenience function for wrapping outputs passed to `JLD2OutputWriter` and `NetCDFOutputWriter` in a `WindowedTimeAverage`. It does not involve any averaging. If you can explain why you think it is convoluted, perhaps we can improve it. `WindowedTimeAverage` is defined in this file: https://github.com/CliMA/Oceananigans.jl/blob/master/src/OutputWriters/windowed_time_average.jl. The key part is `accumulate_result!`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/windowed_time_average.jl#L126-L144. Can you explain why isn't this captured in our tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104:152,wrap,wrapping,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872452104,1,['wrap'],['wrapping']
Integrability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:193,wrap,wrap,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['wrap'],['wrap']
Integrability,The default depends on whether the file already exists or not? Just above that... https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/netcdf_output_writer.jl#L293-L298,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222:12,depend,depends,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2339#issuecomment-1066083222,1,['depend'],['depends']
Integrability,The dependency on OrthogonalSphericalShellGrids here is blocking the progress (the `SplitExplicitAuxiliaryFields` type has changed in this PR). How do we deal with this? We could remove the dependency in the tests of Oceananigans and move those tests over at OrthogonalSphericalShellGrids,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977:4,depend,dependency,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3841#issuecomment-2431512977,2,['depend'],['dependency']
Integrability,"The difference operator doesn't use the grid metrics --- but maybe you mean the derivative / gradient operator?. Such a test would catch this issue, it's true. We could use a simple test with linear gradients. There might already be such a test, but not for all grids... ?. I think the fact that the cell spacings don't add up to the grid size could be an even worse problem because it means that integrals / budgets are not correct. But I'm not sure since the spacings at cell centers might be more important (these lines only manipulate the spacing at cell interfaces).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834:559,interface,interfaces,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755#issuecomment-866287834,2,['interface'],['interfaces']
Integrability,The difficulties in getting a test to fail on #1784 could mean that the issue this PR resolves is machine dependent. But I'm not sure.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764:106,depend,dependent,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-870838764,1,['depend'],['dependent']
Integrability,"The difficulty with `Value` conditions is that they depend on the model / turbulence closure being used (in the simplest case, we can use the user-specification to calculate a gradient, and then infer the cross boundary flux with a diffusivity). We can implement this by implementing some standard notation for the turbulence closures (right now there is a function `viscosity`, for example, and `z_viscosity`. We need the `x` and `y` components as well). In the grid-aligned case we use halos to enforce `Value` boundary conditions, but this approach doesn't work with immersed boundaries. The `Flux` case is a bit more straightforward since it doesn't depend on the closure, but does require some reasoning about boundary normal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850498079,4,['depend'],['depend']
Integrability,"The error comes from here:. https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/src/Distributed/distributed_fft_based_poisson_solver.jl#L65. My guess is that the eigenvalues aren't constructed properly. There's some code in the solver constructor:. https://github.com/CliMA/Oceananigans.jl/blob/aea1e043aa6f965ed599f151b6ace85f25df8cfa/src/Distributed/distributed_fft_based_poisson_solver.jl#L25-L44. which (just a guess) looks like we are trying to hack something together rather than properly using an interface defined by `PencilFFTs`. We have to read the `PencilFFTs` documentation and discover how to correctly define these arrays that are meant to be used in the above broadcasting operation. I think there is another issue about this, might be worth searching so we don't have a duplicate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630:539,interface,interface,539,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445#issuecomment-1101612630,1,['interface'],['interface']
Integrability,The error message we are gettig now does not seem to involve this PR at all. . If that is the case do we need to reset it?. ```. Downloading artifact: OpenSSL; --; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: IntelOpenMP; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: NetCDF; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenSpecFun; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: nghttp2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MbedTLS; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: Zlib; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: OpenMPI; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: FFTW; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: HDF5; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibSSH2; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: CompilerSupportLibraries; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkit,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:10,message,message,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['message'],['message']
Integrability,"The intended user experience is that only one line should need to be changed: `pickup=false` to `pickup=true` in `run!`. Therefore, users should not have to manually specify the ""part"" that they want to pick up from. I don't like option 2 above. I think that fixing this problem may become much easier if we can ""delay"" the creation of the output file. Right now, the output file is created when we build the output writer. But at that point, we have no way of knowing whether we are going to pick up or not. I've long wanted to implement this ""delay"" but more pressing matters have intervened... The basic thing we need to do is to add an `initialize!(output_writer, sim)` utility, which will create the output file. That function then will know whether the simulation is starting fresh (because `iteration(sim) == 0`, or whether it is ""continuing""). One huge feature this will enable is the ability to avoid overwriting an existing file when it represents the output from the current continuing run. That's a huge problem with the current interface, is that you have to be really careful about `overwrite_existing` if you are trying to pickup from a checkpoint. And I think that's a big problem. With that feature I think we can also figure out how to handle output that is split into multiple files --- because we know if a simulation is continuing that we will have to figure out which `part` to use (if any). > continues writing into the most recent output file once it catches up to the latest unsaved iteration. This is a separate feature from what I was talking about, but I think it's also a great idea! There also may be a clue how to solve a roundoff error issue, where two outputs are written one iteration separate from one another, but at virtually identical times (eg distinguished only by machine epsilon). PS: I simplified the example a bit to help me understand it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221:1041,interface,interface,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399#issuecomment-1837211221,2,['interface'],['interface']
Integrability,"The issue is a little tricky. Typically we expect abstract operations to be computed during time-stepping. In that case, the halos should be correctly filled. However, @navidcy expects that abstract operations should be correct at any time and does not expect to have to call fill halo regions. Thus for `compute!` to be more generally useful to users I think we do want this behavior. The problem is that fill halo regions can be expensive eg for distributed models. Therefore to both serve expected user behavior and provide a performant interface we perhaps have to add a flag to `compute!` like `fill_halo_regions=false` so that computation for output does not trigger extra calls to fill halo regions. Note @navidcy you can also use the simpler and more transparent . ```julia; parent(model.velocities.u) .= 1; ```. or just `fill!(model.velocities.u, 1)`. I think your result would be correct then. But still if we are setting to functions then we need `set!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530:540,interface,interface,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3114#issuecomment-1559611530,2,['interface'],['interface']
Integrability,"The issue not only happens after picking up checkpoint, it also occurs before that. For example, with the same MWE, if I set:; ```julia ; Δt = .01 # timestep (s); T1 = 6 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .03 # progress message interval and output saving interval; ```. The issue also occurs in the first run (e.g., 0-6 s):; <img width=""596"" alt=""image"" src=""https://github.com/user-attachments/assets/c4539b8b-b24d-4ba2-8a7e-a99c4d18c9a7"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623:268,message,message,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2259377623,1,['message'],['message']
Integrability,"The library computes the derivatives that are required to compute the tendencies, but they are not stored since that would not be very efficient. Getting some of these values but I don't know what that would look like. Also, if you are not computing this field at every time step, the cost of computing it sepratelyl might not be that high, but that of course depends on the particular problem you are dealing with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025:360,depend,depends,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800521025,1,['depend'],['depends']
Integrability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:103,depend,depending,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['depend'],['depending']
Integrability,"The movies don't play for me. But it seems like a vertically-integrated component (a constant) is missing from the hydrostatic pressure anomaly in the case of a vertically-periodic domain?. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L12-L20. Actually, maybe it's the other way around -- the vertically-integrated component needs to be subtracted when the domain is vertically periodic? This is effectively what occurs here for example:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Solvers/fft_based_poisson_solver.jl#L111. However this is not enforced for the hydrostatic pressure. The tridiagonal solvers are also incorrect for vertically-periodic domains, I think (well, now that we have x- and y- tridiagonal solvers I believe they are also incorrect for x- and y- periodic if using an x-tridiagonal or y-tridiagonal solver). Either way it does seem like the simplest solution is to eliminate the pressure decomposition. Interested what @simone-silvestri and @xkykai think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074:61,integrat,integrated,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290#issuecomment-1734536074,4,['integrat'],['integrated']
Integrability,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:783,integrat,integrated,783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248,1,['integrat'],['integrated']
Integrability,The reason why this test does not pass on the GPU for periodic boundary conditions in the longitudinal direction might have something to do with the synchronization of the halo filling (PR #1985 which we might want to merge soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060:149,synchroniz,synchronization,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060,1,['synchroniz'],['synchronization']
Integrability,"The top of the error message on #1780 is. ```; Stacktrace:; [1] overdub; @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/In",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,2,['message'],['message']
Integrability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:1092,depend,dependent,1092,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['depend'],['dependent']
Integrability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:725,wrap,wrap,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,1,['wrap'],['wrap']
Integrability,"The xz and yz components of stress (called `viscous_flux_uz` and `viscous_flux_vz` in the code) are explicitly elided in the presence of an immersed boundary. For examle:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L59. where. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/ImmersedBoundaries/grid_fitted_immersed_boundary.jl#L45. Since we can prescribe stresses / fluxes explicitly for grid fitted schemes (in principle --- its not implemented yet) I don't think we need to worry about errors in prescribed boundary fluxes. This issue may need to be revisited for other immersed boundary methods if they make approximations there. EDIT after I wrote this I also realized that maybe I don't understand what the boundary integrated stress is here. With a viscosity of 0, shouldn't the integrated stress be zero as well? Or perhaps this is the integrated strain?. Either way I think the simplest strategy for grid fitted boundaries (and relatives like partial cells and shaved cells) is to simply ""drop in"" the relevant prescribed flux where necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499:864,integrat,integrated,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866295499,6,['integrat'],['integrated']
Integrability,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;   | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;   | Stacktrace:;   | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);   | @ Base ./error.jl:168;   | [2] #systemerror#62;   | @ ./error.jl:167 [inlined];   | [3] systemerror;   | @ ./error.jl:167 [inlined];   | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);   | @ Base ./iostream.jl:293;   | [5] open;   | @ ./iostream.jl:282 [inlined];   | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});   | @ Base ./io.jl:328;   | [7] open;   | @ ./io.jl:328 [inlined];   | [8] read;   | @ ./io.jl:434 [inlined];   | [9] _include(mapexpr::Function, mod::Module, _path::String);   | @ Base ./loading.jl:1166;   | [10] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [11] include(x::String);   | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;   | [12] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;   | [13] include(mod::Module, _path::String);   | @ Base ./Base.jl:386;   | [14] include(x::String);   | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;   | [15] top-level scope;   | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;   | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:182,depend,dependency,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134,1,['depend'],['dependency']
Integrability,"There is a fair amount of scalar iteration right now, largely I think because we have array-like objects (Fields, and friends) that lack fully-featured broadcasting capabilities. This means writing something like `a .== 2` triggers scalar iteration on the GPU because it hits Base broadcasting. We _can_ fix the problem by fleshing out broadcasting a bit so `a .== 2` works ""correctly"" / sensibly, but we haven't prioritized it (we also didn't have broadcasting at all for Field until a month or two ago). Possibly, if changing a global via `allowscalar(true)` were not available we would have been forced to address this deficiency in our Field abstraction sooner. So that could have been a good thing depending on your perspective. It did allow us to sweep some things under the hood. On the other hand I don't think we have any performance issues; scalar iteration is only used on very small arrays for testing where we are completely dominated by compile times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884:703,depend,depending,703,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-864145884,1,['depend'],['depending']
Integrability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:91,depend,depends,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,1,['depend'],['depends']
Integrability,"There might be an issue with conditional computations but I'm not sure. For example, `ComputedField` has this `compute!` definition:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/computed_field.jl#L61-L62. I think we want something similar; eg we want the `time` argument in `KernelComputedField`:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L76. and we want to use `compute_at!(dependency, time)` here:. https://github.com/CliMA/Oceananigans.jl/blob/5ec4a7aa3d0ec054d1dc9fd369ca1b412109eae8/src/Fields/kernel_computed_field.jl#L78-L80",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205:512,depend,dependency,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769389205,1,['depend'],['dependency']
Integrability,"There should not be any `AbstractOperations.Average`. If there is, there is a bug. The constructors in the `AbstractOperations` module should simply provide new methods for `Diagnostics.Average`. The problem can be fixed by dispatching the main constructor for `Average` on `Union{Field, Computation}`. I am ok with this restriction of `Average`. However, it's worth noting that it's changes its capability. Previously, `Average` would work with anything that defines `parent` and `architecture`, including arbitrary user-defined types (this is why it works with `Computation`s, for example). With this change, it will only work with types that are specifically allowed by the constructor. Partly I think the underlying motivation for this PR could suggest we need to put a bit more effort into streamlining the user interface to `AbstractOperations` and `Computation`s. For example, it could make sense to define a constructor for `Average` that works with `AbstractOperation` without specifying the `result` (where new memory is allocated for `result`, for example). The purpose of requiring `result` is to require users to explicitly allocate the memory they need --- but the interface may not be intuitive. We may also need to spend some more time refining the `Field` abstraction, and formalizing the connection between `Field`s and other similar objects like `Computation`s and `Average`s. In that case, we could define `Computation` as a subtype of `AbstractField`, and dispatch on `AbstractField` in the constructor for `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389:817,interface,interface,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858#issuecomment-674387389,2,['interface'],['interface']
Integrability,"There used to be an example of using `dynamics` to implement particles that played ""rock, paper, scissors""; ie near-neighbors were identified, and then made to interact in some way that changed particle properties. There is scope for building out a user interface for more generic particle interactions of course. I'm not convinced that this is so important that we should spoon-feed users with an interface though. In principle, `dynamics` can do everything and advanced users can write their own code. It depends on how important the uses get, and how clever we can be with an interface (so it is easy to maintain and doesn't screw things up for future development)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719:254,interface,interface,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819496719,4,"['depend', 'interface']","['depends', 'interface']"
Integrability,"There's a disadvantage if we need to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:449,depend,dependent,449,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['depend'],['dependent']
Integrability,"There's an intriguing side benefit of this ""unified"" interface for output. It means that it is possible (though we don't have it now) for users to specify an ""output preference"" in a `Preferences.toml`, which would then determine the default behavior of `output!`. I think it also legitimately makes it easier to switching between formats.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948:53,interface,interface,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375621948,1,['interface'],['interface']
Integrability,"There's another limitation of the current scheme that's worth mentioning. The scheme currently precomputes the 3D diffusivity / viscosity field at cell centers, which means that a cell is ""unstable"" if _either_ vertical interface has a negative buoyancy gradient. But what we really want to do is precompute _stability_ (or the buoyancy gradient), which is more naturally located at vertical cell interfaces. This provides the tracer diffusivity directly; the momentum diffusivity can be calculated by checking the stability of two neighboring regions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746:220,interface,interface,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746,2,['interface'],"['interface', 'interfaces']"
Integrability,"There's some info in CUDA docs but it doesn't explicitly answer my question:. > For small integer powers (e.g., x2 or x3), explicit multiplication is almost certainly faster than the use of general exponentiation routines such as pow(). While compiler optimization improvements continually seek to narrow this gap, explicit multiplication (or the use of an equivalent purpose-built inline function or macro) can have a significant advantage. This advantage is increased when several powers of the same base are needed (e.g., where both x2 and x5 are calculated in close proximity), as this aids the compiler in its common sub-expression elimination (CSE) optimization. So maybe we shouldn't square at all here...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593:213,rout,routines,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870017593,1,['rout'],['routines']
Integrability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:331,integrat,integrate,331,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['integrat'],['integrate']
Integrability,"These are definitely cool ideas for progress statements!. I see logging as being much more general though. It should also be used when printing progress statements, but I think it's especially useful to have `@debug` messages in certain places to help with debugging. And maybe `@info` messages so the user knows what the model is doing. It could get noisy if we get carried away with them but a user staring at a blank screen for 3 minutes might not know that the GPU stuff is just compiling in the background. More responsive software feels more user-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998:217,message,messages,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-541418998,2,['message'],['messages']
Integrability,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:461,interface,interface,461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400,10,['interface'],['interface']
Integrability,"These resutls are great @whitleyv , well done! A few thoughts. First, if `c` is the concentration of a tracer it should be non-negative. If you are picking it to be a `sine` I might suggest having `1 + sin` just to avoid negative values. That being said, I don't think it's going to have any impact on the results but might be worth trying. Second, are there any boundary conditions imposed on the tracer at the immersed boundary? I remember there was a discussion but I don't remember the conclusion. Sorry. Third, what exactly is computed in the last plot fo the integrated stress tensor? Also, have you computed these for the nonIBM case to see what the real wall does?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419:565,integrat,integrated,565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-866293419,1,['integrat'],['integrated']
Integrability,"These tests aren't passing, and I have no clue why. The error is:. ```; ERROR: `Enzyme=7da242da-08ed-463a-9acd-ee780be4f1d9` depends on `ChainRulesCore=d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4`, but no such entry exists in the manifest.; ```. But I never changed anything related to that. Does anyone know what's going on?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095:125,depend,depends,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2221669095,1,['depend'],['depends']
Integrability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:387,integrat,integrated,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,2,"['depend', 'integrat']","['depending', 'integrated']"
Integrability,"This code works:. ```julia; julia> using CUDA.CUSPARSE, SparseArrays, LinearAlgebra. julia> A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0]); 3×3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B = CuSparseMatrixCSC(A); 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 0 ⋅ 1; ⋅ 2 ⋅; ⋅ ⋅ 0. julia> B += 1I; 3×3 CuSparseMatrixCSC{Int64, Int32} with 4 stored entries:; 1 ⋅ 1; ⋅ 3 ⋅; ⋅ ⋅ 1; ```. There's some `UniformScaling` stuff here: https://github.com/JuliaGPU/CUDA.jl/blob/06e8a4ccca62567d38a567874f82cb58517d8f01/lib/cusparse/interfaces.jl#L179. These appear to be allocating, so it still might make sense to decompose the matrix into a diagonal and off-diagonal component.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389:578,interface,interfaces,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109775389,1,['interface'],['interfaces']
Integrability,"This has implications in terms of code performance, if we have `set!(field)` somewhere in the code it will trigger automatically a `fill_halo_regions!` which we might not want as we are very careful to where we call `fill_halo_regions!`. There are two options then:; (1) remove all instances of `set!` in the internals and make sure to never use it; (2) implement a different interface that can be user-facing which triggers set! and fill_halo_regions! together. I would vote for (2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115:376,interface,interface,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480334115,1,['interface'],['interface']
Integrability,"This is a great question, though more of a Julia issue than something specific to Oceananigans! However, there is an off-chance that there is some feature we could implement to make this easier for people. Note that terminals also have line limits and its a problem for people working in the terminal too. I use the silly but practical solution of reducing my font size and re-executing code until l can see the top of the error message. However, there are probably other solutions. I wrote up a little example to experiment:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1.0); bad_callback(sim) = error(""Why did you write such a bad callback?""); simulation.callbacks[:error] = Callback(bad_callback); run!(simulation); ```. Some hunting on google returned this thread: https://discourse.julialang.org/t/redirect-output-and-error-to-a-file/58908/3. One option is to pipe to a file with the terminal utility `tee`:. ```julia; $ julia --project | tee out.txt; ```. All output generated thereafter is written to `out.txt`. I can't really see myself using this solution though. Changing the text size is easier... It looks it may also be possible to use the Julia module `StackTraces`:. https://docs.julialang.org/en/v1/manual/stacktraces/. With the above example I found. ```julia; julia> err, st = try; run!(simulation); catch err; err, stacktrace(); end; [ Info: Initializing simulation...; (ErrorException(""Why did you write such a bad callback?""), Base.StackTraces.StackFrame[top-level scope at REPL[2]:4, eval at boot.jl:360 [inlined], eval_user_input(ast::Any, backend::REPL.REPLBackend) at REPL.jl:139, repl_backend_loop(backend::REPL.REPLBackend) at REPL.jl:200, start_repl_backend(backend::REPL.REPLBackend, consumer::Any) at REPL.jl:185, run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool) at REPL.jl:317, run_repl(repl::REPL.AbstractREPL, cons",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614:429,message,message,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073029614,1,['message'],['message']
Integrability,This is a lot more sustainable than adding new properties to every output writer every time we want to support splitting a file by a different criterion. It's a decent change to the user interface. I can help if you like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454:187,interface,interface,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000031454,1,['interface'],['interface']
Integrability,"This is an ok idea but the warning really needs to be better. It isn't clear who is ""recommending"" what; also it doesn't really make sense because the CFL depends on the time stepping method and in principle, someone can use `TimeStepWizard` with any time stepper (for example there are models external to Oceananigans that use the `Simulation`). Presumably 0.8 is some rule of thumb for RK3. Note that we envision moving `Simulation` to an external package eventually, where it could be used by other models (eg atmospheric models). Since ClimaAtmos supports all sorts of time-steppers, I'm not sure this ""recommendation"" would continue to make sense. So I'm a little skeptical about how this is put together. You could write something like ""When using 3rd order Runge-Kutta time-stepping, a time-step that produces a CFL number `cfl > sqrt(3) ≈ 1.7` is unconditionally unstable. As a rule of thumb, we recommend using time-steps that lie well within the realm of stability: for a 3rd order Runge-Kutta scheme, for example, we recommend `cfl < 0.8`. For an Adams-Bashforth scheme, which requires `cfl < XX` for stability, we recommend `cfl < 0.2`. Other time-stepping methods have different stability constraints. For more information see [a reference].""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893:155,depend,depends,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1637706893,2,['depend'],['depends']
Integrability,This is another reason why the `Checkpointer` essentially has to depend on the `simulation` rather than just the `model`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055:65,depend,depend,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845#issuecomment-2414490055,1,['depend'],['depend']
Integrability,This is helpful - thanks Greg. It's good to have some options when unable to find the error messages during debugging!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162:92,message,messages,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363#issuecomment-1073032162,1,['message'],['messages']
Integrability,"This is my first attempt at making a version of `cell_advection_timescale` for `ShallowWaterModel`. Note that we are dividing elements of mass flux and height, which are not defined at the same cell points, but if we are looking for estimates I wonder if this will be sufficient. I have not tested this as I'm not sure how to integrate this into the rest of the code, but I thought we could try that after we agree on what the script should look like. ```; ""Returns the time-scale for advection on a regular grid across a single grid cell ; for ShallowWaterModel.""; function cell_advection_timescale(uh, vh, h, grid); umax = maximum(abs, uh / h); vmax = maximum(abs, vh / h). Δx = grid.Δx; Δy = grid.Δy. return min(Δx/umax, Δy/vmax); end. cell_advection_timescale(model) =; cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052:326,integrat,integrate,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762829052,1,['integrat'],['integrate']
Integrability,"This is not a horrible interface, except for the name ""particle_advective_forcing_w""... But this deviates from the other interfaces we provide. It might make more sense to build an interface based on `LagrangianParticles`. You may want. ```julia; struct ParticleAdvectionForcing; x; y; z; parameters; end; ```. then a property called `forcing` to `LagrangianParticles`. And a simple way to specify particle sinking. Since the forcing should depend on `particle`, users _also_ have the option to dispatch on it. I wasn't sure what `p` was in the above. We just need `forcing(particle)` or `forcing(particle, parameters)` right? The `particle` contains all relevant information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592:23,interface,interface,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1817092592,8,"['depend', 'interface']","['depend', 'interface', 'interfaces']"
Integrability,"This is the bathymetry that the code is currently using. Looks pretty nice. @simone-silvestri I am looking in `shallow_water_advection_operators.jl` and find something odd. Bathymetry only appears in `div_Uh` but not in `div_hUu` and `div_hUv`. I think this is reversed as the evolution equation for height doesn't care about the bathymetry, it's only the pressure term that depends on it. Do you agree?. ; ![topography](https://user-images.githubusercontent.com/8239041/168833014-c399f006-b5cb-4c30-b72c-f4b221b911c0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255:375,depend,depends,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255,1,['depend'],['depends']
Integrability,"This issue is connected to #2249. Since we use `solid_interface` to mask a field, we use the same function to reduce the field. ; `solid_interface` is used for masking because we want to mask up to the `interface` to ensure impenetrability. ; For a scalar in the context of a `GridFittedBoundary` `solid_interface` and `solid_node` are equivalent. Maybe, in view of the new `PartialCellBoundary` coming up, we can rethink these functions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107:203,interface,interface,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293#issuecomment-1055551107,1,['interface'],['interface']
Integrability,This looks great! I think we can re-state light integration as a field reduction with this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281:48,integrat,integration,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3590#issuecomment-2100229281,1,['integrat'],['integration']
Integrability,"This may be beyond the point of this PR, but I feel like lots of these discussions that ultimately mostly impact user interface and experience would hugely benefit from, well, user input! . This fact, coupled with the fact that Oceananigans probably now has a decently-sized user-base, may mean that we could start using polls and directly asking users about user-interface decisions. That way we can get more hard data on what makes the code easier and clearer to most users and weight that more accurately against other aspects of the decision. Just a thought...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999:118,interface,interface,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098382999,4,['interface'],['interface']
Integrability,"This should be done already (I'm not sure why the tests keep failing, its annoying). I made the change because I seriously could not understand the code. I kept getting confused between ""compute boundary tendencies"" (which adds fluxes to the tendencies, coming in from the boundaries), and ""compute tendencies_boundaries"", which did something completely different (compute the halo dependent tendencies). So I started by changing the names so I could reason about the code without my head spinning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325:382,depend,dependent,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398224325,1,['depend'],['dependent']
Integrability,"This velocity field:. ```julia; uᵢ(x, y, z) = (1-tanh((x-500)/10)); ```. is compressible, because `uᵢ` depends on `x`. When we project out the compressible component (the part that depends on `x`), we are left with just `u=1`. What do we expect to happen in this case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462:103,depend,depends,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397#issuecomment-1828496462,2,['depend'],['depends']
Integrability,"To address the first issue, here's the definition of `time_average_outputs`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L11-L16. The arguments are the specified `schedule` (which is an `AveragedTimeInterval` per the API we have designed), the `outputs` (here a `Dict`), `model`, and `field_slicer` (because we support averaging slices of fields). The first line:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L12-L13. converts the `outputs` `Dict` into a `Dict` of `WindowedTimeAverages` by wrapping each member of output in `WindowedTimeAverage`. The second part is to return the `TimeInterval` that corresponds to `AveragedTimeInterval`:. https://github.com/CliMA/Oceananigans.jl/blob/d17f926b2c4787bf44f619439e81bfb82937aabf/src/OutputWriters/time_average_outputs.jl#L15. It'd be great to improve this functionality if we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599:662,wrap,wrapping,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-872455599,1,['wrap'],['wrapping']
Integrability,"To answer @tomchor's question, yes, the grid is formed at the faces and that's easy enough to do when building the grid. For @ali-ramadhan questions. 1. @glwagner suggested that I try doing this in `VerticallyStretchedGrid` to see what it looks like and then we can discuss it. I'm happy to say that was very successful and now we are talking about it. I guess whether this PR is merged or not depends on how we want to proceed.; 2. Yes, I guess the question is what is the best design for the average user. Whatever we do, not everyone is going to like it but we should strive for something that is ""easy`, since that's in the description of Oceananigans. As a user I think I would simply want to specify the domain and then say I want a tighter grid around a particular point, say the left boundary, or any other point for that matter. I don't think the average user is going to care whether it's quadratic, cubic or hyperbolic, as long as you get better resolution around the point of interest. Is this something we agree on? If yes I would ideally want to user to specify the domain, where they want the clustering and then boom it happens. . @glwagner also suggeted in #1532, that it would be nice for us to put together some functions that the user can use to define grids. Specifying the array is not too difficult but I think we can make it easier by having functions to do most of the work for the user. I like @ali-ramadhan 's suggestion of having options in terms of what the input is and I will certainly need some help doing this, after we decide what we want the input to be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543:394,depend,depends,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813526543,2,['depend'],['depends']
Integrability,"To be sure, I didn't know that it would fail with scalars on the GPU and I don't really know why that happens... !. Note that you can also simply output a scalar to file every time-step and do the time-integration offline. JLD2 is lightning fast so you probably won't pay for that. That's actually the simplest method, and as a bonus you get the time history.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609:202,integrat,integration,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482943609,2,['integrat'],['integration']
Integrability,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:725,integrat,integrate,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839,3,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Integrability,"To compare the numerical solution of the Rossby-Haurwitz wave on the cubed sphere against an established benchmark, I chose the exact solution of the non-linear barotropic vorticity equation on the sphere (not the solution of the non-linear shallow water equations). This was achieved by replacing the initial phase Rλ with the time-dependent phase Rλ−νt in Equations (143)–(146) of [Williamson et al.](https://www.sciencedirect.com/science/article/pii/S0021999105800166), using the angular velocity ν given by Equation (142). The results at a resolution of 128x128 cells per panel are as follows:. - Since we prescribe the initial stream function and numerically take its derivatives to specify the initial velocities on the cubed sphere, numerical errors are present even in the initial velocities and the diagnosed initial vorticity. The vorticity error is significantly pronounced near the cubed sphere corners due to the deviation from orthogonality. For instance, in the domain's interior, the vorticity error norm is three orders of magnitude less than the vorticity norm, whereas at the corners, it is nearly the same order of magnitude.; - As the simulation progresses, the amplified error from the corners propagates into the interior as expected. After 500 time steps, the vorticity error in the interior increases from three orders of magnitude less to one order of magnitude less than the vorticity norm. I have attached panel-wise plots of the exact vorticity and the error of its numerical counterpart on the cubed sphere for the initial condition and after 500 time steps for reference. Given these circumstances, @navidcy and I are contemplating whether we should continue using the exact solution for verification in the test script or consider alternative verification methods, such as ensuring that the norm of the numerical solution of the Rossby-Haurwitz wave remains bounded within a specified range (as mentioned in the introduction to this PR). @glwagner, @simone-silvestri an",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684:333,depend,dependent,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2134152684,1,['depend'],['dependent']
Integrability,"To do:. - Implement `mul!` for the Laplacian operator; - Implement a wrapper type for `Field` that subtypes `AbstractVector`?; - Implement `ldiv!` for the FFT-based preconditioner (after the first two are done), planning to use [`ldiv=true` with `cg`](https://jso.dev/Krylov.jl/dev/preconditioners/#Examples). This example illustrates implementing a custom operator:. https://jso.dev/Krylov.jl/dev/matrix_free/. Here is the documentation for implementing preconditioners in Krylov:. https://jso.dev/Krylov.jl/dev/preconditioners/. In Krylov, we want to remove broadcasting. . To make `Field` look like a vector we just need. ```julia; struct QuasiVector{FT, F} <: AbstractVector{FT}; field :: F; function QuasiVector(field); FT = eltype(field); F = typeof(field); return new{FT, F}(field); end; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451:69,wrap,wrapper,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415237451,1,['wrap'],['wrapper']
Integrability,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:921,depend,dependencies,921,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423,3,['depend'],"['dependencies', 'dependency']"
Integrability,"To get this PR merged, it sounds like we just want to agree on a naming convention and move the topologically-aware operators to the `Operators` module?. I like the `T` for topology suggestion, e.g. `δxTᶜᵃᵃ`. These operators are not exported so they don't need to have user-friendly names, only developer-friendly names. I'm happy to move forward with this suggestion and try to get this PR review-ready. I also don't think operators should depend on boundary conditions. But I can write down some thoughts in a more appropriate issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652:441,depend,depend,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2397520652,2,['depend'],['depend']
Integrability,"Tthe MPI tag must be an integer. The maximum value is vendor dependent but it is quite strict. ; The smaller maximum value is [32767](https://www.intel.com/content/www/us/en/developer/articles/technical/large-mpi-tags-with-the-intel-mpi.html#:~:text=For%20the%20InfiniBand*%20support%20via,be%20queried%20in%20the%20application.). We could probably record the whole location without incurring in integer dimension issue. We cannot do ; `field_id * 100000 + loc_x * 10000 + loc_y * 1000 + loc_z * 100 + from_side * 10 + to_side` because the tag could be larger than 32767. ; However, we could combine the three locations in a dictionary; ```julia; (Center, Center, Center) -> 0; (Center, Center, Face) -> 1; (Center, Face, Center) -> 2; (Face, Center, Center) -> 3; (Face, Face, Center) -> 4; (Center, Face, Face) -> 5; (Face, Center, Face) -> 6; (Center, Center, Nothing) -> 7; (Face, Center, Nothing) -> 8; (Center, Face, Nothing) -> 9; ...; ```; If all the permutations fit into 99 values, we consume only 2 digits which would probably fit within the limits. We can also compress the `from_side` and `to_side` into only one digit because we have; ```julia; west to east -> 0; east to west -> 1; south to north -> 2; north to south -> 3; top to bottom -> 4; bottom to top -> 5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373:61,depend,dependent,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2297127373,1,['depend'],['dependent']
Integrability,Two questions:. > Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Is this one node or multiple nodes? . Secondly you include a memory measurement. Is this residual memory or memory allocated during a time-step?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585:45,depend,dependent,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505#issuecomment-805913585,1,['depend'],['dependent']
Integrability,"Unfortunately it doesn't work for me:. ```julia; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ -e 'using Pkg; Pkg.instantiate()'; (base) tomas@np900:~/repos/Oceananigans.jl$ julia1.6 --project=docs/ docs/make.jl; ERROR: LoadError: LoadError: LoadError: ArgumentError: Package SpecialFunctions [276daf66-3868-5448-9aa4-cd146d93841b] is required but does not seem to be installed:; - Run `Pkg.instantiate()` to install all recorded dependencies. Stacktrace:; [1] _require(pkg::Base.PkgId); @ Base ./loading.jl:990; [2] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [3] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [6] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compile",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:453,depend,dependencies,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['depend'],['dependencies']
Integrability,"Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146:136,synchroniz,synchronization,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146,1,['synchroniz'],['synchronization']
Integrability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:172,depend,depending,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['depend'],['depending']
Integrability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:95,depend,depend,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['depend'],['depend']
Integrability,"Using this branch I get. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:245; ERROR: ArgumentError: halo must be ≤ size for coordinate y; Stacktrace:; [1] validate_halo(TX::Type, TY::Type, TZ::Type, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/input_validation.jl:87; [2] validate_rectilinear_grid_args(topology::Tuple{…}, size::Tuple{…}, halo::Tuple{…}, FT::Type, extent::Nothing, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:292; [3] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{…}, x::Tuple{…}, y::Tuple{…}, z::Tuple{…}, halo::Tuple{…}, extent::Nothing, topology::Tuple{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:269; [4] with_halo(new_halo::Tuple{…}, old_grid::RectilinearGrid{…}); @ Oceananigans.Grids ~/Projects/Oceananigans.jl/src/Grids/rectilinear_grid.jl:389; [5] inflate_grid_halo_size(::RectilinearGrid{…}, ::WENO{…}, ::Vararg{…}); @ Oceananigans.Models.Nonhyd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352:91,depend,dependency,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310594352,1,['depend'],['dependency']
Integrability,"Very good questions. I don't have very good answers, but happy to share my thoughts. I don't know how things will change for velocity but it should be clearer after we figure out how to deal with the tracers. As for how the velocity is set, we always set the normal velocity to be zero at the interface. The only difference is the `ParitalCell` has a bottom that can be higher and we need to take this into account when computing the fluxes in and out of this region. We haven't gotten there yet but it's part of the plan. There aren't any essential differences between the current method, what we call `GridFitted` and Adcroft et al. call a `FullCell` method, and the `PartialCell` method. The former is the limit when we choose the height of the topography in a cell interface to be zero, whereas the latter can pick it to be between a tolerance (currently 0.2) and 1 of the full depth. So the `GridFitted` boundary must have the boundary between fluid and solid at a face, whereas `PartialCell` can have it anywhere in the interior. That means that the interface is really at i + alpha where 0 \le alpha < 1, or something like that. I can imagine that sometime in the future they are part of the same function, but much testing must happen before. I don't believe we need to change how `solid_interface` works but I need to look over how it's defined to make sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748:293,interface,interface,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1042491748,6,['interface'],['interface']
Integrability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:809,depend,depend,809,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,3,['depend'],"['depend', 'dependencies', 'dependency']"
Integrability,"Very nice work @glwagner , and thanks for making this. Lots of good stuff here. In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent. Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589:240,depend,dependent,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589,1,['depend'],['dependent']
Integrability,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:520,integrat,integrate,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937,1,['integrat'],['integrate']
Integrability,"Very thorough write-up, thank you!. My initial reaction is that maybe something is not wrong. Intuitively I feel that TKE statistics are generally less noisy than dissipation statistics, but I agree the difference between snapshot and time average is pretty big. This is simulation dependent and I'm sure you've thought about all this though. The two should agree in the limit that the averaging window (and output interval) goes to zero? Otherwise there's a bug. I think we have pretty good time averaging tests for NetCDF with analytic solutions (https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_netcdf_output_writer.jl#L476-L570) but we don't explicitly test `NetCDFOutputWriter` + `KernelComputedField` + `AveragedTimeInterval` so there could be a bug. What does a movie of dissipation look like?. I notice the time step is `Δt = 20minutes` while the output interval is `100minutes` so at most a time average will contain 4-5 iterations worth of data. If dissipation changes rapidly (or has a period) then I can see the average being quite different from the snapshot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746:282,depend,dependent,282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-809488746,1,['depend'],['dependent']
Integrability,"We can add a warning message ""note that if you used to use version blah then this now changed... etc"" and keep it there for a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276:21,message,message,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356#issuecomment-1455156276,1,['message'],['message']
Integrability,"We can consider changing this kwarg to `directions`. I don't think we had much a conversation about it, but the two we considered originally were `direction` and `isotropy`. One motivation for using `isotropy` is to smoothly transition from ""IsotropicDiffusivity"" (with three-dimensionality implied) and ""AnisotropicDiffusivity"" (meaning, different in the horizontal and vertical directions) to a single struct. But having a clear meaning for most people is more important than that continuity. Isotropy in _one_ direction is accurate in my opinion, though I agree its the trivial case (like a ""set"" with one element) and therefore reads a little awkwardly. Diffusion can act in the ""horizontal directions"" while being horizontally-anisotropic (ie the diffusion of a vector depends on its orientation), so the meaning is a bit different. But, we can document that `ScalarDiffusivity` is isotropic in its `directions` for vectors like momentum. > To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. We can indeed use a second closure to set a vertical diffusivity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693:774,depend,depends,774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261#issuecomment-1046343693,2,['depend'],['depends']
Integrability,"We can use an abstract type to obviate the need for ""zero functions"":. ```julia; abstract type AbstractBiogeochemistry end. struct NutrientsPlanktonDetritus{FT} <: AbstractBiogeochemistry; background_nutrients :: FT; mortality_rate :: FT; nitrification :: FT; end; ```. then with. ```julia; @inline (::AbstractBiogeochemistry)(i, j, k, grid, val_tracer_name, clock, fields) = zero(grid); ```. users don't need to define the ""netural biogeochemical forcing"" themselves. . Very Important: always use verbose names! I don't know how to enforce that within the API 😂 . I like this interface. Let's figure out if `Val{symbol}` is GPU-friendly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081:577,interface,interface,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1305830081,1,['interface'],['interface']
Integrability,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:273,wrap,wrapper,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949,1,['wrap'],['wrapper']
Integrability,"We could do that, in fact the requests are stored in the `arch.mpi_requests` vector. The problem with using the length of that vector for inferring a `field_id` is that is not unique for different ranks. For example, a slab decomposition on a bounded domain will lead to 2 requests for the rank adjacent to boundaries (RightConnected or LeftConnected) and 4 for ranks connected on both sides. In this way, the counter is incremented globally when one field is sent, the side is inferred from the `fill_halo_side!` routine so this, combined to a location, leads to a unique tag. . What about changing the `mpi_tag` name to `active_comm_counter` and add an inverse function to extract the inputs from the tag? Then it is quite easy to inspect the tag and understand what communication we are looking at.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321:514,rout,routine,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714#issuecomment-2299104321,1,['rout'],['routine']
Integrability,"We could implement an interface similar to `Buoyancy`, but I think this may be more easily done with `FPlane`, since `NonTraditionalFPlane` seems to be dedicated not for tilting domains, but for decomposing rotation based on latitude. We'd have something like. ```julia; θ_rad = 0.05 # radians; g̃ = (sin(θ_rad), 0, cos(θ_rad)); buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃); coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃); ```. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205:22,interface,interface,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-885020205,1,['interface'],['interface']
Integrability,We could to suggest wrapping the `Reduction` in a `Field`. I'm not 100% sure the best way to inject that kind of hint; we don't own operations like `/` so I think to do that we would have to define them (and then throw an error). Hmm.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856#issuecomment-1347473891,2,"['inject', 'wrap']","['inject', 'wrapping']"
Integrability,"We have fully implemented a hard coded drag into all of the momentum viscous fluxes. Since this implementation of the drag has different values for ""symmetric"" fluxes such as `viscous_flux_uy` and `viscous_flux_vx` that are located at the same point, the `conditional_flux_fcc` location-separated fluxes were not enough. We split these into functions such as `conditional_flux_fcc_uy` and `conditional_flux_fcc_vx`. It'll be easier to address these issues directly in the immersed `viscous_flux` once we have a separate term in the tendency equations with its own functions. . These functions then check whether the interface between solid and fluid is at the top of a cell or the bottom of a cell, applying the correctly directioned drag for that side. The way these conditionals work, the fully immersed cells that aren't on a boundary would be calculating fluxes as usual, except that all those terms are masked. So the fluxes inside the solid will remain zero. When the solid-fluid interface is at the top or right hand side of a cell, the velocities for that `(i,j,k)` location will all be within the solid. If you use them in your drag functions, it would just be zero flux. So, the drag at a top flux interface, for instance, located at `(i,j,k)` will use the velocities at `(i,j,k-1)`, and so on for the other directions. This makes them match the usual non-immersed drag BC for the 1D case as seen below. . https://user-images.githubusercontent.com/67593861/160839128-37ab95fa-f28b-43c0-8bbf-3c850ae754f2.mp4. https://user-images.githubusercontent.com/67593861/160839127-912ee3d0-75e9-4536-a494-2ec3c6c2b006.mp4. https://user-images.githubusercontent.com/67593861/160839125-bef17105-d8ac-4999-a3f0-fbbb55e8498a.mp4. @tomchor has also tested them with 3D setups, which worked as well! There's still a lot of room for streamlining and speeding up this set up, which I believe will be easier to do in the full implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667:616,interface,interface,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1083117667,3,['interface'],['interface']
Integrability,We need https://github.com/CliMA/OrthogonalSphericalShellGrids.jl/pull/44 + a new release of OrthogonalSphericalShellGrids.jl otherwise the cyclical dependency blocks Oceananigans from bumping minor version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325:149,depend,dependency,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3860#issuecomment-2436720325,1,['depend'],['dependency']
Integrability,We only put the no normal gradient matching scheme in the source code which just overwrites the boundary point so this wasn't a problem. I though we weren't going to put lots of matching schemes in the source code since its not clear what is the best/correct. We could put in a simple scheme that integrates the boundary point if that would be better?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794:297,integrat,integrates,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2391286794,2,['integrat'],['integrates']
Integrability,"We should have a way to mask the tracers for sure. On the other hand, in our current algorithm we do not ""use"" immersed ""halo"" nodes because we impose a no-flux condition by just setting to zero the fluxes on the immersed boundaries - opposed to actual boundaries where the ""no-flux"" condition is imposed by mirroring the values outside the boundary and explicitly calculating a flux. For this reason, we don't need to mask the tracer within the time integration. So, it is not necessary, but It is definitely a function we want to allow...; I see the confusion, what I meant is we need to remove it if it is done within the time stepping, but we leave the functionality there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180:451,integrat,integration,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249#issuecomment-1042502180,1,['integrat'],['integration']
Integrability,We should wrap up this PR. Let's discuss what's needed. The most important thing is modifying src and test to reflect what we learned.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232:10,wrap,wrap,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1970727232,2,['wrap'],['wrap']
Integrability,"We want to write. ```julia; @inline left_biased_αx₀(i, j, k, grid::AbstractGrid{FT}, ψ) where FT = C3₀ / (left_biased_βx₀(i, j, k, ψ) + FT(ε))^ƞ; ```. this will convert the floating point number `1e-6` to the appropriate precision prior to summing with the result of `left_biased_βx₀`, which in turn will compute the exponential in the appropriate precision. ultimately `left_biased_βx₀` needs to depend on `grid` to resolve #1704 so it might be smart to do that at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896:397,depend,depend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1771#issuecomment-873430896,1,['depend'],['depend']
Integrability,Well it adds a new feature. I could just bump to 0.91.6 instead but it seems quite a major feature to justify the bump in version.; Also it removes dependencies on quite some packages.; What do people think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534:148,depend,dependencies,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2269883534,1,['depend'],['dependencies']
Integrability,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:808,interface,interface,808,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['interface'],['interface']
Integrability,"Well, it depends what definition of `h` you have if you include b in momentum or continuity, I agree with you that if `h` is total depth, b is found in the momentum equations. If not is found in continuity",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553:9,depend,depends,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553,1,['depend'],['depends']
Integrability,"Well, it looks like this PR does not completely solve the problem, and the jury is out perhaps on whether it helps or not. I did learn a few things. It seems the race condition originates from an attempt to ""re-resolve"" the manifest during the test:. https://buildkite.com/clima/oceananigans/builds/17516#01920c32-4e89-4654-a4a8-9b077e51e87c/39-221. The puzzling part is how to solve the problem. I thought at first we could solve it by preventing the Manifest from being ""re-resolved"" --- perhaps by resolving it correctly during initialization? But actually, this isn't possible, since the problematic manifest in question is a temporary run that is created only for the tests (and its different from the project's manifest, because it also includes the test dependencies). This temporary test manifest can't be initialized as far as I can tell and is created independently for each test. Finally, it seems that some race conditions happen in a print statement (this is just from reading the error message). It all boils down eventually to these two lines:. https://github.com/JuliaLang/Pkg.jl/blob/5fbfa125045ce3e68ce10bf9fc1727bb3232c123/src/Operations.jl#L799-L800. The command its trying to run is. ```julia; ERROR: failed process: Process(`/net/ocean/home/data44/data5/glwagner/julia-1.10.5/bin/julia -C native -J/net/ocean/home/data44/data5/glwagner/julia-1.10.5/lib/julia/sys.so -O0 -g1 --color=yes -O0 --color=no --history-file=no --startup-file=no --project=/tmp/jl_f9Z8t1/Project.toml --eval 'append!(empty!(Base.DEPOT_PATH), [""/data5/glwagner/.julia-17516""]); --;   | append!(empty!(Base.DL_LOAD_PATH), String[]). cd(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg""); --;   | include(""/data5/glwagner/.julia-17516/packages/CUDA_Runtime_jll/YgJCI/.pkg/select_artifacts.jl"");   | ' -t1 --startup-file=no x86_64-linux-gnu-libgfortran5-cxx11-julia_version+1.10.5`, ProcessSignaled(11)) [0]; ```. and supposedly the issue arises within the `select_artifacts.jl` call in `CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199:761,depend,dependencies,761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2362378199,4,"['depend', 'message']","['dependencies', 'message']"
Integrability,"Well, right now, the `Model` includes both discrete and continuous aspects of the PDE. `Model` also stores `architecture`, for example, which is unrelated to the PDE. We did consider an abstraction that represented the equation set independent from discretization. This would not be a replacement for model, but would simply be a way to organize some of the properties of model (eg buoyancy, coriolis, diffusion, etc). Yet this is a challenging abstraction to design. One issue is specification. If we try to separate the terms from their numerical implementation, we have to figure how to distinguish between ""diffusion with second-order differences"" and ""diffusion with fourth-order differences"". It's clearly possible to do this, but it's going to take some time and careful thought to implement. We've taken a more incremental approach to development the model instead, resulting in a fairly ""flat"" interface to `IncompressibleModel` that combines aspects both of the continuous equations, their discretization, and things like `architecture`, the `pressure_solver`, etc. I think flat is simple (think parameter files as the platonic ideal of a flat API); however, we still want to benefit from modularity where it's a simple change that doesn't overcomplicate the interface (hence this issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548:903,interface,interface,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175#issuecomment-729123548,2,['interface'],['interface']
Integrability,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:554,depend,dependence,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524,2,['depend'],['dependence']
Integrability,"Well, this is interesting. I guess when we designed the interface for `KernelComputedField` I envisioned that `field_dependencies` would be a list of `AbstractField`s (hence the name). The point is that `compute!(element)` is called on every `element` of `field_dependencies`. `u_tot` is not a field, its an `AbstractOperation`. The interesting thing is that `compute!(u_tot)` can actually do something, because `compute!` is _also_ defined for `AbstractOperations` (if `u_tot` has any `ComputedField`s in its tree, they get computed). This is a use case I didn't think of. Other objects in `field_dependencies` (like integers, floating point numbers) are ok because there's a fallback `compute!(arbitrary_object) = nothing`. However, I don't like allowing this because it makes scripts confusing to read. An integer is an ""integer dependency"" (or just a ""dependency"") --- not a ""field dependency"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594:56,interface,interface,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1323#issuecomment-769383594,4,"['depend', 'interface']","['dependency', 'interface']"
Integrability,"Welp, it's a minor difference at 8m resolution here:. https://user-images.githubusercontent.com/15271942/164351531-dae7cec6-de9a-43a7-a60f-29f6bbeeb060.mp4. ""new"" is this PR. The results are expected though I think: when we put the diffusivity at cell interfaces (holding everything else the same / all parameters constant), the mixing rate is slightly reduced. @navidcy @simone-silvestri @adelinehillier shall we merge?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829:252,interface,interfaces,252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2449#issuecomment-1104607829,1,['interface'],['interfaces']
Integrability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:24,interface,interface,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['interface'],['interface']
Integrability,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:23,rout,route,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917,2,['rout'],['route']
Integrability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:1157,wrap,wrapping,1157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['wrap'],['wrapping']
Integrability,"What parallelism strategy makes sense? One particle per thread? Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Presumably `TimeSeries` makes sense for simple diagnosed particle ""properties"" and is the place to start. Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design, especially because our time stepping is not very abstracted yet. If we are integrated with DifferentialEquations this job might get a bit easier...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123:412,depend,depend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547069123,2,"['depend', 'integrat']","['depend', 'integrated']"
Integrability,What was the code? We can improve the error message,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356:44,message,message,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2313485356,1,['message'],['message']
Integrability,"What's the point of wrapping it in `Forcing`?. I think a cleaner syntax is . ```julia; u_forcing = FieldTimeSeries{}(...); model = NonhydrostaticModel(; grid, forcing = (; u = u_forcing)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112:20,wrap,wrapping,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3760#issuecomment-2329663112,1,['wrap'],['wrapping']
Integrability,"When I exit the REPL I get a very long error message ending:; <summary>; <details>; ```; WARNING: Error while freeing DeviceBuffer(568 bytes at 0x0000000320000400):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemFreeAsync; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #free#2; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:97 [inlined]; [5] free; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:92 [inlined]; [6] #actual_free#976; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:77 [inlined]; [7] actual_free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:74 [inlined]; [8] #_free#998; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:492 [inlined]; [9] _free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:479 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:464 [inlined]; [11] macro expansion; @ ./timing.jl:393 [inlined]; [12] #free#997; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:463 [inlined]; [13] free; @ ~/.julia/packages/CUDA/35NC6/src/pool.jl:452 [inlined]; [14] (::CUDA.var""#1004#1005""{CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, CUDA.CuStream})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:130; [15] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; WARNING: Error while freeing DeviceBuffer(560 bytes at 0x0000000320000000):; CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing). Stacktrace:; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:45,message,message,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,1,['message'],['message']
Integrability,"When I set the halo to be `halo=(3,3)` I get the following error message since it wants `halo=(3,3,0)`. This seems slightly less than idea. Should we make it so that either are acceptable?. ```; [2021/05/18 12:08:59.339] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grid; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614:65,message,message,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843317614,1,['message'],['message']
Integrability,When the `Oceananigans` github page is opened it might present this helpful message:. ![image](https://user-images.githubusercontent.com/15271942/136055771-2191957e-eced-4696-9362-03aac3e10722.png). Copy/pastable commands:. ```; git branch -m master main; git fetch origin; git branch -u origin/main main; git remote set-head origin -a; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1446#issuecomment-934522905,1,['message'],['message']
Integrability,"While bathymetry is not a priority at the moment, there may be simple, non-invasive methods (from an algorithms standpoint) like the one described in the slack message pasted by @ali-ramadhan for modeling non-rectangular domains. . Probably the main challenge is not implementing the method (which could take a few days), but verifying and validating the implementation (more likely a few weeks of work at minimum). A collaboration with others who are knowledgeable in Julia and can participate in debugging and validation is probably the best chance for having this feature implemented any time soon, given the time constraints of the main developers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644:160,message,message,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/530#issuecomment-553467644,1,['message'],['message']
Integrability,"While using `main` indeed I can reproduce the error above... ```Julia; navidcy:Oceananigans.jl/ |main ✓|$ julia-1.10 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.10.0 (2023-12-25); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; └ @ ~/Oceananigans.jl/Manifest.toml:0; ┌ Warning: The project dependencies or compat requirements have changed since the manifest was last resolved.; │ It is recommended to `Pkg.resolve()` or consider `Pkg.update()` if necessary.; └ @ Pkg.API ~/julia-1.10/usr/share/julia/stdlib/v1.10/Pkg/src/API.jl:1800; Precompiling Oceananigans; 1 dependency successfully precompiled in 21 seconds. 143 already precompiled.; [ Info: Oceananigans will use 48 threads. julia> grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0625. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo:; ├── u: 16×16×16 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── v: 16×16×16 Field{Ce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:432,depend,dependencies,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,3,['depend'],"['dependencies', 'dependency']"
Integrability,"Why does `BoundaryConditions` need to depend on `Distributed`? I think `Distributed` needs to _extend_ `fill_halo_regions!`. For this, `Distributed` must come _after_ `BoundaryConditions`. I also think that `Distributed` needs to come after `Field`; and `Field` depends on `BoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489:38,depend,depend,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489,2,['depend'],"['depend', 'depends']"
Integrability,"Wow, awesome work!. Here are a few thoughts/comments:. > * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid"". :+1: much clearer. > * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:775,interface,interfaces,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['interface'],['interfaces']
Integrability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1303,depend,depends,1303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['depend'],['depends']
Integrability,Yeah not the most informative error but it does something! I usually just expect a slower simulation due to float conversions. Checking types would be great! I don't even think there's a test that sets up a `Float32` model and just checks that it's fully `Float32` all the way down. I've also mostly stuck to `Float64` simulations but I am interested in whether `Float32` can work nicely out of the box. Sounds like it'll probably be quite case-dependent...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862:445,depend,dependent,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785#issuecomment-2369729862,1,['depend'],['dependent']
Integrability,"Yeah the plot is from v0.5.x or something lol. Not sure if CPU -> GPU speedups are as relevant anymore? Well, maybe a lot of people are still on CPUs. The speedup can be much larger with WENO, but it's all very CPU and GPU dependent. I've seen ~8x and ~2000x speedups for the same benchmark. Also not sure if there are any good metrics to quantify performance. But @simone-silvestri's scaling plots would probably be great to include?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495:223,depend,dependent,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684#issuecomment-2272351495,1,['depend'],['dependent']
Integrability,"Yeah, I guess that would work too!. It does have to just be one kernel per point I think because the modified value depends on all of the other tracer values.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763:116,depend,depends,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3262#issuecomment-1719178763,1,['depend'],['depends']
Integrability,"Yep. the inputs `Ax, Ay, Az, C, D` are used to construct the matrix that solves; ```; Axᵢ₊₁ xᵢ₊₁ + Axᵢ xᵢ₋₁ + Ayⱼ₊₁ xⱼ₊₁ + Ayⱼ xⱼ₋₁ + Azₖ₊₁ xₖ₊₁ + Azₖ xⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) xᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) xᵢⱼₖ = b; ```; with periodic or zero-flux boundary condition depending on the topology of the grid (i.e. bounded topology -> zero flux BC, periodic topology -> periodic BC). If you need a matrix to solve the discretized Poisson equation at `ᶜᶜᶜ`:; ```; Ax = zeros(N...); Ay = zeros(N...); Az = zeros(N...); C = zeros(grid, N...); D = zeros(grid, N...); for i = 1:grid.Nx, j = 1:grid.Ny, k = 1:grid.Nz; Ax[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δyᶠᶜᵃ(i, j, k, grid) / Δxᶠᶜᵃ(i, j, k, grid); Ay[i, j, k] = Δzᵃᵃᶜ(i, j, k, grid) * Δxᶜᶠᵃ(i, j, k, grid) / Δyᶜᶠᵃ(i, j, k, grid); Az[i, j, k] = Δxᶜᶜᵃ(i, j, k, grid) * Δyᶜᶜᵃ(i, j, k, grid) / Δzᵃᵃᶠ(i, j, k, grid); end; reduced_dim = (false, false, false); matrix_constructors, diagonal, problem_size = matrix_from_coefficients(arch, grid, (Ax, Ay, Az, C, D), reduced_dim); matrix = arch_sparse_matrix(arch, matrix_constructors); ```; Take care that, with these coefficients, the RHS will have to be multiplied by the volume. (otherwise you can always divide the coefficients by the volume before constructing the matrix)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069:297,depend,depending,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1106118069,1,['depend'],['depending']
Integrability,"Yes !. On Thu, Apr 28, 2022 at 06:33:13AM -0700, Gregory L. Wagner wrote:; > @christophernhill does MITgcm have a divergence viscosity feature?; > ; > -- ; > Reply to this email directly or view it on GitHub:; > https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112209787; > You are receiving this because you are subscribed to this thread.; > ; > Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591:363,Message,Message,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440#issuecomment-1112313591,1,['Message'],['Message']
Integrability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:563,integrat,integration,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,2,['integrat'],['integration']
Integrability,"Yes, I can use `AbstractArray{FT}`, but it should represent a vector (whatever format he has).; For common array types, it always leads to an `AbstractVector`, so I never found the need to remove it.; I was always hesitant to relax this constraint because the type of `b` is used for allocating the ""vectors"" in the workspace of a Krylov method.; If a user makes a mistake and provides a matrix with one column instead of a vector, it will fail internally with an unfriendly error message.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444:481,message,message,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3812#issuecomment-2415718444,1,['message'],['message']
Integrability,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:390,interface,interface,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502,1,['interface'],['interface']
Integrability,"Yes, that is the page that I saw.  I got there by searching the docs, not using the index.; On Sep 19, 2023 at 4:41 PM +0100, Gregory L. Wagner ***@***.***>, wrote:; > Hmm, yes I think that is an orphan page in the docs with no link...; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502:362,Message,Message,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502,1,['Message'],['Message']
Integrability,"Yes, this should work.  If it doesn’t work on kelp, you can try it on proteus or oceanus.; On Jun 20, 2024 at 10:41 PM +0100, Jago Strong-Wright ***@***.***>, wrote:; > The distributed regression tests are still failing but I'm not sure how to go about getting them to work because I can't work out how to run mpi locally, is it possible to do e.g. mpiexec -n 4 ... locally just on a single machine?; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099:526,Message,Message,526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181609099,1,['Message'],['Message']
Integrability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:409,rout,routines,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rout'],['routines']
Integrability,"You are also right, the data was generated on the CPU so it should be synchronized correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649:70,synchroniz,synchronized,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1428721649,1,['synchroniz'],['synchronized']
Integrability,You are saying that you’d expect to have estimates of the velocity values at the interfaces rather than their cell-averaged values (centered around the interfaces)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416:81,interface,interfaces,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874098416,2,['interface'],['interfaces']
Integrability,"You can start by allowing the coefficient to be an array as in AMD:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L143. Then with a callback you can implement any model, including dynamic Smagorinsky. So this provides unlimited flexibility in developing a new closure. I think its possible you will find that its more efficient to precompute (eg in a callback) the coefficient rather than compute it on the fly with a function, especially because the computation of the different filters is a bit non-local, eg you have to average over a few grid points, which could involve relatively expensive memory fetches. A function-based interface could be nice too, but note that they are relatively complicated. Do we expect a lot of users to experiment with custom coefficient functions? @tomchor if this feature is just for you to experiment with dynamic Smagorinsky implementations then I think experimenting in the source code is an even quicker and easier option than designing a function-based interface... @simone-silvestri and @xkykai have talked about dynamic Smagorinsky too but I think their main conclusion is that it is not a gimme.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674:764,interface,interface,764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637#issuecomment-2187109674,2,['interface'],['interface']
Integrability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:165,integrat,integrated,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['integrat'],['integrated']
Integrability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:496,depend,depends,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,2,['depend'],['depends']
Integrability,You should be able to load any NetCDF file using xarray and it gives you a nice and powerful interface for analyzing and manipulating the data. Probably not the best example as it's a little old and messy (I've started using Makie more often) but here's one example: https://github.com/CliMA/LESbrary.jl/blob/3595ff2e1db6d5e6898b6ea84335fdb9dbd23b15/src/make_lesbrary_plots.py,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432:93,interface,interface,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-772770432,1,['interface'],['interface']
Integrability,You will need to add `CUDAKernels` as a dependency,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162:40,depend,dependency,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524#issuecomment-811480162,1,['depend'],['dependency']
Integrability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:201,wrap,wrapper,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,1,['wrap'],['wrapper']
Integrability,"`@sprintf` / `@printf` formatters allow right-padding with the syntax `% 123s`, where `123` is the number of spaces. for example:. ```julia; julia> a = ""hi""; ""hi"". julia> b = ""bye""; ""bye"". julia> c = ""yeah sure""; ""yeah sure"". julia> @printf(""a: % 12s\nb: % 12s\nc: % 12s"", a, b, c); a: hi; b: bye; c: yeah sure; ```. Other points:. * The plot looks great!; * I would suggest just merging this plot and working on new advection schemes in another PR.; * You can let a validation script depend on `Polynomials` without adding `Polynomials` to the Oceananigans `Project.toml`. There's a few other validation scripts that depend on random packages that are not a part of Oceananigans.; * This PR also adds a bunch of new examples that are variants on the Bickley jet. Probably not intended?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343:485,depend,depend,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648#issuecomment-839084343,2,['depend'],['depend']
Integrability,"`@stdlib/Serialization`; [1a1011a3] SharedArrays `@stdlib/SharedArrays`; [6462fe0b] Sockets `@stdlib/Sockets`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [4607b0f0] SuiteSparse `@stdlib/SuiteSparse`; [fa267f1f] TOML `@stdlib/TOML`; [a4e569a6] Tar `@stdlib/Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing reg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10337,depend,dependencies,10337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,2,['depend'],['dependencies']
Integrability,"`KernelAbstraction.synchronize(device(arch))` would be the same as the previous `wait(device(arch), event)` where the error would be thrown",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771:19,synchroniz,synchronize,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1514588771,1,['synchroniz'],['synchronize']
Integrability,"`NetCDF_jll <400.900` works for me. Adding the following lines to `Project.toml` of `Oceananigans` or the environment for running `Oceananigans` should work, but it seems not the best practice since it adds a stale dependency. . ```toml; [deps]; NetCDF_jll = ""7243133f-43d8-5620-bbf4-c2c921802cf3"". [compat]; NetCDF_jll = ""<400.900""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241:215,depend,dependency,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777#issuecomment-2356961241,1,['depend'],['dependency']
Integrability,"```; Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question. Stacktrace:; [1] error(s::String); @ Base .\error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore C:\Users\ADMIN\.julia\packages\GPUArraysCore\GMsgk\src\GPUArraysCore.jl:116; [5] getindex(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Int64); @ GPUArrays C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:48; [6] scalar_getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:34 [inlined]; [7] _getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:17 [inlined]; [8] getindex; @ C:\Users\ADMIN\.julia\packages\GPUArrays\Hd5Sk\src\host\indexing.jl:15 [inlined]; [9] getindex; @ C:\Users\ADMIN\.julia\packages\OffsetArrays\rMTtC\src\OffsetArrays.jl:422 [inlined]; [10] getindex; @ C:\Users\ADMIN\.julia\packages\Oceananigans\E4XVr\src\Fields\field.jl:540 [inlined]; [11] rescale!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, @NamedTuple{u::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Fl... (repeats 1 time); [12] top-level scope; @ In[10]:9; ```. This is an error message I am getting from my code. Please share your comments on how to resolve this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299:1902,message,message,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2019782299,1,['message'],['message']
Integrability,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.Operators; using GLMakie. # A bit of code...; @inline f²(i, j, k, grid, f, args...) = @inbounds f(i, j, k, grid, args...)^2. @inline function Riᶜᶜᶜ(i, j, k, grid, U, b); N² = ℑzᵃᵃᶜ(i, j, k, grid, ∂zᶜᶜᶠ, b); S²u = ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u); S²v = ℑyzᵃᶜᶜ(i, j, k, grid, f², ∂zᶜᶠᶠ, U.v); S² = S²u + S²v; return ifelse(S² == 0, zero(eltype(grid)), N² / S²); end. grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); velocities = fake_model.velocities; tracers = fake_model.tracers. # Pacanowski-Philander implementation; #; # The following implements the Packanowski-Philander model for shear-modulated mixing; # with parameters:; ν₀ = 1e-4; ν₁ = 1e-2; κ₀ = 1e-5; κ₁ = 1e-2; c = 5; n = 2. # In Packanowski-Philander both the viscosity and diffusivity; # depend on the Richardson number:; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); Ri = Field(Ri_op). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). @show ν # it's an operation... closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). # For `closure` to work correctly, the Ri must be defined as an ""auxiliary field"" of the model.; # Fields in model.auxiliary_fields are updated every time-stepper stage.; model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer(), auxiliary_fields = (; Ri)); model.velocities = velocities; model.tracers = tracers. # Initial condition with Ri ≈ 0.01; step(x, c, w) = 1/2 * (1 + tanh((x - c) / w)) # smooth step function. N² = 1e-4; bᵢ(x, y, z) = N² * z. S² = 1e-2; Δu = 4 # m; uᵢ(x, y, z) = Δu * sqrt(S²) * step(z, -grid.Lz/2, Δu). set!(model, u=uᵢ, b=bᵢ). simulation = Simulation(model, Δt=1minute, stop_time=1day). # Alternative to writing output.; fields ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967:2375,depend,depend,2375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066093967,1,['depend'],['depend']
Integrability,`auxiliary_fields` are fields that are meant to be used in forcing functions. That's related to why you're getting the error --- `Forcing.field_dependencies` can include auxiliary fields. A callback is a good way to integrate something and will not change your tendency kernel functions.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692:216,integrat,integrate,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1482922692,1,['integrat'],['integrate']
Integrability,`gravitational_acceleration` will always be a Number... We might have to have a derived `g'` for every interface.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338:103,interface,interface,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2954#issuecomment-1452910338,1,['interface'],['interface']
Integrability,"`on_architecture` for a model seems to be a little complicated because of FFTs that depend on very different plans for GPU and CPU. I am leaning towards leaving `on_architecture` only for some basics building blocks (fields, grids, some solvers) and not allow `on_architecture` for models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577:84,depend,depend,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490#issuecomment-1973863577,1,['depend'],['depend']
Integrability,"`src/Fields/show_fields.jl` was. ```; import Oceananigans: short_show. location_str(::Type{Face}) = ""Face""; location_str(::Type{Center}) = ""Center""; location_str(::Type{Nothing}) = ""⋅"". function show_size(field); Nx, Ny, Nz = size(field); return ""$Nx×$Ny×$Nz""; end. show_location(X, Y, Z) = ""($(location_str(X)), $(location_str(Y)), $(location_str(Z)))"". show_location(field::AbstractField{X, Y, Z}) where {X, Y, Z} = show_location(X, Y, Z). short_show(m::Missing) = ""$m"". short_show(field::AbstractField) = string(show_size(field), "" "", typeof(field).name.wrapper, "" located at "", show_location(field)); short_show(field::AveragedField) = string(show_size(field), "" "", ""AveragedField over dims=$(field.dims) located at "", show_location(field), "" of "", short_show(field.operand)); short_show(field::ComputedField) = string(show_size(field), "" "", ""ComputedField located at "", show_location(field), "" of "", short_show(field.operand)). Base.show(io::IO, field::AbstractField{X, Y, Z, A}) where {X, Y, Z, A} =; print(io, ""$(short_show(field))\n"",; ""├── architecture: $A\n"",; ""└── grid: $(short_show(field.grid))""). function Base.show(io::IO, field::Field); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""└── boundary conditions: $(short_show(field.boundary_conditions))""). return nothing; end. show_status(::Nothing) = ""nothing""; show_status(status) = ""time=$(status.time)"". function Base.show(io::IO, field::AveragedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── dims: $(field.dims)"", '\n',; ""├── operand: $(short_show(field.operand))"", '\n',; ""└── status: "", show_status(field.status)). return nothing; end. function Base.show(io::IO, field::ComputedField); print(io, ""$(short_show(field))"", '\n',; ""├── data: "", summary(field.data), '\n',; ""├── grid: $(short_show(field.grid))"", '\n',; ""├── operand: $(short_show(field.opera",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400:557,wrap,wrapper,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400,1,['wrap'],['wrapper']
Integrability,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:95,depend,dependency,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979,2,['depend'],"['dependencies', 'dependency']"
Integrability,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:146,integrat,integrating,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618,2,"['depend', 'integrat']","['depend', 'integrating']"
Integrability,a 20-year integration of the quarter degree simulation (in `validation/near_global_lat_lon/near_global_quarter_degree.jl`) using the following as a free surface:. ```; Δt = 10minutes # probably we can go to 10min or 15min?; CFL = 0.7. wave_speed = sqrt(g_Earth * grid.Lz); Δg = 1 / sqrt(1 / min_Δx(grid)^2 + 1 / min_Δy(grid)^2). @show substeps = Int(ceil(2 * Δt / (CFL / wave_speed * Δg))). free_surface = SplitExplicitFreeSurface(; substeps); ```. https://user-images.githubusercontent.com/33547697/217328677-9c737e8d-140b-4a9f-92b9-d42f5d364a3d.mp4,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576:10,integrat,integration,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1421225576,1,['integrat'],['integration']
Integrability,"ably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1.data, field2.data, field1.operand, field2.operand); end; ```. and the kernel. ```julia; @kernel function _compute_two!(data1, data2, operand1, operand2); i, j, k = @index(Global, NTuple); @inbounds data1[i, j, k] = operand1[i, j, k]; @inbounds data2[i, j, k] = operand2[i, j, k]; end; ```. There should also be a way to generalize to the nth case using some `ntuple` magic. (Note that we tried this with tracer kernels previously without obtaining any speed up, but overlapping `ComputedField`s could be a more promising application of this technique.). # Using `mapreduce` ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1907,depend,depend,1907,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['depend'],['depend']
Integrability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:2334,Message,Message,2334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['Message'],['Message']
Integrability,"ananigans.Fields: _set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl: _set!(ϕ, value); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:import Oceananigans.TimeSteppers: reset!; ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:function reset!(sefs::SplitExplicitFreeSurface); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:using Oceananigans.Fields: _set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:`set!(ϕ::AbstractField, data)` function exists.; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:set!(model, u=u₀, v=v₀, T=T₀); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: @apply_regionally _set!(ϕ, value); ./Models/Models.jl:import Oceananigans.TimeSteppers: reset!; ./Models/Models.jl:function reset!(model::AbstractModel); ./MultiRegion/multi_region_field.jl:im",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:3985,Integrat,Integrate,3985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,any slight dependency update results in most GPU tests failing... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770:11,depend,dependency,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2873#issuecomment-1399622770,1,['depend'],['dependency']
Integrability,"ary conditions (on the domain, not even considering immersed boundary conditions yet). My expectation was that the `GradientBoundaryCondition` would be applied to whichever tracer fields are passed along to the tendency functions:; > ; > ```; > - ∇_dot_qᶜ(i, j, k, grid, closure, diffusivities, val_tracer_index, closure_c, clock, model_fields, buoyancy); > - immersed_∇_dot_qᶜ(i, j, k, grid, closure_c, c_immersed_bc, closure, diffusivities, val_tracer_index, clock, model_fields); > ```; > ; > which in our case should be the sum of the perturbation and background tracer fields. Instead, it seems that our solutions are behaving as though the `GradientBoundaryCondition` is only being applied to the perturbation fluxes at the boundaries. Indeed, when we remove the background field from the gradient values passed to `GradientBoundaryCondition`, we get the behavior we are looking for. `GradientBoundaryCondition` isn't applied to the fields at all. The tracer gradient across the boundary is the quantity we need in order to compute fluxes across boundaries. Therefore when the immersed boundary flux is computed, we call. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L100-L101. Contrast this with the routine for `ValueBoundaryCondition` which is a bit more involved:. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L103-L107. These gradients are then used to compute the flux, for example. https://github.com/CliMA/Oceananigans.jl/blob/738d1724e5128502efe5579dd210fc17aacb9089/src/ImmersedBoundaries/immersed_boundary_condition.jl#L117-L122. > Instead, it seems that our solutions are behaving as though the GradientBoundaryCondition is only being applied to the perturbation fluxes at the boundaries. I don't know exactly what it means for a gradient to be applied to the field. Can you please clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563:1729,rout,routine,1729,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207696563,1,['rout'],['routine']
Integrability,as mentioned on slack here's @jlk9 's Enzyme integration test PR https://github.com/CliMA/Oceananigans.jl/pull/3480. We should check that the tuple doesn't also break that (or try to find the correct mutually happy solution like maybe vararg type),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039:45,integrat,integration,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3477#issuecomment-1944736039,1,['integrat'],['integration']
Integrability,"atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1395,synchroniz,synchronize,1395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronize']
Integrability,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1342,integrat,integrated,1342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939,4,['integrat'],['integrated']
Integrability,"ation); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:import Oceananigans.Fields: set!; ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl: set!(model; kwargs...); ./Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:function set!(model::NonhydrostaticModel; enforce_incompressibility=true, kwargs...); ./Models/ShallowWaterModels/set_shallow_water_model.jl:import Oceananigans.Fields: set!; ./Models/ShallowWaterModels/set_shallow_water_model.jl:function set!(model::ShallowWaterModel; kwargs...); ./Models/ShallowWaterModels/shallow_water_model.jl: set!(bathymetry_field, bathymetry); ./Models/HydrostaticFreeSurfaceModels/matrix_implicit_free_surface_solver.jl: set!(η, reshape(storage, solver.problem_size...)); ./Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl: @apply_regionally set!(free_surface.η, free_surface.state.η̅); ./Models/HydrostaticFreeSurfaceModels/distributed_split_explicit_free_surface.jl:""""""Integrate z at locations `location` and set! `height`` with the result""""""; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:import Oceananigans.Fields: set!; ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl: set!(model; kwargs...); ./Models/HydrostaticFreeSurfaceModels/set_hydrostatic_free_surface_model.jl:function set!(model::HydrostaticFreeSurfaceModel; kwargs...); ./MultiRegion/multi_region_field.jl:import Oceananigans.Fields: set!, compute!, compute_at!, validate_field_data, validate_boundary_conditions; ./Oceananigans.jl: interior, set!, compute!, regrid!, location,; ./OutputReaders/field_time_series.jl:import Oceananigans.Fields: Field, set!, interior, indices; ./OutputReaders/field_time_series.jl: set!(time_series, path, name); ./OutputReaders/field_time_series.jl:##### set!; ./OutputReaders/field_time_series.jl:function set!(time_series::InMemoryFieldTimeSeries, path::String, name::String); ./OutputReaders/field_time_series.jl: set!(time_series[n], field_n); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021:9595,Integrat,Integrate,9595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3010#issuecomment-1480344021,1,['Integrat'],['Integrate']
Integrability,"bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=10.0, max_change=1.1, max_Δt=1minute,cell_advection_timescale = accurate_cell_advection_timescale). start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=wizard, stop_time=40minutes, iteration_interval=10,; progress=progress_message); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586:2970,message,message,2970,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863722586,1,['message'],['message']
Integrability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:78,depend,depending,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['depend'],['depending']
Integrability,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1688,integrat,integrated,1688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678,4,['integrat'],['integrated']
Integrability,"but, @tomchor, I'd be definitely more than happy if you'd made these changes since they are trivial and need not be discussed or what not ;). (just saying in response to your protocol concerns..!). thanks for reviewing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988:175,protocol,protocol,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988,1,['protocol'],['protocol']
Integrability,"casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (semi-Lagrangian vertical coordinate that follows high-pass filtered fast motions only and is restored to a target grid on a relatively short time scale). Other formulations, including classical sigma coordinates and quasi-Lagrangian methods that involve grid warping severe enough to require remapping, may fail unless we improve our method for calculating the horizontal pressure gradient force. In particular, the method we use now is essentially finite difference and requires a vertical coordinate that exactly or ""almost"" coincides with a geopotential surface. Finite volume treatment of the pressure gradient force is discussed by. * [Lin (1997)](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=AKlxv5lyqCcAAAAA:iRV8loXCjnioqxfxVDYQQX7oESyUjXPRF7KEZvYk7TCc_fRLhuiy0oGuza5KOGu9ucP63ZPbgCUI5sY) in the context of an atmospheric model with an effectively linear equation of state; * [Shchepetkin and McWilliams (2003)](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2001JC001047) which implements a high-order method for evaluating a contour integral around momentum elements for computing the pressure gradient force; * [Adcroft et al (2008)](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=97k7TULeY9QAAAAA:_fsnUYOj7nBHPzGZXSO7jG31LMu4qlvJce8lsyof9jQPeICA4CFlsHA6KhH-81xRBiYoiMxElQ) that utilizes a crucial ""analytical integration"" step valid for for a nonlinear equation of state that can be written in a ""simplified"" form, which avoids the relatively more expensive numerical integration of part of the contour (and is more accurate); * [Engwirda et al (2017)](https://www.sciencedirect.com/science/article/pii/S1463500317300665?casa_token=egcQ20_UnnAAAAAA:WuCxxWYCfVpuL8-mrbSLJriY1z9W1TbiQNirtaJ9ZeIoIZkpOWbsod7AY7kLhxy8vcl5GfzcTw) using high-order numerical integration techniques for nonlinear equations of state",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041:2089,integrat,integration,2089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-847224041,6,['integrat'],['integration']
Integrability,"ce, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!)})(::Field{Center, Center, Face, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}}}}}, ::Vararg{Any, N} where N; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/8wtKq/src/CUDAKernels.jl:194; [11] calculate_interior_tendency_contributions!(tendencies::NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, GPU, OffsetArrays.OffsetArray{Float32, 3, CUDA.CuArray{Float32, 3}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, Float32, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:20630,depend,dependencies,20630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['depend'],['dependencies']
Integrability,"cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1643,depend,dependency,1643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['depend'],['dependency']
Integrability,"ch aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2Z",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1533,depend,depend,1533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['depend'],['depend']
Integrability,"cision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::Nothing, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:95; [16] launch!; @ /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:79 [inlined]; [17] regrid!(a::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:12303,depend,dependencies,12303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"ck?. Same! Runs again no complaining :). ```julia; julia> using Oceananigans. julia> grid; 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Bounded y ∈ [0.0, 2.0] regularly spaced with Δy=2.0; └── Flat z. julia> model = HydrostaticFreeSurfaceModel(grid=grid, free_surface = ImplicitFreeSurface()); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Bounded, Flat} on CPU with 1×1×0 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> simulation = Simulation(model, Δt=1.0, stop_iteration=2); Simulation{typename(HydrostaticFreeSurfaceModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0; ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── stop_time_exceeded => typename(Callback); │ ├── stop_iteration_exceeded => typename(Callback); │ ├── wall_time_limit_exceeded => typename(Callback); │ └── nan_checker => typename(Callback); ├── Output writers: typename(OrderedCollections.OrderedDict) with no entries; └── Diagnostics: typename(OrderedCollections.OrderedDict) with no entries. julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (198.852 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.013 minutes).; [ Info: Simulation is stopping. Model iteration 2 has hit or exceeded simulation stop iteration 2.; ```. > Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). yeah!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166:4005,message,message,4005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023672166,1,['message'],['message']
Integrability,closing this as we are moving fwd with a compat entry that will render this message useless.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967:76,message,message,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182#issuecomment-1637677967,1,['message'],['message']
Integrability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1547,depend,depends,1547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['depend'],['depends']
Integrability,"d to use `print` for an application other than the one in #2098. Then this PR creates work for us in the future. We can't really predict whether that will occur (but it could come up in the context of log-file creation... ?). I think the purpose of `print` is to remove ""decorations"" and ""Julia-specific details"", rather than important numerical information such as whether the WENO5 coefficients are grid-stretching-dependent:. ```julia; help?> print; search: print println printstyled sprint isprint prevind parentindices precision. print([io::IO], xs...). Write to io (or to the default output stream stdout if io is not given) a canonical; (un-decorated) text representation. The representation used by print includes minimal; formatting and tries to avoid Julia-specific details. print falls back to calling show, so most types should just define show. Define print if; your type has a separate ""plain"" representation. For example, show displays strings with; quotes, and print displays strings without quotes. string returns the output of print as a string. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> print(""Hello World!""); Hello World!; julia> io = IOBuffer();. julia> print(io, ""Hello"", ' ', :World!). julia> String(take!(io)); ""Hello World!""; ```. Here, it looks like `print` returns the ""base name"" of the advection scheme's type, eg similar to `summary(scheme) = string(typeof(scheme))`, but throwing away type parameter information:. ```julia; help?> summary; search: summary MethodSummary. summary(io::IO, x); str = summary(x). Print to a stream io, or return a string str, giving a brief description of a value. By; default returns string(typeof(x)), e.g. Int64. For arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}. Examples; ≡≡≡≡≡≡≡≡≡≡. julia> summary(1); ""Int64"". julia> summary(zeros(2)); ""2-element Vector{Float64}""; ```. @navidcy suggested `string(typeof(string).name.wrapper)` which seems to do the job of removing type parameter information from a type's string?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328:1936,wrap,wrapper,1936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986784328,1,['wrap'],['wrapper']
Integrability,de/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:/glade/u/apps/casper/23.10/opt/wrappers/bin:/glade/u/apps/casper/23.10/opt/utils/bin:/glade/u/home/knudsenl/.local/bin:/usr/lib/mit/bin:/opt/pbs/bin:/glade/u/apps/casper/23.10/opt/view/bin:/usr/local/bin:/usr/bin:/sbin:/bin:/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin; NCAR_LDFLAGS_INTEL_ONEAPI_COMPILERS = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/lib; MODULESHOME = /glade/u/apps/casper/23.10/spack/opt/spack/lmod/8.7.24/gcc/7.5.0/m4jx/lmod/lmod; PKG_CONFIG_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:14262,wrap,wrappers,14262,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:155,depend,dependency,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,1,['depend'],['dependency']
Integrability,"ditions.gpu__fill_bottom_and_top_halo!)})(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:218; [6] launch!(::GPU, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /glade/work/tomasc/.julia/packages/Oceananigans/0tK7e/src/Utils/kernel_launching.jl:95; [7] fill_bottom_and_top_halo!(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ::Symbol, ::Tuple{Int64, Int64}, ::Tuple{Face, Center, Center}, ::GPU, ::CUDAKernels.CudaEvent, ::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261:2535,depend,dependencies,2535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310844261,1,['depend'],['dependencies']
Integrability,"drostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1245,depend,depend,1245,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depend']
Integrability,"dvantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:1281,integrat,integrate,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['integrat'],['integrate']
Integrability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1671,depend,depend,1671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,['depend'],['depend']
Integrability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1523,depend,depend,1523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,10,['depend'],"['depend', 'dependent', 'depends']"
Integrability,"e.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Bool, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/OC.jl/src/Utils/kernel_launching.jl:103; [15] calculate_interior_tendency_contributions!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Col",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:14775,depend,dependencies,14775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"eananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is using. * I think the `README.md` could be clearer and the scripts could have better names (eg which script runs the benchmark versus which script sets up the model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1526,depend,dependency,1526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,8,['depend'],"['dependencies', 'dependency']"
Integrability,"ecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels ~/.julia/packages/CUDAKernels/3IKLV/src/CUDAKernels.jl:283; [14] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Models.NonhydrostaticModels.calculate_Gu!), ::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353:12822,depend,dependencies,12822,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025#issuecomment-1481807353,1,['depend'],['dependencies']
Integrability,"el clock time:"", mct,; "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll,; "", next_actuation_time: "", nat, "", first_actuation_time: "", fat, "", actuation: "", actuation, "", timestep: "", timestep). # @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim), "", model clock time:"", mct,; # "", window: "", window, "", u-avg: "", res, "", window_start_time: "", wd, "", window_start_iteration: "", ws, "", previous_collection_time:"", pc, "", fetch_operand: "", fo, "", interval: "", interval, "", collecting: "", cll); end; # progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). return simulation; end. function next_actuation_time(sch::AveragedTimeInterval); t₀ = sch.first_actuation_time; N = sch.actuations; T = sch.interval; return t₀ + (N + 1) * T; end. if isfile(""timeavg.nc""); rm(""timeavg.nc""); println(""File 'timeavg.nc' was successfully removed.""); else; println(""File 'timeavg.nc' does not exist.""); end; # run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 4 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s). δt = .01 # progress message interval and output saving interval; # Run a simulation that saves data to a checkpoint. simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; # N = iteration(simulation); # checkpoint = ""test_iteration$N.jld2""; # simulation = test_simulation(T2, Δt, δt, false); # run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); # Plots.savefig(""ln.png""); ln; close(ds); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645:2947,message,message,2947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717#issuecomment-2295024645,1,['message'],['message']
Integrability,"es and nonlinear; > diffusivities depend on the velocity and tracer fields, in general. We; > currently handle this only during time-stepping --- there is no guarantee,; > for example, that the diffusivities or ghost cell values are consistent; > with the velocity field if the velocity field is set by the function set!; > (in fact, the diffusivities are *always* inconsistent with the current; > velocity field due to the fact that they are calculated *prior* to taking; > a time-step). If we want to guarantee such a consistency, we can develop; > the concept of a model ""state"" and apply it to both ocean and atmospheric; > models (eg a function update_state!(model), or something similar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:1437,wrap,wraps,1437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['wrap'],['wraps']
Integrability,"ever we tilt the domain and need to use `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)` (`ĝ` being a unit vector). So we could end up with a case where the vertical direction is implicitly defined as being tilted 45 degrees (by means of `Buoyancy`), but for `ScalarDiffusivity` `Vertical` will still mean the `z` direction, which is confusing. Furthermore, the default option for buoyancy would be called `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=Vertical())`, which is not helpful. ### Option 2. Second option is to change the notation to what I proposed here: `XYDirection` etc., which avoids this inconsistency. The downside is that it doesn't play well with terms like `VerticallyImplicit` anymore. Something we either would have to live with, or we'd need to change those terms as well (something like `ZImplicit` isn't wrong, but it's not what people generally call it). ### Option 3. We could also keep the names `Vertical` etc., but change the interface of `Buoyancy` so that it doesn't implicitly define that the vertical direction is. So instead of having the interface be. `buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=ĝ)`. it would be something like. `buoyancy = Buoyancy(model=BuoyancyTracer(), direction_antiparallel_to_gravity=ĝ)`. which is equally correct and doesn't assume that ""vertical"" is connected to the direction of gravity. The issue here is that the name `direction_antiparallel_to_gravity` is super long. ### Option 4. @simone-silvestri raised an interesting point that these aren't just ""directions"" they are also different formulations. In light of this, it might make sense to not do (2). That way we'd leave `ZDirection` in `Grids`, and define `VerticalFormulation`, `HorizontalFormulation` and `ThreeDimenionalFormulation` in `TurbulenceClosures`. Since these latter aren't ""directions"" anymore, there wouldn't be an overlap with `ZDirection` (which literally indicates only a direction). Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915:1963,interface,interface,1963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266#issuecomment-1049975915,4,['interface'],['interface']
Integrability,"ey can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact multiple model components at the same time. This has cropped up in `HydrostaticFreeSurfaceModel` where `gravitational_acceleration` can be specified separately in the buoyancy model and the free surface model. Dealing with global physical parameters is the purpose of the [`CLIMAParameters`](https://github.com/CliMA/CLIMAParameters.jl) package so we may need to brainstorm about how to use that package in this context...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:1625,wrap,wrapper,1625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['wrap'],['wrapper']
Integrability,"field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to creating the possibility for nice pseudo-animations via `UnicodePlots.jl`). I'm not 100% sure how to do this; one places to start could be https://github.com/ronisbr/TextUserInterfaces.jl. Any work on any of these ideas could be useful! I'd be happy to Skype to talk more and clarify any questions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:4000,message,messages,4000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,3,['message'],"['message', 'messages']"
Integrability,"g to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper support for systems of coupled nonlinear boundary conditions, etc). It's a good discussion to have regardless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:1051,interface,interface,1051,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,10,['interface'],"['interface', 'interfaces']"
Integrability,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1912,depend,depends,1912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,2,['depend'],['depends']
Integrability,"great Ryan - hope we can collaborate on this. There is a growing group of; people using and developing oceananigans and it would be good to link in; with xgcm. John. On Wed, Feb 10, 2021 at 5:03 PM Ryan Abernathey <notifications@github.com>; wrote:. > Hi folks. I just saw this issue. We are very glad that you're working to; > support interoperability btw oceananigans and xgcm! 🎉 We'd love to help; > however we can.; >; > Ideally you would not have to really do much here other than use CF; > conventions in your netCDF output and things would ""just work."" That's the; > beauty of standards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If y",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:336,interoperab,interoperability,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['interoperab'],['interoperability']
Integrability,"hat `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1447,depend,depends,1447,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,1,['depend'],['depends']
Integrability,"he face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:1237,depend,dependent,1237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['depend'],['dependent']
Integrability,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:215,wrap,wrapped,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588,2,['wrap'],['wrapped']
Integrability,"https://github.com/MikeInnes/Requires.jl ?. On Fri, Jun 14, 2019 at 10:47 AM Ali Ramadhan <notifications@github.com>; wrote:. > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?; >; > Mainly I think we can get all the same benefits by maintaining a single; > unified and tidy repository with sub-modules. I don't see Oceananigans as a; > complex project yet, we're barely at 2,500 lines of code (minus turbulence; > closure operators which aren't integrated yet).; >; > I can see reasons for having a separate repository for examples and; > tutorials if there are enough of them, but I don't see e.g. the output; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:492,integrat,integrated,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,1,['integrat'],['integrated']
Integrability,"ies the maximum number of workers connected to in parallel at a host. Defaults to 10. • shell: specifies the type of shell to which ssh connects on the workers.; • shell=:posix: a POSIX-compatible Unix/Linux shell (sh, ksh, bash, dash, zsh, etc.). The default.; • shell=:csh: a Unix C shell (csh, tcsh).; • shell=:wincmd: Microsoft Windows cmd.exe. • dir: specifies the working directory on the workers. Defaults to the host's current directory (as found by pwd()). • enable_threaded_blas: if true then BLAS will run on multiple threads in added processes. Default is false. • exename: name of the julia executable. Defaults to ""$(Sys.BINDIR)/julia"" or ""$(Sys.BINDIR)/julia-debug"" as the case may be. It is; recommended that a common Julia version is used on all remote machines because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4065,message,message,4065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['message']
Integrability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2318,interface,interface,2318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['interface'],['interface']
Integrability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:2094,interface,interface,2094,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['interface'],['interface']
Integrability,"in/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2578/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2578/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. </div></div><div class=""JobLogComponent__Footer pt2"" style=""box-sizing: border-box; display: flex; padding-top: 10px; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:6074,wrap,wrappers,6074,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,1,['wrap'],['wrappers']
Integrability,"in` is. Taking a `RectilinearGrid` and `zspacing` at the `Center` as an example. ---. ### Current behavior for `RectilinearGrid`. Without immersed boundaries, this is pretty straightforward. The call to `zspacings()` dispatches to . https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Grids/rectilinear_grid.jl#L477-L478. which directly accesses the `grid`'s `Δzᵃᵃᶜ` property. The call to `zspacing()` goes through some metaprogramming [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L247-L269) but ultimately also directly accesses the `grid`'s `Δzᵃᵃᶜ` property here:. https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/Operators/spacings_and_areas_and_volumes.jl#L104-L112. ---. ### Current behavior for `ImmersedBoundaryGrid`. For the same grid wrapped around an `ImmersedBoundaryGrid` on `main`, when calling `zspacings()` we get the error at the top comment (`MethodError: no method matching`; which this PR aims to fix). The call to `zspacing()` works the same way as with `RectilinearGrid`, with the exception of an extra dispatch [here](https://github.com/CliMA/Oceananigans.jl/blob/56fc69bcb08623424afe25e39ae616c29208095e/src/ImmersedBoundaries/immersed_grid_metrics.jl#L16-L31). ---. ### Summary of the PR as of this post. This PR is originally trying to fix the issue with `zspacings(::IBG)` simply by adding. ```julia; zspacings(grid::IBG, args...; kwargs...) = zspacings(grid.underlying_grid, args...; kwargs...); ```. If I understand correctly, @glwagner's point is that this is wrong in cases where cells have a fraction of ""wet"" volume and a fraction of ""immersed solid"" volume. (For now the two such cases in sight are `PartialCellBottom` and `CutCellBottom` (for which there's open PR https://github.com/CliMA/Oceananigans.jl/pull/3146).). Again, if I understand correctly, the simple solution would be to red",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041:1052,wrap,wrapped,1052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-1636851041,2,['wrap'],['wrapped']
Integrability,"ind the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1226,interface,interface,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,2,['interface'],['interface']
Integrability,"ions on #1241 (and proposed as a solution there). Specifically, abstraction operations that failed to compile due to a recursive call to `identity` now compile, because we use different identity functions. The compiler doesn't complain and compiles these objects. This includes operators like `u - v + w` as demonstrated in my example. This hack doesn't allow us to execute arbitrarily complex abstract operations on the GPU. I don't think we can guarantee execution of arbitrary code in general. In this case, there are other issues that compiler might encounter that are not related to recursive calls to `identity`. We identified two additional issues on https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['wrap'],['wrapper']
Integrability,"ive this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple model types it makes more sense and would simplify the `Model` type by moving out output writers and diagnostics. I still think we don't need a new type and can simply define a new function like; ```julia; run_model!(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); ```; which just needs `time_step!` to be defined. > Nice work with the test cases @ali-ramadhan! No objections to merging from me, but I think we should have a discussion (in person or in a separate issue) about ways to separate aspects of the model that make it an atmosphere vs. an ocean model from things that make it a compressible vs. incompressible model. Thanks! Hmmm, that's a good point that currently the `IncompressibleModel` is really more of an `OceanModel` as evidence by the `surface_waves` functionality and the `SeawaterBuoyancy` default",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:2278,wrap,wraps,2278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['wrap'],['wraps']
Integrability,"l/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined]; │ [12] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:419 [inlined]; │ [13] macro expansion; │ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1615,synchroniz,synchronization,1615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"lDiffusivities/catke_vertical_diffusivity.jl:285; [2] macro expansion at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:264; [3] gpu_compute_CATKE_diffusivities! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:95; [4] gpu_compute_CATKE_diffusivities! at ./none:0. ┌ Error: Exception while generating log record in module Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities at /home/alir/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:230; │ exception =; │ KernelException: exception thrown during kernel execution on device NVIDIA GeForce RTX 4090; │ Stacktrace:; │ [1] check_exceptions(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/compiler/exceptions.jl:39; │ [2] synchronize(stream::CUDA.CuStream; blocking::Bool, spin::Bool); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:207; │ [3] synchronize (repeats 2 times); │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/synchronization.jl:194 [inlined]; │ [4] (::CUDA.var""#1125#1126""{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, Int64, Vector{Float64}, Int64, Int64})(); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:535; │ [5] #context!#990; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:168 [inlined]; │ [6] context!; │ @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/state.jl:163 [inlined]; │ [7] unsafe_copyto!(dest::CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}, doffs::Int64, src::Vector{Float64}, soffs::Int64, n::Int64); │ @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:531; │ [8] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:489 [inlined]; │ [9] copyto!; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:493 [inlined]; │ [10] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:406 [inlined]; │ [11] CuArray; │ @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:410 [inlined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837:1509,synchroniz,synchronization,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2441915837,1,['synchroniz'],['synchronization']
Integrability,"las.so: symbol cublasLt_for_cublas_DDD version libcublasLt.so.11 not defined in file libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1241,wrap,wrappers,1241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
Integrability,"ld not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a project of our scale we'd want to help and contribute to the packages we use. We definitely want to stick with NetCDF as it's the _de facto_ standard in the climate, atmospheric, and ocean sciences. A discussion might be helpful down the line. With faster IO I think we're happy now and we're still figuring how to do IO long-term. > My feeling is that if you want to write NetCDF files through the HDF API that it will be more work, though I never tried.; > ; > Regarding NetCDF.jl & NCDatasets.jl, I feel that the statements in the OP that NetCDF.jl is not being maintained and that NCDatasets.jl grew out of bugs not being fixed is are a bit of a misrepresentation.; > ; > For installations and dependency reduction, hopefully the new HDF5 release, which will for the first time support cross compilation, will lead to HDF5.jl switching to BinaryBuilder, which will allow NetCDF.jl to do the same. Also with the Clang.jl improvements we can regenerate the bindings. I still hope that NetCDFand NCDatasets will be able to share more code in the future, and be mainly about exposing different user facing APIs. Thanks for the feedback! My thinking was the same, why use HDF5.jl when NetCDF.jl and NCDatasets.jl exist since we want NetCDF output in the end. Sorry if I misrepresented the two packages, it was just what I gleaned by skimming a few issues and PRs. Will definitely keep a look out for new HDF5 releases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:2875,depend,dependency,2875,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['depend'],['dependency']
Integrability,"lem is generic and cannot be solved in general for arbitrary time steps. Here's a few thoughts:. - Reading about [Kahan summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) makes it clear that we simply cannot avoid errors if we would like to add a small floating point number (the time step) to a very large number (the model time). . - I think the issue with the time-step is whether or not we can compute the RHS of the pressure Poisson equation accurately --- which is `div(u') / Δt`, where `u' = u + Δt * Gu` is the predictor velocity and `div` is the divergence. This is interesting, because I could not figure out why we would ever find large `div(u')` with small `Δt` even in this MWE. But now I realize that because of the status of the immersed Poisson solver, the velocity along the boundary is divergent, strongly so. So, `div(u')` is large along the boundary. And when we divide by `Δt` we get something huge. The magnitude of `div(u')` also somehow seems to depend on the time step (as does the magnitude of the spurious circulation). The correct solution to this case remains at rest of course. (An aside is that this problem _could_ be avoided by separately computing the hydrostatic pressure, and then using a special horizontal gradient operators that avoid computing a hydrostatic pressure gradient across an immersed boundary. However, this would only be correct for no-flux boundary conditions on buoyancy on side walls). Anyways, apparently because of this issue with the immersed pressure solver, it seems that `div(u')` is large (because `div(u)` is large) even when `Δt = O(1e-14)`... - As a result of all of this I am confused about whether this MWE is actually reliable for debugging the issue. I guess we should expect to see problems simply when `Δt = O(eps)` because this is when `div(u') / Δt` cannot be reliably computed, I think. This leads to a fairly simple criteria for the time step that's compatible with the pressure correction. But as noted in t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136:1031,depend,depend,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606#issuecomment-2153020136,2,['depend'],['depend']
Integrability,"libcublasLt.so.11 with link time reference; ```. and. ```; Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-5/clima/oceananigans/test/test_hydrostatic_free_surface_models.jl:197; Test threw exception; Expression: time_step_hydrostatic_model_works(grid; free_surface); CUBLASError: the GPU program failed to execute (code 13, CUBLAS_STATUS_EXECUTION_FAILED); Stacktrace:; [1] throw_api_error(res::CUDA.CUBLAS.cublasStatus_t); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:11; [2] macro expansion; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/libcublas.jl:24 [inlined]; [3] cublasDnrm2_v2(handle::Ptr{CUDA.CUBLAS.cublasContext}, n::Int64, x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, incx::Int64, result::Base.RefValue{Float64}); @ CUDA.CUBLAS ~/.julia-10861/packages/CUDA/q3GG0/lib/utils/call.jl:26; [4] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:168 [inlined]; [5] nrm2; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/wrappers.jl:173 [inlined]; [6] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:108 [inlined]; [7] norm; @ ~/.julia-10861/packages/CUDA/q3GG0/lib/cublas/linalg.jl:107 [inlined]; [8] cg_iterator!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Pl::Oceananigans.Solvers.SparseInversePreconditioner{CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}}; abstol::Float64, reltol::Float64, maxiter::Int64, statevars::IterativeSolvers.CGStateVariables{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, initially_zero::Bool); @ IterativeSolvers ~/.julia-10861/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [9] cg!(x::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abstol::Float64, reltol::Float64, maxiter::Int64, log::Bool, statevars::IterativeSolvers.CGStateVariables{Float64, Cu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526:1326,wrap,wrappers,1326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1489524526,1,['wrap'],['wrappers']
Integrability,"looks really cool - nice work!; On Apr 4, 2022, 11:13 AM -0700, Gregory L. Wagner ***@***.***>, wrote:; > Here's a video from the sediment_entrainment.jl validation case:; > https://user-images.githubusercontent.com/15271942/161605652-7e1596b0-f76e-4076-902f-6b4e7c78cfae.mp4; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684:402,Message,Message,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1087890684,1,['Message'],['Message']
Integrability,"lots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]; &nbsp; | [2] run(::Cmd; wait::Bool) at ./process.jl:440; &nbsp; | [3] run(::Cmd) at process.jl:438; &nbsp; | [4] (::var""#1#2"")(::Cmd) at none:4; &nbsp; | [5] (::MPI.var""#8#9""{var""#1#2""})(::String) at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [6] (::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}})() at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:79; &nbsp; | [7] withenv(::MPICH_jll.var""#8#9""{MPI.var""#8#9""{var""#1#2""}}, ::Pair{String,String}, ::Vararg{Pair{String,String},N} where N) at env.jl:161; &nbsp; | [8] mpiexec(::MPI.var""#8#9""{var""#1#2""}; adjust_PATH::Bool, adjust_LIBPATH::Bool) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:78; &nbsp; | [9] mpiexec(::Function) at /storage7/buildkite-agent/.julia-2556/packages/MPICH_jll/ekpo2/src/wrappers/x86_64-linux-gnu-libgfortran4.jl:61; &nbsp; | [10] mpiexec(::var""#1#2"") at /storage7/buildkite-agent/.julia-2556/packages/MPI/b7MVG/src/environment.jl:25; &nbsp; | [11] top-level scope at none:4; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:2418,wrap,wrappers,2418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,['wrap'],['wrappers']
Integrability,"m::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 903 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_yᵃᶠᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 903 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 31 overdub; 911 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _left_biased_interpolate_xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31932,contract,contract,31932,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"mage"" src=""https://user-images.githubusercontent.com/15271942/163682350-9c0e83e4-48c2-488d-8a2a-67c1c896faf8.png"">. Since I had to dig deep into the immersed boundary implementation, I made a few more long-needed changes:. * Finally, we directly serialize `ImmersedBoundaryGrid`; * I changed `ImmersedBoundaryGrid.grid` (eminently confusing!) to `ImmersedBoundaryGrid.underlying_grid` to emphasize that there are ""two grids"" --- one underlying rectangular grid, and an overlying ""immersed grid""; * I cleaned up the output writers utilities a bit as well.; * I built out and hopefully clarified out ""node condition"" functionality. There are now a few functions:; - `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1145,interface,interfaces,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['interface'],['interfaces']
Integrability,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2772,protocol,protocols,2772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932,1,['protocol'],['protocols']
Integrability,"maximum iterations for this test are 20 with a 128 grid size, so I think we need to exclude the boundary condition possibility and look at other synchronization issues (maybe particular to the shallow water model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998:145,synchroniz,synchronization,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430067998,1,['synchroniz'],['synchronization']
Integrability,"model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1233,wrap,wraps,1233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['wrap'],['wraps']
Integrability,"mplement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [umax]) . xu2 = reshape(xu, grid.Nx, 1); zu2 = reshape(zu, 1, grid.Nz); u[bump.(xu2, 0, zu2)] .= NaN . u_plot = heatmap(xu, zu, u'; title = ""x velocity"", color = :balance, clims = (-ulim, ulim)). display(u_plot); ```. Note that the small time-step is near the gravity wave CFL for an explicit free surface on the specified grid. Somewhat larger time-steps are possible with an `ImplicitFreeSurface` but it seems the overall integration is slower that way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2423,integrat,integration,2423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,1,['integrat'],['integration']
Integrability,"mplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:1279,depend,depend,1279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938,1,['depend'],['depend']
Integrability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:2502,depend,depends,2502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['depend'],['depends']
Integrability,"nditions(computational_grid, top = FluxBoundaryCondition(Qᵘ)). @inline Qˢ(x, y, t, S, evaporation_rate) = - evaporation_rate * S; evaporation_rate = 1e-3 / hour; evaporation_bc = FluxBoundaryCondition(Qˢ, field_dependencies=:S, parameters=evaporation_rate); S_bcs = TracerBoundaryConditions(computational_grid, top=evaporation_bc); model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=1e-4),; buoyancy = buoyancy,; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (u=u_bcs, T=T_bcs, S=S_bcs)); # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise; # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); cfl=AdvectiveCFL(0.1); start_time = time_ns() # so we can print the total elapsed wall time; # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, cfl: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; cfl(model), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)); simulation = Simulation(model, Δt=0.1, stop_time=40minutes, iteration_interval=10,; progress=progress_message,parameters=(;cfl)); # Create a NamedTuple with eddy viscosity; eddy_viscosity = (νₑ = model.diffusivities.νₑ,); simulation.output_writers[:slices] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers, eddy_viscosity),; prefix = ""ocean_wind_mixing_and_convection2"",; field_slicer = FieldSlicer(j=Int(computational_grid.Ny/2)),; schedule = TimeInterval(1minute),; force = true); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351:2601,message,message,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741#issuecomment-863550351,1,['message'],['message']
Integrability,"nelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, typeof(Oceananigans.Fields.gpu__regrid!)})(::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::Nothing, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/YWLqR/src/CUDAKernels.jl:273; [15] launch!(::GPU, ::RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:10915,depend,dependencies,10915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['depend'],['dependencies']
Integrability,"nigans.AbstractOperations.ConditionalOperation{…}; call_kwargs::@Kwargs{…}); @ CUDA ./none:0; [18] (::CUDA.HostKernel{…})(::Function, ::Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:345; [19] macro expansion; @ ~/.julia/packages/CUDA/nbRJk/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/nbRJk/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/EZkix/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:637; [27] top-level scope; @ REPL[10]:1; [28] top-level scope; @ ~/.julia/packages/CUDA/nbRJk/src/initialization.jl:205; Some type information was truncated. Use `show(err)` to see complete types.; ```. That suggests that it's because the package dependencies on `main` were resolved with Julia v1.9.3. ```julia; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.3). Unexpected behavior may occur.; ```. This issue will be resolved when #3403 is merged.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372:9579,depend,dependencies,9579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1890373372,2,['depend'],['dependencies']
Integrability,"nst); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:4770; [6] (::Enzyme.Compiler.var""#201#202"")(B::Ptr{LLVM.API.LLVMOpaqueBuilder}, OrigCI::Ptr{LLVM.API.LLVMOpaqueValue}, gutils::Ptr{Nothing}, tape::Ptr{LLVM.API.LLVMOpaqueValue}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:6657; [7] EnzymeCreatePrimalAndGradient(logic::Enzyme.Logic, todiff::LLVM.Function, retType::Enzyme.API.CDIFFE_TYPE, constant_args::Vector{…}, TA::Enzyme.TypeAnalysis, returnValue::Bool, dretUsed::Bool, mode::Enzyme.API.CDerivativeMode, width::Int64, additionalArg::Ptr{…}, forceAnonymousTape::Bool, typeInfo::Enzyme.FnTypeInfo, uncacheable_args::Vector{…}, augmented::Ptr{…}, atomicAdd::Bool); @ Enzyme.API ~/Projects/Enzymantics/Enzyme.jl/src/api.jl:141; [8] enzyme!(job::GPUCompiler.CompilerJob{…}, mod::LLVM.Module, primalf::LLVM.Function, TT::Type, mode::Enzyme.API.CDerivativeMode, width::Int64, parallel::Bool, actualRetType::Type, wrap::Bool, modifiedBetween::Tuple{…}, returnPrimal::Bool, jlrules::Vector{…}, expectedTapeType::Type, loweredArgs::Set{…}, boxedArgs::Set{…}); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:7715; [9] codegen(output::Symbol, job::GPUCompiler.CompilerJob{…}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, toplevel::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9278; [10] codegen; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:8886 [inlined]; [11] _thunk(job::GPUCompiler.CompilerJob{Enzyme.Compiler.EnzymeTarget, Enzyme.Compiler.EnzymeCompilerParams}, postopt::Bool) (repeats 2 times); @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9830; [12] cached_compilation; @ Enzyme.Compiler ~/Projects/Enzymantics/Enzyme.jl/src/compiler.jl:9864 [inlined]; [13] (::Enzyme.Compiler.var""#474#475""{DataType, DataType, DataType, Enzyme.API.CDerivativeMode, Tuple{Bool, Bool, Bool}, Int64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259:1994,wrap,wrap,1994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3360#issuecomment-1791250259,1,['wrap'],['wrap']
Integrability,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1257,synchroniz,synchronize,1257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,4,['synchroniz'],['synchronize']
Integrability,"ocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1006,message,messages,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['message'],['messages']
Integrability,oh @francispoulin I now saw your message!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592:33,message,message,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592,1,['message'],['message']
Integrability,"oh now I saw that the secondary hidden commit message talks about ""a bug...""; can you reproduce the bug here? I mean, can you tell me how to reproduce the bug because I don't know exactly what you are talking about... (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504:46,message,message,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023542504,1,['message'],['message']
Integrability,"oh sorry, I just saw your reply... ; indeed the problem was with CUDA... I fixed it!. (I removed my question though... just putting this here in case the messages seem strange for the git-archaeologists of the next century.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992:154,message,messages,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638#issuecomment-839420992,1,['message'],['messages']
Integrability,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1529,interface,interface,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943,4,['interface'],['interface']
Integrability,or at least we could try following that route (it seems like there were some problems also with that implementation),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834:40,rout,route,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2251239834,1,['rout'],['route']
Integrability,"ordering requirements are necessary for filling corner halos. ; This is done by `Periodic` boundary conditions in non-distributed simulations.; Additionally, since communication boundary conditions can be asynchronous, distributed (and multi-region) BCS need to be filled last. To remove order requirements we would need to fill the halo for flux, value, and gradient also in the corners.; I thought that might be a good idea but we hit a problem when having an `AbstractArray` boundary condition because we would need to construct the associated `OffsetArray`. . This can be prevented by wrapping the array in a `Field` and filling the halo regions but it seems like a heavy requirement to do it, and generally, a large API change that we might want to think about a little more. In #3338 I fixed the problem by separating out communicating boundary conditions which wasn't that complicated and maintained the current logic. . Maybe in the future, we might want to eliminate the order requirement though. So we can keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174:589,wrap,wrapping,589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3342#issuecomment-1765302174,1,['wrap'],['wrapping']
Integrability,"ore generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor so that. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L176. becomes. ```julia; filepath = joinpath(dir, filename) ; update_schedule!(schedule, filepath); ```. Make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:1518,interface,interface,1518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['interface'],['interface']
Integrability,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_Δ, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_Δ, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2718,protocol,protocols,2718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326,1,['protocol'],['protocols']
Integrability,"r constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5259,message,message,5259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['message'],['message']
Integrability,r/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib/pkgconfig:/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:15985,message,message,15985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['message'],['message']
Integrability,"rection to being fully three-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:1485,depend,depend,1485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,2,['depend'],['depend']
Integrability,"red buoyancy frequency) should be calculated using the local thermal expansion coefficient and haline contraction coefficient (the analytical derivatives of the equation of state with respect to temperature and salinity at constant depth) --- This is (apparently) a more accurate approximation to the buoyancy gradient than calculating the buoyancy gradient with finite differences of buoyancy at different vertical levels. But this means that all equations of state should define functions that return these coefficients. In addition, we will supply a function to calculated the buoyancy frequency squared (I'm currently calling it `N2`). 3. For Boussinesq equations of state, we do not require the non-static components of pressure as input; instead we use the geopotential depth (corresponding to the use of hydrostatic pressure, `ρ₀ g depth`, to calculate compressive / thermobaric effects on density). At the moment we thus only require `-z` as an input --- though we may need to generalize the buoyancy implementation in the future if for some reason calculating the 'geopoential depth' requires more information (like free surface elevation). Luckily, this is a small change that just requires changing the function arguments to `buoyancy_perturbation`; etc. 4. The name `buoyancy_perturbation` is ok. It is actually potentially confusing, since ""buoyancy"" in ordinary usage is *already* associated explicitly with density anomalies --- rather than static, typically constant or z-dependent components of the density profile. So I think calling this function simply `buoyancy` might be better. On the other hand, we probably want to use `model.buoyancy` to refer to the model field that holds buoyancy-related parameters. Because of that we may want to stick with `buoyancy_perturbation`. Any ideas / alternative suggestions? An alternative is to perform a translation in the kernel functions; aka use `buoyancy_params` in the function signature of kernel(s) that call the function `buoyancy`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557:1786,depend,dependent,1786,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412#issuecomment-532995557,1,['depend'],['dependent']
Integrability,"riodic, Flat} on CPU with 3×3×0 halo; ├── operand: Reducing sum! over dims 1 of 256×256×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 1×256×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1); ├── grid: 256×256×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,); ├── status: time=0.0; └── data: 1×262×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1×-2:259×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:3220,depend,depend,3220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643,1,['depend'],['depend']
Integrability,"rom a slack conversation... I’ll try to clarify what we found for @francispoulin and @tomchor, if I understand correctly what was happening. I think @tomchor was. 1. Initializing a velocity field using set!(model, …); 2. Constructing a computed field ∂z_u = ComputedField(∂z(model.velocities.u)); 3. Evaluating the computed field via compute!(∂z_u); 4. Plotting ∂z_u and noticing that it’s wrong on boundaries. The reason why ∂z_u is wrong on boundaries is because the vertical derivative of u is calcaluated with a second-order difference that spans the boundary, and thus depends on “halo points” that are outside the physical domain. In Oceananigans, we use halo points to enforce Periodic, Value and Gradient boundary conditions, and will eventually use them for parallelization. If ∂z_u were calculated during a simulation, the halo points of u would be filled. However, in this case ∂z_u was evaluated before invoking run!As a result, the halo points of u were not filled, and thus ∂z_u was wrong on boundaries.; One fix for this mentioned by @alir is to fill the halo points “manually” by calling fill_halo_regions(u, CPU()) after invoking `set!`. This will work provided that u does not have function boundary conditions. If the boundary conditions of u depend on other model fields or the simulation time, this will fail. The code that fills halo regions is here: https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Models/IncompressibleModels/update_incompressible_model_state.jl#L15-L16. The “real” fix for this (a more generic solution that doesn’t require magical incantations in user scripts), however, is to fill_halo_regions! within set!. In fact, an even better solution is to call update_state!(model) at the end of set!. This way nonlinear diffusivities and hydrostatic pressure are also correct. We have also discussed projecting the velocity field onto an incompressible field within set!. We could make all these changes in one PR perhaps…",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131:1270,depend,depend,1270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1252#issuecomment-739528131,1,['depend'],['depend']
Integrability,"s (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the implementer of the BGC model has to perform the substepping inside `update_biogeochemical_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl#L49. Possibly we can go further and define an interface that does the substepping automatically though. I think that an effort like this would be good not to go so far, and first test ideas in a ""minimal"" implementation that simply uses `update_biogeochemical_state!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:2321,interface,interface,2321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['interface'],['interface']
Integrability,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m⁻¹; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:2490,message,message,2490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166,1,['message'],['message']
Integrability,"s).; ERROR: LoadError: BoundsError: attempt to access 56×56×56 OffsetArray(::Array{Float64, 3}, -2:53, -2:53, -2:53) with eltype Float64 with indices -2:53×-2:53×-2:53 at index [54, 49, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64, Int64}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:420 [inlined]; [4] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/field.jl:399 [inlined]; [5] getindex; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Utils/sum_of_arrays.jl:23 [inlined]; [6] _interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:148 [inlined]; [7] interpolate; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Fields/interpolate.jl:197 [inlined]; [8] advect_particle; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:83 [inlined]; [9] macro expansion; @ ~/Documents/IdealizedOceanWorlds.jl/OceananigansMemeoryIssue.jl/dev/Oceananigans/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:145 [inlined]; [10] cpu__advect_particles!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; ...; ```. I do not see why viscosity/Coriolis/buoyancy is required for shear instability. Anyway, I found another way to reproduce the error on CPU, while keeping `CFL = 10`, is to introduce a small perturbation to the initial velocity field:; ```Julia; function initial_u(x::R, y::R, z::R) where {R<:Real}; ϵ = 1e-7; return (max_velocity / Lx) * y + ϵ * max_velocity * sin(6π * x / Lx); end; ```. The output error message is the same as the previous one, in which `CFL = 51`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135:2975,message,message,2975,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1773032135,2,['message'],['message']
Integrability,"so catching up with a past discussion on turbulence closure (#1277). I tried setting up a simulation with `closure = (AnisotropicMinimumDissipation(), ScalarDiffusivity(ν=κ,κ=κ))` but am getting errors with `no method matching south_ib_flux`. Could this be specific to immersed boundary or has the turbulence closure definition of the molecular values of kinematic viscosity and diffusivity changed since #1277?. Here's a question. Doing wall-resolved LES is a bit tricky here. In the way the code is written, the diffusivity for wall fluxes with value or gradient boundary condition is derived from the model closure. For closure tuples, the logical thing to do is to add all the diffusivities together to come up with the immersed flux. However, this means that to do wall resolved LES we have to solve a tricky problem which is how to specify that the LES diffusivity has a value of 0 on the boundary. The interface implemented here doesn't support that; when we write `ValueBoundaryCondition(0)` what that means is that we add fluxes to a tendency consistent with `ValueBoundaryCondition(0)`. (The alternative, which would essentially mean ""return `0` when the field is reconstructed on boundary faces"" requires feeding boundary conditions into the reconstruction operator used by the closure. Doing that would substantially complicate the code.) This means effectively that there's no way to set the LES diffusivity to 0 on an immersed boundary. Even if there were a way to ensure this, it's also inconvenient to have to specify boundary conditions on the LES diffusivities... An alternative approach might attach a diffusivity / viscosity to the immersed boundary condition. Then the closure is ignored when calculating the immersed flux and the ""boundary diffusivity"" is used instead. This has some convenience downsides (ie diffusivity values have to be passed both to the closure _and_ the boundary condition), but would at least produce correct results in a straightforward way. I won't be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166:979,interface,interface,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1107321166,1,['interface'],['interface']
Integrability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2362,integrat,integrate,2362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['integrat'],['integrate']
Integrability,"some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia -t n` where `n` is the number of threads to use) until a GPU version is up and running.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1742,wrap,wrapper,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,2,['wrap'],['wrapper']
Integrability,spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/netcdf/4.9.2/oneapi/2023.2.1/gfig/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi:1;/glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/bin:2;/glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin:2;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/bin:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin/intel64:1;/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/bin:1;/glade/u/apps/casper/23.10/opt/wrappers/bin:1;/glade/u/apps/casper/23.10/opt/utils/bin:1;/glade/u/home/knudsenl/.local/bin:1;/usr/lib/mit/bin:1;/opt/pbs/bin:1;/glade/u/apps/casper/23.10/opt/view/bin:1;/usr/local/bin:3;/usr/bin:3;/sbin:2;/bin:3;/glade/u/apps/casper/23.10/spack/opt/spack/llvm/14.0.6/gcc/7.5.0/arf7/bin:1; __LMOD_REF_COUNT_NCAR_LDFLAGS_CUDA64 = /glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:1; NCAR_LDFLAGS_UCX = /glade/u/apps/casper/23.10/spack/opt/spack/ucx/1.14.1/gcc/7.5.0/vf2h/lib; __LMOD_REF_COUNT_ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards:1; ACL_BOARD_VENDOR_PATH = /opt/Intel/OpenCLFPGA/oneAPI/Boards; __LMOD_REF_COUNT_NLSPATH = /glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin/locale/%l_%t/%N:1; JAVA_HOME = /usr/lib64/jvm/java-11-openjdk-11; INSTALLPATH_ROOT = /glade/u/apps/casper/default/spack/opt/spack; __LMOD_REF_COUNT_LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:3850,wrap,wrappers,3850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['wrap'],['wrappers']
Integrability,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1192,depend,depend,1192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457,3,['depend'],"['depend', 'dependent']"
Integrability,"sure - I was able to repro the error by using the basic example on the `KernelAbstractions` quick start page:. https://juliagpu.github.io/KernelAbstractions.jl/dev/quickstart/. ```. using KernelAbstractions. @kernel function mul2_kernel(A); I = @index(Global); A[I] = 2 * A[I]; end. dev = CPU(); A = ones(1024, 1024); ev = mul2_kernel(dev, 64)(A, ndrange=size(A)); synchronize(dev); all(A .== 2.0). ```. this is the error. ![ka_err](https://github.com/CliMA/Oceananigans.jl/assets/16384103/4fe91c2a-e7c9-4fb5-b328-353d921d6a6b). the author of the `KernelAbstractions` library has responded to this issue here and thinks it's the fault of the debugger:. https://github.com/JuliaGPU/KernelAbstractions.jl/issues/405. I'm not sure if that's helpful, but I have only experienced this issue with the `KernelAbstractions` library and not any other library. I've also opened an issue on the julia-vscode extension repo, but have not received a response yet:. https://github.com/julia-vscode/julia-vscode/issues/3349. please let me know if there's anything else I can try - thank you again for helping me with this issue",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600:365,synchroniz,synchronize,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171#issuecomment-1624346600,1,['synchroniz'],['synchronize']
Integrability,"sure with viscosity ν and tracer diffusivities κ for each tracer field in tracers. If a single κ is provided, it is applied to all tracers. Otherwise κ; must be a NamedTuple with values for every tracer individually. Arguments; ≡≡≡≡≡≡≡≡≡. • time_discretization: either ExplicitTimeDiscretization() (default) or VerticallyImplicitTimeDiscretization(). • formulation:; • HorizontalFormulation() for diffusivity applied in the horizontal direction(s); • VerticalFormulation() for diffusivity applied in the vertical direction,; • ThreeDimensionalFormulation() (default) for diffusivity applied isotropically to all directions. • FT: the float datatype (default: Float64). Keyword arguments; ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡. • ν: Viscosity. Number, AbstractArray, Field, or Function. • κ: Diffusivity. Number, AbstractArray, Field, Function, or NamedTuple of diffusivities with entries for each tracer. • discrete_form: Boolean; default: false. When prescribing the viscosities or diffusivities as functions, depending on the value of keyword argument discrete_form, the constructor expects:. • discrete_form = false (default): functions of the grid's native coordinates and time, e.g., (x, y, z, t) for a RectilinearGrid or (λ, φ, z, t) for a LatitudeLongitudeGrid. • discrete_form = true:; • with loc = (nothing, nothing, nothing) (default): functions of (i, j, k, grid, ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center().; • with loc = (ℓx, ℓy, ℓz) with ℓx, ℓy, and ℓz either Face() or Center(): functions of (i, j, k, grid). • parameters: NamedTuple with parameters used by the functions that compute viscosity and/or diffusivity; default: nothing. julia> using Oceananigans. julia> ScalarDiffusivity(ν=1000, κ=2000); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=1000.0, κ=2000.0). julia> const depth_scale = 100;. julia> @inline ν(x, y, z) = 1000 * exp(z / depth_scale); ν (generic function with 1 method). julia> ScalarDiffusivity(ν=ν); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=ν (generic functi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498:1551,depend,depending,1551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3667#issuecomment-2258700498,1,['depend'],['depending']
Integrability,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1076,depend,depend,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151,4,"['depend', 'inject']","['depend', 'injected']"
Integrability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2067,message,messages,2067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['message'],['messages']
Integrability,"tagging the wrong Navid…. ___________________________________________; Multidisciplinary Composer | Media Alchemist | Artist-Researcher; Associate Director, Topological Media Lab; Research Associate: Matralab, Milieux, HEXAGRAM, LASG; navidnavab.com <http://navidnavab.com> | 514.432.6633; ----------------------------------------------------------------------------. On Wed, Feb 14, 2024 at 12:47 AM Navid C. Constantinou <; ***@***.***> wrote:. > Thanks @navid <https://github.com/navid> for your suggestions above. I; > will incorporate them in subsequent commits.; >; > You can just click the button next to them and they are committed!; > Screenshot.2024-02-14.at.07.46.47.png (view on web); > <https://github.com/CliMA/Oceananigans.jl/assets/7112768/34363045-e8b1-4776-8436-a551babaa02e>; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1943122887>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDTZNCXD3DWZHODH2M3JLYTRFXFAVCNFSM6AAAAAA5S3QE4CVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSNBTGEZDEOBYG4>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984:1172,Message,Message,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1944385984,1,['Message'],['Message']
Integrability,"tandards.; >; > Unfortunately, CF conventions don't quite provide the right vocabulary to; > describe the curvilinear geometry of staggered grid models compactly (see; > cf-convention/discuss#5; > <https://github.com/cf-convention/discuss/issues/5>). In the meantime,; > every modeling center seems to have their own preference for how to encode; > this (e.g. comodo conventions; > <https://web.archive.org/web/20160417032300/http://pycomodo.forge.imag.fr/norm.html>; > [now offline] used by ROMS and NEMO, S-grid; > <https://github.com/sgrid/sgrid>, mosaics; > <https://extranet.gfdl.noaa.gov/~vb/talks/grids-short.pdf> from GFDL).; >; > With xgcm, we decided to use the Comodo conventions (rather than invent; > yet another new convention). In retrospect, this was maybe the wrong; > choice, since the pycomodo project seems to have totally disappeared. 🤦; > However, if you put the right metadata; > <https://xgcm.readthedocs.io/en/latest/grids.html#detecting-axes-from-dataset-attributes>; > in your attributes, xgcm should be able to figure out your grid.; >; > Whatever you do, please try your best to squeeze your data into existing; > standard file formats and metadata conventions.; > Don't invent something new. MITgcm did this with the mds data format and; > it has been endless headaches for our community. I don't know what JLD2 is,; > but it sounds like you could be going down that route...; >; > If you have any questions, please ask! I'll try to respond.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777066134>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXRYPNOI5TLPGVKV3DS6L7EJANCNFSM4XBBPGJA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535:1982,rout,route,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-777140535,1,['rout'],['route']
Integrability,thanks. And presumably a similar change needs to be done in the original script to include `IncompressibleModel`. That I think I can find and do. The last thing I can think of is where to define the function before there is a dispatch that occurs depending on the model.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343:247,depend,depending,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-762968343,1,['depend'],['depending']
Integrability,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1985,depend,depend,1985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861,2,['depend'],['depend']
Integrability,"the bug because I don't know exactly what you are talking about...; > ; > (there is a chance you may need to delete the dowloaded `.jld2` file to force DataDeps to download it again... perhaps that's your issue -- I'm not sure). The bug manifests when executing the following code snippet over the REPL:; ```; using Oceananigans; using DataDeps; cs32_4 = DataDep(""cubed_sphere_32_grid_with_4_halos"",; ""Conformal cubed sphere grid with 32×32 cells on each face and 4 halos on each side"",; ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/main/cubed_sphere_grids/cs32_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2"",; ""fbe684cb560c95ecae627b23784e449aa083a1e6e029dcda32cbfecfc0e26721""); DataDeps.register(cs32_4); grid_filepath = datadep""cubed_sphere_32_grid_with_4_halos/cubed_sphere_32_grid_with_4_halos.jld2""; cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); cs_grid_MITgcm = ConformalCubedSphereGrid(grid_filepath;; Nz = 1,; z = (-1, 0),; panel_halo = (4, 4, 1),; radius = 6370e3); ```; The complete error message is; ```; ERROR: KeyError: key ""panel1"" not found; Stacktrace:; [1] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/groups.jl:101; [2] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 ~/.julia/packages/JLD2/VWinU/src/JLD2.jl:494; [3] conformal_cubed_sphere_panel(filepath::String, architecture::CPU, FT::Type; panel::Int64, Nz::Int64, z::Tuple{…}, topology::Tuple{…}, radius::Float64, halo::Tuple{…}, rotation::Nothing); @ Oceananigans.Grids /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cs-grid-metrics/src/Grids/orthogonal_spherical_shell_grid.jl:807; [4] construct_regionally(::Int64, ::Function, ::String, ::Vararg{Any}; kwargs::@Kwargs{Nz::MultiRegionObject{…}, z::Tuple{…}, panel::Oceananigans.Utils.Iterate{…}, topology::Tuple{…}, halo::Tuple{…}, radius::Float64}); @ Oceananigans",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954:1246,message,message,1246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2023704954,1,['message'],['message']
Integrability,"the offender is this line ; https://github.com/CliMA/Oceananigans.jl/blob/17e6fc045a32fcbd685737878ccf9638197c7b50/src/ImmersedBoundaries/grid_fitted_bottom.jl#L75. `MultiRegionGrid` is created by wrapping around an `ImmersedBoundaryGrid` where the letter are constructed with `construct_regionally(construct_grid, args...)`; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L83; https://github.com/CliMA/Oceananigans.jl/blob/eb38eeade577eca5056b99ca8839ca6c674ae0e2/src/MultiRegion/multi_region_grid.jl#L110. `fill_halo_regions!` cannot be called within a regional `@apply_regionally` call, so we probably have to shift around the construction when there is an ImmersedBoundaryGrid. (I wonder how this test is passing on main). I see two solutions here:; 1) change the constructor of `MultiRegionGrid` to make sure that fill_halo is called outside, aka partition the immersed_boundary outside the `construct_regionally`, fill_halo and then build the immersed grid with an offsetarray (simple but probably worst long term); 2) Make `ImmersedBoundaryGrid` wrap around `MultiRegionGrid`(slightly more complex, maybe for another PR, but probably useful for the cubed sphere grid?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063:197,wrap,wrapping,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122#issuecomment-1603029063,4,['wrap'],"['wrap', 'wrapping']"
Integrability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:51,depend,depend,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,2,['depend'],"['depend', 'dependent']"
Integrability,"this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2377,integrat,integration,2377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['integrat'],['integration']
Integrability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2804,depend,depend,2804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['depend'],['depend']
Integrability,"this was the innovation that Alistair had when he was sorting out the; numerics of the cubed sphere out. One needs the vorticity at the corner. He; expressed it as a circulation integral snaking across three surfaces of the; cube, rather than differencing. I'm in full support. On Sun, Apr 30, 2023 at 11:25 AM Gregory L. Wagner ***@***.***>; wrote:. > Does it make sense to try to reconstruct vorticity in the same way? Ie; > have we tried reconstructing the circulation:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/98bcdde7ae679583ea88474ec0909469abccfc90/src/Operators/vorticity_operators.jl#L9; >; > and then computing vorticity by dividing by Azᶠᶜᶜ and Azᶜᶠᶜ?; >; > It makes a lot of sense to me that δx(Δy * u) + δy(Δx * v) is smoother; > than δx(Δy * u) + δy(Δx * v) / Azᶜᶜᶜ when the grid is strongly stretched.; >; > Maybe we should come up with test cases that have even more extreme; > stretching? It will be very very nice to have good properties on stretched; > grids for the cubed sphere.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529053452>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQRBF7RYUYWS3KH4NGDXDZ75XANCNFSM6AAAAAAXQNM76E>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646:1350,Message,Message,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1529054646,1,['Message'],['Message']
Integrability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2583,wrap,wrapper,2583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['wrap'],['wrapper']
Integrability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1346,message,messages,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['message'],['messages']
Integrability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:528,wrap,wrapping,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['wrap'],['wrapping']
Integrability,"ue to a finite time step. It's important to recognize that the dynamics of the _discrete_ linear equations are different than the continuous. When we have a smooth solution, such that our spatial discretization should approximate some exact smooth solution, we can test that refining the grid and time step leads to convergence to an exact solution. Moreover, we can estimate the time-scale of the dynamics using the time-scales of the smooth dynamics as a guide. An example is a resolved buoyancy oscillation: it has a timescale of roughly 1/N. This example is dominated by small amplitude (eg linear) noise at the grid scale. Therefore my initial time scale estimate of 1/N may not hold. Instead, we'd have to look at the discrete eigenvalues of the system at the very higheset wavenumbers (ie the Nyquist number 2pi / dx). We could then calculate the time-step that would be required to resolve these (completely unphysical) dynamics. I'm not sure what a lower bound on such spurious discrete dynamics might be. It could be far smaller than any physical time scale, ie as small as 1e-16, or smaller? Perhaps the evolution of grid scale noise also has to do with spatial resolution, so that could be another knob to vary. So if we want to investigate this further, we should conduct a systematic study of the dynamics of this grid-scale noise system affected by buoyancy, decreasing the time-step to zero. Or we can convince ourselves that non-noisy dynamics _are_ accurate --- eg by analyzing a system like the one we use for our ""internal wave"" dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_internal_wave_dynamics.jl. that test verifies that a wave packet in our code propagates at the correct group speed, for example. But one could dive much deeper into that example and test a wide variety of wave numbers. It depends whether you are interested in the grid-scale noise system, or whether you are interested in verifying that smooth resolved dynamics are correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423:2077,depend,depends,2077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1444451423,2,['depend'],['depends']
Integrability,"vection/upwind_biased_advective_fluxes.jl:98; [2] _advective_momentum_flux_Ww(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::Oceananigans.Fields.ZeroField, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); @ ~/software/New_Oceananigans/Oceananigans.jl/src/Advection/momentum_advection_operators.jl:16; ```. The function `_advective_momentum_flux_Ww(i, j, k, grid, scheme, W, w)` is called in `div_Uw`. Later on we see this:. ```; [6] div_Uw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ::WENO5, ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. Rewriting the error message makes it a bit clearer:. ```julia; div_Uw(::Int64, ::Int64, ::Int64, ; ::RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, ; ::WENO5, ; ::NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, ; ::OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}); ```. We thus see that the first four arguments are `i, j, k, grid`, the fifth argument is `WENO5`, the sixth argument is a named tuple of `ZeroField`s, and the seventh argument is an `OffsetArray`. The sixth argument --- `U` --- is a tuple of `ZeroField`s when the default value of `background_fields.velocities` is the advecting velocity field:. https://github.com/CliMA/Oceananigans.jl/blob/78f63ff9329b15ce20c33faed11e96ebf0dbc67d/src/Models/IncompressibleModels/velocity_and_tracer_tendencies.jl#L140. This PR helps the compiler realize that `div_Uw` called when `U` i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828:1120,message,message,1120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790#issuecomment-871449828,2,['message'],['message']
Integrability,"ving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ```; We don't need to be told `N` times how many threads Oceananigans is ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:1039,protocol,protocol,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,6,"['depend', 'protocol']","['dependencies', 'dependency', 'protocol']"
Integrability,"we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1201,interface,interface,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['interface'],['interface']
Integrability,"whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to the above, when we support ""open"" boundaries, I think we may actually want an ""Open"" topology that functions similar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:2023,interface,interface,2023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['interface'],['interface']
Integrability,"wicePrecision{Float64}, Base.Twice...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 _advective_momentum_flux_Uu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 overdub; 1363 0 @Oceananigans/src/Operators/difference_operators.jl 21 δxᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1372 0 @Oceananigans/src/Operators/difference_operators.jl 21 overdub; 1602 0 @Oceananigans/src/Operators/difference_operators.jl 20 δxᶜᵃᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1681 1681 @KernelAbstractions/src/compiler/contract.jl 18 mul_float_contract; 1681 0 @KernelAbstractions/src/compiler.jl 47 overdub; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 _advective_momentum_flux_Vu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 overdub; 1714 0 @Oceananigans/src/Operators/difference_operators.jl 23 δyᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1781 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 13 _advective_momentum_flux_Vv(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1781 0 @Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:38491,contract,contract,38491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846,1,['contract'],['contract']
Integrability,"yeah, if they are slow, the horizontal BCs for the barotropic velocities are included in the vertically integrated tendencies.; Not sure about eta",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886:104,integrat,integrated,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179221886,1,['integrat'],['integrated']
Integrability,"yeah, that interpolation operator is defined as ; ```; @inline ℑxᶜᵃᵃ(i, j, k, grid::AG{FT}, u) where FT = @inbounds FT(0.5) * (u[i, j, k] + u[i+1, j, k]); ```. so it assumes that the field to be interpolated is located at `Faces`. It should not be used on Centered fields.; I do not think we need fallbacks, the operators are not part of the public API and I am not sure we want them to be as they have to be wrapped around kernels",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362:409,wrap,wrapped,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2969#issuecomment-1466331362,1,['wrap'],['wrapped']
Integrability,"yep, makes sense and works. ; Suggestion: add some comments/explanations in https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/. Maybe another possibility is to always have the user interface present fields centered and only when going into calculations doing the decentering/staggering internally. That would keep the user away from internals and staggering conventions. Anyway thanks for the quick and useful reply !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236:206,interface,interface,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656#issuecomment-839722236,1,['interface'],['interface']
Integrability,"yes please!. On Mon, Mar 28, 2022 at 8:04 PM Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** approved this pull request.; >; > Bump minor version. Would also be sweet to see some of the global; > solutions!; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/2317#pullrequestreview-923878927>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQXBJN3S56JM4PSIOITVCJCIPANCNFSM5QCCJFGA>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >. -- ; ==========================================; Professor John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485:549,Message,Message,549,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1274241485,1,['Message'],['Message']
Integrability,"you cannot use `WENO(; order =5)` in the y-direction if you have only one grid point. ; In this case the script would have to change to ; ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)); 16×1×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×1×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.0625. julia> advection = FluxFormAdvection(WENO(order=5), nothing, WENO(order=5)). julia> model = NonhydrostaticModel(; grid, advection); ```; I think spitting out the error should be the correct behavior because we want to make sure that people know what scheme is begin used in the different directions, and correct the advection scheme accordingly. We can probably change the error message to be a bit more descriptive",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348:204,depend,dependency,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3732#issuecomment-2310601348,2,"['depend', 'message']","['dependency', 'message']"
Integrability,"~~I would try `u` because the behavior of eta could depend on whether you use explicit or implicit time-stepping.~~. Okay, I realized that you're using `ExplicitFreeSurface`. I think the comparison you want to make is to take an `euler` step with a NaN in `G-`, and check whether the NaN appears in the field where the NaN was inserted. You're checking `G-`, rather than the field itself. Since you're checking `G-` for NaNs, it doesn't appear for a couple more time-steps because the NaNs first appear in eta, and then get transferred to `Gn`, and _then_ get transferred to `G-` when `store_tendencies!` is called using `Gn` that has a NaN.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381:52,depend,depend,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2260#issuecomment-1046412381,1,['depend'],['depend']
Integrability,"~~Is there a way around the order of `includ`ing files so that this works? If not, it probably isn't necessary to force that the `particles` slot in models is taken by a `Nothing` or `LagrangianParticles` as it is now? So we could get rid of the particles dependency in models and change the order to `include` particles after models?~~. ~~The only thing I can think of is that if a user passes something other than particles it might give a confusing error.~~. ~~I think I found a use case for removing the typing of the particles slot and overloading the update functions too but I can't remember what it was now.~~. This won't work because particles need to already be defined for the timesteppers. My other solution would be to define a function `total_velocities` that is defined somewhere early on, and then define new methods for each model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779:256,depend,dependency,256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1490850779,1,['depend'],['dependency']
Integrability,"✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_CUC33l"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /gl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:4478,depend,dependency,4478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['depend'],['dependency']
Modifiability," 2, 2020, 5:41 PM Ali Ramadhan <notifications@github.com> wrote:. > This PR adds experimental support for rotating/tilting the gravity vector.; >; > I'm not even sure if it works properly but I'm opening a draft PR as it; > might be ready to be experimented with? I don't think we can have a; > non-zero gravity component along a periodic direction as the fluid just; > free falls along that dimension and the model blows up.; >; > But here's a plume rising with gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b5",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1089,refactor,refactor,1089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,1,['refactor'],['refactor']
Modifiability," A hydrostatic Boussinesq model would be super useful too of course. I think we should talk. We are working on a similar model using discontinuous Galerkin numerics over at [ClimateMachine.jl](https://github.com/CliMA/ClimateMachine.jl) and these projects would have overlapping goals. Nevertheless I would personally find it extremely useful to be able to run `Oceananigans.IncompressibleModel`s with a `HydrostaticPressureSolver` and `ExplicitFreeSurface` since I could use it to benchmark / compare with the DG functionality that I'm working on for `ClimateMachine`, and the relative advantages of high-order finite volume methods compared with DG may still be in question, at least for structured grids (meaning that an Oceananigans development effort is not a waste of time). Perhaps a zoom conversation on that topic is in order. I agree with the framework / level-of-difficulty that you've laid out for student projects!. As for deciding FourierFlows vs Oceananigans, that's up to you for sure and depends basically on whether you are okay staying with doubly-periodic systems (what FourierFlows currently supports) or whether you want to do problems with boundaries (what Oceananigans promises). FourierFlows is a nice tool for idealized problems and theoretical work (and you can run pretty large problems these days since it has GPU support); Oceananigans is evolving more towards a tool for ocean modeling that is capable of doing idealized problems, but flexible enough to use for large eddy simulation and realistic non-hydrostatic modeling, in bounded domains and hopefully irregular domains as well, eventually, using immersed boundaries. Switching between the two would be a dream... ! I'm afraid this is too futuristic for Oceananigans. It may be possible to build FV functionality into FourierFlows (which is generally more flexible than Oceananigans, but has fewer features for the specific problem of the nonhydrostatic Boussinesq equations), but that's not a small piece of work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226:1672,flexible,flexible,1672,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724302226,2,['flexible'],['flexible']
Modifiability," I understand point 4 completely. The ocean model also has the concept of a model ""state""; for example, ghost cell values and nonlinear diffusivities depend on the velocity and tracer fields, in general. Right. But I guess users don't have to worry about ghost cell values and nonlinear diffusivities as they'll get filled in or calculated as needed. But in JULES.jl, if you want to add a potential temperature perturbation and modify θ you need to modify both the density ρ and the ρθ field. [Example:](https://github.com/thabbott/JULES.jl/blob/beec6727eef83343dd1adac8834f1545994098e2/verification/dry_rising_thermal_bubble/dry_rising_thermal_bubble.jl#L91-L95). ```julia; θ = Θ[i, 1, k] / ρ[i, 1, k] + θ′(xC[i], 0, zC[k]); π = Π(i, 1, k, grid, gas, Θ). ρ[i, 1, k] = pₛ / (Rᵈ*θ) * π^(cᵥ/Rᵈ); Θ[i, 1, k] = ρ[i, 1, k] * θ; ```. From a user's perspective this is much more complicated than using Oceananigans' `set!` function. To further complicate things, how ρ is computed will change if you're running with entropy as a prognostic variable instead of potential temperature. > If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). This sounds like a good idea and would be of great benefit to users. > What does the jargon ""sounding"" mean?. Ah sorry I'm referring to [atmospheric soundings](https://en.wikipedia.org/wiki/Atmospheric_sounding). From talking to @thabbott apparently it's pretty common to initialize a model using observational data obtained from e.g. a weather balloon. Apparently some models get pretty fancy and construct a hydrostatic base state from the sounding to avoid transient acoustic waves when running the model. > I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. Hmmm, I wasn't super into the idea of a new `Simulation` type before but with multiple",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155:1429,variab,variable,1429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580555155,1,['variab'],['variable']
Modifiability," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1174,config,config,1174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['config'],['config']
Modifiability," c is a two-dimensional wave depending on an x wavenumber $\kappa$, a y wavenumber $\mathcal{l}$, and a time-dependent amplification factor $\xi(t)$, then; $c^n_{ij} = \xi^n \exp{(- \Im \kappa \cdot i \Delta x - \Im \mathcal{l} \cdot j \Delta y)}$. (because of overlap with the x-index $i$, I defined $\Im$ as the imaginary number $\Im = \sqrt{-1}$); Substituting this definition of $c$ and dividing through by $c^n_{ij}$ we get; $$\frac{\xi^{n+1} / \xi^n - 1}{\Delta t} = u \left(\frac{1 - \exp{(- \Im \kappa \Delta x)}}{\Delta x}\right) + v \left(\frac{1 - \exp{(- \Im \mathcal{l} \Delta y)}}{\\Delta y}\right)$$; we can make use of $\exp{\Im \theta} = \cos{\theta} + \Im \sin{\theta}$ and rewrite a bit:; $$\frac{\xi^{n+1}}{\xi^n} = 1 + \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} + \Im \sin{\kappa\Delta x}\right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} + \Im \sin{\mathcal{l} \Delta y} \right) \right]$$; Now, to ensure stability, the real part of $\xi^{n+1} / \xi^n$ should be bounded, so we have to ensure that; $$\left| \Re \left( \frac{\xi^{n+1}}{\xi^n} \right) \right| < 1$$; This yields; $$-2 < \Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 0$$; The right inequality does not limit $\Delta t$, but the left does:; $$\Delta t \cdot \left[ \frac{u}{\Delta x} \left( 1 - \cos{\kappa \Delta x} \right) + \frac{v}{\Delta y} \left( 1 - \cos{\mathcal{l} \Delta y} \right) \right] < 2$$; The worst-case scenario occurs when both cosines evaluate to -1, to hit this condition it is enough to have grid-scale noise, which has the maximum expressible wavenumber of $\kappa = \pi / \Delta x$. In this case we have; $$\Delta t \cdot \left( \frac{u}{\Delta x} + \frac{v}{\Delta y} \right)< 1$$; Since the direction is arbitrary you can substitute $u$ and $v$ with their absolute values and you get; $$\Delta t < \left( \frac{|u|}{\Delta x} + ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511:1139,rewrite,rewrite,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3037#issuecomment-1489468511,1,['rewrite'],['rewrite']
Modifiability," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:1950,extend,extend,1950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['extend'],['extend']
Modifiability," if we consider for now just a 1D problem with boundary point $\phi_b$ and interior points at $\phi_{b-1}$ etc. When we go to update the boundary point we have $\phi_b^n$ and $\phi_{b-1}^{n+1}$ and we want $\phi_b^{n+1}$. As per previous work we assume that the bulk speed is the same at both $b$ and $b-1$ but we don't have both the spatial and time derivatives of the $\phi$ interior at the same step so we first need to approximate the previous step as:. $\phi_{b-i}^n = \phi_{b-i}^{n+1}-\Delta t G^n_{b+1}$. We can then find the bulk velocity at timestep n as:. $U_b^n = -\frac{2\Delta x_{b-1}G^n_{b-1}}{\phi^n_b - \phi^{n+1}_{b-2} - \Delta t G^n _{b-2}}$. We then have all the information to step $\phi_b$ to:. $\phi_b^{n+1}=\phi_b^n-\frac{\Delta t}{\Delta x_b}U_b(\phi_b^n-\phi_{b-1}^{n+1} - \Delta t G^n_{b-1})$. This will require us to give the boundary condition both the tendencies and $\Delta t$, but this seems to be the easiest thing to change. I also think this is the only way we can get a physically sensible bulk speed where all of the components are calculated at the same timestep. I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it. Does this make sense to everyone? I also can't see an obvious way to get $\Delta t$ to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. Update:. I'm not sure if",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810:2112,extend,extend,2112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971616810,1,['extend'],['extend']
Modifiability," push!(Rit, deepcopy(interior(Ri, 1, 1, :))); push!(bt, deepcopy(interior(b, 1, 1, :))); push!(ut, deepcopy(interior(u, 1, 1, :))); push!(et, deepcopy(interior(e, 1, 1, :))); push!(κct, deepcopy(interior(κc, 1, 1, :))); push!(κut, deepcopy(interior(κu, 1, 1, :))). return nothing; end. t = 0:10minutes:simulation.stop_time; Nt = length(t). simulation.callbacks[:dc] = Callback(collect_data, SpecifiedTimes(t)). run!(simulation). fig = Figure(resolution=(800, 600)). axR0 = Axis(fig[1, 1], xlabel=""Ri⁻¹"", ylabel=""z (m)""); axe0 = Axis(fig[2, 1], xlabel=""e"", ylabel=""z (m)"", xticks=[1e-6, 2e-5]); axκ0 = Axis(fig[3, 1], xlabel=""κ"", ylabel=""z (m)"", xticks=[0.0, 2e-3, 4e-3]). axR = Axis(fig[1, 2], xlabel=""Time (hr)"", ylabel=""z (m)"", xaxisposition=:top); axe = Axis(fig[2, 2], ylabel=""z (m)""); axκ = Axis(fig[3, 2], xlabel=""Time (hr)"", ylabel=""z (m)""). hidexdecorations!(axe). hidespines!(axR0, :r, :t); hidespines!(axe0, :r, :t); hidespines!(axκ0, :r, :t). Prt = map((κu, κc) -> κu ./ κc, κut, κct). bzt = hcat(bt...)'; Rzt = hcat(Rit...)'; ezt = hcat(et...)'; κzt = hcat(κct...)'; Pzt = hcat(Prt...)'. zc = znodes(grid, Center()); zf = znodes(grid, Face()). for n = (7, 49, 24*4+1); @show tn = t[n] / hour; label = @sprintf(""t = %d hr"", tn); lines!(axR0, 1 ./ Rit[n], zf; label); ln = lines!(axe0, et[n], zc); lines!(axκ0, κct[n], zf, color = ln.color.val, label=""κᶜ""); lines!(axκ0, κut[n], zf, linestyle=:dash, color=ln.color.val, label=""κᵘ""); end. Legend(fig[2, 0], axR0); Legend(fig[3, 0], axκ0, merge=true). vlines!(axR0, 4, color=(:gray, 0.5), linewidth=4). cr = contourf!(axR, t ./ hour, zf, 1 ./ Rzt, levels = 0:10, colormap=:viridis)#, extendhigh=true, extendlow=true); Colorbar(fig[1, 3], cr, label=""Ri⁻¹""). cr = contourf!(axe, t ./ hour, zc, ezt, levels=10, colormap=:heat); Colorbar(fig[2, 3], cr, label=""E (m² s⁻²)""). cr = contourf!(axκ, t ./ hour, zf, κzt, levels=10, colormap=:solar); Colorbar(fig[3, 3], cr, label=""κᶜ (m² s⁻¹)""). colsize!(fig.layout, 1, Relative(0.2)). display(fig); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970:2692,extend,extendhigh,2692,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3090#issuecomment-1528811970,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability," well, complex, and I don't pretend to understand the nuances there, but in simple rectilinear geometries, I think it would be fairly easy to have an option to go between rigid-lid and linear free-surface in both `NonhydrostaticModel` and `HydrostaticModel`. Is this true? Would people want these options?. Yes, any solver for an implicit free surface can be generalized with some small code modifications to the rigid lid case. When using a _direct_ solve, there is negligible or actually zero difference in cost between an implicit free surface and rigid lid. When using an iterative solve, the rigid lid can be more expensive because the solution may not converge as quickly. I don't think a linear + porous free surface with a fixed grid is very useful in the non-hydrostatic model (in some respects the resulting model might be a worse approximation to any real ocean scenario). It can be done, but I don't think there is much benefit from a modeling perspective. With a breathing / moving grid that follows the surface the story might be a bit different. Having such an abstraction would enable some neat problems that are difficult to solve with any code. But for that someone would have to refactor the non hydrostatic model to use generalized vertical coordinates, and also develop a new pressure solver. This paper by Sullivan and McWilliams describe such a model for atmospheric simulations with a moving, weakly distorted lower boundary:. https://journals.ametsoc.org/view/journals/atsc/71/11/jas-d-14-0095.1.xml. In that paper the ""undistorted"" pressure solve is used a preconditioner for a fixed point iteration. We could do the same thing except with a conjugate gradient iteration (possibly slightly better than a fixed point iteration). It's possibly a nice project for someone interested in LES above or below weakly distorted boundaries. Note that this method probably won't work when the bathymetry is ""too big"", because the iterative solve may converge too slowly. cc @whitleyv .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514:1616,refactor,refactor,1616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882660514,2,['refactor'],['refactor']
Modifiability," … 0.00%; Time (median): 9.717 ms ┊ GC (median): 0.00%; Time (mean ± σ): 9.797 ms ± 271.120 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █ █ █ █ █; █▁█▁▁▁▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 9.61 ms Histogram: frequency by time 10.3 ms <. Memory estimate: 89.45 KiB, allocs estimate: 320. ```. on this branch:; ```julia ; julia> using NESAPOceananigans; julia> set_problem_size!(500, 500, 50). julia> trial1 = run_model_benchmark!(momentum_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(momentum_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(13.991 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 13.991 ms … 22.167 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 14.057 ms ┊ GC (median): 0.00%; Time (mean ± σ): 15.676 ms ± 3.629 ms ┊ GC (mean ± σ): 0.00% ± 0.00%. █; █▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁; 14 ms Histogram: frequency by time 22.2 ms <. Memory estimate: 487.70 KiB, allocs estimate: 766. julia> trial1 = run_model_benchmark!(tracer_kernel_test, GPU();; use_benchmarktools = true,; bathymetry = random_bathymetry()); trial1 = run_model_benchmark!(tracer_kernel_test, arch; use_benchmarktools = true, bottom_height = random_bathymetry()) = Trial(4.807 ms); BenchmarkTools.Trial: 5 samples with 1 evaluation.; Range (min … max): 4.807 ms … 5.457 ms ┊ GC (min … max): 0.00% … 0.00%; Time (median): 4.819 ms ┊ GC (median): 0.00%; Time (mean ± σ): 4.958 ms ± 281.609 μs ┊ GC (mean ± σ): 0.00% ± 0.00%. █▁ ▁ ▁; ██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁; 4.81 ms Histogram: frequency by time 5.46 ms <. Memory estimate: 88.53 KiB, allocs estimate: 261. ```; A test on the global ocean configuration (found in [prototype_omip_simulation.jl](https://github.com/CliMA/ClimaOcean.jl/blob/aacd2e19b81e35a3b220bd45aa6b5bcb98dc876d/prototype_omip_simulation/prototype_omip_simulation.jl) ) is incoming",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643:2789,config,configuration,2789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3658#issuecomment-2243530643,1,['config'],['configuration']
Modifiability,"""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha! I was testing locally with v1.9 but the docs use v1.8.5; Seems like from v1.9 onwards the package environment is inherited so we don't need to instantiate multiple times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:6210,inherit,inherit,6210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,3,['inherit'],"['inherit', 'inherited', 'inheriting']"
Modifiability,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1307,parameteriz,parameterizations,1307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['parameteriz'],['parameterizations']
Modifiability,"# Progress update. I decided to take a stab at the simplest case: triply-periodic on the CPU. Surprisingly I was able to get a distributed `IncompressibleModel` running just using multiple dispatch without having to modify any existing code, although a cleaner design might require a bit of refactoring. PR is still a work-in-progress so it's a bit messy, the purpose was to demonstrate a proof of concept. MPI.jl and PencilFFTs.jl are new dependencies but I haven't updated the Project.toml yet. So far this PR adds some new infrastructure:; 1. Distributed/multi-architectures (e.g. `MultiCPU`) that know about rank connectivity.; 2. Halo communication between ranks is done via multiple dispatch on a new `HaloCommunicationBC` type.; 3. A `DistributedFFTBasedPoissonSolver` for solving Poisson equations across ranks.; 4. A `DistributedModel` that creates local grids for each ranks, injects halo communication BCs, and passes the distributed pressure solver to a local `IncompressibleModel`. I also added some simple tests for multi architecture rank connectivity, local grid construction, injection of halo communication BCs, and halo communication (testing x, y, and z slab decompositions). Also added tests for the distributed Poisson solver ensuring the solution is divergence-free. Next step for testing would probably be to test that the code handles `Bounded` topologies correctly then add tests that reproduce the regression tests but on multiple ranks and ensure the output matches the regression output. ## Some notes. ### Domain decomposition. Domain decomposition is supported and tested in x, y, and z. But for `IncompressibleModel` z-decomposition won't work right now because vertical integrals are done inside GPU kernels (so we probably don't want to decompose in z). And PencilFFTs.jl supports decompositions in dimensions 2 and 3 (since dimension 1 FFTs are the fastest). As a result, right now Oceananigans.jl only supports slab decompositions in y although we should figure out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066:291,refactor,refactoring,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-775301066,1,['refactor'],['refactoring']
Modifiability,## try. Configuration problem:; bors.toml: not found,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702:8,Config,Configuration,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702,1,['Config'],['Configuration']
Modifiability,"(@simone-silvestri, until we implement the refactor and/or changes, what's the best way forward using v0.87.1?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026:43,refactor,refactor,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695628026,1,['refactor'],['refactor']
Modifiability,"**Can we use advection for mass evolution equation?**. Let me try and convince you that using advection for continuity makes sense. If I don't succeed then clearly I need to put more thought into it. The governing equation can be written in two forms; $$; \partial_t = -\partial_x (h u) - \partial_y (h v) = - \partial_x U - \partial_y V ; $$; If we were to solve this in terms of the velocities (u,v), then using advection is clearly a good idea as we are advecting h by the velocity. In the case of upwinding, we pick the direction based on the sign of u (or v). We are using the transports instead of velocities but it is very similar to the advection of a tracer $\nabla \cdot (u c)$ except that we use c = 1. Given that the physics is the same in both cases, I think we should be using the advection scheme for this term. . The evolution equations for h and c have a lot in common, which is helpful here. The one major difference is that h is an active tracer in the sense that it feeds back on the momentum. Even though that's the case, I don't think this should affect how we discretize the advection of h, even though it is disguesed with our use of the transport variable. If you agree with my reasoning I don't think we need to do anything different for the evolution of height equation, we might just need to have some new functions that account for this, which are essentially equivalent to c = 0. Maybe what you suggest is the way to proceed?. **High Order Finite Volume**. I agree that keeping things finite volume is a good idea, and that is how I would like to proceed. Good to know that IncompressibleModel won't generalize to higher order. I agree that the 4th-order pieces are there and just need to be assembled. The paper you cited above is very helpful but needs to be modified slightly as they present the method for a non-staggered grid, but ours is staggered. That is not problem, I just need to work through the details. Unless they have been done already?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924:1172,variab,variable,1172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744478924,2,['variab'],['variable']
Modifiability,", 2, 3...`.; * With `maxiter=100`, the problem is stable with `OpenBoundaryCondition` on west and east. At late times, the solver converges very quickly, in 1-5 iterations. I'd like to analyze the divergence more, but it seems that it is substantially higher with `FlatExtrapolationOpenBoundaryCondition`. I would also like to understand the convergence rate, which seems slower than with a prescribed outflow. From these results we see that `maxiter` should probably be set right now as a matter of practice. I think that even a handful of CG iterations is probably preferred to simply using the FFT solver naively with no CG iteration. There's also future work to understand the interaction of the solver with open boundary conditions. Finally I would like to point out that there is probably little to gain, from a computational point of view, in using the FFT-based solver with 100+ CG iterations. If we are using 100+ iterations, we might as well use a faster preconditioner. My script adapted from @ali-ramadhan's:. ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2); z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = prescribed_flow,; east = extrapolation_bc); #east = prescribed_flow). boundary_conditions = (; u=u_bcs); reduced_precision_grid = with_number_type(Float32, grid.underlying_grid); preconditioner = fft_poisson_s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426:1369,adapt,adapted,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426,2,['adapt'],['adapted']
Modifiability,"-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:1817,extend,extended,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['extend'],['extended']
Modifiability,".julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:112; [10] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:97; [11] run!(sim::Simulation{NonhydrostaticModel{…}, Float64, Float64, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}, OrderedCollections.OrderedDict{…}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:85; [12] top-level scope; @ ~/repos/Oceananigans.jl/sandbox/mwe.jl:31; [13] include(fname::String); @ Base.MainInclude ./client.jl:489; ```. So it's not as trivial as the single change I just made. From glancing at the code we at least have to modify `initialize_nc_file!()` to take a `grid` option as well:. https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/OutputWriters/netcdf_output_writer.jl#L625-L636. plus a couple of other things. Still pretty easy, but more work/time that I have right now. @iuryt feel free to jump in here and make these changes if you feel it's necessary, since creating a whole separate model can be a bit onerous and wastes precious GPU memory.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:3084,sandbox,sandbox,3084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['sandbox'],['sandbox']
Modifiability,"/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essenti",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7133,adapt,adapt,7133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,1,['adapt'],['adapt']
Modifiability,/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9maWVsZC5qbA==) | `79.76% <100.00%> (+3.85%)` | :arrow_up: |; | [src/TimeSteppers/TimeSteppers.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2348,parameteriz,parameterized,2348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) = prettytime(Δt); pretty_Δt(Δt::TimeStepWizard) = prettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1953,config,configurable,1953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['config'],['configurable']
Modifiability,"19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version = ""0.5.3+4"". [[OrderedCollections]]; git-tree-sha1 = ""4fa2ba51070ec13fcc7517db714445b4ab986bdf""; uuid = ""bac558e1-5e72-5ebc-8fee-abe8a469f55d""; version = ""1.4.0"". [[Parsers]]; deps = [""Dates""]; git-tree-sha1 = ""c8abc88faa3f7a3950832ac5d6e690881590d6dc""; uuid = ""69de0a69-1ddd-5017-9359-2bf0b02dc9f0""; version = ""1.1.0"". [[Penci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11562,Adapt,Adapt,11562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"1f90decc"". [[SparseArrays]]; deps = [""LinearAlgebra"", ""Random""]; uuid = ""2f01184e-e22b-5df5-ae63-d93ebab69eaf"". [[SpecialFunctions]]; deps = [""ChainRulesCore"", ""OpenSpecFun_jll""]; git-tree-sha1 = ""5919936c0e92cff40e57d0ddf0ceb667d42e5902""; uuid = ""276daf66-3868-5448-9aa4-cd146d93841b""; version = ""1.3.0"". [[Static]]; deps = [""IfElse""]; git-tree-sha1 = ""ddec5466a1d2d7e58adf9a427ba69763661aacf6""; uuid = ""aedffcd0-7271-4cad-89d0-dc628f76c6d3""; version = ""0.2.4"". [[StaticArrays]]; deps = [""LinearAlgebra"", ""Random"", ""Statistics""]; git-tree-sha1 = ""e8cd1b100d37f5b4cfd2c83f45becf61c762eaf7""; uuid = ""90137ffa-7385-5640-81b9-e52037218182""; version = ""1.1.1"". [[StaticPermutations]]; git-tree-sha1 = ""193c3daa18ff3e55c1dae66acb6a762c4a3bdb0b""; uuid = ""15972242-4b8f-49a0-b8a1-9ac0e7a1a45d""; version = ""0.3.0"". [[Statistics]]; deps = [""LinearAlgebra"", ""SparseArrays""]; uuid = ""10745b16-79ce-11e8-11f9-7d13ad32a3b2"". [[StructArrays]]; deps = [""Adapt"", ""DataAPI"", ""Tables""]; git-tree-sha1 = ""44b3afd37b17422a62aea25f04c1f7e09ce6b07f""; uuid = ""09ab397b-f2b6-538f-b94a-2f83cf4a842a""; version = ""0.5.1"". [[StructTypes]]; deps = [""Dates"", ""UUIDs""]; git-tree-sha1 = ""e36adc471280e8b346ea24c5c87ba0571204be7a""; uuid = ""856f2bd8-1eba-4b0a-8007-ebc267875bd4""; version = ""1.7.2"". [[TOML]]; deps = [""Dates""]; git-tree-sha1 = ""44aaac2d2aec4a850302f9aa69127c74f0c3787e""; uuid = ""fa267f1f-6049-4f14-aa54-33bafae1ed76""; version = ""1.0.3"". [[TableTraits]]; deps = [""IteratorInterfaceExtensions""]; git-tree-sha1 = ""c06b2f539df1c6efa794486abfb6ed2022561a39""; uuid = ""3783bdb8-4a98-5b6b-af9a-565f29a5fe9c""; version = ""1.0.1"". [[Tables]]; deps = [""DataAPI"", ""DataValueInterfaces"", ""IteratorInterfaceExtensions"", ""LinearAlgebra"", ""TableTraits"", ""Test""]; git-tree-sha1 = ""c9d2d262e9a327be1f35844df25fe4561d258dc9""; uuid = ""bd369af6-aec1-5ad0-b16a-f7cc5008161c""; version = ""1.4.2"". [[TaylorSeries]]; deps = [""InteractiveUtils"", ""LinearAlgebra"", ""Markdown"", ""Requires"", ""SparseArrays""]; git-tree-sha1 = ""66f4d1993bae49eeba21a1634",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:15966,Adapt,Adapt,15966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"2 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 259.679 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (319.597 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.116 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.121 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stoppi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:2473,variab,variably,2473,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"2, time: 2 seconds, wall time: 998.405 ms; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (-16387479425.34, 18491107419.68) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 997.956 ms; │ ├── max(u): (9.82e+04, 7.85e+04, 2.49e+03) m s⁻¹; │ ├── extrema(T): (-1654340357512160890046119936.00, 2003185335144995241362194432.00) ᵒC; └ └── max|η|: 2.34e+03 m; ```. so the temperature is blowing up. The problem persists even when we don't have an immersed boundary:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 229.227 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (290.636 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.441 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 1.446 seconds; │ ├── max(u): (7.77e-23, 4.67e-05, 1.18e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.18e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.348 seconds; │ ├── max(u): (1.04e-08, 9.33e-05, 2.36e-06) m s⁻¹; │ ├── extrema(T): (-456436497.24, 490120296.28) ᵒC; └ └── max|η|: 3.55e-06 m; [ Info: Simulation is stoppin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:4269,variab,variably,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"3x"" needed for RK3 to be superior. But that's just in theory. In practice we find that solutions become unstable at lower CFL, and caution warrants a bit of buffer. It seems like we usually use CFL=0.1-0.2 for AB2 but CFL=0.5-1 for RK3. So at the lower end for AB2, RK3 is indeed providing a decent speed up for time to solution. And I agree with you @ali-ramadhan that I have found in practice that I prefer RK3 for LES. There is more to the story --- RK3 also has superior stability properties for diffusion. Where there is some interesting room for further research is also to understand how much more stable RK3 might make a turbulence closure scheme like CATKE or k-epsilon. We do find that these can impose stricter time-step restrictions than advection, especially on grids with very fine vertical resolution near the surface. RK3 also has the crucial advantage that it is self-starting. This means we can change the time-step at will (without resolving this issue I guess) and we don't need tendencies to checkpoint. Also of course RK3 is actually 3rd order whereas QAB2 is first order. Note that the advantages of RK3 have historically not been useful for ocean simulations because at coarse (non-eddy-resolving) resolutions the momentum time-step is limited by Coriolis, not by CFL / advection. In that case a one-stage time-stepper might be preferred. > Out of curiousity, how much work is it to implement RK3 for HydrostaticFreeSurfaceModel?. It may be a research project to adapt the split-explicit free surface. It's little unclear because naively, we may be able to advance the split-explicit free surface each stage and therefore use the same algorithm we use for AB2. But there has been some work to implement an algorithm that resembles Le and Moin 1991 where the free surface is advanced to the end of the time-step, while baroclinic variables are advanced in stages. That would yield even more speed up. @simone-silvestri has thought about this a bit and might have more to add...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394:2482,adapt,adapt,2482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418061394,4,"['adapt', 'variab']","['adapt', 'variables']"
Modifiability,"5 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlined]; [23] invokelatest; @ ./essentials.jl:714 [inlined]; [24] print_res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7160,Adapt,Adapt,7160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,"6d7b675f75dd867b9f153685""; ---; > project_hash = ""bfbc7775b0a550569ac26abdec5f544ef80e881c""; 23c23; < git-tree-sha1 = ""76289dc51920fdc6e0013c872ba9551d54961c24""; ---; > git-tree-sha1 = ""02f731463748db57cc2ebfbd9fbc9ce8280d3433""; 25c25; < version = ""3.6.2""; ---; > version = ""3.7.1""; 37c37; < git-tree-sha1 = ""f83ec24f76d4c8f525099b2ac475fc098138ec31""; ---; > git-tree-sha1 = ""16267cf279190ca7c1b30d020758ced95db89cd0""; 39c39; < version = ""7.4.11""; ---; > version = ""7.5.1""; 93,94c93,94; < deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; < git-tree-sha1 = ""f062a48c26ae027f70c44f48f244862aec47bf99""; ---; > deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CUDA_Driver_jll"", ""CUDA_Runtime_Discovery"", ""CUDA_Runtime_jll"", ""Crayons"", ""DataFrames"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""KernelAbstractions"", ""LLVM"", ""LLVMLoopInfo"", ""LazyArtifacts"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""NVTX"", ""Preferences"", ""PrettyTables"", ""Printf"", ""Random"", ""Random123"", ""RandomNumbers"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""UnsafeAtomicsLLVM""]; > git-tree-sha1 = ""64461b0e9df3069248979113ce8ab6d11bd371cf""; 96,97c96; < version = ""5.0.0""; < weakdeps = [""SpecialFunctions""]; ---; > version = ""5.1.0""; 99a99; > ChainRulesCoreExt = ""ChainRulesCore""; 101a102,105; > [deps.CUDA.weakdeps]; > ChainRulesCore = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; > SpecialFunctions = ""276daf66-3868-5448-9aa4-cd146d93841b""; >; 104c108; < git-tree-sha1 = ""35a37bb72b35964f2895c12c687ae263b4ac170c""; ---; > git-tree-sha1 = ""1e42ef1bdb45487ff28de16182c0df4920181dc3""; 106c110; < version = ""0.6.0+3""; ---; > version = ""0.7.0+0""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:3036,Adapt,Adapt,3036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,2,['Adapt'],['Adapt']
Modifiability,"76d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d25087efb5615b5a207""; uuid = ""7057c7e9-c182-5462-911a-8362d720325c""; version = ""0.3.5"". [[ChainRulesCore]]; deps = [""Compat"", ""LinearAlgebra"", ""SparseArrays""]; git-tree-sha1 = ""5402b5674b3068ca570771c11da9a57bfa70acd4""; uuid = ""d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4""; version = ""0.9.39"". [[Compat]]; deps = [""Base64"", ""Dates"", ""DelimitedFiles"", ""Distributed"", ""InteractiveUtils"", ""LibGit2"", ""Libdl"", ""LinearAlgebra"", ""Markdown"", ""Mmap"", ""Pkg"", ""Printf"", ""REPL"", ""Random"", ""SHA"", ""Serialization"", ""SharedArrays"", ""Sockets"", ""SparseArrays"", ""Statistics"", ""Test"", ""UUIDs"", ""Unicode""]; git-tree-sha1 = ""ac4132ad78082518ec2037ae5770b6e796f7f956""; uuid = ""34da2185-b29b-5c13-b0c7-acf172513d20""; version = ""3.27.0"". [[CompilerSup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:1532,Adapt,Adapt,1532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,": Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4973,variab,variable,4973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,": ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:2826,Adapt,Adapt,2826,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['Adapt'],['Adapt']
Modifiability,"; Installed Missings ──────────────────── v1.2.0; Installed StringManipulation ────────── v0.3.4; Installed UnsafeAtomics ─────────────── v0.2.1; Installed SortingAlgorithms ─────────── v1.2.1; Installed Atomix ────────────────────── v0.1.0; Installed LLVM ──────────────────────── v8.0.0; Precompiling project...; ✓ LLVMLoopInfo; ✓ DataValueInterfaces; ✓ Reexport; ✓ IteratorInterfaceExtensions; ✓ LaTeXStrings; ✓ InvertedIndices; ✓ ExprTools; ✓ DataAPI; ✓ Requires; ✓ CompilerSupportLibraries_jll; ✓ OrderedCollections; ✓ Compat; ✓ AbstractFFTs; ✓ InlineStrings; ✓ Scratch; ✓ CEnum; ✓ StaticArraysCore; ✓ TableTraits; ✓ Missings; ✓ PooledArrays; ✓ BFloat16s; ✓ Preferences. ✓ Adapt; ✓ Statistics; ✓ SentinelArrays; ✓ Compat → CompatLinearAlgebraExt; ✓ Crayons; ✓ UnsafeAtomics; ✓ CUDA_Runtime_Discovery; ✓ PrecompileTools; ✓ JLLWrappers; ✓ Tables; ✓ RandomNumbers; ✓ Atomix; ✓ TimerOutputs; ✓ AbstractFFTs → AbstractFFTsTestExt; ✓ NVTX_jll; ✓ JuliaNVTXCallbacks_jll; ✓ MacroTools; ✓ LLVMExtra_jll; ✓ CUDA_Driver_jll; ✓ Random123; ✓ DataStructures; ✓ StringManipulation; ✓ FixedPointNumbers; ✓ SortingAlgorithms; ✗ CUDA_Runtime_jll; ✓ ColorTypes; ✓ LLVM; ✓ LLVM → BFloat16sExt; ✓ StaticArrays; ✓ Adapt → AdaptStaticArraysExt; ✓ StaticArrays → StaticArraysStatisticsExt; ✓ UnsafeAtomicsLLVM; ✓ Colors; ✓ GPUArraysCore; ✓ NVTX. ✓ GPUArrays; ✓ KernelAbstractions; ✓ PrettyTables; ✓ GPUCompiler; ✓ DataFrames; ✗ CUDA; 61 dependencies successfully precompiled in 190 seconds. 5 already precompiled. The following 1 direct dependency failed to precompile:. CUDA [052768ef-5323-5732-b1bb-66c8b64840ba]. Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_UQIv2i"".; [45592] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:3638,Adapt,Adapt,3638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,3,['Adapt'],"['Adapt', 'AdaptStaticArraysExt']"
Modifiability,"> 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). I quite like the current convention for specifying fluxes since (imho) it's more mathematically intuitive, so my vote goes to maintaining that convention if we can (although I agree that it makes it harder to apply it generally for immersed solids...). One way to do it would be to leave most of the heavy work for the user, which would have to specify fluxes in each of the immersed solid's interfaces separately. The user's script would look like what I did here:; https://github.com/CliMA/Oceananigans.jl/blob/faed0c4ac85409cb94811b0bdba2bbb7becf330a/sandbox/drag_test.jl#L25-L41. The downside is that this won't work for non-grid-fitted boundaries and requires more user-written code. The upside is that could (I think) re-use much of the inner-workings of the current BC implementation. > We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs. Not sure I understand this point. Do you mind clarifying @glwagner? By ""overhang"" do you mean that there's no fluid-to-the-bottom-immersed-boundary-to-the-top interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975:1053,sandbox,sandbox,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-1086345975,2,['sandbox'],['sandbox']
Modifiability,"> 2\. Climate Machine also has a shallow water [model](https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl). I don't know the details of what this does but I should probably learn how the two models will differ. I'm not 100% sure how its implemented but I think at the end it'd be great if both ClimateMachine and Oceananigans shallow water models used the same equation set, since we can then compare the numerics. We don't have the bandwidth to develop the ClimateMachine shallow water model, but possibly at the time the Oceananigans has a nice one we'll be motivated to flesh out ClimateMachine's model. I'm not sure about immersed boundaries --- does the method generalize in a simple way? I'm not sure whether a special treatment is required for the height field, compared to an ordinary velocity variable, or tracer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787:850,variab,variable,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787,1,['variab'],['variable']
Modifiability,"> > > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > > ; > > > ; > > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > > ; > > ; > > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt.; > ; > But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another. Makes sense. `advect_lagrangian_particles!` first before `dynamics` it is!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866:47,evolve,evolve,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874604866,1,['evolve'],['evolve']
Modifiability,"> > > Does it have to do with output? Do you know what the time-step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > > ; > > ; > > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there.; > ; > Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. Good point. > > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?; > ; > I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure. Yeah I see your point. I'll check `model.last_Δt` and report soon. I think it'll be good news if this is the culprit because it seems like we'd have fairly simple options to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352:1318,config,configuration,1318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103036352,2,['config'],['configuration']
Modifiability,"> > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > > ; > > ; > > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.; > ; > True true.; > ; > Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?. Because of the no-flux boundary condition? I think that's correct, ok to have. You could have a mixed layer at the top too!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063:390,parameteriz,parameterizations,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986931063,1,['parameteriz'],['parameterizations']
Modifiability,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:397,flexible,flexible,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399,2,['flexible'],['flexible']
Modifiability,"> > > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > > ; > > ; > > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.; > ; > I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time t before it is being advected to time t+Δt. But in that case, when a time-step is complete, the radius has been computed at time `t` but the particle position is updated to time `t + Δt`. This means that if the user asks for output, the two are inconsistent with one another.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919:45,evolve,evolve,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1874440919,1,['evolve'],['evolve']
Modifiability,"> > > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > > ; > > ; > > But I thought the whole idea is to be able to provide an `Array` for forcing.; > . `Field` is an abstract array. You should think of `Field` as a kind of `Array`. (We also want `CuArray` of course, and `SubArray`, `OffsetArray`, etc...). This code should work with anything for which `array[i, j, k]` is meaningful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941:123,adapt,adapts,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988819941,1,['adapt'],['adapts']
Modifiability,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:655,config,configuration,655,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['config'],['configuration']
Modifiability,"> > > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > > ; > > ; > > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.; > ; > Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?. Sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422:375,flexible,flexible,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088747422,2,['flexible'],['flexible']
Modifiability,"> > > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > > The other option to not use MPI variables is to hardcode the number of processors; > > ; > > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > > ; > > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.; > ; > Just to clarify, this is already possible, just by doing; > ```julia; > arch = Distributed(); > rank = arch.local_rank; > ```; > The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.; > . @iuryt this works already if you don't want to hardcore/import the MPI module. I would leave the validation case like this though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613:90,variab,variables,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895862613,2,['variab'],['variables']
Modifiability,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787,1,['refactor'],['refactor']
Modifiability,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:454,layers,layers,454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['layers'],['layers']
Modifiability,"> > AUUUGHHH that was hard but finally found the source of the type instability:; > ; > which type instability; is this related to discussion in #3750?. Yes. That issue documents slow reductions for windowed fields on immersed boundary grids. I hypothesized that it was due to a failure of type inference. Looking into it further I see that `axes(op::AbstractOperation)` cannot be type inferred when indices is not `(:, :, :)` because of the tuple generator. We found the same problem with `axes` for `Field` and fixed it but didn't fix it for AbstractOperations. Reducing windowed fields on immersed boundary grids requires this because they are wrapped in `ConditionalOperation` in order to mask the immersed regions during the reduction. This PR extends the fix we implemented for `Field` to also encompass `AbstractOperation`. It also cleans up conditional operations quite a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438:749,extend,extends,749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380361438,1,['extend'],['extends']
Modifiability,"> > Also I am not sure about renaming to `buffer`. What is called `buffer` here is not really a buffer but a `halo-dependent` region of the active domain. What about calling it `compute_halo_dependent_tendencies!`?; > ; > This PR _defines_ the ""buffer"" as the halo dependent region of the domain.; > ; > Before this PR there was no definition of this region at all, so this PR simply introduces one possible name. I am ok with a different name, but I think we should do it in another PR. Ok, can we leave the refactoring to another PR than to clean up this one?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122:509,refactor,refactoring,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2398015122,2,['refactor'],['refactoring']
Modifiability,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:935,refactor,refactor,935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['refactor'],['refactor']
Modifiability,"> > Doesn't that already exist?; > > We just have to adapt the test; > ; > Yes, the test I think only tests the `NetCDFOutputWriter`. There is already a test for the `JLD2OutputWriter`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160:53,adapt,adapt,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001918160,1,['adapt'],['adapt']
Modifiability,"> > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > > Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`....; > ; > Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures).; > ; > I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically. True true. Any idea how to deal with the dz(b) that vanishes at the top? Or should we live with it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817:368,parameteriz,parameterizations,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920817,1,['parameteriz'],['parameterizations']
Modifiability,"> > Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.; > ; > I think so. Let's definitely try!; > ; > Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?. We have `FluxBoundaryCondition` already which is the same. The difference in terms of user input is that an immersed boundary condition _function_ has to be called with three indices `i, j, k` rather than two like all the other boundary conditions. I don't think we need any new types in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738:21,adapt,adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050162738,1,['adapt'],['adapt']
Modifiability,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027:385,flexible,flexible,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027,2,['flexible'],['flexible']
Modifiability,"> > I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...; > ; > What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help. ```bash; $ which mpiexec; /opt/homebrew/bin/mpiexec; ```. I don't have a `LocalPreferences.toml`, I never did anything with MPIPreferences. Do I need to? I just did what the tutorial was suggesting and that wasn't part of the instructions -- that's why I didn't do anything.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128:169,config,configuration,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282898128,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> > I don't really get why returning 0 is useful though. You say ""for writing general code from the user perspective"" but I don't quite understand that.; > ; > What I mean is that it's makes it easier for a user to write something like:; > ; > ```julia; > u_sgs_flux(model) = - viscosity(model.closure, model.diffusivity_fields) * ∂z(model.velocities.u); > ```; > ; > and have it (correctly) return 0 when `closure=nothing`.; > ; > I've been writing utilities of this kind for the past couple of months for a project which has simulations both without and without closure, and I've been using if-else statements to deal with that. It's not the worst thing, but having these extra two lines in Oceananigans would help me (and possibly other users) have cleaner code in these instances.; > ; > Although admittedly I don't expect a big chunk of users to need that. The main reasons for me to propose this is that the behavior of `viscosity()` and `diffusivity()` will now be more consistent (i.e. they would work for all (?) closures we have so far), and it's only a simple two-line addition. In the future instead of using an if-statement, you can extend `viscosity` and `diffusivity` in your own code (temporarily, until a PR like this one is merged)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192:1146,extend,extend,1146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2951#issuecomment-1454777192,2,['extend'],['extend']
Modifiability,> > I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`.; > ; > I don't see it; did you push?. Sorry! I have added it now. https://github.com/CliMA/Oceananigans.jl/blob/fp-ss/shallow-water-version2/validation/shallow_water_model/shallow_water_jet_topography.jl. One of my mitakes is that I didn't define the bathymetry. I need to figure out how to do that. Thanks for the very helpful feedback!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954:83,evolve,evolves,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975142954,2,['evolve'],['evolves']
Modifiability,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:415,config,configured,415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570,2,['config'],['configured']
Modifiability,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399:206,variab,variable,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399,2,['variab'],['variable']
Modifiability,"> > I now recall the reason for the discrepancy. It was due to an index shift, which made filling the extra layer of halos quite straightforward, so I proceeded with it. For example, field_1[2:Nc+1, Nc+1:Nc+Hc] from an odd panel corresponds to field_2[1:Hc, 1:Nc] from the panel to the north. I can modify this expression to field_1[2:Nc, Nc+1:Nc+Hc] aligning with field_2[1:Hc, 2:Nc] and make similar adjustments for other halo fillings to minimize confusion. Please let me know your thoughts.; > ; > My thoughts are two:; > ; > * how will we know that while doing that change you won't break anything since there is no test for any of these things; > * I understand that you are telling me is merely an indexing reordering, that is instead of doing; > ```julia; > for j in 1:10; a[j] = 10; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > you do; > ```julia; > for j in 2:11; a[j-1] = j-1; > ```; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > ; > right? But these two will result to the same array. So I'm confused. I understand that there is no test for these things, but the chances of breaking the code is nil because the same logic applies to the remaining halo points. Regarding the index shifting, your example is not quite analogous to our case. Just consider my example above, where field_1[2:Nc+1, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 1:Nc] of panel 3. That is for sure, right? If, instead, I specified field_1[2:Nc, Nc+1:Nc+Hc] of panel 1 corresponds to field_2[1:Hc, 2:Nc] of panel 3, that would have removed the additional row/column of halo fills and made it look cleaner. I thought if the additional row/column were filled incorrectly, it would have been reflected in the remaining rows/columns as well, since the halos were filled in the same way. But, yes, I agree with your other comment that cleaning up the code would enhance its clarity and enable future recollection of our work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530:1854,enhance,enhance,1854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2025907530,1,['enhance'],['enhance']
Modifiability,"> > I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation.; > ; > I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":; > ; > Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems.; > ; > We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:608,adapt,adapt,608,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,1,['adapt'],['adapt']
Modifiability,"> > I suggest we remove the parameter for `gravitational_acceleration`.; > > @francispoulin any objection to that?; > ; > Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations. I only meant removing the explicit type declaration of the parameter. Sorry, should have been clearer. :); But we decided not to. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182:209,evolve,evolve,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453564182,2,['evolve'],['evolve']
Modifiability,"> > I think having a default but non-trivial CFL would be surprising and therefore undesirable, even if it's convenient for some users.; > > I was hoping we might be able to deprecate `diffusive_cfl` because it's a big maintenance burden, but let's keep it if its useful.; > ; > I wouldn't setting the `diffusive_cfl` is surprising. After all the diffusive cfl is as much of a necessary condition for convergence as the advective cfl, it just is a limiting-factor less often for oceanic simulations. But I'm okay with keeping the current behavior as well. I certainly don't disagree that it's convenient; the question is more whether the benefit justifies the cost. Users also want a code that's easy to maintain and extend because then they get more features! For constant diffusivities, the CFL constraint can be pre-calculated. For some common closures the calculation is simple, but this is not _generically_ the case for all turbulence closures. It's really only for variable diffusivities that we _need_ a feature for on-the-fly calculation. We could also use something like `diffusive_cfl=nothing` which completely avoids the calculation. Then we can justify supporting a diffusive CFL calculation for selected turbulence closures. That might be a good route (discussion for another issue).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247:717,extend,extend,717,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2205#issuecomment-1025985247,4,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"> > I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit.; > ; > To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU?. If the precomputation is storing values in an `Array` or `CuArray` (which is already mutable) then no. If you need to precompute a number for every boundary, then yes you need something mutable. But it looks like this would not involve the `BoundaryCondition` itself but rather a component of the boundary condition (eg the `condition` or the `classification`). None of this is hard though. I think we need to write down the use cases we want to support (explicitly, as detailed as possible), then we can design the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558:244,adapt,adapt,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979244558,1,['adapt'],['adapt']
Modifiability,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:641,extend,extended,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['extend'],['extended']
Modifiability,"> > I think the majority of simulations do not use a Checkpointer so the warning would be irrelevant in most cases.; > ; > I don't get this. How are people not using a Checkpointer? Is no one else limited by HPC wall times or running long simulations? It seems like one of the most fundamental capabilities of any time-stepped numerical model.; > ; > But yes, this warning should only be issued if a Checkpointer is used (and maybe also when a simulation picks up from an existing Checkpoint). I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient. Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon. @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. I'm not saying we don't want to develop this, I'm just providing some context about why this hasn't been resolved / developed yet. In an ideal world the simulations would run fast enough that we wouldn't need checkpointing, after all 😄",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230:846,parameteriz,parameterization,846,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305131230,2,['parameteriz'],['parameterization']
Modifiability,"> > I will add a docstring with some explanation, and replace some of the if-statements with multiple dispatch.; > ; > What will you dispatch on though? A docstring is for sure needed. Thanks!. I see your point. For dispatch, the argument types need to be different, which is not the case here. I used so many if statements to minimize the number of functions. I think I will just rewrite them in more readable way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932:381,rewrite,rewrite,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867#issuecomment-1653960932,1,['rewrite'],['rewrite']
Modifiability,"> > I'm strongly opposed to having multiple small packages.; >; > Why is that, given the benefits?. Mainly I think we can get all the same benefits by maintaining a single unified and tidy repository with sub-modules. I don't see Oceananigans as a complex project yet, we're barely at 2,500 lines of code (minus turbulence closure operators which aren't integrated yet). I can see reasons for having a separate repository for examples and tutorials if there are enough of them, but I don't see e.g. the output writers as being logically separate from the main code. As a stand alone package, OceananigansOutput.jl doesn't do anything useful. Something like TurbulenceClosures.jl could though. Keeping things in tidy submodules within a single repository increases code visibility, which I think is important. When I see a package or framework spread across multiply small packages I find it hard to get an idea about what it can do. Another nice thing is we currently have ""unified versioning"" so when releases occur we know everything works together. We don't have to worry about running with Oceananigans v0.x with OceananigansPlotting v0.y and OceananigansOutput#master to fix some issue. From a development perspective, issues and pull requests are now spread across multiple repositories and we can end up with pull requests that depend on other pull requests in other repositories, e.g. when adding in halo regions the main code got refactored but so did the output writers and plotting code would change as well. We can also end up with multiple test suites that need to pass, plus possibly multiple CI pipelines to manage. So right now it's easy to make atomic changes that touch upon multiple pieces of code (and we'll probably be in this stage where we need to refactor frequently for a while). I also don't have to git clone a bunch of repositories just to work on a simple example. But this is getting off-topic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749:1439,refactor,refactored,1439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502137749,2,['refactor'],"['refactor', 'refactored']"
Modifiability,"> > In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it.; > ; > Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`. I think that depends on how one defines the advective velocity eg. if it is defined as an explicit function of time then it is better that dynamics act first to compute the radius at time $t$ before it is being advected to time $t + \Delta t$.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652:43,evolve,evolve,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873881652,1,['evolve'],['evolve']
Modifiability,"> > It's something to do with GPU, maybe GPU reductions?; > > ```; > > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > > --; > >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; > >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); > >   | Evaluated: 0.0 ≈ 1.0471975511965976; > > ```; > ; > I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(. I guess its a CUDA version issue or something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329:124,variab,variably,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1567729329,1,['variab'],['variably']
Modifiability,> > Likely this function is the problem:; > > https://github.com/CliMA/Oceananigans.jl/blob/775d1544610d5af6f602254ec5dff3dec7f18480/src/BoundaryConditions/update_boundary_conditions.jl#L15-L16; > ; > Yeah I saw that this was where some of the errors were coming from but I don't really understand what is going on with Enzyme that this causes problems?. It could be that this function is recursive coupled with the fact that `boundary_conditions` is not type-inferrable. So we may want to rewrite both of those functions. Luckily typically the changes we make to improve type inferrence (making it easier for the compiler to understand) also make it easier for humans to understand. As a starting point I don't think we can use the `Tuple` generator...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349:490,rewrite,rewrite,490,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2263694349,1,['rewrite'],['rewrite']
Modifiability,"> > Most of the changes are separating the bgc transitions from the rest of the tendencies which isn't that hard but is just quite a lot of lines.; > ; > Can you elaborate for the benefit of future generations?. For sure, the problems were:. - to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to `biogeochemical_transitions` - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable; - I then needed to be able to compute the bgc tendencies only so I added a function to the bgc file to launch a kernel that just computes `biogeochemical_transitions`; - Then I made the new time stepper which is just a container for two different timesteppers called `physics` and `biogeochemistry` (which are normal timesteppers so each have a set of tendencies etc.); - this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at `timestepper.G` / `$G^-$`, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned `timestepper.physics.G` etc.; - Then I had to add `time_step_biogeochemistry!` functions which do the same as `time_step!` but only comput the bgc tendencies. So to summarise: 1) separating the bgc tendency calculations from the rest, 2) make somewhere for the bgc tendencies to live and return the physics tendencies when expected, 3) step the bgc on its own",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735:572,maintainab,maintainable,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455392735,1,['maintainab'],['maintainable']
Modifiability,"> > Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better.; > ; > But I thought the whole idea is to be able to provide an `Array` for forcing. `Field` is an abstract array. You should think of `Field` as a kind of `Array`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257:121,adapt,adapts,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1988818257,1,['adapt'],['adapts']
Modifiability,"> > Probably the quickest way to start is simply to add the ""holes"" manually after calling `compute!`.; > > The reason this test is failing is not because `compute!` doesn't work, right? Getting `compute!` to work is just visualization.; > ; > We need to be able to compute the vorticity in those points as well as those points are involved in the ζk^×u term. So I think the dynamics test is blowing up because of that, but I'm not 100% sure. But I think the problem here is just that the kernel launched by `compute!` does not extend to all the points where zeta is defined. On the other hand, when zeta is used during time-stepping, we compute it for the u- and v- tendency kernels. In those kernels, all relevant grid points are touched.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128:528,extend,extend,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3306#issuecomment-1759751128,2,['extend'],['extend']
Modifiability,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:994,sandbox,sandbox,994,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509,2,['sandbox'],['sandbox']
Modifiability,"> > This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?; > ; > This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`. Got it! Agreed. Should we test that `hydrostatic_pressure_anomaly` is either `CenterField(grid)` or `nothing` and throw a helpful error otherwise?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540:363,flexible,flexible,363,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088696540,2,['flexible'],['flexible']
Modifiability,"> > This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage; > ; > So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way? We should definitely add a link to that docs page then. No the best thing to do is to call `mpiexecjl`, which is installed when you install `MPI.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680:39,config,configure,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278730680,2,['config'],"['configuration', 'configure']"
Modifiability,"> > We should also add a test similar to the one that was added in #3512.; > ; > Doesn't that already exist?; > ; > We just have to adapt the test. Yes, the test I think only tests the `NetCDFOutputWriter`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688:132,adapt,adapt,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2001910688,1,['adapt'],['adapt']
Modifiability,"> > Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > > ```julia; > > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which will become a number for single layers?; > ; > Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both. Ok! This type field will be pf different type for single and multilayer models then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372:328,layers,layers,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472887372,1,['layers'],['layers']
Modifiability,"> > What's the error with `TimeInterval`?; > ; > I think the issue was the interval being stored as a Float64, but I'm not sure why that would ever endup in a kernel. (copy-pasting from #2618). One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698:940,variab,variables,940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734542698,1,['variab'],['variables']
Modifiability,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:233,adapt,adapted,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['adapt'],['adapted']
Modifiability,"> > but I guess you are telling me that it defaults to the position of the first variable?; > ; > Correct.; > ; > > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something; > ; > My apologies for being unclear! I would write; > ; > ```julia; > uh, vh, h = model.solution; > u = ComputedField(uh / h); > ```. Great to know, thanks!. Actually, the fact that I have uh, vh and h already defined causes some problems. Rather than introducing more variables I will probably just use the long name. I will try and not forget this in the future though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723:81,variab,variable,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760282723,2,['variab'],"['variable', 'variables']"
Modifiability,"> > in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > > The other option to not use MPI variables is to hardcode the number of processors; > ; > This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line.; > ; > I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do. Just to clarify, this is already possible, just by doing; ```julia; arch = Distributed(); rank = arch.local_rank; ```; The script, on the other hand, explicitly uses the MPI module before constructing the architecture, for which it makes sense to have `using MPI; MPI.Init()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065:88,variab,variables,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894742065,2,['variab'],['variables']
Modifiability,"> > potentially with a default value of overwrite_existing = false.; > ; > Do you run with `overwrite_existing=false`? (Outside the context of restoring from a checkpoint.). I agree, that is not a common use case scenario. I have only used `overwrite_existing=false` without a checkpoint for short tests within the same Julia instance to extend the model output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391892045,1,['extend'],['extend']
Modifiability,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,2,['variab'],['variable']
Modifiability,"> @Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the momentum equations.; > ; > If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue. @francispoulin I am interested deriving/testing closures in the 2D Adv-Diff equation in the (general) case of periodic shear flows. A constant shear flow won't do it. More like a velocity field that can be decomposed into a shear flow u(y) (e.g. a cosine in y or sum of cosines) plus a cellular flow (square waves). I am still a newbie over here, so I am open to trying different models.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388:207,evolve,evolve,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768512388,1,['evolve'],['evolve']
Modifiability,"> @glwagner ,; > ; > So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:; > ; > ```julia; > lamb = 1 # decay scale for slip velocity in meters; > @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); > sinking = SlipVelocity(WENO5(), w=w); > ```; > ; > The way the code is, does it accept functions for velocity inputs? Is that something I could do to help you?. You can do this a few ways:. ```julia; # Vertical velocity function; const lamb = # something; const H = # something; @inline w_func(x, y, z) = tanh(max(-z / lamb, 0.0)) * tanh(max((z + H) / lamb, 0.0)). # Field (allocates memory and precalculates w_func); w = ZFaceField(grid); set!(w, w_func); sinking = AdvectiveForcing(w = w). # Function field (avoids allocating memory but calls `w_func` every iteration); w = FunctionField{Center, Center, Face}(w_func, grid); sinking = AdvectiveForcing(w = w); ```. We could also add the feature to `AdvectiveForcing` that, if an input is a function, we assume it's a function of `x, y, z, t` and deal with it appropriately (by wrapping in a `FunctionField` and adding reference to the model `clock`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436:126,adapt,adapted,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083548436,1,['adapt'],['adapted']
Modifiability,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:694,layers,layers,694,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,2,['layers'],['layers']
Modifiability,"> @glwagner and @simone-silvestri; > ; > Continuing the discussion. [#2788 (reply in thread)](https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280); > ; > It looks like MPI needs to be initialized before accessing its communication variables.; > ; > Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`.; > ; > https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22; > ; > Should we initialize MPI when importing DistributedComputations?. Either 1) explicitly invoke `MPI.Init()` or 2) move those lines to after the grid constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511:263,variab,variables,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894650511,1,['variab'],['variables']
Modifiability,> @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. Sorry! I hadn't realised they could be merged without the tests passing so when I saw the PR approved just hit merge. Sorry for all the problems!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868338988,1,['adapt'],['adapt']
Modifiability,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:139,refactor,refactor,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702,1,['refactor'],['refactor']
Modifiability,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:427,config,configuration,427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,2,['config'],['configuration']
Modifiability,"> @navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?; > ; > https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725; > ; > Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?. Perhaps if we update Documenter.jl in the docs to the latest version we can alleviate that. At the moment DocumenterCitations v0.2.0 is precluding Documenter from v0.26 and later; see https://github.com/ali-ramadhan/DocumenterCitations.jl/pull/34#issuecomment-782308024.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873:56,config,config,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782308873,1,['config'],['config']
Modifiability,"> @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?. Yes. Consider the following sources for the grid metrics:. 1. the `cs32` grid with one halo layer, used by:; - Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; - yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; 3. the `cc32` grid created by Oceananigans. In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018:430,layers,layers,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1977945018,1,['layers'],['layers']
Modifiability,"> @siddharthabishnu, what capability does this PR add?. @glwagner, this PR uses the new halo-filling functions to update halos for prognostic variables and refines the vorticity computation function on the cubed sphere. Additional features introduced in this PR are detailed in the description.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213:142,variab,variables,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570#issuecomment-2087903213,1,['variab'],['variables']
Modifiability,> @simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ). @christophernhill don't we need to implement thickness weighting as part of a general overhaul to generic vertical coordinates? Or can we implement thickness weighting even in a fixed Z coordinate system?. @glwagner and @simone-silvestri I think you could explore thickness weighting in the non-linear shallow water. @francispoulin does that make sense? Might be a way to more quickly pilot some API and numerics aspects?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693:172,flexible,flexible,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081924693,1,['flexible'],['flexible']
Modifiability,> @tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?; > ; > Looks like `ScalarBiharmonicDiffusivity` needed it here:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113; > ; > Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?. I tried that and got a different error. But now looking at `ScalarBiharmonicDiffusivity` I think I probably did something wrong. I'll try again soon!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686:60,adapt,adapting,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313450686,2,['adapt'],['adapting']
Modifiability,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1000,adapt,adapt,1000,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695,2,['variab'],['variable']
Modifiability,"> @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel. Sure, you could e.g. have an adapt rule return a named tuple so that you can still do `.time` etc, as long as you don't have any signatures relying on `::Clock`. Getting mutables to work is much tougher, but not impossible either, especially if the object doesn't contain pointers (as Clock here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181:45,adapt,adapt,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599136181,2,['adapt'],['adapt']
Modifiability,"> Actually I think you want `u` at the same location as `uh`, so you should write; > ; > ```julia; > u = ComputedField(uh / h); > ```. Agreed. What I did was `u = ComputedField( @at (Face,Cell,Cell) uh/h )` but I guess you are telling me that it defaults to the position of the first variable?. Actually, I needed to use `model.solution.uh` instead of `uh` and it seems to be working better (but I'm not done). Does that make sense or am I missing something?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876:284,variab,variable,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760279876,1,['variab'],['variable']
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. That help was from Adapt 3.6.2, which is in the Oceananigans Manifest. I'll check v4 now. But I don't think it matters. The first argument `to` is necessary --- that indicates the device you are adapting to. There are two pieces of information required to adapt an object: the device we're adapting to, and the object being adapted.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867963146,7,"['Adapt', 'adapt']","['Adapt', 'adapt', 'adapted', 'adapting']"
Modifiability,"> Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh.; > ; > We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?. The syntax for `adapt` on v4.0.0 is the same:. ```julia; help?> adapt; search: adapt Adapt InvalidStateException. adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171:2,Adapt,Adapt,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867964171,21,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,"> Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? [- @glwagner]. Flux boundary conditions are both conceptually and practically easier to implement when the boundary fluxes are zero or constant. They can be trickier when they depend on interior flow variables. In our case, for example, the boundary condition on the perturbation variable $b'$ (the buoyancy tracer in Oceananigans) is that the *total* diffusive flux should vanish, which means the *perturbation* diffusive flux needs to be minus the *background* diffusive flux. . ![image](https://github.com/CliMA/Oceananigans.jl/assets/12971166/d5eae1d6-4aa8-438e-870b-0ff17352dcea). Imposing a flux boundary condition requires knowing the diffusivity $\kappa$ right at the boundary. It is obvious how to implement this if the diffusivity is a constant, because the background diffusive flux is also a known constant, but less obvious how to do it when using a subgrid turbulence closure that yields a diffusivity that varies in space and time. @tomchor pointed out to use that we can sidestep this complexity if we just divide both sides of the boundary condition by $\kappa$, because then the boundary condition simply becomes that the buoyancy gradient across the boundary should just be equal to minus the background buoyancy gradient—a known constant in our problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146:296,variab,variables,296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2211446146,4,['variab'],"['variable', 'variables']"
Modifiability,"> Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model. Even more than details associated with particular challenging ODEs is the more fundamental software challenge of designing a flexible and useful system for user-specification of ODEs (special fields defined on sets of particles, each associated with an independent ODE that is coupled to the model solution) to be solved on particle trajectories. If we were integrated with DifferentialEquations.jl, this might not be all that hard, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256:435,flexible,flexible,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-548641256,1,['flexible'],['flexible']
Modifiability,> Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged. I was also puzzled why that happened. I just pulled master and then `git merge master`...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083:24,sandbox,sandbox,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783653083,1,['sandbox'],['sandbox']
Modifiability,"> Ah sorry I really do think it would be confusing to users that one has to use HydrostaticSphericalCoriolis on grids that have spherical coordinate systems; and that the ""constant Coriolis"" type only applies to Cartesian coordinate systems :-( don't others agree?. I do agree it's a bit confusing, but IMO it's also obscure to name it `ConstantCartesianCoriolis`. As a user I'm thinking what's a cartesian Coriolis? And I definitely wouldn't make the leap in reasoning that `ConstantCartesianCoriolis` is meant to be used with _rectilinear grids_ (none of those two words appears in the name). Which is I suggested a few posts back to use the (very verbose) `ConstantRectlinearGridCoriolis` or something to that effect. > Sorry this is becoming laborious... if the name is changed to include Cartesian then we can merge this and discuss further in an issue. I'm okay with this. It seems like the background rotation implementation could use a big refactoring, which is kind of outside the scope of this PR anyway.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511:948,refactor,refactoring,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511,1,['refactor'],['refactoring']
Modifiability,"> Ah, I see...; > ; > ```; > @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); > ```; > ; > that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree. So I pushed fd3a456.; Is there a test for that? Do we need to test that this expression is actually correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171:220,extend,extended,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054872171,1,['extend'],['extended']
Modifiability,"> Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think. @glwagner we can merge this in at some point. I didn't want to lose it meantime. Looks like #1575 needs other bits doing too, since #1522 did its stuff!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246:84,refactor,refactor,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820454246,1,['refactor'],['refactor']
Modifiability,"> Also just to clarify, the problem is not `SeawaterBuoyancy` but rather any buoyancy model at all. When I tested with `BuoyancyTracer` the issue doesn't come up. I suppose you mean any buoyancy model that doesn't have buoyancy as an explicit prognostic variable right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697:254,variab,variable,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795#issuecomment-2377886697,1,['variab'],['variable']
Modifiability,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1007,layers,layers,1007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257,1,['layers'],['layers']
Modifiability,"> Also this works:; > ; > ```julia; > julia> import Base: minimum; > ; > julia> using OffsetArrays; > ; > julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); > minimum (generic function with 21 methods); > ; > julia> minimum(zspacings(grid, Center())); > 1.0; > ; > julia> grid; > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; > └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; > ```; > ; > so it might have something to do with the `KernelFunctionOperation` that's used here?:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413. We use the `KernelFunctionOperation` because this generalizes to any grid, including immersed boundary grids that may modify the spacings of the underlying grid (for example with `PartialCellBottom`). It's possible to implement shortcuts like calculating a minimum directly over a `view`, but I'd hesitate to put this in the source code. Maybe we can make some improvements to `KernelFunctionOperation` that allow it to be reduced more easily. That would benefit everyone.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276:573,variab,variably,573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1499438276,1,['variab'],['variably']
Modifiability,"> Also, you don't need the `field_dependencies` argument with `discrete_form=true` (but I think that has no effect, so just a side comment, maybe we should throw an error for that). Ah yeah, I forgot to change that when I adapted it to discrete form. Thanks for catching that and for the other tips!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397:222,adapt,adapted,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401359397,1,['adapt'],['adapted']
Modifiability,"> And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that _dispatch_ on the number or arguments and argument types. That makes sense and it should be easy enough to define `ShallowWaterModel` versions of these. I will work on the advection case and let you know what I come up with.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109:35,extend,extend,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761165109,1,['extend'],['extend']
Modifiability,"> Another possibility is that we figure out how to translate `x^2` to `x*x` (eg hook into `Base.literal_pow`). Exponentiation by literals is covered by that, just not when using constants as in #1770 . ```julia; julia> f(x) = x^2; f (generic function with 1 method). julia> code_warntype(f, Tuple{Float64}); Variables; #self#::Core.Const(f); x::Float64. Body::Float64; 1 ─ %1 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2}); │ %2 = (%1)()::Core.Const(Val{2}()); │ %3 = Base.literal_pow(Main.:^, x, %2)::Float64; └── return %3; ```; ```julia; julia> const factor = 2; 2. julia> g(x) = x^factor; f (generic function with 1 method). julia> code_warntype(g, Tuple{Float64}); Variables; #self#::Core.Const(g); x::Float64. Body::Float64; 1 ─ %1 = (x ^ Main.factor)::Float64; └── return %1; ```. HOWEVER, on the CPU both result in good code:. ```julia; julia> code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1923(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_342(double %0) {; top:; ; ┌ @ math.jl:918 within `^'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }; ```. Whereas with CUDA, the non-literal version leads to expensive code:. ```; julia> CUDA.code_llvm(f, Tuple{Float64}); ; @ REPL[12]:1 within `f'; define double @julia_f_1908(double %0) {; top:; ; ┌ @ intfuncs.jl:312 within `literal_pow'; ; │┌ @ float.jl:332 within `*'; %1 = fmul double %0, %0; ; └└; ret double %1; }. julia> CUDA.code_llvm(g, Tuple{Float64}); ; @ REPL[6]:1 within `g'; define double @julia_g_1282(double %0) {; top:; ; ┌ @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:223 within `^' @ /home/tim/.julia/packages/CUDA/Ozu5O/src/device/intrinsics/math.jl:218; %1 = call i32 @llvm.nvvm.d2i.hi(double %0) #4; %2 = call i32 @llvm.nvvm.d2i.hi(double 2.000000e",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587:308,Variab,Variables,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-875793587,2,['Variab'],['Variables']
Modifiability,"> Are you envisioning that we need something additional to simply dispatching on the boundary condition types (which is already implemented?). Good point, we should just dispatch on the boundary conditions. Might get messy if we're passing the boundary conditions through multiple layers of operators so maybe there's a way to include them in the grid? The grid is already passed in. > I vote for using the halo regions to satisfy boundary conditions rather than writing if-statements into the operators. Don't think I'll use an `if` statement, maybe we can use a 1D array like `Ay[0] = Ay[Ny+1] = 0` and `Ay[j] = Δx*Δz`. Reason being is that apparently there are issues or reasons why it's better to enforce the wall by setting the area to zero at the wall, rather than using the halo regions to enforce things. I still need to discuss this with @jm-c and @christophernhill.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322:281,layers,layers,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-500781322,1,['layers'],['layers']
Modifiability,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:707,config,configuration,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274,2,['config'],['configuration']
Modifiability,"> As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Good to hear! Thanks!. > Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython... I don't think there is a _problem_, because NetCDF accepts unicode names, etc, and Python (and most other modern programming languages I thnik) also do. The issue that I pointed out is that, because most other programming languages don't let you write code with all unicode characters, most source-code editors/prompts don't let you type all unicode characters easily. So you can write the following in Python and it'll work (I think, I haven't tested); ; ```Python; ds.plot(x=""xᶜᵃᵃ""); ```. But every time you wanna do it (or write other characters like `xᶜᵃᵃ`) you have to copy paste those characters from somewhere else, which is kind of a hassle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309:280,variab,variable,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799825309,2,['variab'],['variable']
Modifiability,"> As for the origninal problem I suggested, with terrain-following coordinates, since the grid is fixed all it needs is analogous versions of the operators in xz space. So the machinary is all there but some translation needs to be done. Starting with a 2D vertical slice would be very similar to shallow water but there is an incompressibility condition that needs to be imposed, but we have tools to solve that. I don't think we need to go to 3D curvlinear coordinates since it's only curvlinear in 2 dimensions. I can find references for this if that would help. References would help! We are currently curvilinear only in xy... so 2D curvilinearity in xz is the same thing as 3D curvilinearity. But maybe I am misunderstanding what you're saying. > Create a dispatch between ConservationForm and VectorInvariantForm (similar to HydrostaticModel I presume). Alternatively, you can adapt the existing ""flux form"" momentum advection operators to work on curvilinear grids. This is something we plan to do eventually (so we can use WENO advection schemes on a lat-lon grid, for example), but haven't gotten to it yet. There is already a `VectorInvariant` type. You just need to move around some of the code and ensure that the vector invariant advection scheme generalizes / can be generalized to a shallow water system. > Define a new grid, maybe called BoundaryFollowingGrid. I think you could build something more generic like `HorizontallyWarpedGrid` with a warping function that maps from the rectangle / square to whatever geometry you're trying to use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781:884,adapt,adapt,884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814261781,1,['adapt'],['adapt']
Modifiability,> As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?. I agree Makie is way better. Can we do animations too though? I'll explore. Sadly tartarus is not open CL enabled.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750:26,refactor,refactor,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064673750,1,['refactor'],['refactor']
Modifiability,"> As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`. So what we did here was; https://github.com/CliMA/Oceananigans.jl/blob/5d9836398cb49cf2eea38ec6da505b03d9a94a66/docs/make.jl#L46-L53; which is equivalent to `pmap`, right?. But now I see. I thought the `run('...')` was only if I wanted to carry out global variables from one example to the other.; So you are saying that . ```Julia; asyncmap(1:length(example_scripts)) do n ; example = example_scripts[n] ; example_filepath = joinpath(EXAMPLES_DIR, example) ; withenv(""JULIA_DEBUG"" => ""Literate"") do ; run(`julia --project=docs -e'Literate.markdown(example_filepath, OUTPUT_DIR; flavor = Literate.DocumenterFlavor(), execute = true)'`; end ; end; ```; right? I'll try that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246:115,variab,variable,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576460246,2,['variab'],"['variable', 'variables']"
Modifiability,"> As you know, the two methods are virtually identical. I am happy to go the way of generalizing `GridFittedBottom` and add in a tolerance and a way of specifying the height. Shouldn't be much work, it's just a matter of deciding exactly what we want this to look like. The only change to existing code you need is a new property in `GridFittedBottom`. Then the current methods are the fallback (default), and we extend behavior by defining new functions for specific cases.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063:413,extend,extend,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251#issuecomment-1044750063,1,['extend'],['extend']
Modifiability,"> Awesome!; > ; > How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?. It is not that large, I figured that with `UInt16` we can cover almost all practical cases. `wet_cell_map` will be a vector of _active_ locations defined by a tuple of indices. Depending on what % of the domain is active, the size of the map will be. `prod(size(grid)) * %active * 3 * sizeof(Type)`. where `Type` is the `UInt` with the minimum size required to represent `maximum(size(grid)))`; In the example of the ocean, where 57% of the domain is active, the map is 42.75% the size of a standard Float64 `Field`:. a UInt16 occupies 2 bytes, so compared to a field, the map is . `(0.57 * 3 * 2) / 8 ≈ 0.4275` . I guess adding the opt in/opt out can be nice and is very easy because of . https://github.com/CliMA/Oceananigans.jl/blob/b7835edbac0a7318d49462addb1c1046014e39c4/src/ImmersedBoundaries/wet_cells_map.jl#L10-L21. which is used now to calculate the map only when we construct the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775:56,extend,extend,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317283775,1,['extend'],['extend']
Modifiability,"> Before proceeding further, I guess we should discuss a bit on whether we want a single parameter for gravitational acceleration (`effective_gravitational_acceleration`, which can encapsulate both gravitational acceleration `g` and reduced gravity `g'` terms) or two parameters (one for `g` and `g'` each), with Navid's code above an example of the latter. I am inclined towards the former as I feel it's cleaner (scientifically and for coding purposes), but happy to go either ways. I didn't really think through my code above so don't pay too much attention to it. :); It was just a placeholder to demonstrate about parametric types. But I don't understand exactly what you suggest. `gravitational_acceleration` is a number, and it the same regardless of the number of layers you have. It's the acceleration that the top-layer surface feels (given that we use the approximation that `ρ_air ≪ ρ_fluid`. The reduced gravities `g'_{k+1/2} = g * (ρ_layer_k+1 - ρ_layer_k) / ρ_layer_k+1` are the gravitational accelerations each of the fluid interfaces feel. So `g'` is a Tuple of `k-1` numbers, where `k` is the number of layers, right? And this parameter is irrelevant for the SingleLayerModel. Were you suggesting to combine these in a single `k`-long tuple, e.g.,. ```julia; gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); ```; which will become a number for single layers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937:772,layers,layers,772,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1471840937,3,['layers'],['layers']
Modifiability,"> Blast. How about `x′`, `y′`?; >; > Can also change the vorticity notation in field_metric_products to something else. I'm okay with `x′`, `y′` but I'll leave it for now since it's localized to the grid constructor so it hopefully shouldn't cause any confusion (and there's a comment). Could be cool if we had like a notation list/glossary so every variable had one meaning like some books have, but we'd probably run out of letters very quickly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016:350,variab,variable,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417#issuecomment-799811016,1,['variab'],['variable']
Modifiability,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1404,variab,variable,1404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,"> But question: floats need adaptation?. The answer is no. For any object that doesn't have an explicitly defined `adapt` method, then `adapt(to, x) = x`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846:28,adapt,adaptation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2179041846,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> Can any of you take a look to see if I'm doing anything that's wrong or ill-advised in any way? (I solved it in a pretty pythonic way...). I think your solution is fine. In more complicated scenarios it's sometimes better to use dispatch rather than if statements because the code is then more extensible (by defining new functions, which can go anywhere, rather than adding conditions to a chain of if statements in some central location). Here it's not so crucial and we can refactor later if we need to. We certainly _can_ use if statements in julia (and dispatch in python!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053:479,refactor,refactor,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784539053,1,['refactor'],['refactor']
Modifiability,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:212,variab,variable,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,3,"['Variab', 'variab']","['Variable', 'variable']"
Modifiability,"> Can't we add advective terms via the biogeochemical forcing term?; > ; > edit: I see you mentioned that, so I might be missing something... I'll take a look at your examples.; > ; > PS we should add those scripts to `validation/biogeochemistry/`. > I think we can impose a little more structure that eases biogeochemical model development.; > ; > One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like; > ; > ```julia; > struct TracerBasedBiogeochemistry; > biogeochemical_tracers; > drift_advection_schemes; > drift_velocities; > transitions; > auxiliary_fields; > end; > ```; > ; > and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior.; > ; > Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow).; > ; > I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like; > ; > ```julia; > biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); > ```; > ; > rather than having to use the ""discrete form"".; > ; > This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development. This seems like a good idea, I will have a think and try and come up with something",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594:1455,coupling,coupling,1455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1311545594,1,['coupling'],['coupling']
Modifiability,"> Curious what's the status of this effort to add Metal support to Oceananigans. It's crazy how easy it is to add this support, but the major limitation is that Metal only supports Float32. There hasn't been much effort to validate anything for Float32, though this is a worthwhile goal... Also if we do refactor this PR, I think we should probably put the Metal functionality in an extension, much as #3468 does.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191:304,refactor,refactor,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-2093736191,1,['refactor'],['refactor']
Modifiability,"> Did you want me to give this a try? It does not seem like a lots needs to change and I will certainly learn a lot in the process. That's fine with me (and I am very happy to help, or pair program over zoom). I think resolving this issue (moving files around) should happen in a separate PR from implementing `ShallowWaterModel`. Imports and exports will also change, for example `IncompressibleModels` will become a submodule of `Models`, and we'll have to pull the name `IncompressibleModel` into `Models`:. ```julia; # in Models.jl. include(""IncompressibleModels/IncompressibleModels.jl""). using IncompressibleModels.IncompressibleModel; ```. Hopefully we can reuse as much code as possible. If your prognostic variables are `hu,`, `hv`, `h`, you may benefit from some fancy julia abstraction that will let you reuse momentum advection and tracer advection operators like `div_Uu` and `div_Uc`. I'm happy to help with that. Your fields will all have to be three-dimensional (with a single grid point in the vertical direction). Also until #1024 is fixed we will unfortunately also need halo regions in the vertical direction. Hopefully this won't matter too much and eventually we will be able to use `Flat` vertical directions. As for the file structure, I think some functions can be generalized to work for any model rather than split, like `store_tendencies!` (it perhaps makes sense that `store_tendencies!` is independent of the model type). I think it's nice that the physics-specific functions will now be in `Models/IncompressibleModels`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396:715,variab,variables,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-725500396,1,['variab'],['variables']
Modifiability,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:73,refactor,refactor,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['refactor'],['refactor']
Modifiability,"> Does anybody know what is the rationale for `similar(::Field)` to drop the boundary conditions?. I think it depends on how you view ""boundary conditions"". If we adopt a ""weak formulation philosophy"" then boundary conditions are part of the definition of an equation set and don't belong to fields at all. This is how `ImmersedBoundaryGrid` works; inhomogeneous boundary conditions can only be enforced by adding boundary fluxes to a tendency. There's no such thing as a ""boundary condition"" outside the context of time stepping. Unfortunately, `Oceananigans` is not consistent in how this philosophy is applied and when we are on ""non-immersed"" grids we have more of a ""strong formulation"" philosophy. I believe the rationale for not transferring boundary conditions is the expectation that we will eventually adopt a ""weak formulation philosophy"" consistently throughout the code. In that case, non-default boundary conditions are meaningless on anything but prognostic fields that are evolved during time-stepping.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487:989,evolve,evolved,989,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882#issuecomment-1411317487,1,['evolve'],['evolved']
Modifiability,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1136,extend,extend,1136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878,2,['extend'],['extend']
Modifiability,"> Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support. It's also crucial for the semantics of `set_default_number_type!` versus simply ""set_number_type!"", ie we want to preserve independent settability for all parameters. We've been intentionally disciplined / conservative about ""no global settings"", so this would represent an adventure away from that philosophy. It seems well-motivated in this case. The only other parameter that can possibly appear more than once in Oceananigans (as far as I know) is gravitational acceleration (free surface and buoyancy). Good points about environment variables and portability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167:705,variab,variables,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2397234167,4,"['portab', 'variab']","['portability', 'variables']"
Modifiability,> Great job guys. @jagoosw have you been able to run this (https://github.com/CliMA/Oceananigans.jl/blob/19dac0b8f6b621057e250ecf0510b3c4c91915e9/validation/lagrangian_particles/particles_in_convection.jl#L30) on GPU?; > ; > . I haven't run that case on GPU but would have thought it will run if you change the grid architecture and adapt the initial particle positions (which is described in the simulation tips part of the docs). I can have a look later to see if I can run it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430:333,adapt,adapt,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1590920430,1,['adapt'],['adapt']
Modifiability,"> Greg, Doesn't Ali have a version of immersed boundary layers going?. @johncmarshall54, Ali experimented with a simple immersed boundary implemented via Oceananigans's user-defined forcing functions. The code is these 9 lines:. https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27. This implementation damps the velocity field to zero on a very fast time-scale (specified by the parameter `K`) within the immersed boundary. This is certainly a nice, simple immersed boundary implementation for Dirichlet / Value boundary conditions and could be a good starting point. However, I also think there's some good reasons to pursue an alternate immersed boundary implementation to what @ali-ramadhan has done:. 1. @ali-ramadhan's implementation doesn't obviously extend to other boundary conditions, like prescribed gradients or fluxes (the latter being crucial for the geophysical problems we're interested in). So, even if we use a continuous forcing method similar to @ali-ramadhan's implementation, we need to figure out how to enforce boundary conditions other than Dirichlet boundary conditions.; 2. @ali-ramadhan's implementation conforms exactly to the grid; however we would like to be able to model smoothly-varying boundaries.; 3. As noted by @whitleyv, @ali-ramadhan's ""continuous forcing method"" implementation introduces a time-step restriction due to the need to explicitly resolve the damping time-scale in the forcing function. It seems that a discrete forcing method overcomes this restriction and could prove crucial for geophysical problems that involve otherwise long time-steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244:56,layers,layers,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707412244,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:1459,refactor,refactoring,1459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413,1,['refactor'],['refactoring']
Modifiability,"> Hm.... `HydrostaticFreeSurfaceModel` does not support `BackgroundFields`.... Right, we do not support that right now. I think there are some niche uses but, for the most part, when we go hydrostatic we are often doing large scale and a bit more complicated modeling with parameterizations, etc, where getting background fields right would be more of a pain than with NonhydrostaticModel (which still does not work properly with nonlinear subgrid-scale turbulence closures). I think its better to go more mainstream for this example. I think the use cases that this example serves as a starting point for are probably not going to use background fields, typically.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020:273,parameteriz,parameterizations,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986920020,1,['parameteriz'],['parameterizations']
Modifiability,> Hmmm I thought this line would be enough; > ; > https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; > ; > but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think.; > ; > Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to.; > ; > But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666. Perhaps you are right that nowadays (with more recent Documenter versions) ; https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150; suffices. Bit while ago it wasn't enough! :) . I'll test it though and we'll find out.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270:229,variab,variable,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782353270,1,['variab'],['variable']
Modifiability,"> Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions. I think so. Let's definitely try!. Is it useful to have a general `Drag` boundary condition in general (in addition to `Periodic`, etc.), that would be used not only for immersed boundaries, but also for actual boundaries?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921:19,adapt,adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050120921,1,['adapt'],['adapt']
Modifiability,"> However, I found that the velocity shear at the first grid points is much larger than that predicted by the Monin-Obukhov similarity theory. I don't have much experience with solid wall boundary layers. A quick search returns this review:. https://journals.aps.org/prfluids/pdf/10.1103/PhysRevFluids.2.104601?casa_token=VBO0hrNqp-cAAAAA%3A3XEKZfLTdhiVluwRl8sCQCkOK44GoGUX-546uFtqQjSWAUIDQpKyyQsA4lQd65Oz6Kw5ClWias_CVQ0. suggesting that correct flux predictions in wall-modeled LES is unsolved. For example:. <img width=""616"" alt=""image"" src=""https://github.com/CliMA/Oceananigans.jl/assets/15271942/a6ffe67e-2009-441a-a440-80afe0dc4a70"">. shows a mismatch between DNS and wall-modeled LES for a few standard codes. Based on the literature, a failure to reproduce the log-law is expected?. It might help if you provide more background on what exactly you're trying to achieve, and why you believe the current approach will achieve that objective. For example, are we attempting to reproduce a known result?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364:197,layers,layers,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1650818364,1,['layers'],['layers']
Modifiability,"> I agree that the PoissonSolver struct is a better place to store the pressure boundary conditions, but what do you think of just storing them in model.boundary_conditions?. I don't like this idea, because I would like the tuple of boundary conditions to have the same length as the number of solution variables to permit easy and simple looping / code reduction / arbitrary tracer stuff in the future. . While not crucial, I think it makes sense (though of course we don't currently have a `solution` tuple, though that would be easy to add). Edit: we could achieve both aims by adding a level of hierarchy to `boundary_conditions`, so that it has fields `solution, tendencies, pressure`, (each of them a tuple), or something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861:303,variab,variables,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389#issuecomment-527167861,1,['variab'],['variables']
Modifiability,"> I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos. On the contrary with this approach you should be able to use the existing `construct_output`:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/OutputWriters/output_construction.jl#L44-L46. which is designed for `Field` / `AbstractOperation` already. So I think again with this approach the kwarg `with_halo` is irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823:133,config,configured,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450926823,1,['config'],['configured']
Modifiability,"> I also suggest changing the module name to Buoyancies or BuoyancyModels and reserving Buoyancy for the user-facing object. The current names that @ali-ramadhan and I used were always meant to be a placeholder as we couldn't agree on good ones to use. I quite like this suggestion (and I suspect @ali-ramadhan does too) so I implemented it.; Just as a reference, here are the commands that I used (plus the same for the struct `Buoyancy`):. ```bash; find . -type f -name ""*.jl"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; find . -type f -name ""*.md"" -exec sed -i ""s/\<Buoyancy\>/BuoyancyModels/g"" {} \;; ```. I also added an example in the sandbox that runs a fully quiescent fluid with a tilted stratification for an hour and then makes sure that the vertical and horizontal derivatives stay the way we expect them. (This test is done both for `BuoyancyTracer` and for `SeawaterBuoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154:651,sandbox,sandbox,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-795853154,1,['sandbox'],['sandbox']
Modifiability,"> I am not sure that I am following everything there. Is it for flux-form of vector-invariant ? otherwise, I don't recognize the energy-conserving discretization (thought it would have been nice to have). I didn't realize the the Coriolis implementation is different for the ""flux-form"" momentum equations than for vector-invariant momentum equations --- thanks for pointing that out @jm-c. I don't quite understand why this is the case. However, it is not that difficult to extend our Coriolis implementation to dispatch on the `advection` ""scheme"" / form if we need to. After looking into the details (see below), it would appear that the implementation we are using is correct if. 1. The horizontal grid is regular; 2. The horizontal grid is curvilinear and we are using `momentum_advection=VectorInvariant()`. Because these are the only two possible cases, I believe the current Coriolis implementation is sufficient. However when/if we support curvilinear horizontal grids with flux form advection terms, we will (if we follow the MITgcm implementation) need to dispatch the evaluation of the Coriolis term on `momentum_advection` scheme. Another question is whether it even makes sense / is physically consistent to support `FPlane` and `BetaPlane` on grids that are sectors of the sphere. Perhaps there's no point at all in implementing a curvilinear-friendly version of `FPlane` and `BetaPlane`. If this is true, we can revert back to the prior implementation of both for Rectilinear grids, and focus on a energy/enstrophy - conserving Coriolis scheme for curvilinear grids on the surface of the sphere. # Some notes on Coriolis implementations for vector-invariant and flux form momentum schemes . Focusing on the x-component, the [MITgcm documentation](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8) writes that with a vector-invariant advection scheme, the Coriolis term that preserve potential enstrophy is. <img width=""228"" alt=""image"" src=""https://user-images.gith",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799:475,extend,extend,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384#issuecomment-782741799,1,['extend'],['extend']
Modifiability,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:561,variab,variables,561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['variab'],['variables']
Modifiability,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:376,flexible,flexible,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311,2,['flexible'],['flexible']
Modifiability,"> I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain.; > . Yeah sorry, that was very imprecise of me. I more mean that that case was a good demonstration of a situation where we need a very large domain to not effect the interior solution in the area we are interested in, or have a matching scheme. > I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence. That sounds good in the long term. Do you want that all for this PR or can we merge this part after I've implemented a simple matching scheme as a demonstration and then work on the rest elsewhere?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373:280,layers,layers,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2037435373,2,['layers'],['layers']
Modifiability,> I can adapt `GridFittedImmersedBoundary` for `IncompressibleModel` in a separate PR if that makes sense?. I think a separate PR is best. It's really a research PR since we don't have a recipe so the validation process will probably be more involved. It's not clear what algorithm we should choose for `IncompressibleModel`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448:8,adapt,adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-839931448,2,['adapt'],['adapt']
Modifiability,"> I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine... What is your setup? Is your MPI executable path exported in the bash? Do you have a `Localpreferences.toml` file generated from MPIPreferences? ; Another way to use MPI.jl is through the [mpiexecjl](https://github.com/JuliaParallel/MPI.jl/blob/master/bin/mpiexecjl) command. I typically just use the mpirun executable, but this other approach might help",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458:167,config,configuration,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282771458,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,"> I can't see the modifications to `geostrophic_adjustement.jl` that were made on this PR --- have these changes been pushed?; > ; > I don't think `Flat` will work in the vertical for `HydrostaticFreeSurfaceModel`. We have to inspect the way vertical velocities are calculated but I believe it will fail. Perhaps we need a more general algorithm, or we can write code to deal with that special case. I don't think its important (aside from testing) since if one wants to run a shallow water model they might be better off using `ShallowWaterModel`... Sorry, since that example didn't work I decided to restore that example to master. If you wanted to see the minor changes that I have done you can go here https://github.com/CliMA/Oceananigans.jl/pull/1513/commits/f372a5e5aa2c5d9cb3cdc9d0bc3104df5f1de184. I added in some `Flat` tests to `test_hydrostatic_free_surface_models.jl` and I'm happy to say all of those pass. Actualy, since last night all checks have passes so this PR seems to be in the clear. I should mention that I did adapt the `cell_advection_timescale` to deal with a vertically stretched grid and my solution might not be the cleanest but it does work. I do wonder whether something similar needs to be done to `cell_diffusion_timescale`. . One issue is that this version of `lid_driven_cavity.jl` is different from `master` but restoring that should be easy, if that's what we decided to do. Another thought: `HydrostaticFreeSurfaceModel` is labelled as experimental. If for some reason `Flat` does no work completely with that model, I suppose it's not as bad as it seems to work with the other two models, as far as I can tell. @glwagner if you are able to review this PR and tell me what other concerns you have or other tests we need to do, I can certainly try and do those.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000:1035,adapt,adapt,1035,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513#issuecomment-810123000,2,['adapt'],['adapt']
Modifiability,"> I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > although I imagine that could use a lot more memory if there were a large grid and small amount of particles. It seems the memory requirement of the forcing function approach is proportional to the number of _tracers_, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125:1226,flexible,flexible,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125,1,['flexible'],['flexible']
Modifiability,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:305,maintainab,maintainable,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029,1,['maintainab'],['maintainable']
Modifiability,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:235,flexible,flexible,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241,1,['flexible'],['flexible']
Modifiability,"> I have also realised that we need to have an exterior value for every open boundary for when the flow spontaneously becomes an inflow so I think it would make sense to have every open boundary be the same and just be `OpenBoundaryCondition(external_value)`, and then put the tendencies etc in as arguments to `_fill_X_halo!`. Then when `U_b` is negative we either set the value or do nudging like in ROMS to prevent shocks (but I think this is a question for further down the line). We might also want to consider oblique waves but that shouldn't be too hard to extend to we might just have to calculate a lot of surrounding points which might motivate some other way to do it.; > ; > Does this make sense to everyone? I also can't see an obvious way to get Δt to the halo fill since it doesn't even make it into the `update_state!` so any suggestions would be appreciated. To clarify, the statement ""when U_b is negative"" means more generally ""when U_b implies inflow into the domain"". It makes sense to me that inflow is prescribed, whereas outflow is a little tricker, requiring us to smoothly advect information out of the domain. Having the boundary condition depend on the previous time-step does seem to break assumptions we have made about how information flows. For example, we call `update_state!` during model construction. How does the first time-step / initialization work with this kind of outflow model? It might help to consider that. Practically speaking it would not be hard to pass the time-step to update state. But it might be nice to understand the implications before committing, because a different design / redesign could make sense. For example I supposed we would need to have a default ""time step"" that is 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289:564,extend,extend,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1972515289,1,['extend'],['extend']
Modifiability,> I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. I don't see it; did you push?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077:81,evolve,evolves,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1975080077,1,['evolve'],['evolves']
Modifiability,"> I have only used overwrite_existing=false without a checkpoint for short tests within the same Julia instance to extend the model output. Thank you for pointing out this use case. I think this is another situation that could be solved by waiting until `run!` for initialization. We can analyze an existing file and determine whether or not any data within the file will be overwritten based on the simulation parameters (current time, stop time). Another idea by the way would be to move the concept of ""overwriting"" to `run!`, as well. Then the single keyword can apply to all output, or not, which presumably more aligned with what a user would want (rather than toggling `overwrite_existing` for each writer individually).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348:115,extend,extend,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2392171348,1,['extend'],['extend']
Modifiability,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:409,config,configured,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918,2,['config'],['configured']
Modifiability,"> I hope this description of the workflow is clearer. It's clear!. > I thought the optimal implementation is to append to the previous existing file when using checkpoints. Of course I agree with this. I think our basic principle should be that there is no difference in workflow, either for running or analysis, between scripts for checkpointing or not. Also, I think that `overwrite_existing` should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. > If I don't change the name each time I pickup, with the overwrite_existing=false it crashes, and with overwrite_existing=true it rewrites all the files. If we have a system that does not overwrite files when picking up from a checkpoint, do you think that it will be necessary to have `overwrite_existing=false` by default? In this case, the only time we risk overwriting files is when we _re-run_ a simulation from the beginning. Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:. In my experience, I typically set up a script with `overwrite_existing=true` from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed `overwrite_existing=false` because of some concern about overwriting data. It's inconvenient, in fact, to set `overwrite_existing=false`. My thought is that it makes more sense to ask people to intentionally request `overwrite_existing=false` in the _rare_ case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Also, even for this purpose I don't really want a ""non-overwriting guarantee"" as a feature. I would prefer something like ""unique_filenames = true"" or something, which I could then ""turn on"" if I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201:645,rewrite,rewrites,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2392162201,2,['rewrite'],['rewrites']
Modifiability,"> I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > ; > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?. I don't quite understand the question --- what would you like a reference for?. It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know. We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372:204,variab,variable,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372,1,['variab'],['variable']
Modifiability,"> I mostly do it to keep a consistent size and chunks across files for post-processing. Ok! Curious how this will evolve, we eventually hope to support FieldTimeSeries for NetCDF which will give us some options to design various productivity features...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831:114,evolve,evolve,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393589831,1,['evolve'],['evolve']
Modifiability,"> I see your point _but_ I don't think an example in a GitHub repo is the place to introduce notation. I dispute that I'm introducing new notation! Both `=` and approx have unambiguous meaning. Let me elaborate on ""why approx"":. Oceananigans solves the full N-S with nonlinear terms. The script's power method algorithm will fail if the eigenmode to grow too much --- this is a real pitfall of the power method. The purpose of the approx symbol is to concisely illustrate why this can happen. This is crucial to explain for users who want to experiment with the script, change parameters, and adapt it for new problems. We can explain this all in words, but I thought the approx is _visual_ which is helpful. Even just scanning the document you see, this equation involves an _approximation_. The approx is, in fact, a more precise and correct representation of the problem. We can in fact regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms. It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701:593,adapt,adapt,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720089701,1,['adapt'],['adapt']
Modifiability,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1589,evolve,evolved,1589,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['evolve'],['evolved']
Modifiability,"> I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`. sounds good",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030:129,refactor,refactor,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437202030,1,['refactor'],['refactor']
Modifiability,> I suggest we remove the parameter for `gravitational_acceleration`.; > ; > @francispoulin any objection to that?. Please don't remove the parameter. It appears in the model equations and we need it to evolve the momentum equations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047:203,evolve,evolve,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2955#issuecomment-1453388047,1,['evolve'],['evolve']
Modifiability,"> I think for sophisticated research Checkpointing is common, but for simpler classroom and LES applications the checkpointer is used less. After all, probably the most simulations are actually run in our examples on CI -- and there are no examples with a checkpointer! (It would be nice to change that). Agreed!. > I can't speak for others, but for boundary layer parameterization work the LES typically run in less than 24 hours of wall time. We also only utilize very simple diagnostics, like the horizontally-averaged solution at the final time step. So in those rare cases that we need a checkpointer (I have used a handful of times) barebones checkpointing is sufficient.; > ; > Of course we are currently working on building a OMIP simulation and that will require much longer runs, so we will definitely need more sophisticated checkpointing very soon.; > ; > @simone-silvestri and @tomchor might have more to add. Or @sandreza, what do you use for the neverworld work?. For context, 100% of my simulations have used checkpoints. As far as I know, 100% of the simulations from others in my group also use checkpoints. The only exceptions for my case are very early scripts still in the development phase, and still with very coarse grids. As soon as I try to get more serious with it, I need checkpoints. So this a PR I'm very much looking forward to seeing merged ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720:365,parameteriz,parameterization,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2305164720,2,['parameteriz'],['parameterization']
Modifiability,> I think it would be better to add an interface for precomputing the boundary conditions and then add a line to `update_state!` that does this. It's more explicit. To do this wouldn't I need to make the boundary condition mutable and adapt it for GPU? That's why I didn't originally go down the route of making the velocity explicitly part of the boundary condition.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869:235,adapt,adapt,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1978824869,1,['adapt'],['adapt']
Modifiability,"> I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all.; > ; > In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"".; > ; > There's a few things I think should go in before 1.0:; > ; > * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; > * Resolve [Should we store `architecture` in `grid`? #1825](https://github.com/CliMA/Oceananigans.jl/issues/1825) (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; > * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot.; > ; > It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature. in my opinion, for v1.0 we should finalize spherical implementations and bathymetry also...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635:1013,refactor,refactor,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882109635,2,['refactor'],['refactor']
Modifiability,"> I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. Sorry I wasn't clearer before. > To re-use that code with a new `condition`, we can use a nesting technique:; > ; > ```julia; > function getbc(open_bc::OpenBoundaryCondition, ...); > state_value = getbc(open_bc.condition.external_state, ...); > # other stuff related to matching; > end; > ```; > ; > This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. I can see how this could work. As it currently is `getbc` expects a full `BoundaryCondition` so we would need to-do some rewriting of that to unpack like `getbc(bc::BoundaryCondition, ...) = getbc(bc.condition, ...)` and then modify all of the existing `getbc` methods. > On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. I see your point. For e.g. gradient boundary conditions it feels like the ""boundary condition value"" being the gradient at the boundary has about as much meaning as the boundary condition value for an open boundary condition being the external state and then we do some matching to get the internal solution to approximate it. But its quite unclear since an open boundary isn't mathematically defined like the other conditions so I think whatever we settle on is really equally as valid. . `getbc` is also not part of the API right? So if in the new code we say `external_value = getbc(...)` it should be clear enough to a future developer how it's being used and we shouldn't need to worry that a user would be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582:616,rewrite,rewrite,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1991781582,2,['rewrite'],['rewrite']
Modifiability,"> I think we should fix this problem first by generalizing the code so that explicit references to grid properties don't appear anywhere (instead we should use functions like all_x_nodes, etc). Changing the name of the grid property can come last (as a purely aesthetic improvement). Interesting consideration. I was gonna take a crack at fixing this in order to expedite my validation of the tilted buoyancy, but I think, given all the talks going on about the grids etc, I'm gonna let that one for you guys to solve. > Ah, I think you using IPython, rather than python, correct? I believe Jupyter notebooks support backslash / latex notation for expressing unicode, but IPython may not. Jupyter uses IPython for it's kernel (by default at least I think), so that ability comes from IPython. In any case, that doesn't work for all unicode characters. Just the ones that python can recognize as valid variable names (which I believe is [every unicode character that represents characters in written languages](https://python-3-for-scientists.readthedocs.io/en/latest/python3_features.html)). So all greek letters can be typed LaTeX style, but subscripts and supercripts can't, along with many other ones that are valid names in Julia. So if nothing is done to ""translate"" these variable names when writing NetCDF files, it's unfortunately going to be hard to deal with Oceananigans output outside of Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731:901,variab,variable,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799804731,2,['variab'],['variable']
Modifiability,"> I think wrapping `Base.Broadcast.materialize!` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/6730e6f6b2c8f1695e20b95ef467b5b14fdc4c5f/src/Fields/broadcasting_abstract_fields.jl#L24; > ; > around `@apply_regionally` for multi region fields might do the job. Or we can extend `materialize!(dest::MultiRegionField, ...)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485:279,extend,extend,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3577#issuecomment-2093438485,1,['extend'],['extend']
Modifiability,"> I want to merge this then use it to develop the user API for immersed boundary fluxes.; > ; > Also, did anyone use this?. I haven't used this, but I can test it if you want. > Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations.; > ; > It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...). Shaved cells are definitely preferred in terms of accuracy (and convergence with resolution), but might not be necessary in a number of cases. My intuition from seeing results from papers (and from previous LES+IBM at my previous group) is that partial step cells would be almost as accurate as shaved cells (at least for oceanic cases with mild bathymetry slopes) but significantly simpler to implement. Since we already have the full-cell grid-fitted IBM it might be better to just focus on that for now and later modify it to make it partial-step when everything is working well (I think we'd just need to modify the calculation of vertical areas and volumes, no?). Also, when running ocean LES the aspect ratios are generally isotropic (Δz/Δx~1) but the bathymetry slopes are very small, which means that for some cases even full-step grid-fitted IBM might be enough. Only some tests will tell for sure though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266:614,parameteriz,parameterizations,614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100238266,2,['parameteriz'],['parameterizations']
Modifiability,"> I wasn't specific about time because I wasn't sure. I often find myself spending way longer on PRs than I initially anticipate so I'm generally not very good at assessing these things lol. ok ok! Here's a rule of thumb: a bugfix or refactor is the least committment, because you can get away with no new tests or docs. A new _feature_ takes more time because of documentation. One should expect to spend most of their time on docs and tests. If you're spending a lot of time implementing a feature, then either the feature is very complicated / hard, or your workflow can use some improvement. Among new features, different types of features require different amount of effort. This case is one of the easier cases --- it's extending functionality without changing existing functionality, also its fairly niche (at this point) so simple documentation will suffice. The work required to test the feature also has already been partially completed (the script you posted). Other features, like adding new _physics_ will take much longer, because often you'll have to run a full validation case + analysis to assess whether things work as expected. So even if the source code change is small to implement new physics, the validation will take a while and dominate the development effort. If a new feature also requires changing existing functionality / refactoring, that's going to take the most amount of time, because you will probably also have to change existing tests. And many tests are poorly written, so updating test code is a potential rabbit hole.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258:234,refactor,refactor,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2093480258,6,"['extend', 'refactor']","['extending', 'refactor', 'refactoring']"
Modifiability,"> I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. We have an implementation like that for `fill_halo_regions!` here; > ; > https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78; > ; > What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields.; > ; > On the other hand, if defining a new type is useful for OutputWriters I am ok with it. The new commit follows the suggestion of overloading the `compute!` method to apply it on a tuple of `ComputedField`. I also added a check to make sure that all these fields are `FullField`. However, I wonder whether we should throw an error when any of these fields is not a ""full field"" or we should follow the implementation of `fill_halo_regions!` to fill these regions using different methods?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036:550,extend,extend,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694253036,1,['extend'],['extend']
Modifiability,"> I'd love to hear feedback about this design.; ; Maybe I'm personally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily speci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:409,flexible,flexible,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,2,['flexible'],['flexible']
Modifiability,"> I'm assuming this is a relatively simple issue to resolve?. Unfortunately not due to our current algorithm that we inherited from MITgcm, but which we hope to change pretty soon. Right now Oceananigans splits up the pressure into the hydrostatic pressure anomaly and the non-hydrostatic pressure (see https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/pressure_decomposition/). MITgcm did this to facilitate easy switching between a hydrostatic mode and a non-hydrostatic mode: to turn a non-hydrostatic model into a hydrostatic one, just don't compute the non-hydrostatic pressure and recompute w from the continuity equation. But we feel we can use multiple dispatch to implement a hydrostatic model in Julia. This algorithm also requires extra memory (2 pressure fields instead of just 1). So we're hoping to change the algorithm to only use 1 pressure field and get rid of this pressure decomposition. The algorithm also makes it difficult to implement tilted gravity because the hydrostatic pressure anomaly is computed as. ```; pHY′ = ∫ buoyancy_perturbation dz from z=0 down to z=-Lz; ```. where `buoyancy_perturbation = g * (αT - βS)` if you're using a linear equation of state. So now if gravity is tilted it's not just a vertical integral. I'm actually not sure how to modify the vertical integral if gravity is tilted... Seemed easier to move away from this vertical integral by not decomposing pressure then we should be able to easily add in support for tilted gravity via a `bg⃗` term in the momentum equation where `g⃗ = g⃗(x, y, z)` can be whatever the user wants. Not sure if we have an issue discussing this change to the pressure decomposition, but if it doesn't exist then I can open one to track progress on it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605:117,inherit,inherited,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1151#issuecomment-732369605,1,['inherit'],['inherited']
Modifiability,"> I'm confused as to what T would be here. It feels like it should be simulation.Δt, but that wouldn't work for variable Δt. The time interval that user specifies, `TimeInterval(T)`. > We probably would need to discuss how that would interact with min_Δt from the TimeStepWizard, no?. I hadn't thought of that. But `min_Δt` is not a global constraint, it's only the `min_Δt` that the TimeStepWizard specifies. The simulation `Δt` can still be smaller.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707:112,variab,variable,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104627707,1,['variab'],['variable']
Modifiability,"> I'm not sure I exactly understand whats changed here because of all the renaming. The important changes are here right?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Utils/kernel_launching.jl#L120-L158; > ; > And this makes it so that instead of being able to optionally fill the right boundary point, you can set it to `true` and it will instead compute 2:N for face fields (and presumably still 1:N for center fields)?. Heh, I'd argue that without the renaming it would also be hard (harder) to understand! Especially for me... The outcome of this PR is a key change to the computation of nonhydrostatic tendencies, here:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl#L104-L115. In addition to that, we do not update the periphery regardless:. https://github.com/CliMA/Oceananigans.jl/blob/7cc97812d42982b2c8bd5635b40f807e800b2472/src/TimeSteppers/runge_kutta_3.jl#L172. The keyword `exclude_periphery` propagates into `work_layout` as noticed. When we use the `:xyz` specification, ask for `exclude_periphery`, and the location is `Face` and the topology is `Bounded`, then the kernel is configured to loop from 2:N. Otherwise, it loops from 1:N as usual. Hope that helps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646:1256,config,configured,1256,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3814#issuecomment-2393866646,1,['config'],['configured']
Modifiability,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > […](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option. — You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:524,Adapt,Adapt,524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502,1,['Adapt'],['Adapt']
Modifiability,"> I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. `ShallowWaterModel` is totally independent from the other models --- so this is up to how `ShallowWaterModel` is written. But in a shallow water system it seems (based on the discussion on this thread) that bathymetry is treated via pressure gradients (and also vanishing layers or other techniques to handle outcropping). So we won't use `ImmersedBoundaryGrid`, which is how complex domains are handled elsewhere in Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977:465,layers,layers,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977,1,['layers'],['layers']
Modifiability,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:514,flexible,flexible,514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['flexible'],['flexible']
Modifiability,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:141,refactor,refactored,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532,3,['refactor'],"['refactored', 'refactoring']"
Modifiability,"> I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm. https://github.com/CliMA/slurm-buildkite is what is being used IIUC. . Oceananigans doesn't use this afaik, but instead just uses runners on a private compute node.; Looks like me, @glwagner or @charleskawczynski have the right priviliges to create an agent token.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736:28,config,configure,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328798736,1,['config'],['configure']
Modifiability,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:178,layers,layers,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,2,['layers'],['layers']
Modifiability,"> If we take a look at those other kernels, maybe we can get to the bottom of it?. Actually now that I'm checking my scripts, I have always differentiated arguments passed as a `computed_dependency`. I hadn't paid attention to this before but I've never differentiated a variable that I created _inside_ the kernel, as is the case with `wp`. Apparently this is yet another limitation of GPU computing that I wasn't aware of. For my application this already solves the issue, as I can just define a vertical derivative kernel and pass the abstract operation `w*p`. But for the sake of the general user: is there any way around this limitation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346:271,variab,variable,271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786715346,1,['variab'],['variable']
Modifiability,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:857,extend,extending,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,1,['extend'],['extending']
Modifiability,"> In line 39, where I define the background buoyancy of the jet, I can't use coriolis.f because CUDA seems to need a global variable and this doesn't cut it. This isn't a GPU issue I don't think because initialization is done on the CPU. I don't see a `coriolis` object defined in your script. You may need to write `model.coriolis.f`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759:124,variab,variable,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815045759,1,['variab'],['variable']
Modifiability,"> In python the convention is to put import statements at the top of a file? So the python convention is not to have local import statements. Since every file is a module, this means that in python import statements are at the top of modules by convention.; > ; > In julia modules can be split among many files. Thus if imports are at the top of a file, they are scattered within the module. I meant ""more local"" so putting `import` and `using` statements at the top of each file. I think putting them at the module level makes module files messy/cluttered and actually makes it harder to see where and how imported functions are used and overloaded. > One reason to put things at the top level is so that its easy to see at a glance what a package imports. It's also nice to see what methods are being extended via implication; for example if one sees `import Base: +` we can expect that `+` is redefined. If I want to check what a package imports, I will check the `Project.toml`. I think it's very rare for me to check ""what a module imports"". The much more common case in my experience is I'm looking at a file and see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:803,extend,extended,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['extend'],['extended']
Modifiability,"> In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Are you sure? This could mean that the advecting velocity is extracted at time-step `n` but we are using a radius from `n+1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345:41,evolve,evolve,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1873552345,1,['evolve'],['evolve']
Modifiability,"> In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?. That's right. The ""nonlinear Coriolis term"" in the vector invariant advection scheme requires reconstructing the vorticity at the locations of the x- and y-momentum. This PR implements WENO reconstruction of this term with two possibilities for the smoothness calculation: `VorticityStencil()` ([Roullet and Gaillard](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2021MS002663)) and `VelocityStencil()` (uses velocity rather than vorticity to calculate smoothness coefficients, implemented in this PR). The API is probably WIP; hopefully we will smooth this out. Anyways, this scheme can be used by writing. ```julia; using Oceananigans.Advection: VelocityStencil, VorticityStencil. # and then. momentum_advection = WENO5(vector_invariant=VelocityStencil()); ```. for example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086:130,rewrite,rewrite,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081940086,1,['rewrite'],['rewrite']
Modifiability,"> Indeed, the boundary conditions for `U` and `V` should be the integral of boundaries for `u` and `v`. I am unsure about the boundaries for `η`; I think `η` is typically prescribed outside the domain in regional simulations, but we probably need to find a reference for that. For reference, I think ROMS currently uses the algorithm described [here](https://www.sciencedirect.com/science/article/abs/pii/S146350031000082X?via%3Dihub). I haven't read it carefully, but it seems to project both `U` and `η` to a common point outside of the domain, calculate a variable that depends on both quantities (Eq. (2)), and specify the BCs for both based on that. (Likewise for `V`.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930:559,variab,variable,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930,1,['variab'],['variable']
Modifiability,"> Is it worth to rotate x- and y-stretched grids so that the stretching is in the `z` direction and then use the tridiagonal solver behind the scenes? I have no idea how slow something like that would be on a GPU. I think it might be more fruitful to generalize `BatchedTridiagonalSolver`. It's a little annoying (our fault for using `i, j, k` rather than `CartesianIndex`...) --- but we can probably figure out how to rotate indices in https://github.com/CliMA/Oceananigans.jl/blob/a314f1f64e80181ecff84d6bab1e5182644d95cc/src/Solvers/batched_tridiagonal_solver.jl#L91. Not a small refactor, so I'd argue not priority 1 right now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655:583,refactor,refactor,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023499655,1,['refactor'],['refactor']
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. I would wait for KA to merge (we do not want to depend on a branch). . On the other hand, I would prefer not to wait for KA to have this PR ready to merge so we can merge the two PRs in rapid succession and not take time to refactor/review this one later (it would be better to merge this by July 15th and I think it has some major changes we want to discuss before). In the end the KA PR just handles how offsets are used in indexing kernels. I don't think that API will change even when changing the internals, and even if it does, it is just a matter of changing one function (`launch!` in `src/Utils/kernel_launching!`) to reflect the API changes",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611315191,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"> Is the PR on KA very crucial?; > ; > Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?. Sorry, I misunderstood. Yeah, it would be indeed a bit of refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008:60,refactor,refactoring,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1611394008,2,['refactor'],['refactoring']
Modifiability,"> Is the vertical velocity generated over the piecewise constant topogrpahy something that is of a concern? When I increased the resolution I believe I saw the vertical velocity generated increased as well. I agree with @glwagner that it's concerning at least for your current configuration. My guess is that with bottom drag and a more turbulent simulation that might not be a huge problem. But as it stands it's definitely affecting the dynamics. (Btw, I say that because I've run a fair amount of turbulent simulations with immersed boundaries at this point and I've never seen this being an issue in my simulations. But they are always turbulent.). > I think so! Is this with GridFittedBottom or PartialCellBottom? I feel like this motivated cut / shaved cells. @glwagner reading the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/Test_ImmersedBoundaryMethod/validation/immersed_boundaries/linear_bottom_example_take1.jl) it seems that it's a `GridFittedBottom`. @francispoulin Like Greg mentioned, shaved cells would be ideal here, but since we don't have that yet, I'd suggest trying out the `PartialCellBottom`. I expect some improvement there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617:277,config,configuration,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028920617,1,['config'],['configuration']
Modifiability,> Is there any other model that may be impacted from this?. As mentioned in a DM I don't think `HydrostaticFreeSurfaceModel` supports vertically-flat configurations; even with one grid point in the vertical we may need vertically `Bounded`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014:150,config,configurations,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2093#issuecomment-985522014,1,['config'],['configurations']
Modifiability,"> Is this still an issue?. Apparently not anymore. I just tested @navidcy 's MWE are everything seems to work fine (on a Quadro GPU and CUDA 3.12 on `main`):. ```julia; julia> grid; 150×150×12 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=5.00e+01, max(h)=5.00e+01); ├── underlying_grid: 150×150×12 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-200.0, 200.0) regularly spaced with Δx=2.66667; ├── Periodic y ∈ [-200.0, 200.0) regularly spaced with Δy=2.66667; └── Bounded z ∈ [0.0, 100.0] variably spaced with min(Δz)=8.33333, max(Δz)=8.33333. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807:625,variab,variably,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807,1,['variab'],['variably']
Modifiability,"> It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether. Don't know if it's always possible but if we can avoid temporary variables by aggressively inlining all calculations, that would be cool. Every temporary field saved means being able to run a larger model on GPUs. We will always need a couple of temporary arrays so if we can't inline we can just try to share and reuse the temporary arrays as much as possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396:227,variab,variables,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468751396,1,['variab'],['variables']
Modifiability,"> It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Just to make sure I understand correctly: you're talking about expanding the use of the already-existing keyword argument `field_dependencies` to include not only prognostic fields (which apparently is the current status), but all fields. If that's correct, I don't see why not. It'd make the code more flexible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785:500,flexible,flexible,500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785,1,['flexible'],['flexible']
Modifiability,"> It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs. Agreed. https://github.com/CliMA/Oceananigans.jl/pull/3080 is for now just a start to see if anything significant breaks. So far everything looks OK there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862:21,refactor,refactor,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518198862,1,['refactor'],['refactor']
Modifiability,"> It's something to do with GPU, maybe GPU reductions?; > ; > ```; > [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; > --; >   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199; >   | Expression: minimum_xspacing(grid) ≈ FT(π / 3); >   | Evaluated: 0.0 ≈ 1.0471975511965976; > ```. I see this error. But I can't reproduce it. On tartarus it's not happening and I don't have access to Svedrup. So I don't know what to do... :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080:122,variab,variably,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1566845080,1,['variab'],['variably']
Modifiability,"> Its ok for there to be a divergence in the slip velocity. In the case of the ocean surface or seafloor that's exactly what you want since the particles will then accumulate at those surfaces depending on whether they are light or dense. Tracer is conserved in an integrated sense since the flux through the boundary vanishes. In some cases the user might want a flux across the boundary, e.g. for dense particles sinking through an open boundary at the bottom of the domain, so we probably want the profile of the slip velocity in the user's control. Also, note that for very buoyant tracers there will be numerical issues if the tracer all accumulates at the surface. Finer grid spacing can help a bit, but I think this is a drawback to using buoyant tracers and particles work better in those cases (Jenny discusses this in her draft paper on microplastics which is under review). That makes physical sense!. I believe supporting divergent slip velocities means we cannot use the ""flux form"" of the advection term, ie we cannot rewrite. ```; u_slip ⋅ ∇c = ∇ ⋅ (u_slip c); ```. correct? This means that we cannot use native Oceananigans operators for this advection term, since the operators we've implemented all assume that the advecting velocity field is non-divergent. This is not much of an issue since we can easily write a second-order discretization of `u_slip ⋅ ∇c`. In addition, we can support a flag in which users might optionally declare the velocity field as non-divergent, in which case we can use higher-order discretizations of `∇ ⋅ (u_slip c)`. Perhaps `SlipVelocity` is a better name than `AdvectiveForcing` since it parallels the literature?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860:1032,rewrite,rewrite,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082424860,1,['rewrite'],['rewrite']
Modifiability,"> Just to clarify a point here. The background field here does not participate in the hydrostatic pressure, it only adds an advective term to the tracer equation which reads ∇⋅(uB). So in practice, you are solving; > ; > ∂tu+(u⋅∇)u=−∇p+g^b+Di(u) ∂tb+∇⋅(ub)+∇⋅(uB)=Di(b)+Di(B) where Di is the implicit diffusion coming from 5th order upwind. Yup, and just to clarify the physics behind this set-up, it is necessary when simulating things like doubly-periodic tilted boundary layers in a stratified environment (such as our [tilted bottom example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/)). @simone-silvestri not to sidetrack from the issue but isn't $\mathcal D_i(B)$ ignored in the evolution equation? I got that impression from reading the docs [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/background_fields/) and [here](https://clima.github.io/OceananigansDocumentation/stable/physics/nonhydrostatic_model/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866:474,layers,layers,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1490474866,1,['layers'],['layers']
Modifiability,"> Looks like a good interface to me.; > ; > But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?; > ; > @liuchihl will test it in our configurations. Well yes, it's substantial effort to support background fields. So we implemented it in the nonhydrostatic model first. Nobody has requested having background fields for the hydrostatic model. It's not impossible but might require some thinking if it's going to work with the more complicated turbulence closures (like CATKE or k-epsilon) that sometimes get used for hydrostatic applications. Since the nonhydrostatic model is fast (at least on one GPU) the hydrostatic model is mostly important for simulations on the sphere (although this statement needs to be evaluated more carefully for complex domains when we have a proper nonhydrostatic solver).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460:227,config,configurations,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2206898460,1,['config'],['configurations']
Modifiability,"> Looks like me, @glwagner or @charleskawczynski have the right privileges to create an agent token. I'm happy to help, but @glwagner is probably more familiar with the Oceananigans configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328997644,1,['config'],['configuration']
Modifiability,"> Luckily, I found a reliable way to get NaNs immediately is to set both reltol and abstol to zero and maxiter to more than a thousand. The purpose is to test the numerical stability of the iteration method. I think this makes sense. When the residual is reduced to near machine precision then I think this is when the present instability is exposed, which occurs when the search direction is essentially a constant. I wonder if its possible that the instability was observed in the original simulations when, for some random reason of the flow configuration, the CG solution converged especially fast (thereby exposing the instability).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546:545,config,configuration,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2420734546,1,['config'],['configuration']
Modifiability,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:794,parameteriz,parameterization,794,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650,2,['parameteriz'],['parameterization']
Modifiability,> Maybe compute_w_from_continuity! is missing a datatuple or something is missing from an adapted struct?. But it's only with the `RegularLatitudeLongitudeGrid` -- a model with `RegularRectilinearGrid` passes. 🤔,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534:90,adapt,adapted,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449#issuecomment-796257534,1,['adapt'],['adapted']
Modifiability,> Maybe it did need some of the overwrite existing because it writes different configurations to the same file; > ; > Update: passes locally if I add them back. hmm ok that's ok. Could also just manually delete the existing files which might save future pain / confusion,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051:79,config,configurations,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570923051,1,['config'],['configurations']
Modifiability,"> More out of interest, is there a benefit to passing variables explicitly?. Is this question about CUDA.jl behavior? I'm afraid I don't know, but this comment might help:. https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852. It could be worth asking on #gpu slack, or on https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107:54,variab,variables,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107,1,['variab'],['variables']
Modifiability,"> Multiple forcing is tested but all the forcing tests just check that they don't error, so I expect in this situation the advective forcing would have no effect but wouldn't error.; > ; > Perhaps all of the forcing tests should really have something checking that they are changed, the forcing a could all just be set to return 1 and then we check that all of the tracers that are forced are not zero at the end?. Mm yeah I can extend the existing test to pass only if the tracer distribution changes after that time-step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234:429,extend,extend,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3259#issuecomment-1715595234,1,['extend'],['extend']
Modifiability,"> My end goal here is to recreate the set-up in [this paper](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/frontogenesis-and-frontal-arrest-of-a-dense-filament-in-the-oceanic-surface-boundary-layer/2FFBE4503C590CE7BDB1B8BAA236C387) and see if I can see some submesoscale activity. This is just a proof (or disproof I guess) of concept, so I'm aiming for a coarser resolution and other simplifications. Any tips are greatly appreciated. If you're mostly interested in the oceanic boundary layer and don't need topography or a free surface, then Oceananigans probably has most of what you need. (See #443 if you're interested in surface physics.). 8192×3072×256 ~ 10¹⁰ grid points is out of our reach for the moment although our plan is to be able to run these super large simulations one day!. We're still limited to 1 GPU (with 16 or 32GB RAM) which lets us go up to ~5×10⁷ grid point. We could probably extend that to ~10⁸ grid points if we implement #98 but even then it would take 50-100 GPUs to reach 10¹⁰ grid points. We've mostly been running oceanic mixed layer simulations with a focus on vertical mixing so no need for a ton of horizontal resolution, but we do have horizontal mixing problems in mind at which point we'll need to start running on multiple GPUs with MPI. This is something we're starting to get serious about as we do need it ourselves. Not sure how coarse you can go but if you can go down to ~10⁸ grid points then maybe Oceananigans can be useful. If the factor of ~2 reduction in memory usage from #98 would be useful for you, let us know and we can look into implementing it. In general, I think we're happy to work together on features that you might need. I still need to work on some documentation to showcase all the model creation options, etc. so let us know if you're not sure how to impose a certain boundary condition or forcing, etc. Out of curiosity, what LES model are you currently using?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886:933,extend,extend,933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539743886,1,['extend'],['extend']
Modifiability,"> My fear is that making things less standardized (i.e. adding more possibilities), it'll be harder to spot these mistakes. It will mean that `set!` becomes more specific; ie two-dimensional set functions can only be applied to two-dimensional variables. I think there are more _possibilities_ for bugs if three-dimensional functions can be applied to two-dimensional variables. For example, you might accidentally assign the wrong initial condition to a variable. When half the variables are 2D and half are 3D, you have the possibility that a typo throws an error. We can add some `try catch` statements to throw helpful errors within `set!` when we encounter a `MethodError`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1777716631,4,['variab'],"['variable', 'variables']"
Modifiability,"> Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there. Hm ok got it, it depends on the status of what's returned",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438850544,1,['variab'],['variable']
Modifiability,"> OK! I'll review this!; > ; > so in Oceananigans terms is the `e-ϵ` parameterization, right?. I think we should call it ""TKE dissipation vertical diffusivity"", or k-epsilon in a nod to the literature. I don't think we shoudl call it ""e-epsilon"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889:69,parameteriz,parameterization,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2164357889,1,['parameteriz'],['parameterization']
Modifiability,"> OK, perhaps I'm a bit oblivious to physics of tilted gravity etc. Are is the tilted gravity crucially important for this to occur?. Apparently yes. This doesn't happen when the buoyancy acceleration is aligned with the model's z-coordinate. > Also, is there an energy integral associated with these dynamics when there is a fixed imposed buoyancy? Even in the continuous case, before we go to discrete world, is there guarantee that E should decrease?. That's a good point and as far as I can tell this system should have a a finite, non-increasing total energy since the background buoyancy is stable. So the background buoyancy shouldn't be introducing any extra energy reservoirs (unlike, for example, an Eady set-up, which constantly injects energy into the system by imposing a horizontal buoyancy gradient). My understanding of this comes mainly from [Umlauf et al (2015)](https://journals.ametsoc.org/configurable/content/journals$002fphoc$002f45$002f12$002fjpo-d-15-0041.1.xml?t:ac=journals%24002fphoc%24002f45%24002f12%24002fjpo-d-15-0041.1.xml). Their equation (24) applied to the set-up above (i.e. without any boundary stresses and without applying a Reynolds decomposition) reads. ```math; \frac{d}{dt}\int_V \left[ \frac{u_i u_i}{2} + \frac{b^2}{2N^2} \right] dV = ; - \int_V \left[ ; \kappa \frac{\partial_j b \partial_j b}{N^2} ; + \nu {\partial_j u_i \partial_j u_i}; \right] dV \le 0; ```. Also it's worth noting that even in a `(Bounded, Flat, Bounded)` domain I still get an energy buildup, although in this case the KE stops growing after a while:. https://user-images.githubusercontent.com/13205162/228590310-51b59910-2550-48c9-93a7-f22d70c2474e.mp4. I say that because this may be a more familiar set-up and because sometimes a tilted, periodic domain might introduce some unexpected effects.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882:910,config,configurable,910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1488852882,1,['config'],['configurable']
Modifiability,"> Ok I fixed that. Probably we should use a Field rather than ones for the test and examples, because it automatically adapts to GPU, distributed, etc, so it's a bit better. But I thought the whole idea is to be able to provide an `Array` for forcing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274:119,adapt,adapts,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1987930274,1,['adapt'],['adapts']
Modifiability,"> Ok I think I figured it out. The `Float64` values are coming in from functions like `depthᶜᶜᶠ` and `height_above_bottomᶜᶜᶠ`. The main issue is actually the grid coordinates not being fully `Float32`.; > ; > In particular, when coordinates like `grid.zᵃᵃᶜ` are ranges the reference and step size are `Float64`:; > ; > ```julia; > julia> r = range(0.0f0, 1.0f0, 16); > 0.0f0:0.06666667f0:1.0f0; > ; > julia> typeof(r); > StepRangeLen{Float32, Float64, Float64, Int64}; > ```. Can you clarify? You're showing the type of `r`, but not the type of the coordinate that would be produced by indexing into the range, which is what we care about. The docstring specifically says . ```julia; help?> StepRangeLen; search: StepRangeLen StepRange. StepRangeLen( ref::R, step::S, len, [offset=1]) where { R,S}; StepRangeLen{T,R,S}( ref::R, step::S, len, [offset=1]) where {T,R,S}; StepRangeLen{T,R,S,L}(ref::R, step::S, len, [offset=1]) where {T,R,S,L}. A range r where r[i] produces values of type T (in the first form, T is deduced automatically), parameterized by a reference; value, a step, and the length.; ```. Therefore `StepRangeLen{Float32, Float64, Float64}` should produce values of `Float32`. Is this not happening?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713:1038,parameteriz,parameterized,1038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445639713,1,['parameteriz'],['parameterized']
Modifiability,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106:823,variab,variable,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106,2,['variab'],['variable']
Modifiability,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:364,variab,variability,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['variab'],['variability']
Modifiability,"> One aspect of this change is that the models will no longer be concretely typed (because `OrderedDict{Symbol, Callback}` is not a concrete type). I'm not sure this matters, but it's worth noting this.; > ; > Thinking about the API issues, I wonder if there's another advantage in putting the state callbacks in `Simulation`, that we have a system in which a ""model"" is not modified after its created (eg we are not adding callbacks to it) --- that's something that we do with Simulations. With this PR, we mix the concepts of models and simulations. Which may be ok... Perhaps we could change it so you give the model a Tuple or NamedTuple of callbacks when you specify it so the API is more consistent and the model not modified after? I think it could be argued that state callbacks are part of the model rather than the simulation, like forcing functions are, since they could be an intrinsic part of how the model evolves, e.g. if it modified the tendencies. I suppose this argument could be made for some callbacks as well though so I don't know whats best!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047:920,evolve,evolves,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047,1,['evolve'],['evolves']
Modifiability,"> Or maybe we can do this just with `AbstractOperations`, the problem is that we have to define a ""helper"" model. I think extending the capabilities of the `DiscreteDiffusionFunction` is the right approach here. But I also think we should only make the necessary changes in abstract_scalar_diffusivity.jl and abstract_biharmonic_scalar_diffusivity.jl and leave the tendency kernels and existing closures (like AMD) unchanged. The only thing that needs to be done is `merge(U, C)` there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066:122,extend,extending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066,1,['extend'],['extending']
Modifiability,"> Personally, I don't think it's confusing. I also don't feel strongly either way though. Ah yes, totally agree that it isn't confusing. I wasn't arguing that it was confusing though. . In terms of _reading_ these code statements I much prefer seeing `pressure_solver = poisson_solver`. Its even pedagogical because it teaches you that we solve the Poisson equation for pressure. I love that and that is exactly why we chose this design. Please bear with me to understand the reason I am proposing this change. In practical usage / when coding new experiments it is easy to mix up ""pressure"" with ""poisson"". I've been working testing lots of different solvers these past few days, and keep accidentally typing `pressure_solver = ConjugateGradientPressureSolver(grid)` which is wrong. If it becomes more common to configure the pressure / poisson solver in the future (because we have better support for different solvers for irregular geometries) then I would like to also help others that may run into this issue. It's nice to have syntax that ""rolls of the tongue"", ie, is what you would type if you were typing without concentrating very hard. It's not big deal either. I just tend to think that if one makes the same syntax mistake multiple times, it's important to make sure you step back and consider whether the problem is you, or the syntax.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234:813,config,configure,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234,1,['config'],['configure']
Modifiability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:948,parameteriz,parameterization,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,2,['parameteriz'],"['parameterization', 'parameterization-derived']"
Modifiability,"> Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at n and the time step at n-1 to be correct. It seems like a good idea to use this. . Although, I think we basically always recommend using RK3 for `NonhydrostaticModel`. . Would another path forward be to also implement RK3 for `HydrostaticFreeSurfaceModel`, and basically deprecate any recommendation to use AB2 at all? It's just so much more convenient to use RK3 and also seems to have better numerical properties, not least in light of this issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477,2,['variab'],['variable']
Modifiability,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:229,refactor,refactor,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388,1,['refactor'],['refactor']
Modifiability,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:104,layers,layers,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717,2,['layers'],['layers']
Modifiability,"> Should also restructure the new `ShallowWaterModel` version in a similar way. Quite! In the context of `ShallowWaterModel`, this will only effect 1D models where adaptive time-stepping may not be that useful (because the vertical dimensions is `Flat` _a priori_). But we can add it there too if we think that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226:164,adapt,adaptive,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226,1,['adapt'],['adaptive']
Modifiability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:26,extend,extend,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['extend'],['extend']
Modifiability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:133,inherit,inherit,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['inherit'],['inherit']
Modifiability,"> So whatever's happening probably has to do with the HydrostaticModel, which I'm really not familiar with unfortunately.; > ; > What do you prefer that I do?. the hydrostatic model does not have `w` as state variable... try removing `w` and see if all is good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409:209,variab,variable,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409,1,['variab'],['variable']
Modifiability,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:184,config,configured,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533,1,['config'],['configured']
Modifiability,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:1569,variab,variably,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,2,['variab'],['variably']
Modifiability,"> Some sandbox stuff might've been added by accident. Ah, thanks for catching that. I was investigating the stretched grid + timestep wizard thing. Should be good now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034:7,sandbox,sandbox,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034,1,['sandbox'],['sandbox']
Modifiability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:105,adapt,adapt,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:96,variab,variability,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489,2,['variab'],['variability']
Modifiability,"> Sorry, let me rephrase, users shouId pass clock and fields only when boundary conditions require it, so we need some type of warning to make sure the error is well documented.; > ; > I think it is nice to have `fill_halo_regions!(field)`, it will be a bit cumbersome to always have to pass a clock and fields also when non using complex BCs. It's not even possible to construct a field with `ContinuousForcing` outside a model constructor. The model constructor has to do things like compute the index of `fields(model)` that a field name belongs to. So its more than cumbersome, its not possible. Also we need to prioritize. We are trying to do simulations, not have uber fancy flexible field abstractions (this is just an auxiliary feature that's very nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646:681,flexible,flexible,681,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646,1,['flexible'],['flexible']
Modifiability,"> Sounds like the plan is to switch to SolutionBoundaryConditions but that might involve more refactoring so maybe best left for another PR?. This is already done, because the model constructor calls the function `ModelBoundaryConditions` here:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/models.jl#L64. which then dispatches based on whether the argument `boundary_conditions` is a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/boundary_conditions.jl#L254. Thus in either case the model is constructed with a `ModelBoundaryConditions`. Edit: note that this is required for correct checkpointing, because the checkpointer passes a `ModelBoundaryConditions` to the model constructor, while we expect users to pass a `SolutionBoundaryConditions`. . The downside to this pattern is that the type of `model.boundary_conditions` will often be different than the keyword argument `boundary_conditions`. Hopefully this is not confusing or surprising... :-/ An alternative is perhaps to specifically delineate between them; ie change the keyword argument in the `Model` constructor to `solution_boundary_conditions`. However, something to consider is that the `tendency` and `pressure` fields of `ModelBoundaryConditions` should be uniquely determined by `SolutionBoundaryConditions`. Another factor to consider is that the pattern that keyword arguments correspond to fields is not a guaranteed julia pattern, it is simply an organizational principle that we feel is helpful. Thus I think we can break it occasionally if it improves the readability and simplicity of code. We should note the difference in the documentation to the `Model` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747:94,refactor,refactoring,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747,1,['refactor'],['refactoring']
Modifiability,"> Stokes vorticity?. Ah, when using a GM parameterization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490:41,parameteriz,parameterization,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490,1,['parameteriz'],['parameterization']
Modifiability,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:817,refactor,refactor,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045,2,['refactor'],['refactor']
Modifiability,"> Sure, I think a problem might also be that it varies so much on a case by case basis. The most important case, which is supported by many other codes, is _nesting_. In this situation the entire 3D state outside the prognostic domain is provided. To support this we need to be able to extract the boundary state and potentially also sponge layers from the prescribed 3D state. I think cases where the boundary state is directly prescribed (perhaps for idealized simulations) will be a lot more rare. Yes there are some use cases (like the developing boundary layer case that @simone-silvestri referenced). But I think this will be a lot less common than nesting, which is already widely used for regional modeling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948,1,['layers'],['layers']
Modifiability,"> Thank you for your help! I have installed the updated version of Julia and when running it appears to be Segfaulting when trying to add CUDA. I will open an issue with them if I cannot figure out how to solve it. Thank you again. @logan can you link the CUDA issue here please?. Also, if you haven't tried, erase everything on your `$JULIA_DEPOT_PATH` (really to be safe you should make a backup of everything there first) and then run the same script you've been running with `using Pkg; Pkg.instantiate()` on the first line. This should ""re-install"" all the packages from scratch. For context [`$JULIA_DEPOT_PATH`](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH) by default is `~/.julia`, I think, and that's where julia stores the package files it downloads. The hypothesis here is that at some point some package download/compilation went wrong and you have some broken code there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622:671,variab,variables,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622,1,['variab'],['variables']
Modifiability,"> Thank you for your replies!; > ; > The FFT-based preconditioner was the first one that I tried. It produced suspicious zonal jets in my simulations. This figure shows the difference between the two solvers. It seems to me that these zonal jets are numerical artifacts. Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583:690,adapt,adaptive,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583,1,['adapt'],['adaptive']
Modifiability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:378,portab,portable,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['portab'],['portable']
Modifiability,"> Thanks a lot for your hint, I wanted to make sure what you mean by _number_ of actuations as a criteria. Do you mean; > ; > ```julia; > first_actuation_time::Number; > ```; > ; > and do you think this will potentially prevent the floating point issue?. Not quite. `TimeInterval` keeps a count of _how many times it has been actuated_. This is stored in the variable `TimeInterval.actuations`. It's use is illustrated in the computation of the `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63. To understand this consider an example. `TimeInterval` has been actuated 2 times, with an interval of 1.1. This means that the next actuation time --- the _third_ actuation_ -- will occur at the time. ```; t = 3 * 1.1 = 3.3; ```. Thus rather than storing the ""previous actuation time"" (a floating point number), we instead store the _number_ of actuations (an integer, and exact), and compute the next actuation time with the formula above. Does this make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182,1,['variab'],['variable']
Modifiability,"> That's a really cool idea. I can see how we could do that with KernelComputedFields, but I can't really see how to do it for ComputedFields. I think we understand how to write a `compute!` function that fuses the kernels for multiple `ComputedField`s or `KernelComputedField`s. But the harder part is designing an API that implements fusion for an output writer. We might need to add a property called something like `fused_compute` to both `OutputWriter`s. For example, `JLD2OutputWriter` fetches output in a loop:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/jld2_output_writer.jl#L195-L196. where `fetch_and_convert_output` calls `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/fetch_output.jl#L13-L16. which in turn calls `compute_at!`. But we want to trigger _one_ call to `compute_at!` for all the outputs at the same time ... I think ... so that requires some refactoring and API design.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659:1004,refactor,refactoring,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659,1,['refactor'],['refactoring']
Modifiability,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:109,variab,variables,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509,1,['variab'],['variables']
Modifiability,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:111,Adapt,Adapt,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This is not quite right. We want a view of the interior indices; the indices `1:grid.Nz` of the parent array covers the halo region at the bottom, and does not cover all the points near the top / surface. It should be sufficient to compute the minimum of `parent(grid.Δzᵃᵃᶜ)` because the spacing in the halo region is extended from the interior points (and thus contains no new extrema).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813:387,extend,extended,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813,1,['extend'],['extended']
Modifiability,> The memory savings is a major advantage of this closure over `AnisotropicMinimumDissipation` for problems with very large numbers of tracers (eg biogeochemistry problems with 10+ tracers).; > ; > Note also that there is overhead to launching a kernel which cannot be ignored --- we can't estimate computational cost just by adding the number of operations. Typically (though not always) our goal is to reduce the number of kernel launches as much as possible. Good points. I also wasn't aware that the kernel launch time was an important issue. I'll close this PR and open another one extending `κᶠᶜᶜ()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733:587,extend,extending,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733,1,['extend'],['extending']
Modifiability,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:837,parameteriz,parameterization,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937,1,['parameteriz'],['parameterization']
Modifiability,"> There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. I added these because it was the only way to make tests pass locally. However, I can't fully reproduce tests results locally anyway, like I mentioned in my previous comment, so these may well be unnecessary (since these lines might be passing on buildkite).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468:104,refactor,refactoring,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468,1,['refactor'],['refactoring']
Modifiability,"> There could be consistency requirements between the treatment of pressure / height gradients in the momentum equation, and transport gradients in the continuity equation. @francispoulin do you know of any requirements here or is this not a concern?. Hmm, I don't believe so. If whatever finite volume scheme we use for the evolution of height, we will ensure mass is conserved. This presumably variable height will drive the motion, and that parts seems very distinct to me. However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this? I don't believe this is a concern though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855:396,variab,variable,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855,1,['variab'],['variable']
Modifiability,"> There's a lot of references to an 'embedded' model. Should we remove these @ali-ramadhan and simply call it a model ? It doesn't seem appropriate for documentation --- the model can be run without embedding it in anything. Yes, calling it a model and not an embedded model sounds like a good call. For context, the LaTeX notes I copied from envisioned this model being a super-parameterization or embedded model but this has changed since the notes were typeset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243:379,parameteriz,parameterization,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243,1,['parameteriz'],['parameterization']
Modifiability,"> There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly.; > ; > We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`; > ; > ```julia; > @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > ```. I may be missing something, but when I make those changes I still get the errors in #2869. The changes in this PR are the only ones I've tried that seem to solve the issue. I've implemented and pushed your solution to the [tc/smag-binary-op2 branch](https://github.com/CliMA/Oceananigans.jl/blob/tc/smag-binary-op2/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl) in case you wanna check if I understood your suggestion. Basically these are the changes:. https://github.com/CliMA/Oceananigans.jl/blob/56a76ae24d7199a3efe822d06969acc7b6ce6b16/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L127-L129. I'm getting a `device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)` error with only those changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342,1,['extend'],['extend']
Modifiability,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:147,refactor,refactor,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['refactor'],['refactor']
Modifiability,"> This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., i = Hx and i = Nx - Hx, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. @simone-silvestri I think this description is incomplete. Isn't there also a change to how the auxiliary computations are done?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512:60,variab,variables,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512,2,['variab'],['variables']
Modifiability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:416,config,configuration,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,2,['config'],['configuration']
Modifiability,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:134,extend,extends,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912,2,['extend'],['extends']
Modifiability,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:372,Adapt,Adapt,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940,1,['Adapt'],['Adapt']
Modifiability,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:355,flexible,flexible,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,2,['flexible'],['flexible']
Modifiability,"> This is of course a lot of overlap between this model and ShallowWaterModel. @francispoulin physically yes but numerically no. `ShallowWaterModel` uses a conservative formulation that solves for the thickness-weighted velocities `hu` and `hv`. Here we use the ""primitive"" variables `u`, and `v`. In addition to that, the free surface displacement equation is linearized. In the future, we could envision generalizing `HydrostaticFreeSurfaceModel` to have a nonlinear free surface and also to have a ""layered"" implementation that might use the thickness weighted velocities like `ShallowWaterModel`. At that point there might be overlap and we can consider merging the two and combining our work...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227:274,variab,variables,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227,1,['variab'],['variables']
Modifiability,"> This looks like a symptom of a larger problem and, indeed, does not seem to be tested. I think to solve it we should fix the time-indexing of reduced FTS.; > ; > We seem to be missing the 4D indexing of reduced FTS:; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, j, 1, memory_index(f, n)); > @propagate_inbounds getindex(f::XZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, 1, k, memory_index(f, n)); > @propagate_inbounds getindex(f::YZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, 1, j, k, memory_index(f, n)); > ```; > ; > to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L108); > ; > and the 2D-Time indexing of reduced FTS; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, time_index::Time) = getindex(f, i, j, 1, time_index); > @propagate_inbounds getindex(f::XZFTS, i::Int, k::Int, time_index::Time) = getindex(f, i, 1, k, time_index); > @propagate_inbounds getindex(f::YZFTS, j::Int, k::Int, time_index::Time) = getindex(f, 1, j, k, time_index); > ```; > ; > maybe to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L116); > ; > and all the respective methods for 1D and 0D FTS. In theory, the boundary conditions should work as intended. Indeed, we should add a test for it. and the GPU adapted versions right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241:1516,adapt,adapted,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241,1,['adapt'],['adapted']
Modifiability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:805,variab,variables,805,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['variab'],['variables']
Modifiability,> This provides another reason to include all the `Nz+1` face data for face-centered fields. Will this feature be easy to implement in the future?. So that comment is actually outdated now. The Neumann boundary conditions can be built into the `Nz x Nz` tridiagonal system. > Pretty simple PR I think because it basically just adds a test (please confirm... ?). Yes. It was originally going to add a vertically stretched pressure solver but then I realized it would be much better code design to do the refactoring I did PR #589 first then add the solver in. So this PR just adds a test that shows you can implement a vertically stretched pressure solver using the `BatchedTridiagonalSolver`. > I think the test may be incorrectly named and can also be greatly simplified. I'm not sure if the test is 1) not achieving its intended purpose or 2) is over-complicated. Either way I think it should be cleaned up a bit before merging. Yes it is unfortunately over-complicated because there is no abstraction for a vertically stretched grid or a stretched pressure so they are implemented in the test itself. This test will be massively cleaned up in PR #543.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779:503,refactor,refactoring,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779,1,['refactor'],['refactoring']
Modifiability,> This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage. So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way?; We should definitely add a link to that docs page then.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087:37,config,configure,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087,2,['config'],"['configuration', 'configure']"
Modifiability,"> Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on **non-immersed** boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. I can't really conceive of any reasons why one would want Value / Gradient BCs on the immersed boundary though, and agree it is not alone worth a major refactor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956:915,refactor,refactor,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956,1,['refactor'],['refactor']
Modifiability,"> To properly handle the checkpoint pickup, we manually adjusted the actuation to match the correct value based on the pre-pickup simulation. Here's an [example](https://github.com/liuchihl/Oceananigans.jl/blob/correct-averagedtimeinterval/test_netcdf_timeaverage.jl#L105-L116) to illustrate what I mean.; While this resolves the issue of checkpoint for now, it's more of a workaround. Agree we need to refactor the Checkpointer. Thank you for documenting a way to proceed for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553:403,refactor,refactor,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553,1,['refactor'],['refactor']
Modifiability,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:299,variab,variables,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487,3,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"> Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :). I see what you're saying @dhruvbalwada ... ! :-D Maybe `IsopycnalTensorDiffusivity` ? The thing is, when users build this closure they have the option only to set _coefficients_ (which may be constants or nonlinear functions of model variables) of two tensors --- an ""isopycnal rotation tensor"" that is symmetric and rotates a vector into the isopycnal plane, and another skew-symmetric or antisymmetric tensor. So the tensor is not general; it has a specific form... On the other hand I think we are leaning towards more substantial changes to this parameterization than would be covered by this name. So we could have one `IsopycnalTensorDiffusivity` corresponding only to the symmetric component, and another `GentMcWilliamsDiffusivity`(or something?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093:476,variab,variables,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093,2,"['parameteriz', 'variab']","['parameterization', 'variables']"
Modifiability,> We could further simplify the time stepping code if we adapt the Field abstraction to be GPU compatible (#298). Just a note: I attempted this while working on abstract operations and was unable to solve the problem. But we are using new versions of julia + cuda tools all the time so it is / will be worth revisiting,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716:57,adapt,adapt,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716,1,['adapt'],['adapt']
Modifiability,"> We could procede in a couple of ways from here:. Let me provide a few other options:. * Compute the 2D boolean masks for reduced operations in `x`, `y`, and `z` when forming `ImmersedBoundaryGrid`. Then, use those masks for conditional differencing of reduced fields, rather than calling `immersed_inactive_node`. * For `GridFittedBottom` and `PartialCellBottom`, as a stop gap, define these methods:. ```julia; @inline conditional_δx_f(ℓy, ℓz, i, j, k, ibg::GFBIBG, δx, r::ZIRF, args...) = ifelse(immersed_inactive_node(i, j, ibg.Nz, ibg, c, ℓy, ℓz) |; immersed_inactive_node(i-1, j, ibg.Nz, ibg, c, ℓy, ℓz),; zero(ibg),; δx(i, j, k, ibg.underlying_grid, r, args...)). ```. That use a condition based on whether `k == Nz` is immersed. This will fix fields that are reduced in `z` without increasing memory storage or doing a computation in the immersed boundary grid constructor. And that's the most common case anyways. * When building a `ReducedField`, compute the mask that has to be applied to abstract operations. Then, extend the `_derivative` constructor for the combination of a `ReducedField` argument + `ImmersedBoundaryGrid` using conditional operation. This has the advantage of avoiding the mask computation in `ImmersedBoundaryGrid` (since its only needed to do operations on reduced fields). The disadvantage is that different reduced fields have to redo the computation. Also, this only fixes abstract operations and does not fix the internal operators. We also have to update the conditional operators to throw away the immersed boundary grid for reduced fields, or throw away the immersed boundary grid inside the abstract operation. * A variant on the above approach is to compute the mask when forming `Derivative`. But then a new mask is computed for every operation. There's probably a lot of other options. Keep the brainstorming coming.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353:1028,extend,extend,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353,1,['extend'],['extend']
Modifiability,> We should also add a test similar to the one that was added in #3512. Doesn't that already exist? . We just have to adapt the test,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614,1,['adapt'],['adapt']
Modifiability,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:30,variab,variable,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188,1,['variab'],['variable']
Modifiability,"> Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > ; > ```julia; > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > ```; > ; > which will become a number for single layers?. Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794:260,layers,layers,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794,1,['layers'],['layers']
Modifiability,"> What I meant about trusting users for auxiliary fields is that you can do e.g. this: `model = NonhydrostaticModel(; grid, auxiliary_fields=(; A = randn(1, 2))` and it doesn't error. Why do we want to support arrays in `auxiliary_fields`?. The main usage for `auxiliary_fields` is that they can be invoked in continuous-form forcing functions. In that usage they have to be `AbstractField`, otherwise we can't figure out how to interpolate them into a forcing function. `auxiliary_fields` isn't meant to be a place to store just any information needed for a model (what would the purpose of that be?) We can adapt `auxiliary_fields` but it would be good to understand why. Separately, perhaps we should check that all `auxiliary_fields` are `AbstractField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649:609,adapt,adapt,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649,1,['adapt'],['adapt']
Modifiability,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:583,variab,variable,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"> What about the topologically aware operators PR? Should that come first? That seems to me to be the most significant improvement.; > ; > Note there are some changes on #3867 to respect. Right, I guess we can first #3268, then #3841 and then we can refactor the split explicit code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553,1,['refactor'],['refactor']
Modifiability,"> What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`? `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels.; > ; > (I really should have made this comment in #3488, but it's never too late..). It's been taken care of in commit [5cffc13](https://github.com/CliMA/Oceananigans.jl/pull/3547/commits/5cffc139eb93c1afbd68c520a95e21ba56d73990).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671:198,config,configs,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671,1,['config'],['configs']
Modifiability,> What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else...; > ; > But I'm not sure if it's difficult to refactor. I don't think its hard.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362:187,refactor,refactor,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362,1,['refactor'],['refactor']
Modifiability,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:84,parameteriz,parameterization,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['parameteriz'],['parameterization']
Modifiability,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:231,adapt,adapted,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['adapt'],['adapted']
Modifiability,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:1027,refactor,refactor,1027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['refactor'],['refactor']
Modifiability,"> Work with FieldTimeSeries as if it were a 4D array (with operations ignoring the halos). To clarify, are you referring to getting broadcasting and reduction to work?. If so I would clarify this comment: we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. The problem is not merely to avoid operations on halos, but also to correctly interpolate between locations on a staggered grid and correctly apply derivatives on arbitrary grids. The built-in broadcasting machinery launches kernels via `launch!` so such functionality avoids operations on halos like all other `launch!` kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735:216,extend,extend,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735,1,['extend'],['extend']
Modifiability,"> Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394; > ; > And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`. GOTHCA!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014:28,adapt,adapted,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"> You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence.; > ; > Does `AnisotropicMinimumDissipation` work? Or other closures?. Nice catch! It does work for AMD. I hadn't tried that before because I assumed it wasn't gonna work. Unfortunately I can't really use AMD because it produces a lot of noise in the stratified regions of my domain, but hopefully adapting Smag isn't too hard?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249:706,adapt,adapting,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249,1,['adapt'],['adapting']
Modifiability,"> ```julia; > u_subsampled = XFaceField(subset_grid); > ; > function subsample_u(model); > u = model.velocities.u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I see, so there is no way to make this seamlessly work with a NamedTuple I already have with all variables I want to output?; I would need to create a function for each of the variables?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385:317,variab,variables,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385,2,['variab'],['variables']
Modifiability,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:806,refactor,refactored,806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['refactor'],['refactored']
Modifiability,"> and the GPU adapted versions right?. right, should be accounted for if we define the 1D and 0D FTS as we do the 2D ones; ```julia; const XYFTS = FlavorOfFTS{<:Any, <:Any, Nothing, <:Any, <:Any}; const XZFTS = FlavorOfFTS{<:Any, Nothing, <:Any, <:Any, <:Any}; const YZFTS = FlavorOfFTS{Nothing, <:Any, <:Any, <:Any, <:Any}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309:14,adapt,adapted,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309,1,['adapt'],['adapted']
Modifiability,"> but I guess you are telling me that it defaults to the position of the first variable?. Correct. > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something. My apologies for being unclear! I would write. ```julia; uh, vh, h = model.solution; u = ComputedField(uh / h); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879:79,variab,variable,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879,1,['variab'],['variable']
Modifiability,"> forcing at the surface to generate mixing (through convection or mechanical stress), while the forcing in the interior restores the stratification. Hi there. Talked briefly about this with @zhenwu0728 earlier and was suggesting something along those lines for the physics too. I could imagine additional applications for configs like these and am willing to help with e.g. exploring the parameter space a bit if needed. Maybe the simplest, yet rather tunable, approach I could think of would be something like:. - at the top: warming (e.g. via relaxation to SST0) + wind stress to mechanically generate turbulence; - below a certain depth z1: cooling (e.g. via relaxation to T1<SST0) to restore to positive stratification. I feel that this simple approach should lead to a statistically steady stratification within an appropriate ranges of [SST0 T1 z1] and piston velocities. . With this basic config in place, which maybe is not far from your `examples/ocean_wind_mixing_and_convection.jl`, my guess is that adding a diel or seasonal mixed layer deepening is straightforward -- e.g. via a time variation in SST0. Does that make sense? Am I missing something obvious?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072:323,config,configs,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072,2,['config'],"['config', 'configs']"
Modifiability,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:330,variab,variably,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869,1,['variab'],['variably']
Modifiability,"> in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > ; > The other option to not use MPI variables is to hardcode the number of processors. This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line. I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642:86,variab,variables,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642,2,['variab'],['variables']
Modifiability,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:885,extend,extending,885,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238,1,['extend'],['extending']
Modifiability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:571,extend,extend,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,2,['extend'],['extend']
Modifiability,> the time integral when we use variable time stepping that is a feature we use quite often. What do you mean by this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035:32,variab,variable,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035,1,['variab'],['variable']
Modifiability,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:20,rewrite,rewrite,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,4,['rewrite'],['rewrite']
Modifiability,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:120,variab,variables,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287,1,['variab'],['variables']
Modifiability,> we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. @glwagner Reductions on `Field`s don't all work on `master` but work now (without the `interior_copy` version) but trigger scalar operations on the GPU. Might be worth doing a bit of pair programming later around this? I'll see if I can add some CPU tests which should pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428,1,['extend'],['extend']
Modifiability,> when I run; > ; > ```shell; > (base) navid:OceananigansDistributedExamples/ (glw/docs2) $ mpiexec -n 2 julia --project distributed_example.jl; > ┌ Warning: You appear to have run julia under a different `mpiexec` than the one used by MPI.jl.; > │ See the documentation for details.; > └ @ MPI ~/.julia/packages/MPI/is7GN/src/environment.jl:26; > ```. This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760:388,config,configure,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760,2,['config'],"['configuration', 'configure']"
Modifiability,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1258,config,configuration,1258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674,2,"['config', 'extend']","['configuration', 'extend']"
Modifiability,"> you are referring to including the horizontal components of the rotation vector within the tangent plane approximation?. Ah I should have been clearer. For the Cartesian domains we might want `FullCoriolis` but including the cosine term would only make sense if we're running on a sphere. > Do you think that we should not have the concept of a molecular transport coefficient at all?. I think it makes sense to have this, especially so that the default is a DNS. Not sure if this is the most common use case, in which case maybe we can spit out a warning to new users so they know what they're running. > The point is that density is not a variable in a Boussinesq code and the value of the reference density has no effect on the dynamics. This makes sense to me, but then I'm wondering if ρ₀ is important to know to calculate diagnostics etc. where should we store it? EOS makes the most sense to me as a storage place even though it doesn't influence the dynamics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754:643,variab,variable,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754,1,['variab'],['variable']
Modifiability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:731,rewrite,rewrite,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,2,['rewrite'],['rewrite']
Modifiability,"@BrodiePearson I refactored `StokesDrifts.jl` very slightly --- I agree with the new terms you added!. I put together this script that reproduces the ""deep Eulerian return flow"" from McIntyre (1981):. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. ϵ = 0.1; λ = 60 # meters; g = 9.81. const k = 2π / λ. c = sqrt(g / k); const δ = 1kilometer; const cᵍ = c / 2; const Uˢ = ϵ^2 * c. @inline A(ξ) = exp(- ξ^2 / 2δ^2); @inline A′(ξ) = - ξ / δ^2 * A(ξ); @inline A′′(ξ) = (ξ^2 / δ^2 - 1) * A(ξ) / δ^2. # Write the Stokes drift as; #; # uˢ(x, z, t) = A(x, t) * ûˢ(z); #; # which implies. @inline ûˢ(z) = Uˢ * exp(2k * z); @inline uˢ(x, z, t) = A(x - cᵍ * t) * ûˢ(z); @inline ∂z_uˢ(x, z, t) = 2k * A(x - cᵍ * t) * ûˢ(z); @inline ∂t_uˢ(x, z, t) = - cᵍ * A′(x - cᵍ * t) * ûˢ(z). # Note that if uˢ represents the solenoidal component of the Stokes drift,; # then; #; # ```math; # ∂z_wˢ = - ∂x_uˢ = - A′ * ûˢ .; # ```; #; # We therefore find that; #; # ```math; # wˢ = - A′ / 2k * ûˢ; # ```; #; # and. @inline ∂x_wˢ(x, z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2Ou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:17,refactor,refactored,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['refactor'],['refactored']
Modifiability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:205,evolve,evolve,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,1,['evolve'],['evolve']
Modifiability,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1281,variab,variables,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493,1,['variab'],['variables']
Modifiability,"@ali-ramadhan does makes a fair point. But there will be some learning curve either way... The user should either know some git, or they should be familiar with Julia's syntax, or Julia's project management (`julia --project=...`). To that extend, perhaps the doc instructions could suggest few avenues that the user can start running the examples. Cloning the repo could be one of them. But also copy-paste from the docs after ensuring the the proper `Project.toml` is instantiated could also be a viable option!. By the way Literate.jl provides ways to output the examples in different forms other than markdown for the docs.; https://fredrikekre.github.io/Literate.jl/v2/outputformats/; With some pre/postprocessing we can have Literate.jl strip out things like `nothing #hide` and then point the users to cleaner `.jl` scripts or Jupyter notebooks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746:240,extend,extend,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746,1,['extend'],['extend']
Modifiability,@ali-ramadhan let's focus first on #3801 and then we can revisit this PR. There are some additional challenges to resolving #3791 unfortunately that will also require some test refactoring.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408:177,refactor,refactoring,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408,1,['refactor'],['refactoring']
Modifiability,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:65,config,config,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187,1,['config'],['config']
Modifiability,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:564,Adapt,Adapt,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['Adapt'],['Adapt']
Modifiability,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:543,variab,variables,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['variab'],['variables']
Modifiability,"@francispoulin and I ran some of the strong and weak scaling scripts recently up to 128 CPU cores. An extra bit of code was added into the files that handled the plotting. Also added was a small but vital configuration adjustment for the @benchmark macro which allowed for more than 64 cores to be benchmarked without what is perceived as deadlocking from occurring. I will PR my all my changes made to the benchmarking scripts shortly. Here are the results:. weak scaling shallow water model, with grid size being 8192 x 512R where R is the number of cores:; ```; ┌───────────────┬──────────┬─────────┬─────────┬─────────┬─────────┬──────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────┼─────────┼─────────┼─────────┼─────────┼──────────┼────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.464 s │ 1.464 s │ 1.465 s │ 1.466 s │ 1.60 MiB │ 2804 │ 4 │; │ (8192, 1024) │ (1, 2) │ 1.475 s │ 1.475 s │ 1.477 s │ 1.486 s │ 1.49 MiB │ 3146 │ 8 │; │ (8192, 2048) │ (1, 4) │ 1.472 s │ 1.475 s │ 1.477 s │ 1.509 s │ 1.49 MiB │ 3146 │ 16 │; │ (8192, 4096) │ (1, 8) │ 1.500 s │ 1.503 s │ 1.508 s │ 1.537 s │ 1.49 MiB │ 3146 │ 32 │; │ (8192, 8192) │ (1, 16) │ 1.545 s │ 1.578 s │ 1.593 s │ 1.682 s │ 1.49 MiB │ 3146 │ 64 │; │ (8192, 16384) │ (1, 32) │ 1.744 s │ 1.803 s │ 1.805 s │ 1.894 s │ 1.49 MiB │ 3146 │ 96 │; │ (8192, 32768) │ (1, 64) │ 1.723 s │ 1.792 s │ 1.795 s │ 1.868 s │ 1.49 MiB │ 3155 │ 192 │; │ (8192, 65536) │ (1, 128) │ 1.679 s │ 1.809 s │ 1.811 s │ 1.907 s │ 1.49 MiB │ 3155 │ 384 │; └───────────────┴──────────┴─────────┴─────────┴─────────┴─────────┴──────────┴────────┴─────────┘. Shallow water model weak scaling speedup; ┌───────────────┬──────────┬──────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼──────────┼──────────┼────────────┼──────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ (1, 2) │ 1.00706",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422:205,config,configuration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422,1,['config'],['configuration']
Modifiability,"@francispoulin explained the situation well for `Gradient` and `Value` boundary conditions. I'd like to restate what he said in the context of the finite volume method and clarify the situation for `Flux` boundary conditions because I said something wrong above... Oceananigans uses a weak formulation of PDEs via the finite volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:343,evolve,evolve,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,1,['evolve'],['evolve']
Modifiability,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:1467,refactor,refactor,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629,2,['refactor'],['refactor']
Modifiability,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:979,evolve,evolved,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720,1,['evolve'],['evolved']
Modifiability,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:118,adapt,adapted,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129,1,['adapt'],['adapted']
Modifiability,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:300,parameteriz,parameterization,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,4,['parameteriz'],['parameterization']
Modifiability,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:97,variab,variable,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665,1,['variab'],['variable']
Modifiability,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:239,extend,extended,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754,2,['extend'],['extended']
Modifiability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:369,layers,layers,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,2,['layers'],['layers']
Modifiability,@glwagner I won't ask for git history rewrite now but let's not get into the habit of calling me Dr Constantinou.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397:38,rewrite,rewrite,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397,1,['rewrite'],['rewrite']
Modifiability,"@glwagner Sorry for a late response. The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Obviously with tracers there is no projection because it's not a vector like that. I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case, and also different from what you do for the usual boundary condition. My interpolation can handle Neumann and Dirichlet ie. `Value` and `Gradient` and the original idea was to infer `Flux` from `Gradient`, but right now everything is hard coded in. The normal and tangential though, would not hold with the current boundary condition set up with `North` or `East` or `Top` etc, but I don't think it would be hard to have whatever implementation is decided and just have 'Tang' and 'Normal' or whatever as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557:249,variab,variable,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557,1,['variab'],['variable']
Modifiability,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:63,refactor,refactored,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430,1,['refactor'],['refactored']
Modifiability,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:224,variab,variables,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124,1,['variab'],['variables']
Modifiability,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:140,Adapt,Adapt,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"@glwagner or @ali-ramadhan probably can change that. I actually like the description as is. :); I'd probably just add the ""flexible"" to the current description: ""A flexible oceanic...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563:123,flexible,flexible,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563,2,['flexible'],['flexible']
Modifiability,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:560,extend,extends,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,3,['extend'],"['extend', 'extending', 'extends']"
Modifiability,@glwagner the important changes are basically the `Advection` module and `conditional_fluxes.jl` in the `ImmersedBoundaries` module. The rest is only adapting here and there (and some small bugfixes in immersed boundaries and shallow water module),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301:150,adapt,adapting,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301,1,['adapt'],['adapting']
Modifiability,"@glwagner yes, that was more along the lines of what I was saying. From the docs it seemed to me using a Gaussian mask in the relaxation should be equivalent to a sponge layer, which is why I expected the gaussian function to be set-up with a sharp cut-off. But I think we're on the same page about what a sponge layer should be. . So I think it may be a matter of maybe making the docs clearer? Maybe also, like you said, constructing an example that uses sponge layers (I think there's an issue about there somewhere, right?). The Langmuir example might a good one. In the original paper by Jim they use a radiation boundary condition at the bottom which doesn't have an analog in the Langmuir example at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742:464,layers,layers,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742,1,['layers'],['layers']
Modifiability,"@glwagner, @simone-silvestri: Question: How is Δx^faa, defined for the F at the edge of the domain?. Is it the distance between `C[1] - F[1]`? (don't think so...); Or distance between `C[1] - C[0]`?. For a curvilinear grid with variable distances (as the `OrthogonalSphericalShellGrid` we need to compute where the halo faces and centers would be if we actually extended the grid, right? We can't just replicate the `C[2] - C[1]` distances `Hx` times...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027:228,variab,variable,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027,2,"['extend', 'variab']","['extended', 'variable']"
Modifiability,"@glwagner, I think there was a misunderstanding about the test failing. For the background-flux-divergence PR, we were just confused as to why it wasn't passing the existing test suite. The separate issue of adding a new test is for the [unrelated PR](https://github.com/CliMA/Oceananigans.jl/pull/3721) related to refactoring `AveragedTimeInterval` to fix the existing bug. @liuchihl has some local branches where he'd merged both of those and was testing them in combination, so we got our signals crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389:315,refactor,refactoring,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389,1,['refactor'],['refactoring']
Modifiability,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:251,variab,variables,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['variab'],['variables']
Modifiability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:577,layers,layers,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,1,['layers'],['layers']
Modifiability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:513,refactor,refactoring,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,4,"['config', 'refactor']","['configurations', 'refactor', 'refactoring']"
Modifiability,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:419,adapt,adapt,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892,1,['adapt'],['adapt']
Modifiability,"@jmbeckers thanks for the delucidation! Indeed, a conservative discretization might be more ""natural"" (have better discrete properties) in terms of momentum conservation. Especially because vector invariant formulations do not conserve momentum but angular momentum. @francispoulin, indeed, I think that, for a one layer model explicit dissipation might not be necessary because the noise associated with a horizontal velocity divergence is encoded in the mass equation which is discretized with a WENO formulation also (another way of repeating what @glwagner said). This is the difference with the hydrostatic model where we do not explicitly evolve a prognostic equation for the vertical velocity and we have to explicitly damp the noise contained in the vertical velocity `w` through a divergence damping closure. So you can think at that ""divergence damping"" closure as a ""WENO"" for an hypothetical `w` equation (which we have in the shallow water equations explicitly trough `h`). I agree also that we should introduce a diffusion term anyways. It is always good to be able to quickly quantify the dissipation you have in your model and with implicit dissipation that is very difficult (implicit LES is frowned upon by many purist of turbulence). for the documentation problem I think it's just because I changed the example. I ll fix the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380:645,evolve,evolve,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380,1,['evolve'],['evolve']
Modifiability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:131,refactor,refactor,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['refactor'],['refactor']
Modifiability,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:120,refactor,refactoring,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281,1,['refactor'],['refactoring']
Modifiability,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:420,config,configuration,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,2,['config'],['configuration']
Modifiability,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033:61,adapt,adaptive,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033,2,['adapt'],['adaptive']
Modifiability,"@navidcy . I just sent you an invite to the overleaf document. I thought maybe we want to have both the tracer and momentum equations before we create a PR, but I'm flexible. Thanks also for the reference. I remember seeing this paper before and liking it so I will look at it again. It seems that our advection schemes use the cell-averaged velocity to approximate the velocity at the edge. This is a perfectly valid choice and corresponds to a certain order of accuracy. I don't know what that is but I imagine using more cell averaged velocities would give a higher order accuracy. I'm not suggesting we do this, but I'm just trying to get a better understanding of the order of accuracy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460:165,flexible,flexible,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460,1,['flexible'],['flexible']
Modifiability,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ CenteredFourthOrder │ 1.779 s │ 1.789 s │ 1.794 s │ 1.814 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.066 s │ 1.061 s │ 1.090 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.467 s │ 2.505 s │ 2.505 s │ 2.544 s │ 1.05 MiB │ 1685 │ 2 │; │ CPU │ UpwindBiasedThirdOrder │ 1.808 s │ 1.877 s │ 1.862 s │ 1.903 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.775 s │ 6.775 s │ 6.775 s │ 6.775 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.879 ms │ 20.970 ms │ 21.078 ms │ 21.874 ms │ 2.17 MiB │ 20610 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.402 ms │ 15.533 ms │ 15.138 ms │ 15.680 ms │ 2.05 MiB │ 13147 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.356 ms │ 23.498 ms │ 24.055 ms │ 29.246 ms │ 2.21 MiB │ 23281 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.863 ms │ 19.027 ms │ 19.298 ms │ 21.745 ms │ 2.12 MiB │ 17945 │ 10 │; │ GPU │ WENO5 │ 23.234 ms │ 28.467 ms │ 27.982 ms │ 28.684 ms │ 2.30 MiB │ 29259 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; This PR same file, (WENO5 on uniform grids); ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:130,adapt,adapted,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['adapt'],['adapted']
Modifiability,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:54,config,config,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428,1,['config'],['config']
Modifiability,"@navidcy PyPlot is used for the log2 scale for the x-axis of certain graphs. The normal backend of Plots,jl only has natural log scale axis option. Log-base-2 scale works best for these plots since most of them have an independent variable that scales based on powers of 2. The inclusion of Oceananigans in `benchmark/Project.toml` is likely due to a Julia package config suggested by @ali-ramadhan. What was done was that in Julia's package manager, `dev ..` was inputted to enable what I assume is the dev version of the Oceananigans package folder. Before this was done, there were numerous output errors with the benchmark scripts, and doing so fixes them all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629:231,variab,variable,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:259,parameteriz,parameterization,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733,1,['parameteriz'],['parameterization']
Modifiability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:233,config,configuration,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,2,['config'],"['config', 'configuration']"
Modifiability,"@peterahrens thanks for that tip!. @vchuravy, by closure-specific temporary variables (or fields), I am referring to domain-size quantities that can be re-used in computing the contribution of an LES closure to the 'source terms' for momentum and tracers. In other words, [this line, which computes the source term for `u`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/a544300cabe6f8d872b7f9658284cad34c8619ad/src/time_steppers.jl#L223) could become something like. ```julia; kernel_temporaries!(subgrid_closure, ..., i, j, k); Gu[i, j, k] = ... + subgrid_closure.u(subgrid_closure_temporaries, ..., i, j, k); ```. ... I think. In physical terms, the intermediate variable is an 'eddy viscosity' that acts on all momentum terms. But I guess when I say the computation 'will benefit' from variables to store intermediate results, what I really mean is that I'm expecting the calculation of this temporary variable to be fairly involved (potentially >20 derivatives of velocity and tracer fields in x, y, z, plus scalar operations to combine the fields, and a 'clipping' function to make sure the viscosity is not negative --- see [the formula for the eddy viscosity predictor](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html#the-eddy-viscosity-predictor)). It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674:76,variab,variables,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674,4,['variab'],"['variable', 'variables']"
Modifiability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:489,adapt,adapted,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['adapt'],['adapted']
Modifiability,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:321,extend,extends,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017,1,['extend'],['extends']
Modifiability,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:126,evolve,evolve,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762,2,['evolve'],['evolve']
Modifiability,"@simone-silvestri I refactored the CFL calculation so that we only have one function all the time, rather than one ""ordinary"" and one ""accurate"". The tests still fail though. I'm not totally sure why, but I am somewhat confused how this is supposed to work on a staggered grid. I don't think we can apply wikipedia's definition; we need the definition that's correct for a C grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri You seem to be right. On the cluster I get:. ```julia; julia> using Oceananigans.Architectures: DEVICE_STREAMS, DEVICE_FREE_STREAMS; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> length(DEVICE_STREAMS); 1. julia> DEVICE_FREE_STREAMS; (CUDA.CuStream[],). julia> CUDA.dev^C. julia> using CUDA. julia> CUDA.devices(); CUDA.DeviceIterator() for 2 devices:; 0. Tesla V100-SXM2-32GB; 1. Tesla V100-SXM2-32GB. julia> CUDA.ndevices(); 2; ```. If you need to reproduce this and aren't able to, we can set up a PP session via zoom and I can share my screen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343:191,variab,variable,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"@simone-silvestri asked for a little more alignment, so we have. ```julia; julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.83091; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292:397,variab,variably,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292,1,['variab'],['variably']
Modifiability,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244:80,adapt,adapts,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244,2,['adapt'],['adapts']
Modifiability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:600,refactor,refactoring,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,6,"['adapt', 'polymorphi', 'refactor']","['adapt', 'polymorphism', 'refactoring']"
Modifiability,"@simone-silvestri here's some description of the GVC problem. There's additional discussion on #1549. Today, we discussed whether the prognostic variable in a model formulated with a generalized vertical coordinate is thickness weighted velocity `hu`, or velocity `u` (which has also come up on #2522). Based on some discussion and consultation with papers it seems that we want both, because we evolve `hu` when we use ""flux form"" or ""conservative form"" momentum advection, but we evolve `u` when we use ""vector invariant"" advection. This choice has consequences beyond momentum advection though (I think). Also, whichever momentum variable we prognose, we always prognose the thickness weighted tracer concentration `hc`. Thoughts on this are very welcome @jm-c @jmbeckers !. In the ""z-tilde"" paper by [Leclair and Madec 2011](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=DHE0RUlG-WMAAAAA:lJV98AknVQXrbcNmIUI9sxHLYoqmw4I7lw0EKSMyhiX9lKR6sxreDJ5Kt86jhc2fbqFH88aAYew), we find. <img width=""544"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/167006545-ffff4819-a5a5-4fbc-88a6-aefbed6322cb.png"">. I think `e3` above is our `h`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226:145,variab,variable,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226,4,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,@simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582:170,flexible,flexible,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582,1,['flexible'],['flexible']
Modifiability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:485,config,configuration,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['config'],['configuration']
Modifiability,"@simone-silvestri, in relation to why `cpu_face_constructors` require `with_halos=true`: note that before the grid_utils refactor `cpu_face_constructors` were using `cpu_face_constructors` were using `all_x/y/z_nodes` which is exactly equivalent to `x/y/znodes(; with_halos=true)`. ;). https://github.com/CliMA/Oceananigans.jl/blob/e7cb507b2645f04c6cdf52ee6f18c2c5b79f7bde/src/Grids/grid_utils.jl#L244-L246",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886:121,refactor,refactor,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886,1,['refactor'],['refactor']
Modifiability,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:446,evolve,evolves,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227,2,"['evolve', 'sandbox']","['evolves', 'sandbox']"
Modifiability,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:246,variab,variable,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663,2,['variab'],['variable']
Modifiability,@tomchor I extended both JLD2 and NetCDF tests to include a StepRange index specification. All that's potentially left is to spruce up the docstring if we have the motivation here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001:11,extend,extended,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001,1,['extend'],['extended']
Modifiability,@tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?. Looks like `ScalarBiharmonicDiffusivity` needed it here: https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113. Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100:58,adapt,adapting,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100,2,['adapt'],['adapting']
Modifiability,"@tomchor and @francispoulin (and more) should this include ""flexible"" (to convey the LES <-> general circulation, lab/theory simulations <-> exoplanets, etc.... )?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910:60,flexible,flexible,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910,1,['flexible'],['flexible']
Modifiability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:62,refactor,refactoring,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['refactor'],['refactoring']
Modifiability,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:478,config,configuration,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configuration']
Modifiability,"@tomchor, I haven't implemented `MultiRegion` for `NonhydrostaticModel` yet. It would be quite easy to extent it if it weren't for the pressure solver which is done in two different ways and both of them are global (`FFT` and `TridiagonalFFT`). A quick and dirty solution would be to do as I have done with the `ImplicitFreeSurface` and reserve the calculation on 1 GPU only. The problem is that the pressure solve is 3D and not 2D so we would probably like to use the `cuFFT` multi-gpu functionality (in particular the cuFFTxt library, which I hope is implemented in `CUDA.jl` although I haven't checked yet) I ll open a PR to start implementing it. Regarding the `OutputWriters`, they are implemented in jld2 trivially with `reconstruct_global_field`. ; You can specify a `JLDOutputWriter` as you do for a single region grid, provided you don't want to slice the direction across the regions ; for example you cannot do; ```; indices = (1:10, :, :) ; ```; for an `XPartition` or ; ```; indices = (:, 1:10, :); ```; for a `YPartition`; (`MultiRegion` does not play well with `indices` at the moment). . It runs, but there is a weird bug for which the fields are not updated as the model timesteps (i.e., all the outputs are the initial condition). I think it is easily solvable but I have to take a deeper look. So basically, it is not working at the moment... On the other hand, to anticipate the `CubedSphere` refactor, we probably want to have `OutputWriters` which output all regions separately (as `reconstruct_global_field` does not mean much in a cubed sphere context). The `OutputReaders`, on the other hand, are completely undefined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842:1413,refactor,refactor,1413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842,1,['refactor'],['refactor']
Modifiability,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Adapt,Adapt,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616,1,['Adapt'],['Adapt']
Modifiability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['variab'],['variable']
Modifiability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:214,refactor,refactor,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['refactor'],['refactor']
Modifiability,A default argument works great too! You can also capture data as a global variable:. ```julia; julia> a = 3; 3. julia> f(x) = x * a; f (generic function with 4 methods). julia> f(2); 6; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481,1,['variab'],['variable']
Modifiability,"A few more comments:. * Perhaps we can name `SomethingBiogeochemistry` ""BasicBiogeochemistry"". I think this is appropriate communication about the purpose of this object; large, sophisticated packages should implement their own models from the ground up.; * I think `light_attenuation_model` is too specific for `BasicBiogeochemistry`. For example, it only pertains to biology; however some models are chemistry-only. @jagoosw do you mind if I address these, and also adapt `test_biogeochemistry.jl` into a form that's close to merge-ready?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022:468,adapt,adapt,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022,1,['adapt'],['adapt']
Modifiability,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:35,variab,variable,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363,1,['variab'],['variable']
Modifiability,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1161,parameteriz,parameterization,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,4,['parameteriz'],['parameterization']
Modifiability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:15,extend,extending,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['extend'],['extending']
Modifiability,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:630,variab,variables,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952,1,['variab'],['variables']
Modifiability,"A warning might make sense. `show` can be more specific (spacing `Array` doesn't mean that the spacing is variable, it means the spacing is given by an `Array`). It's good at least now that `show` helps you realize that `Array` spacings are special.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084:106,variab,variable,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084,1,['variab'],['variable']
Modifiability,"Actually I'll reopen this since I'm still getting an error, albeit a different one:. ```; julia> grid; 44×8×52 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [4.35026e-15, 894.427) regularly spaced with Δx=20.3279; ├── Periodic y ∈ [-8.74514e-15, 178.885) regularly spaced with Δy=22.3607; └── Bounded z ∈ [-178.885, 178.885] variably spaced with min(Δz)=4.76685, max(Δz)=21.2525. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:374,variab,variably,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['variab'],['variably']
Modifiability,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028,2,['Adapt'],['Adapt']
Modifiability,"Adapting Smagorinsky seems an easy avenue. . In terms of Implicit LES, you could try using just WENO without any closure, but if you are in a true LES regime it would probably be too dissipative. A Smagorinsky viscosity combined with an energy-conserving advection scheme has been found to be less dissipative although noisier (here is an example applied to Burgers equation https://reader.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['Adapt'],['Adapting']
Modifiability,Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? I had thought that it's usually preferred to use `FluxBoundaryCondition` since this is often the preferred parameterization for large scale motions and basically we only use `ValueBoundaryCondition` for DNS (and `GradientBoundaryCondition` almost never). Curious to understand the class of problems that benefit from `GradientBoundaryCondition`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968:201,parameteriz,parameterization,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968,1,['parameteriz'],['parameterization']
Modifiability,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:88,extend,extend,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"After talking a bit with @ali-ramadhan, I think we might have settled on the following solution:. * Introduce a new type called `PhysicalParameters` that holds `g` and `ρ0`; * Introduce a new abstract type called `Rotation` (or some such) that encodes information about the background rotation rate of the model --- `TangentPlane` with `f` and `β`, and possibly non-traditional Coriolis parameters, another type for the sphere, etc.; * Group viscous and diffusive transport coefficients into the upcoming `TurbulenceClosure` type, allowing for isotropic constant transport coefficients, anisotropic constant coefficients, or nonlinear closure schemes. These changes will also require us to compute buoyancy rather than a density perturbation, and may motivate us to simplify the code by defining variables in `pressures` as having units of the 'kinematic pressure', which is the ordinary pressure divided by `ρ0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546:796,variab,variables,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546,1,['variab'],['variables']
Modifiability,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:101,sandbox,sandbox,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214:22,sandbox,sandbox,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214,1,['sandbox'],['sandbox']
Modifiability,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:486,config,configure,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173,1,['config'],['configure']
Modifiability,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:214,variab,variable,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['variab'],['variable']
Modifiability,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:235,variab,variable,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934,1,['variab'],['variable']
Modifiability,Ah sorry for the slow reply. Docs build on `tartarus.mit.edu` through Buildkite which has GPUs but we disable the GPU through the Buildkite config. I think if we just remove this line we can build examples on the GPU!. https://github.com/CliMA/Oceananigans.jl/blob/81d9c0e061cae4aa5a0ec770ff8348be7517aa53/.buildkite/pipeline.yml#L324. Doesn't have to happen in this PR of course.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902:140,config,config,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902,1,['config'],['config']
Modifiability,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:148,variab,variable,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['variab'],['variable']
Modifiability,Ah yes! Seems like we were probably not doing it exactly right before... We could also add the environment variable `JULIA_DEBUG=Documenter` if people think it's helpful to get an idea of which example is currently being built (for when you build docs + examples locally).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377:107,variab,variable,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377,1,['variab'],['variable']
Modifiability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,adapt,adapt,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['adapt'],['adapt']
Modifiability,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428,1,['extend'],['extended']
Modifiability,"Ah, I think suffice to say that in the context of the Craik-Leibovich equations, whenever the word ""Stokes drift"" is used, it's ""pseudomomentum"" that is really meant. . In particular the original context of ""Stokes drift"" is the specific situation in which surface waves forced from rest are associated with a mean Lagrangian current that causes particles and fluid to ""drift"". In the Craik-Leibovich equations, the Lagrangian-mean momentum is a prognostic variable and is not determined or _explicitly_ modified by the ""Stokes drift"" (it is only _implicitly_ modified through changes to the fluid physics). Thus rather than causing fluid to ""drift"", specifying the ""Stokes drift"" in the Craik-Leibovich equations (and in Oceananigans) instead acts to modify the underlying fluid dynamics by changing the relationship between momentum and vorticity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789:457,variab,variable,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789,1,['variab'],['variable']
Modifiability,"Ah, right! We have to extend the outer functions (`left_biased_interpolate`, `right_biased_interpolate`, and `symmetric_interpolate`) instead of the `inner` ones",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805:22,extend,extend,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805,1,['extend'],['extend']
Modifiability,"Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429:82,refactor,refactor,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429,1,['refactor'],['refactor']
Modifiability,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:98,refactor,refactored,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063,1,['refactor'],['refactored']
Modifiability,Also apologies if this is PR feature scope but I found it easier to refactor if I de-cluttered the `ImmersedBoundaries.jl` module file. This ended up creating three new files:. * `immersed_boundary_grid.jl`; * `immersed_boundary_interface.jl`; * `immersed_boundary_nodes.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652,1,['refactor'],['refactor']
Modifiability,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:991,layers,layers,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194,1,['layers'],['layers']
Modifiability,"Also this works:. ```julia; julia> import Base: minimum. julia> using OffsetArrays. julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); minimum (generic function with 21 methods). julia> minimum(zspacings(grid, Center())); 1.0. julia> grid; 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; ```. so it might have something to do with the `KernelFunctionOperation` that's used here?: https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038:527,variab,variably,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038,1,['variab'],['variably']
Modifiability,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691,2,['variab'],['variable']
Modifiability,"Also what we'd call `filename` would be different than what is called file name in the docs for [`JLD2`](https://docs.juliahub.com/JLD2/O1EyT/0.4.22/internals/#JLD2.jldopen) and [`NCDatasets`](https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#NCDatasets.NCDataset-Tuple{NCDatasets.CFVariable}), which might be a source of confusion in new users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438:248,variab,variables,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438,1,['variab'],['variables']
Modifiability,"Also, `float_type` is part of the grid and all field defined on the grid could inherit that, right?; (perhaps this is already the case?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386:79,inherit,inherit,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386,1,['inherit'],['inherit']
Modifiability,"Although I prefer being explicit I'm a big fan of the macro you suggested as it collapses 20+ lines into a single elegant statement (and buries the ugly unpacking) whereas the `unpack_model` function still requires a comma separate list of 20+ variables. I think I'll go with the simple macro. If the unpacking variables have descriptive names, e.g. `grid`, `source_terms`, `velocities`, etc. then I think it'll still be understandable without being explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870,2,['variab'],['variables']
Modifiability,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:566,adapt,adapt,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,3,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that *dispatch* on the number or arguments and argument types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934:33,extend,extend,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934,1,['extend'],['extend']
Modifiability,"Another application is for regularization in parameterizations, for example:; ```julia; Ri = ℑxyᶜᶜᵃ(i, j, k, grid, ℑxyᶠᶠᵃ, diffusivities.Ri) # Not boundary-aware . Ri = ℑxyᶜᶜᶜ(i, j, k, grid, ℑxyᶠᶠᶜ, diffusivities.Ri) # Boundary-aware ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565:45,parameteriz,parameterizations,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565,1,['parameteriz'],['parameterizations']
Modifiability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:437,refactor,refactor,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,2,['refactor'],['refactor']
Modifiability,"Another design we can consider is something like:; ```julia; grid = RegularCartesianGrid(size=(x=128, z=64), x=(-1, 1), z=(-1, 0), topology=(x=Periodic, z=Bounded)); ```; where since `y` has not been specified, it is assumed to be `Flat`. This makes the grid constructors more verbose but has the added benefit of being clearer and not having to specify flat dimensions, i.e. it's an xz-model so y should not even be mentioned. It would require a lot more refactoring though... but now's the time I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270:456,refactor,refactoring,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270,1,['refactor'],['refactoring']
Modifiability,Another outstanding issue is the formulation of tracer evolution. At the moment we are evolving tracers but maybe we want to evolve thickness weighted tracers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286:125,evolve,evolve,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286,1,['evolve'],['evolve']
Modifiability,Another possibility is that we refactor the code to generalize integer types. Which is not actually a horrible idea. There's some notion that we may also benefit from index types that are `Int32`. Adding an integer type for `Nx` would allow us to also automatically convert integers to `Int32` (eg we write something like `i = inttype(grid)`).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482:31,refactor,refactor,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482,1,['refactor'],['refactor']
Modifiability,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546,2,['variab'],['variable']
Modifiability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['variab'],['variable']
Modifiability,"As for the `with_halo`, I am testing things out in REPL. Below you see that I have `with_halo` defined already but when I try the line you suggested it says that the function must be explicitly exported to be extended. Sorry that my function defining chops are not skilled enough to figure this out. ```; julia> methods(with_halo); # 2 methods for generic function ""with_halo"":; [1] with_halo(new_halo, old_grid::RegularRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; [2] with_halo(new_halo, old_grid::VerticallyStretchedRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242. julia> with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ERROR: error in method definition: function Grids.with_halo must be explicitly imported to be extended; Stacktrace:; [1] top-level scope; @ none:0; [2] top-level scope; @ REPL[40]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017:209,extend,extended,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017,2,['extend'],['extended']
Modifiability,"As of PR #3783 the current config is to retry automatically once, but only if the exit status is 1. ```; retry:; automatic:; - exit_status: 1 ; limit: 1; ```. So I think this issue has been resolved. Thanks @glwagner!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483:27,config,config,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483,1,['config'],['config']
Modifiability,As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506:24,refactor,refactor,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506,1,['refactor'],['refactor']
Modifiability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:51,refactor,refactor,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,1,['refactor'],['refactor']
Modifiability,"As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. ```Julia; using GLMakie. filename = ""internal_wave"". fig = Figure(resolution = (800, 400)). ax = Axis(fig[1, 1];; xlabel = ""x"",; ylabel = ""z"",; limits = ((-π, π), (-π, π)),; aspect = AxisAspect(1)). iter = Observable(0). using JLD2. file = jldopen(filename * "".jld2""); grid = file[""serialized/grid""]. title = @lift(string(""ωt = "",; string(round(file[""timeseries/t/"" * string($iter)] * ω, digits=3)))). w = @lift(Array(file[""timeseries/w/"" * string($iter)][:, 1, :])). x, y, z = nodes((Center, Center, Center), grid). w_lim = 1e-8; w_levels = range(-w_lim, stop=w_lim, length=10). contourf!(ax, x, z, w; ; levels = w_levels,; colormap = :balance,; colorrange = (-w_lim, w_lim),; extendlow = :auto,; extendhigh = :auto). fig[0, :] = Label(fig, title, textsize=24). iterations = parse.(Int, keys(file[""timeseries/t""])). record(fig, filename * "".mp4"", iterations, framerate=8) do i; @info ""Plotting iteration $i of $(iterations[end])...""; iter[] = i; end; ```. https://user-images.githubusercontent.com/7112768/168449952-2ce68db5-1e21-4f04-8dc8-a29d2fba6c57.mp4. While with **everything same except** the line `fig[0, :] = Label(fig, title, textsize=24)` I get. https://user-images.githubusercontent.com/7112768/168450064-ab456174-06da-45e4-8674-55f0a3356091.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142:799,extend,extendlow,799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability,"As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498:113,variab,variable,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498,1,['variab'],['variable']
Modifiability,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:508,rewrite,rewrite,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956,1,['rewrite'],['rewrite']
Modifiability,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:308,config,configuration,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132,3,['config'],['configuration']
Modifiability,Awesome!. How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117:48,extend,extend,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117,1,['extend'],['extend']
Modifiability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,adapt,adapt,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['adapt'],['adapt']
Modifiability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:90,Parameteriz,ParameterizedCallback,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,3,['Parameteriz'],['ParameterizedCallback']
Modifiability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:106,refactor,refactor,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['refactor'],['refactor']
Modifiability,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16548,sandbox,sandbox,16548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170,2,['sandbox'],['sandbox']
Modifiability,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Adapt,Adapt,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Adapt'],['Adapt']
Modifiability,But question: floats need adaptation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826:26,adapt,adaptation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826,1,['adapt'],['adaptation']
Modifiability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['Adapt'],['Adapt']
Modifiability,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:94,variab,variable,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256,2,['variab'],"['variable', 'variables']"
Modifiability,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:821,refactor,refactor,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406,1,['refactor'],['refactor']
Modifiability,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:16,refactor,refactoring,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856,1,['refactor'],['refactoring']
Modifiability,Can you write these possibilities for variable `ν` (eg `ν` must always appear inside the divergence)? These don't all have the same dimensions --- what's happening?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262:38,variab,variable,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262,1,['variab'],['variable']
Modifiability,"Can't reproduce the problem. On tartarus with Julia v1.8:. ```Julia; julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545:389,variab,variably,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545,1,['variab'],['variably']
Modifiability,"CenteredSecondOrder` advection and `ScalarDiffusivity` with constant coefficients; * Large eddy simulation with `SmagorinskyLilly` or `AnisotropicMinimumDissipation` turbulence closures; * Idealized problems (eg two-dimensional turbulence) in 1-3 dimensions that use Laplacian, biharmonic, or implicit numerical dissipation.; 2. `HydrostaticFreeSurfaceModel`, which solves the hydrostatic Boussinesq equations with linear free surface dynamics and a `z` coordinate. The hydrostatic model is useful for larger scale simulations, eg regional ocean modeling, and can be used with `RectilinearGrid` stretched in any or all directions as well as a `LatitudeLongitudeGrid`. We have a prototype closure for vertical mixing called `CATKEVerticalDiffusivity` (paper coming soon...) as well as a `RiBasedVerticalDiffusivity` and `ConvectiveAdjustment` that support implicit time discretization for vertical diffusion. We have a new high-order advection scheme specialized for geophysical turbulence / mesoscale turbulence problems that uses a vector invariant formulation. We can treat the free surface dynamics implicitly in time with various methods (FFT-based on rectilinear grids with flat bottoms, or preconditioned conjugate gradient based with various preconditioners in other situations). We also have a `SplitExplicitFreeSurface`. All models support complex domains / bathymetry via `ImmersedBoundaryGrid`, a variety of Coriolis forces (`FPlane`, `BetaPlane`, as well as some more exotic options), a wide variety of boundary conditions for any prognostic variable on any model boundary. Note however that the pressure solver for `NonhydrostaticModel` is only approximate on `ImmersedBoundaryGrid` (we are working on an exact pressure solver for immersed boundaries). We don't support simulations on the full sphere, or sea ice, yet, but we are working on both of those. Let me know if you have any specific questions about capabilities, I'm curious to hear what problems you're interested in tackling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030:2708,variab,variable,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030,1,['variab'],['variable']
Modifiability,Changed the title slightly as it is being adapted: https://github.com/CliMA/Oceananigans.jl/blob/bf767af3c40c049ebc9499b7553065a9ef350178/src/ImmersedBoundaries/partial_cell_bottom.jl#L72-L84,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562:42,adapt,adapted,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562,1,['adapt'],['adapted']
Modifiability,"Correct. Buildkite doesn't support any templating last I looked.The `codecov` variable is currently unused though, so you can leave that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075:78,variab,variable,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075,1,['variab'],['variable']
Modifiability,"Curious if @glwagner has any thoughts on `backend_kw` vs. `reader_kw`, but I'm thinking of renaming to `reader_kw` then potentially revising the naming in a future refactor of `OutputReaders` (probably as part of supporting NetCDF).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434:164,refactor,refactor,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434,1,['refactor'],['refactor']
Modifiability,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,4,"['rewrite', 'variab']","['rewrites', 'variable']"
Modifiability,Did some refactoring and CPU and GPU hydrostatic regression tests pass locally so I think this PR is ready for review!. @simone-silvestri Requesting a review from you on your own PR again lol but I won't approve unless you do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856,1,['refactor'],['refactoring']
Modifiability,Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384,1,['refactor'],['refactor']
Modifiability,"Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not? Meaning it considers whether a cell is part of the interior of the domain or is a halo/immersed solid cell when calculating `Δz`? Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. For example in the script below, I can retrieve `Δz` directly from `grid`, but the edges do not reflect the fact that the `z` direction is bounded. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25. julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.25; 0.25; 0.25; 0.25; 0.25; ```. To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; ```julia ; julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.125; 0.25; 0.25; 0.25; 0.125; ```; since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". I looked for ways to do this in that are already in the code but couldn't find anything. I wanted to ask before I started coding something from scratch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618:812,variab,variably,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618,1,['variab'],['variably']
Modifiability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:23,extend,extending,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['extend'],['extending']
Modifiability,"Do you want to add this here: https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans ? . Let's phase these ""extended instructions"" out of the Documenter-based docs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285:150,extend,extended,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285,1,['extend'],['extended']
Modifiability,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:318,plugin,plugins,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592,1,['plugin'],['plugins']
Modifiability,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:227,variab,variably,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718,1,['variab'],['variably']
Modifiability,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:486,variab,variably,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['variab'],['variably']
Modifiability,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:219,sandbox,sandbox,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153,1,['sandbox'],['sandbox']
Modifiability,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:234,variab,variables,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['variab'],['variables']
Modifiability,"Feel free to refactor [`generated_vertically_stretched_grid`](https://github.com/CliMA/Oceananigans.jl/blob/6ff1f69e2bc5d66a0889fb3c62fb2a3b633ab535/src/Grids/vertically_stretched_rectilinear_grid.jl#L189) as part of #1532 and put it in a new file, so we can use it for grid stretching in non-z directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370:13,refactor,refactor,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370,1,['refactor'],['refactor']
Modifiability,"Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:62; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Field{Center,Face,Center,OffsetArrays.OffsetArray{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:2635,sandbox,sandbox,2635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['sandbox'],['sandbox']
Modifiability,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14990,sandbox,sandbox,14990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['sandbox'],['sandbox']
Modifiability,"For a future PR (probably #2642):. * Use the _order_ (not buffer size) as a type parameter, so WENO(order=5) yields a type `WENO{5}`, for example; * Improve docstrings for advection schemes (but this is contingent on the larger advection refactor in #2642)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440:238,refactor,refactor,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440,1,['refactor'],['refactor']
Modifiability,"For future reference, instead of the second step above, we need to add an environment variable `DOCUMENTEY_KEY=path_to_long_private_key` to the file `/etc/buildkite-agent/hooks/environment` (which may not exist yet).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701:86,variab,variable,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701,1,['variab'],['variable']
Modifiability,"For regular spacing:. ```julia; julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(2, 2, 2)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 2.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 2.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-2.0, 0.0] regularly spaced with Δzᵃᵃᶜ = 2.0; ```. for variable spacing:. ```julia; julia> σ = 1.1; # stretching factor. julia> Nz = 24; # vertical resolution. julia> Lz = 32; # depth (m). julia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));. julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 64.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 64.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-32.0, -0.0] variably spaced with min(Δzᵃᵃᶜ) = 0.682695, max(Δzᵃᵃᶜ) = 1.830909; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511:338,variab,variable,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511,2,['variab'],"['variable', 'variably']"
Modifiability,For sure. The trick about the global environment is just Julia knowledge. But it is relevant to efficient workflows for testing so we can indeed put it there. Personally I don't test just one file unless I am debugging major refactors but perhaps others do it differently...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395:225,refactor,refactors,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395,1,['refactor'],['refactors']
Modifiability,"For the moment this works only with the `SplitExplicitFreeSurface` but I think it can be extended to work also with an implicit free surface following the above mentioned algorithm where $\text{barotropic-step}$ and $\text{barotropic-correction}$ are substituted with a solve of the linear system (starting from interpolated velocities) and a pressure correction step with interpolated eta, i.e.:. ***substep 1:***; - $u^{*, n+1/2} = u^{n} + \Delta t G(u^{n})$; - $\eta^{n+1/2} = \text{barotropic-solve}\left(\eta^n, \int_z u^{*, n+1/2} \right)$; - $u^{n+1/2} = \text{pressure-correction}\left(u^{*, n+1/2}, \eta^{n+1/2} \right)$. ***substep 2***; - $u^{*, n+1/3} = \frac{3}{4}u^{n} + \frac{1}{4}\left(u^{n+1/2} + \Delta t G(u^{n+1/2}) \right)$; - $\eta^* = \text{barotropic-solve}\left(\eta^{n+1/2}, \int_z u^{*, n+1/3} \right)$; - $\eta^{n+1/3} = \frac{3}{4}\eta^{n} + \frac{1}{4}\eta^*$; - $u^{n+1/3} = \text{pressure-correction}\left(u^{*, n+1/3}, \eta^{n+1/3} \right)$. ***substep 3***; - $u^{*, n+1} = \frac{1}{3}u^{n} + \frac{2}{3}\left(u^{n+1/3} + \Delta t G(u^{n+1/3})\right)$; - $\int_z u ^{n+1} = \frac{1}{6}\int_z u^{n} + \frac{1}{6}\int_z u^{n+1/2} + \frac{2}{3}\int_z u^{*, n+1}$; - $\eta^{n+1} = \text{barotropic-solve}\left(\eta^{n}, \int_z u ^{n+1} \right)$; - $u^{n+1} = \text{pressure-correction}\left(u^{*, n+1}, \eta^{n+1}\right)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636:89,extend,extended,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636,1,['extend'],['extended']
Modifiability,"From the stacktrace, it looks like it's complaining about `ω̄ ` and looking at the script: . https://github.com/CliMA/Oceananigans.jl/blob/master/examples/Bickley_jet_shallow_water.jl#L92. it looks like it's using a global variable `U` in the definition of `ω̄ ` which won't work in a GPU kernel. Probably the easiest solution is to just define `const U = 1.0` since `const` global variables can be referenced in GPU kernels. Not sure if there's a clean way of putting in `U` as a parameter (like with forcing functions) since you're using `ω̄ ` in an abstract operation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997:223,variab,variable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997,2,['variab'],"['variable', 'variables']"
Modifiability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1147,extend,extend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['extend'],['extend']
Modifiability,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:281,variab,variables,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,4,['variab'],"['variable', 'variables']"
Modifiability,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Adapt,Adapt,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631,1,['Adapt'],['Adapt']
Modifiability,"Getting at least area and volume in there would be helpful, but kind of stopping short of 'doing this right'. . Each time I look at the SGRID specs I think ""Its right there"" when I see the specifications of 'edges=length', 'faces=area', and 'volume'; <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/14314623/227060884-d28ff5d1-9e0a-4874-b9eb-093afd4607f9.png"">; But AFAIK there is no way to actually assign a coordinate/data variable to each of these positions? If we could somehow add that into the spec I think that would be much better than abusing `cell_thickness`. . In my mind, all that is needed to correctly parse a metric into xgcm is a flag (e.g. this is a metric) and information on the 'kind' of metric and its 'orientation', both of which I believe can be encoded in SGRID already? So really all that is needed is some metadata that implements the flag. I hope this makes sense to folks. . Maybe we get some of the sgrid folks into this discussion? Just to see if I misinterpret what is already possible and whether we could add something to SGRID that indicates that a variable/coordinate represents some physical metric (length, area, volume). cc @hrajagers @rsignell-usgs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005:453,variab,variable,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005,2,['variab'],['variable']
Modifiability,"Go for it! If you want to discuss an idea before writing code, let's discuss here. Here's my thoughts:. 1. We can add a color to an important `show` method like one / all of the models, or `Simulation`; 2. We can add a nice utility for logging progress that uses `Term.jl`, that users can configure and then add to `simulation.callbacks` (we could also consider making it default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914:289,config,configure,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914,1,['config'],['configure']
Modifiability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:302,config,configuration,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['config'],['configuration']
Modifiability,"Good idea. Maybe even suggest the user try `ShallowWaterModel`, as that is a better way to try this configuration? ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291:100,config,configuration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291,1,['config'],['configuration']
Modifiability,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:675,parameteriz,parameterizations,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['parameteriz'],['parameterizations']
Modifiability,"Heh. I would never imply you can't take my code and adapt it to do nice things. You can of course do that. For example if you have `outputs` already assembled, you can do. ```julia; function create_subsampled_output(field); loc = location(field); subsampled_field = Field(loc, subsampled_grid); function output(model); interpolate!(subsampled_field, field); return subsampled_field; end; return output; end. subsampled_outputs = NamedTuple(name => create_subsampled_output(outputs[name]) for name in keys(outputs)); ```. And there's an infinity of other ways you can write your code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916:52,adapt,adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916,1,['adapt'],['adapt']
Modifiability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:145,evolve,evolves,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,1,['evolve'],['evolves']
Modifiability,Here's how the `u` field from the code-snippet above looks like when evolved on a SingleRegion and MultiRegion grids:. ![u](https://github.com/CliMA/Oceananigans.jl/assets/7112768/cf256be5-7e94-45d6-9bc3-e5c7a6adc1fb),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836:69,evolve,evolved,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836,1,['evolve'],['evolved']
Modifiability,"Here's my latest work on setting up an OMIP simulation:. https://github.com/CliMA/ClimaOcean.jl/blob/glw-ss/ice-ocean-model/experiments/prototype_omip_simulation/omip_simulation.jl. which also includes an example of using `ImmersedBoundaryGrid` to implement bathymetry. Bathymetry is a little sad there; I ""diagnose"" it from the ECCO state rather than prescribing directly. We need initialization tools for reasonable ""in painting"" for cases where initial condition information and bathymetry are slightly different (ie filling in NaNs near boundaries, etc). All of this should evolve quite a bit in the next few months. PS I'm going to convert this to a Discussion so that we can continue the party without needing to make any source code changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687:578,evolve,evolve,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687,1,['evolve'],['evolve']
Modifiability,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:91,variab,variables-and-scoping,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,4,['variab'],"['variables', 'variables-and-scoping']"
Modifiability,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:362,adapt,adapt,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['adapt'],['adapt']
Modifiability,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:712,parameteriz,parameterize,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685,2,['parameteriz'],['parameterize']
Modifiability,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:590,rewrite,rewrite,590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,1,['rewrite'],['rewrite']
Modifiability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:906,adapt,adapt,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,1,['adapt'],['adapt']
Modifiability,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:321,evolve,evolve,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554,1,['evolve'],['evolve']
Modifiability,"Hmm yes, perhaps the output writers need to be re-initialized when picking up as well? That would require extending what we do when we pick up here:. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/src/Simulations/run.jl#L87-L90",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752,1,['extend'],['extending']
Modifiability,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467:92,evolve,evolves,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467,2,['evolve'],['evolves']
Modifiability,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:87,extend,extended,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599,2,"['Adapt', 'extend']","['Adapt', 'extended']"
Modifiability,"Hmm, we need to take care because apparently only openmpi allows us to check this:. ```; help?> MPI.has_cuda; MPI.has_cuda(). Check if the MPI implementation is known to have CUDA support. Currently only Open MPI provides a mechanism to check, so it will return false with other implementations (unless overridden). For ""IBMSpectrumMPI"" it will; return true. This can be overridden by setting the JULIA_MPI_HAS_CUDA environment variable to true or false. │ Note; │; │ For OpenMPI or OpenMPI-based implementations you first need to call Init(). See also MPI.has_rocm for ROCm support.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465:428,variab,variable,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465,1,['variab'],['variable']
Modifiability,"Hmm... maybe something like. ```julia; s = 10 # stretching factor; h(k) = (1 - exp(s * (1 - k) / N)) / (1 - exp(-s)) # normalized, stretched height (goes from 0 at z=-Lz to 1 at z=0).; z_faces(k) = Lz * (h(k) - 1) # offsets normalized height and scales by Lz; ```. I get. ![image](https://user-images.githubusercontent.com/15271942/123190408-b7c2aa80-d45c-11eb-9eed-3c9aa1ed7c67.png). The stretched height function could be further parameterized by an exponent but it may not be necessary if changing `s` is sufficient for generating different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377:432,parameteriz,parameterized,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377,1,['parameteriz'],['parameterized']
Modifiability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:309,refactor,refactor,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['refactor'],['refactor']
Modifiability,"Hmm... with a vanilla closure, the change is completely encapsulated in the addition of two layers of abstraction (we are just calling a simple diffusion operator). So, let's figure out how to make the abstractions fast. I think the slow down for vanilla closures should be `nil`. The 'abstraction slowdown' causes much larger problems with the complicated closures, so we need to solve that problem anyways. Edit: I see your post, so what I said above holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529:92,layers,layers,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529,1,['layers'],['layers']
Modifiability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:660,flexible,flexible,660,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['flexible'],['flexible']
Modifiability,Hmmm I thought this line would be enough. https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150. but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think. Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to. But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460:215,variab,variable,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460,1,['variab'],['variable']
Modifiability,"Hmmm, do we know why we can't adapt the full `Field` to work inside GPU kernels? I think you said you've tried it but ran into some issues a while back?. The definition is; ```julia; struct Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; boundary_conditions :: B; ```; where the `grid` has been adapted, `data` is usually an offset array which has also been adapted, and I thought individual boundary conditions have been adapted as well so feels like it should be easy to adapt the full `Field`. Note: `boundary_conditions` is a named tuple of `FieldBoundaryConditions` so maybe we just need to adapt `FieldBoundaryConditions`, `CoordinateBoundaryConditions`? Hmmm but they're really named tuples so maybe they're already adapted. If we can't adapt `Field` then yeah the adapt rules you've suggested sound pretty good and would simplify the time stepping a lot. The kernels already deal with data tuples so not much would even have to change I think. If we can adapt `Field` though, then we should get all the benefits of simpler time stepping code without the confusion of a non-vanilla adapt rule. X-Ref: https://github.com/climate-machine/Oceananigans.jl/issues/298",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535,11,['adapt'],"['adapt', 'adapted']"
Modifiability,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:275,variab,variable,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682,1,['variab'],['variable']
Modifiability,"How about this @dhruvbhagtani?. ```Julia; julia> struct SingleLayer end. julia> struct MultiLayer end. julia> struct ShallowWaterModel{N, T}; number_of_layers :: Int; parameter :: T; ; function ShallowWaterModel(number_of_layers, parameter); if number_of_layers == 1; return new{SingleLayer, typeof(parameter)}(number_of_layers, parameter); else number_of_layers > 1; return new{MultiLayer, typeof(parameter)}(number_of_layers, parameter); end; end; end. julia> const SingleLayerShallowWaterModel{T} = ShallowWaterModel{SingleLayer, T}; SingleLayerShallowWaterModel (alias for ShallowWaterModel{SingleLayer}). julia> model1 = ShallowWaterModel(1, 2.0); SingleLayerShallowWaterModel{Float64}(1, 2.0). julia> model2 = ShallowWaterModel(2, 2.3); ShallowWaterModel{MultiLayer, Float64}(2, 2.3). julia> typeof(model1) <: ShallowWaterModel; true. julia> typeof(model1) <: SingleLayerShallowWaterModel; true. julia> typeof(model2) <: ShallowWaterModel; true. julia> typeof(model2) <: SingleLayerShallowWaterModel; false. julia> do_something(::SingleLayerShallowWaterModel) = ""I'll do something for single layer""; do_something (generic function with 1 method). julia> do_something(x) = ""I'll do something for multiple layers""; do_something (generic function with 2 methods). julia> do_something(model1); ""I'll do something for single layer"". julia> do_something(model2); ""I'll do something for multiple layers""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178:1210,layers,layers,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178,2,['layers'],['layers']
Modifiability,How does this PR change `adapt`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080:25,adapt,adapt,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080,1,['adapt'],['adapt']
Modifiability,"Hyperviscosity _is_ an LES closure. It's not just a great one because it requires tuning (ie you have to select the hyperviscosity, and the hyperviscosity doesn't change). You can use a scaling argument to find the hyperviscosity:. $$ \nu_4 = \Delta^4 / \tau $$. where $\Delta$ is a length scale (typically the grid spacing) and $\tau$ is the time-scale over which you'd like to damp grid scale motions. The longer the better. Perhaps you can estimate a time-scale in terms of the buoyancy frequency (eg to damp grid scale buoyancy oscillations) --- like $\tau = C / N$ where $N$ is the buoyancy frequency and $C$ is a constant (perhaps not O(1)). $C = 10$ could be a good starting point. If you need more dissipation then decrease $C$, if you need less increase $C$. Its not ""less correct"" than an LES closure. (Both are closures, not exact.) As for all LES or macroscale computational science in general the goal is to find solutions with statistics of interest that are indepednent of resolution. Note that upwinding can be thought of as adding hyperdissipation which scales with the velocity (similar to traditional LES closures in fact). WENO is adaptive-order hyperdissipation, from biharmonic on up. Personally I suspect that WENO produces more physical solutions than ""traditional"" LES closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193:1151,adapt,adaptive-order,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193,1,['adapt'],['adaptive-order']
Modifiability,"I added some more but they definitely don't cover _all_ cases. Either I forgot or I am missing the point of `x/y/z/λ/φspacing` methods (the ones that give you a particular spacing). Like where would those be useful?. Btw, a periodic grid with faces at [0, 1, 11, 101] implying centers at [0.5, 6, 56] has the following spacings. It took me a while to confirm that the first spacing for Faces is actually correct. ```julia; julia> grid = RectilinearGrid(size=3, topology=(Periodic, Flat, Flat), x=[0, 1, 11, 101]); F = vcat(F₋, interiorF, F₊) = [-101.0, -100.0, -90.0, 0.0, 1.0, 11.0, 101.0, 102.0, 112.0, 202.0]; C = [(F[i + 1] + F[i]) / 2 for i = 1:TC] = [-100.5, -95.0, -45.0, 0.5, 6.0, 56.0, 101.5, 107.0, 157.0]; 3×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── Periodic x ∈ [0.0, 101.0) variably spaced with min(Δx)=1.0, max(Δx)=90.0; ├── Flat y; └── Flat z. julia> xspacings(grid, Center()); 3-element view(OffsetArray(::Vector{Float64}, -2:5), 1:3) with eltype Float64:; 1.0; 10.0; 90.0. julia> xspacings(grid, Face()); 3-element view(OffsetArray(::Vector{Float64}, -3:6), 1:3) with eltype Float64:; 45.5; 5.5; 50.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678:824,variab,variably,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678,1,['variab'],['variably']
Modifiability,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565:298,adapt,adapt,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565,2,['adapt'],['adapt']
Modifiability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:346,variab,variable,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,3,['variab'],"['variable', 'variables']"
Modifiability,"I agree we can make the functions a little more verbose in that sense. ; We can change `calc_ κᶜᶜᶜ` to `calc_nonlinear_ κᶜᶜᶜ` and `calc_νᶜᶜᶜ` to `calc_nonlinear_νᶜᶜᶜ`. ; (`κᶜᶜᶜ` does not exist because diffusivity is needed at faces). For the variables we can make them verbose or agree to have a _concise_ naming convention (parallel to the verbose one) that is always consistent (i.e., `U` is `velocities`, `C` is `tracers`, `b` is `bouyancy` and so on)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335:242,variab,variables,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335,1,['variab'],['variables']
Modifiability,"I agree with @ali-ramadhan, keeping a `overwrite_existing` seems quite important to me too, potentially with a default value of `overwrite_existing = false`. . Another issue to add into this discussion is the fact of how to handle output (e.g. `file.nc`) with checkpoints and `file_splitting`. Currently, when a simulation is pickup from a checkpoint having the flag `overwrite_existing = true` rewrites to empty all the pre-existing files (i.e. file_part1.nc, file_partN.nc). With `overwrite_existing = false`, the simulation crashes because it doesn't find the file `file.nc`. I think it will be useful to handle automatic concatenation to splitted files, to allow a more flexible output particularly in the context of HPC computing with manageable file sizes, chunks, and wall times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179:395,rewrite,rewrites,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179,2,"['flexible', 'rewrite']","['flexible', 'rewrites']"
Modifiability,"I agree, let's just disable this test for now so we can merge outstanding PRs and rewrite the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087:82,rewrite,rewrite,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087,1,['rewrite'],['rewrite']
Modifiability,"I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860:131,config,configured,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860,1,['config'],['configured']
Modifiability,"I am just not extremely sure about the name `backend_kwargs`: at first glance, I thought it would be the keyword arguments of the `backend`, but it is just related to the reader of the underlying data (which for the moment, is only JLD2) and is not necessarily related to the backend (for the moment). ; I guess `jld2_kw` like in the `JLD2OutputWriter` does not work if we want to extend this to NETCDF. would something like `reader_kwargs` or `IO_kwargs` work you think?; Otherwise, if `backend_kwargs` is ok for the majority I can accept this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321:381,extend,extend,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321,1,['extend'],['extend']
Modifiability,"I am thinking about it actually, for the moment I am dealing with bug fixing and improving stability and accuracy (which should be basically finished), when I have everything tested and verified I ll proceed with the refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210:217,refactor,refactor,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210,1,['refactor'],['refactor']
Modifiability,"I am very curious to hear what people think but do think it would make sense to have a tab called Models where we state briefly the model equations. This way the user knows exactly what their getting themselves into. We have that for `IncompressibleModel` in the `Physics` section, and feel the other two models should get a bit of converge. Even though the numerical methods will evolve, the governing equations will not change. Or if they do we'll be adding more into them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226:381,evolve,evolve,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226,1,['evolve'],['evolve']
Modifiability,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:192,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008,3,"['Adapt', 'layers', 'variab']","['Adapt', 'layers', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,"I can help with a few things:. 1. Moving the existing implementation of `set!` to `Models/IncompressibleModels`.; 2. Writing a new version of `set!` that works with `ShallowWaterModel`.; 3. Implementing a few simple tests that ensure `ShallowWaterModel` can be instantiated. @francispoulin let me know if you'd like to me to work on those three things. For 2. I need some clarification: `IncompressibleModel` has a tuple of fields called `model.velocities`, which always has fields `velocities.u, velocities.v, velocities.w`. For `ShallowWaterModel` I believe the three essential prognostic variables are `uh`, `vh`, and `h`. Then there can be additional tracers in `sw_model.tracers`. How do you want to organize the essential prognostic variables? I think you can come up with any name you want, or you can split them into multiple places...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232:591,variab,variables,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232,2,['variab'],['variables']
Modifiability,"I can use CUDA on sverdrup:. ```julia; julia> using CUDA. julia> CUDA.has_cuda(); true. julia> CuArray(rand(3)); 3-element CuArray{Float64, 1}:; 0.5230283963088462; 0.0396121811777137; 0.04373785020067866; ```. this is with CUDA v3.3.1:. ```julia; (v1.6) pkg> st; Status `/net/ocean/home/data44/data5/glwagner/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.3.1; ```. so this suggests that indeed the problem is with the buildkite setup. > Why is JULIA_CUDA_USE_BINARYBUILDER=""true"" needed?. This was needed briefly when an nvidia driver went out of date. It is no longer out of date, however, so this environment variable is not needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666:625,variab,variable,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666,1,['variab'],['variable']
Modifiability,"I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425:165,config,configuration,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,I changed the title if you want to focus on variable time-step but I think you should open another discussion or issue for the other stuff about the size of chi,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216:44,variab,variable,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216,1,['variab'],['variable']
Modifiability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:12,refactor,refactoring,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['refactor'],['refactoring']
Modifiability,"I decoupled the high-order reconstructions from the low-order interpolations. ; The reconstruction for advective fluxes are in `Advection/reconstruction_coefficients.jl`. You can probably extend all the instances of `symmetric_interpolate`, `left_biased_interpolate` and `right_biased_interpolate` in `flat_advective_fluxes`. Or maybe put a fallback for Flat grids in `topologically_conditional_interpolation.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946:188,extend,extend,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946,1,['extend'],['extend']
Modifiability,"I didn't have a use-case in mind when suggesting this. It'll be rare for oceanography that two horizontal directions need to have different eddy diffusivities (though I'm sure that would be reasonable in some cases (balanced jet?)), but I think it's worth to implement that capability if we're trying to make Oceananigans a flexible, general-purpose-ish CFD package. Plus, given that parallelization capabilities are limited to only some directions, I can envision cases where users will rotate their domain in a way where the ""horizontal"" directions are actually `y`, `z`, and then `HorizontalDirections` won't work as intended. In any case, I personally will probably never use this feature, and it was only a suggestions for possible future uses. So feel free to ignore it if you think it's not worth it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720:324,flexible,flexible,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720,1,['flexible'],['flexible']
Modifiability,"I didn't have the same problem! I think that means the issue could arise from some downstream package in your Manifest.toml in your global 1.5 environment (which is not present in mine, for some reason). What is the output of. ```julia; julia> pkg""st --manifest""; ```. ?. Mine is. ```julia; julia> pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v2.4.0; [4fba245c] ArrayInterface v2.14.17; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e4b80f9] BenchmarkTools v0.7.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.3.0; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.4; [d360d2e6] ChainRulesCore v0.9.29; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.10.2; [3da002f7] ColorTypes v0.10.9; [5ae59095] Colors v0.12.6; [34da2185] Compat v3.25.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.3; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.2+1; [0c68f7d7] GPUArrays v6.2.0; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.53.0; [d2c73de3] GR_jll v0.53.0+0; [5c1252a2] GeometryBasics v0.3.9; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.8.19; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] Intel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:412,Adapt,Adapt,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Adapt'],['Adapt']
Modifiability,"I don't think so, we can refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680:25,refactor,refactor,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680,1,['refactor'],['refactor']
Modifiability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,adapt,adapted,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,1,['adapt'],['adapted']
Modifiability,I don't think we use PencilArray for CuArray either in the source code or tests. My question is: does bumping PencilArrays and PencilFFTs mean that we can extend the distributed FFT algorithm (currently only implemented on CPU) to GPUs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127,1,['extend'],['extend']
Modifiability,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,adapt,adapted,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748,1,['adapt'],['adapted']
Modifiability,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:522,parameteriz,parameterized,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781,4,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,"I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977:233,flexible,flexible,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977,1,['flexible'],['flexible']
Modifiability,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,adapt,adapt,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032,1,['adapt'],['adapt']
Modifiability,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:15,refactor,refactoring,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079,4,['refactor'],"['refactor', 'refactoring']"
Modifiability,I guess we could call it `grid_metric` instead of `area` and the iterator can be called `met` or `m` or `grid_term` instead... Probably also the comment above should be changed to something in the line of `operators of the form M * q where M is a grid metric and q is some variable`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558:273,variab,variable,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558,1,['variab'],['variable']
Modifiability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:285,variab,variables,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['variab'],['variables']
Modifiability,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:143,extend,extend,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['extend'],['extend']
Modifiability,"I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. . Some preliminary results are shown below. First, this is the case with a flat bottom and it does produce the same results as what we have in the example. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/3f8cc034-6764-4d3e-a7c1-510d7b55073d). Second, this is an example of prograde topography with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/d262c028-1ea3-41b8-8573-8ab4419ed891). Third, this is an example of retrograde topopgraphy with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/064ebf34-b8bf-4cca-9000-a9edb1bdfd94). The growth rates differ but I want to update my linear stability code to compute the growth rates so that we can validate that the results are quantitatively close. But for this case here the prograde case is slightly more unstable with the rettrograde case, which is qualitatively correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400:79,evolve,evolves,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400,1,['evolve'],['evolves']
Modifiability,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450,2,['config'],['configuration']
Modifiability,"I honesntly don't have a personal preference here. I'm just myself off of [Julia naming conventions](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) for variables and [general identified styles](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Examples_of_multiple-word_identifier_formats). `ZFaces`, `z_faces` or `z_Faces` work for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240:141,variab,variables,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240,2,['variab'],['variables']
Modifiability,I just changed the Adapt.jl compat entry to make use of the new version with the `StepRangeLen` fix. The MWE from #3870 does not error with Adapt.jl v4.1.1 locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135:19,Adapt,Adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135,2,['Adapt'],['Adapt']
Modifiability,"I just looked over the source code, and while I think this will be easy for the serial case, the code for distributed models is... fun... I have wanted to refactor the distributed stuff to make it understandable for a while anyways though. So I think we can come out on top.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708:155,refactor,refactor,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708,1,['refactor'],['refactor']
Modifiability,"I left a few comments in the code. To guide the design of this feature, consider a few important use cases:. 1. Buoyant particles (eg particles that feel an ""additional"" advecting velocity, in addition to `model.velocities` and `model.background_fields.velocities`); 2. Chemical reactions taking place on particles; 3. ""Elastic"" particles that bounce of walls with a specified coefficient of restitution; 4. Particles that are nudged with random stochastic noise in addition to advection (this is a crucial feature that is necessary to approximate the effect of molecular / subfilter turbulent diffusion). I am not suggesting that we support all of these immediately or in the near future, but it'd be good to have a type-based infrastructure for particle dynamics that can be extended to include more features.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396:777,extend,extended,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396,1,['extend'],['extended']
Modifiability,"I looked at both of those and they aren't very fast. That's why I coded up; my own in WaterLily. I have used CG preconditioners before with variable coefficient Poisson; equations and I agree they are a nice matrix free approach. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Thu, Jun 17, 2021 at 2:54 AM Francis J. Poulin ***@***.***>; wrote:. > I have never used multigrid solvers in julia but did a quick look around; > and found there are at least a couple of libraries one can use. If someone; > decides they want to play with multigrid, I would suggest looking at these; > and other libraries as that would be very fast to get started.; >; > https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl; > https://github.com/JuliaInv/Multigrid.jl; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862853210>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJ7IMJP5XPQFKUSYHGDTTFIUFANCNFSM457USDVQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831:140,variab,variable,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831,1,['variab'],['variable']
Modifiability,"I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name. It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420,1,['variab'],['variable']
Modifiability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['adapt'],['adapt']
Modifiability,I opened a new issue for parameterized Callbacks --- check out #2127,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751:25,parameteriz,parameterized,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751,1,['parameteriz'],['parameterized']
Modifiability,"I put a ton of effort into making it so that we could include one file and run the tests. So if its broken or wasn't a complete solution hopefully we can fix it, or make it work more generally. It's more annoying to have to include the filename as a global variable. I don't like that workflow as much. When we can include a file, we can rapidly iterate because we don't have to wait for things to recompile.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228:257,variab,variable,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228,1,['variab'],['variable']
Modifiability,"I put some work into the description, removing ""oceanic"" in favor of ""ocean-flavored"" and adding ""flexible"". Please reopen if there's still an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339:98,flexible,flexible,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339,1,['flexible'],['flexible']
Modifiability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2,refactor,refactored,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['extend', 'refactor']","['extended', 'refactored']"
Modifiability,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973:370,config,configuration,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973,2,['config'],['configuration']
Modifiability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:98,extend,extended,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,2,['extend'],"['extend', 'extended']"
Modifiability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:1508,evolve,evolved,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,1,['evolve'],['evolved']
Modifiability,"I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605:127,refactor,refactor,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605,1,['refactor'],['refactor']
Modifiability,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:280,extend,extended,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,2,['extend'],['extended']
Modifiability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:128,flexible,flexible,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['flexible'],['flexible']
Modifiability,"I think all the closures we have contain diffusivity data (constants or functions or fields) that are not in `diffusivities`. The list is here:. https://github.com/CliMA/Oceananigans.jl/tree/master/src/TurbulenceClosures/turbulence_closure_implementations. Only a subset of the code is documented, so better to look to the source when considering refactoring I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159:347,refactor,refactoring,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159,1,['refactor'],['refactoring']
Modifiability,"I think broadcasting for same-field operators, e.g. `CellField .+ CellField` would be really useful and make the code more readable. The simplification here is fewer loops to look at which is a big plus I think. But cross-field broadcasting is a bit trickier so might be better to leave it unimplemented especially as it's not a very common operation, I only use it when adding `f .* v` to `Gu` or `f .* u` to `Gv`. Without it you would have to explicitly write `u .+ avgx(avgy(v))` so if you forget it then it might make finding the bug a bit harder. With it, you can just write `u .+ v` with the averaging happening behind the scenes, so you might apply it by mistake without realizing it. Another potentially difficult bug to find. I feel like everyone has a different opinion on this but in my mind, I'm thinking this would make the code easier to read and write (short-term), and ultimately easier to extend by users (long-term). I just sometimes use issues leave random TODO notes and ramble.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799:906,extend,extend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799,1,['extend'],['extend']
Modifiability,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537:8,extend,extending,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537,2,['extend'],['extending']
Modifiability,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:139,parameteriz,parameterizations,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576,1,['parameteriz'],['parameterizations']
Modifiability,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652,1,['variab'],['variable']
Modifiability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Adapt,Adapt,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['Adapt'],['Adapt']
Modifiability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:623,variab,variable,623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"I think it's a clue that . ```julia; vz_op = @at((Face, Center, Center), ∂x(b) / f); ```. is valid. My guess now is that if. ```julia; vz_op = @at (Face, Center, Center) - ∂x(b) / f; ```. is interpreted as. ```julia; loc = (Face, Center, Center); op = ∂x(b) / f; invalid_subtraction = -(loc, op) # not only does this not work, it's also just one `Expr`; vz_op = @at invalid_subtraction; ```. We can try to bandaid this by extending `@at` but I guess it's really just invalid syntax. `@at((Face, Center, Center), ∂x(b) / f)` is the right way to express this --- nice find @iuryt !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478:422,extend,extending,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478,1,['extend'],['extending']
Modifiability,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634:891,refactor,refactor,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634,2,['refactor'],['refactor']
Modifiability,"I think so, the issue #3342 applies also to multi-region, so I think in a next PR we can extend this halo splitting to multi region boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630:89,extend,extend,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630,1,['extend'],['extend']
Modifiability,I think some stuff in `broadcast_abstract_field.jl` may need to be extended:. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl. specifically. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L18. which helps us identify when we're broadcasting between arrays and fields so that we hit . https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L42. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L46. Also. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L24-L28. where we take a shortcut for things like `u .= a` where `u isa Field` and a is some kind of array.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783:67,extend,extended,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783,1,['extend'],['extended']
Modifiability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:169,extend,extending,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,1,['extend'],['extending']
Modifiability,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:130,refactor,refactor,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677,1,['refactor'],['refactor']
Modifiability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:412,extend,extend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['extend'],['extend']
Modifiability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:121,layers,layers,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,2,['layers'],['layers']
Modifiability,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:177,refactor,refactor,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493,2,"['Extend', 'refactor']","['Extend', 'refactor']"
Modifiability,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:1285,variab,variables,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,1,['variab'],['variables']
Modifiability,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977:111,adapt,adapted,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977,2,['adapt'],['adapted']
Modifiability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:362,layers,layers,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,2,['layers'],['layers']
Modifiability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:1132,coupling,coupling,1132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,1,['coupling'],['coupling']
Modifiability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:169,refactor,refactor,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['refactor'],['refactor']
Modifiability,"I think we should delete the regression test and put a warning in the model constructor ""The ShallowWaterModel has not been validated"". It's a shame we've put so much time into the regression test as it is. I think the model likely has a few bugs to be ironed out. I'm also not convinced that we have all the numerical methods (ie vanishing layers, positive preserving advection) that would be needed to advertise the model as ""production-ready""). One could argue that the regression test is misleading in that it gives the false impression that the model is in a state that shouldn't change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100,1,['layers'],['layers']
Modifiability,"I think we should do 1. and 2., keeping them separate. On Wed, Mar 17, 2021, 8:53 PM Ali Ramadhan ***@***.***> wrote:. > Some time ago @sandreza <https://github.com/sandreza> and @xiaozhour; > <https://github.com/xiaozhour> suggested it would be useful to add the; > GM-Redi parameterization to Oceananigans.jl since we may want to train; > mesoscale eddy parameterizations.; >; > I'm opening this issue to discuss on what exactly needs to be implemented.; > My main reference is; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html; >; > It seems that there are three different new closures that could; > potentially be added:; >; > 1. Redi (symmetric) tensor diffusivity.; > 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; > 3. GM-Redi combining the two.; >; > Note: @glwagner <https://github.com/glwagner> has already implemented; > parts of the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themsel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:275,parameteriz,parameterization,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,2,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:457,extend,extended,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['extend'],['extended']
Modifiability,"I think we want `h` to be the layer thickness, so that these ideas generalize to ""n"" layers. Then the ""surface height"" is `H(x, y, t) = h(x, y, t) + b(x, y, t)`, where `b` is the height of the bathymetry. `eta` is defined relative to some reference height, eg `eta(x, y, t) = H(x, y, t) - H0`. I think with this definition, `b` comes into the pressure gradient but not momentum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918:85,layers,layers,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918,1,['layers'],['layers']
Modifiability,I think we want to do this over a few PRs. The first task is to extend BatchedTridiagonalSolver,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725,1,['extend'],['extend']
Modifiability,"I think we're ready to merge this once we hammer out the details. Still TODO will be:. - refactoring the model setup pages to be more tutorial-like; - finishing the tutorials on reductions, simulations, and field time series / post-processing. @navidcy @simone-silvestri @rafferrari",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831:89,refactor,refactoring,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831,1,['refactor'],['refactoring']
Modifiability,"I think what we want in terms of API is the ability to specify boundary conditions on the surface of an immersed boundary. One design would be to introduce a type called `ImmersedBoundary` that collects information about the location of the boundary and the boundary conditions for each field prescribed on it. This could be relatively simple to implement in the code, though it doesn't exactly conform to our current code design in which boundary conditions are embedded in `Field` objects. Another possibility that may better conform to our current boundary conditions / field design would be to embed `boundaries` in `grid` objects. With this design, `ImmersedBoundary` collects only information about its geometry and parameters related to its numerical implementation (eg regularization functions, interpolation methods, etc). We can then infer from `grid` the information needed to define boundary conditions for fields in both (`x` ,`y`, `z`), as well as on any `ImmersedBoundary`s. Grid constructors would then be something like. ```julia; grid = RegularCartesianGrid(; immersed_boundaries = ImmersedBoundary(geometry = # a function of (x, y, z, t); transfer_function = # parameters ; ); topology = # etc; ); ```; ; As for verification, I think we should use a quantitative test that verifies that boundary conditions are satisfied on the immersed boundary. Reproducing the Reynolds number correction to the drag coefficient on a sphere might be a good one, though it could be challenging because we'd have to use sponge layers to replicate an open boundary. We could also reproduce driven-cavity results in a triply periodic domain using rectangular immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759:1529,layers,layers,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759,1,['layers'],['layers']
Modifiability,"I think what you have discovered is that simulations with `BackgroundField` can behave differently on the GPU than on the CPU for some reason. What do you mean when you say the `BackgroundField` is not consistent with the boundary condition? The boundary condition is applied only to the prognostic variable (the deviation) only. Indeed, one of the most important applications of `BackgroundField` is to run simulations in which the deviations are _periodic_ even though the `BackgroundField` is not. The Eady turbulence problem is an example of one such problem. In that case the background velocity and buoyancy fields are not periodic in the y-direction; but because they only vary _linearly_, deviations from that background state _can_ be idealized as periodic. There may indeed be some issue regarding `BackgroundField` and `Bounded` directions, but I believe this is a bug and not expected. Certainly there is a bug if different results occur on the CPU versus the GPU. Hopefully we can get to the bottom of it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587:299,variab,variable,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587,1,['variab'],['variable']
Modifiability,"I think you instantiate a model to do many things; one of them is time-stepping, but another may be analysis. Another is testing. Even now we can't actually solve poisson's equation without a `Model` easily, which seems like an unnecessary restriction of our non-modularity. I don't think we should make this problem worse. I think it makes sense `model` is a field of `Simulation`. Its simple to envision `Simulation` parameters that are identical, with a different underlying `model` (eg, changing the number of passive tracers)`. The way I envision a logical course for the development of complex software in general is that we start with the fundamental building blocks and make them as easy to use in their low-level form as possible. When we've decided we can proceed no farther, we add another layer of abstraction that fuses these underlying building blocks into a higher-order coherent object. And so on. I think its a better design strategy to add *layers* of abstraction, rather than *embedding* abstraction within already complex objects. The latter strategy would lead to unmanageable complexity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410:959,layers,layers,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410,1,['layers'],['layers']
Modifiability,"I think η★ U★, and V★ (the intermediate variables at time step m+½ I think) are currently computed on-the-fly (mostly needed for AB3), which makes sense why imposing the topology and boundary conditions had to be baked into the operators. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L105-L120",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960:40,variab,variables,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960,1,['variab'],['variables']
Modifiability,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840:149,evolve,evolve,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840,2,['evolve'],['evolve']
Modifiability,"I want to merge this then use it to develop the user API for immersed boundary fluxes. Also, did anyone use this?. Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations. It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717:551,parameteriz,parameterizations,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717,1,['parameteriz'],['parameterizations']
Modifiability,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:251,rewrite,rewrite,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761,1,['rewrite'],['rewrite']
Modifiability,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:63,sandbox,sandbox,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,I will move `MultiDimensionalScheme` and the advection refactor to two different PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807:55,refactor,refactor,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807,1,['refactor'],['refactor']
Modifiability,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:538,extend,extend,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688,1,['extend'],['extend']
Modifiability,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Adapt,Adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['Adapt'],['Adapt']
Modifiability,"I would not incorporate those modifications but rather try to understand why that happens. The only difference there is the use of `getregion` instead of indexing with `[region]`. But `getregion` is intended to be basically just an indexing for the variables you have there, so it means that there is a problem with `getregion`, maybe a missing `@inline` somewhere?. In the end, with apply_regionally what happens under the hood is just this:. ```julia; for (r, dev) in enumerate(devs); switch_device!(dev); regional_func!((getregion(arg, r) for arg in args)...; (getregion(kwarg, r) for kwarg in kwargs)...); end; ```; In this case `regional_func!` is the launch! function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115:249,variab,variables,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115,1,['variab'],['variables']
Modifiability,I'd like to eliminate `Δx` from the code because this grid metric is only valid on regular horizontal grids. This is why I did not extend `Δx` for `ImmersedBoundaryGrid` when I extended all of the other grid metrics here:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/ImmersedBoundaries/immersed_grid_metrics.jl. I was hoping that not including rogue metrics like `Δx` would facilitate in excising them from the code base. Where in `ShallowWaterModel` to you use `Δx`? I think in the stack trace for the error you received you should be able to locate where the problematic `Δx` is called.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836,2,['extend'],"['extend', 'extended']"
Modifiability,I'm closing this. I'll open an issue to discuss an advection scheme refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459,1,['refactor'],['refactor']
Modifiability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:92,variab,variable,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['variab'],['variable']
Modifiability,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:234,layers,layers,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['layers'],['layers']
Modifiability,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Adapt,Adapt,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,1,['Adapt'],['Adapt']
Modifiability,"I'm not sure. I'm not very familiar with the testing part of Oceananigans, so I'm not sure what would be a good test for this. Just testing that `min_Δz` works seems too specific, on the other hand, creating a whole simulation with a stretched grid and running it with an LES and adaptive time-stepping just to test that seems wasteful. I'm happy to just merge this for now and create a test for this in the future. Thoughts?. CC @glwagner @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165:280,adapt,adaptive,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165,1,['adapt'],['adaptive']
Modifiability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,2,['extend'],['extend']
Modifiability,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:139,refactor,refactored,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:750,variab,variable,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047,1,['variab'],['variable']
Modifiability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:26,config,configure,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['config'],['configure']
Modifiability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:1798,variab,variable,1798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,2,['variab'],['variable']
Modifiability,If `times` is a `Vector` then it needs to be converted to `arch_array` _and_ adapted when passed to GPU. We're doing a big overhaul on #3450 and this is one of the thing we fixed:. https://github.com/CliMA/Oceananigans.jl/blob/13dcd4ff9767c5a1e030bf4ce5765cc661b1175b/src/OutputReaders/field_time_series.jl#L235-L243,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002:77,adapt,adapted,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002,1,['adapt'],['adapted']
Modifiability,If it was related to the rewrite of the terms then shouldn't been affecting CPU regression test as well?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830:25,rewrite,rewrite,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830,1,['rewrite'],['rewrite']
Modifiability,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:24,variab,variable,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174,1,['variab'],['variable']
Modifiability,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:626,evolve,evolve,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702,1,['evolve'],['evolve']
Modifiability,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:402,variab,variables,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298,1,['variab'],['variables']
Modifiability,"In case people don't know, @hennyg888 ran all the benchmark scrips and I beileve he has posted the results here. Thank you Henry!. I think the scripts have evolved in that some of the outputs are formatted different than what currently appears. I'm not sure if people want to change everything to the current benchmark scripts that we have?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836:156,evolve,evolved,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836,1,['evolve'],['evolved']
Modifiability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:224,variab,variable,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,In the examples I have developed I have tried to always declare variables that are referenced globally in forcing functions or boundary conditions as `const`. Definitely open PRs to fix this if you find places where that isn't the case. I haven't stayed on top of every example that's been added.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284:64,variab,variables,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284,1,['variab'],['variables']
Modifiability,"Indeed the pressure solver at the moment allows only a variable z-direction. This is because for a regular grid we can use a full FFT solve while with a singular stretched direction we can solve a tridiagonal system. . For more than one stretched direction we should use an iterative solver to solve the Poisson equation (the solvers are there but the infrastructure not quite yet). We should implement the iterative solver as a default for two or more stretched directions. And set up the FFT-tridiagonal solver as default when we have one stretched direction (either x, y or z). In the meantime, as a hotfix, If you only need one stretched direction I would suggest you to rotate your problem to stretch it in z-direction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786:55,variab,variable,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786,1,['variab'],['variable']
Modifiability,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,adapt,adapt,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,3,['adapt'],['adapt']
Modifiability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:923,extend,extend,923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['extend'],['extend']
Modifiability,Is the PR on KA very crucial?. Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664:52,refactor,refactoring,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664,1,['refactor'],['refactoring']
Modifiability,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:288,refactor,refactor,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617,1,['refactor'],['refactor']
Modifiability,"It also bears mention that the curious behavior in the lat-lon results above (what looks like spurious boundary fluxes after around 20 days) apparently occurs whether we include the GM parameterization or not. So something else is wrong, perhaps with Bounded boundary conditions on lat-lon (but not sure).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179:185,parameteriz,parameterization,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179,1,['parameteriz'],['parameterization']
Modifiability,"It appears to be related to the size of the grid:. ```julia; julia> grid = RectilinearGrid(GPU(), size=(8, 8, 8), x=(0,1), y=(0,1), z=0:8); 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [0.0, 8.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0. julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Cartesian",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313:371,variab,variably,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313,2,['variab'],['variably']
Modifiability,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:637,variab,variably,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:186,Adapt,Adapt,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:38,variab,variables,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,2,['variab'],['variables']
Modifiability,"It would be nice to convert it into a discussion, but I think we want to correct the AB2 for variable time stepping quite soon, because it might be a large source of error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962:93,variab,variable,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962,1,['variab'],['variable']
Modifiability,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947,2,['extend'],['extend']
Modifiability,"It's hard because even [wikipedia](https://en.wikipedia.org/wiki/Stokes_drift) is misleading on this subject and says. > For a pure wave motion in fluid dynamics, the Stokes drift velocity is the average velocity when following a specific fluid parcel as it travels with the fluid flow. Yet if a mean velocity exists, the motion is not a ""pure wave"" motion; it has a mean component and a wave component, each of which have dynamics that are independent in the limit of small amplitude waves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:789,evolve,evolve,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,1,['evolve'],['evolve']
Modifiability,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:261,layers,layers,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,4,['layers'],['layers']
Modifiability,"It's mirroring Base julia, eg. ```julia; julia> a = rand(2, 3, 4); 2×3×4 Array{Float64, 3}:; [:, :, 1] =; 0.264469 0.977549 0.937297; 0.491955 0.710279 0.315507. [:, :, 2] =; 0.243796 0.783644 0.820073; 0.682626 0.351825 0.503396. [:, :, 3] =; 0.726912 0.287171 0.671998; 0.234873 0.993365 0.913062. [:, :, 4] =; 0.507489 0.568977 0.327032; 0.59475 0.547478 0.459589. julia> size(a, 3); 4; ```. We've extended `size` for fields, and `1, 2, 3` do currently correspond to the first, second, and third dimensions in that syntax. So I don't agree that it ""means nothing"", but perhaps we want something else for our API... I do agree that having named dimensions is a cool idea. I wonder if it'd be better to do this properly in the sense of #1700 or https://rafaqz.github.io/DimensionalData.jl/stable/course/#Dimensions-and-DimArrays rather than just providing functions like `size(c::AbstractField, :x)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695:401,extend,extended,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695,1,['extend'],['extended']
Modifiability,"It's needed when your computation is located on `Face`s. By default, `work_layout` returns a layout that extends from ""1 to `N`"". This default is used for time-stepping kernels. But for diagnostics you usually want that last grid point at `N+1`. It might make sense to change the default value, since users / people writing new kernels probably want `include_right_boundaries=true`, and its only a minority of rarely-changed kernels (for time-stepping) that want `include_right_boundaries=false`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764:105,extend,extends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764,1,['extend'],['extends']
Modifiability,It's so nice that we have these tests. Seeing them pass makes me so confident that you did this matrix constructor refactor correctly @elise-palethorpe.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052:115,refactor,refactor,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052,1,['refactor'],['refactor']
Modifiability,"It's something to do with GPU, maybe GPU reductions?. ```; [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; --;   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199;   | Expression: minimum_xspacing(grid) ≈ FT(π / 3);   | Evaluated: 0.0 ≈ 1.0471975511965976; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331:112,variab,variably,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331,1,['variab'],['variably']
Modifiability,"It's true that global variables have to be defined as `const`, but it's also true that global variables are never ""required"" (they just may be more convenient than defining a callable struct)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878,2,['variab'],['variables']
Modifiability,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:75,Extend,Extending,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432,3,"['Extend', 'extend']","['Extending', 'extended']"
Modifiability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:132,variab,variable,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,1,['variab'],['variable']
Modifiability,Just a small plea to make this implementation compatible with / moves us towards the refactor envisioned in #2454,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043:85,refactor,refactor,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043,1,['refactor'],['refactor']
Modifiability,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:188,variab,variables,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,4,"['Variab', 'variab']","['Variable', 'variable', 'variables']"
Modifiability,"Just as an update --- we actually currently cannot do this verification experiment because of a problem with LES models (a theoretical problem, not an implementation problem) with specified buoyancy flux boundary conditions and zero stress boundary conditions. In short, we observe grid-scale oscillations in the near-surface buoyancy gradient when buoyancy fluxes are specified. The primary issue is associated with a too-small near-surface LES diffusivity. . I want to emphasize that this is not a numerical issue with boundary condition specification, or a bug in the LES implementation --- this is a fundamental, theoretical problem with LES formulation. Others have observed this issue before with a variety of LES formulations, so this issue is not particular to AMD, either. I'm working on a fix because this is an important, canonical problem. The easiest way to fix the problem is to allow the LES model constant (which we should view as a free parameter) to vary in space and in particular to increase near the wall. This is simple, yet completely empirical solution. . The level of empiricism / near-wall enhancement of the model constant needed for a smooth solution is mitigated somewhat if we can specify the gradient of buoyancy / temperature on the boundary. This second component of the fix can be done by introducing a wall model on top of the interior LES formulation that applies *on* boundaries. The wall model introduces a second free parameter in addition to the interior LES free parameter. Adjusting the wall model's free parameter allows us to ""effectively"" increase the near-wall value of the AMD diffusivity. An even better, more complete fix would also modify the interior LES model near the wall. But this is an open-ended science problem with no clear solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239:1116,enhance,enhancement,1116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239,1,['enhance'],['enhancement']
Modifiability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:911,variab,variable,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['variab'],['variable']
Modifiability,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777:94,evolve,evolves,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777,2,['evolve'],['evolves']
Modifiability,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:113,layers,layers,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998,3,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:87,flexible,flexible,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,1,['flexible'],['flexible']
Modifiability,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:529,config,configurations,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,2,['config'],['configurations']
Modifiability,"KE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1730,variab,variable,1730,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['variab'],['variable']
Modifiability,"Let me try to reframe the problem and tell me if you agree. I think its a real issue that the output files are created when the output writers are instantiated. Because of this, we find ourselves having to write `overwrite_existing=false` when we pickup from a checkpoint, but `overwrite_existing=true` otherwise. This is a hack for sure. It's a failure of the checkpointer design --- the whole point of the design is to make checkpointing easy. We should be able to change just one line. I even think we should be able to pick up from a checkpoint with an environment variable so we don't have to change the run script at all. That would be more robust. What you're describing sounds like an additional problem of this deficiency. The fix seems straightforward. We just need to introduce the concept of output ""initialization"". Then we can delay creating the output file to `run!`. At that point we know if we are picking up from a checkpoint or not, obviously if we are picking from a checkpoint we don't want to delete any existing files. It seems like if we introduce initialization we can also handle file splitting. What do you think? If you want to help we can get started on it. I was putting it off myself because I don't have immediate needs for checkpointing but that will probably change pretty soon. Separately I don't like I also don't like `overwrite_existing` more broadly because I feel its boilerplate, which we are discussing a bit over on #3793 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167:569,variab,variable,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167,1,['variab'],['variable']
Modifiability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:212,config,configurations,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['config'],['configurations']
Modifiability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Adapt,Adapt,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,2,['Adapt'],['Adapt']
Modifiability,"Looks like this happened after PR #1740 was merged as https://buildkite.com/clima/oceananigans/builds/2893 looks fine (GPU tests running on the commit before #1740 was merged) but the next commit/build on master is not fine https://buildkite.com/clima/oceananigans/builds/2895 (no GPU tests on the #1740 merge commit). Maybe this had something to do with CUDA.jl v3.3.0 or with the addition of the `JULIA_CUDA_USE_BINARYBUILDER=""true""` environment variable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977:448,variab,variable,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977,1,['variab'],['variable']
Modifiability,"Lots of interesting discussion here. Nomenclature can be a pain as people use a lot of different words for the same things and sometimes use the same word for different things. I wonder whether finding a good review article and citing that would be a good way to establish our foundation? I imagine there is a lot to choose from out there but don't have a specific one in mind. Below are a few thoughts. 1) I would argue that molecular viscosity is real (resolved) physics, in these continuum models, is derived from physical principles and you should not change the coefficients based on the grid you are using. These are measured in experiments and are what the community to believe as true when doing lab experiments. 2) For large-scale flows, as many of us consider, molecular viscosity is insignificant and should probably be ignored as it has no real meaning on the large scales. That is why summing molecular and eddy viscosities does not seem like such a good idea to me. However, adding a very small number to a large number will nto make much of a difference for all intensive purposes. I would think that the user has the onous of responsibility of picking the viscosity that is appropriate for their problem. . 3) For large-scale flows where you need some parameterization, I think that using `eddy` or `sgs` are accepted by large groups in the community. Effective seems a little less desirable for me as it does not say where it comes from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859:1268,parameteriz,parameterization,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859,1,['parameteriz'],['parameterization']
Modifiability,Maybe better to extend the `Checkpointer` constructor specifically for `ShallowWaterModel`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956:16,extend,extend,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956,1,['extend'],['extend']
Modifiability,Maybe it did need some of the overwrite existing because it writes different configurations to the same file. Update: passes locally if I add them back,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076:77,config,configurations,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076,1,['config'],['configurations']
Modifiability,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:1039,refactor,refactoring,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,1,['refactor'],['refactoring']
Modifiability,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397:384,extend,extend-parent-indices,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397,2,['extend'],['extend-parent-indices']
Modifiability,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:70,config,configured,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285,1,['config'],['configured']
Modifiability,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:294,parameteriz,parameterizations,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['parameteriz'],['parameterizations']
Modifiability,"Navid here is the output-; ```; julia> using Pkg. julia> Pkg.activate("".""); Activating environment at `~/new_directory/Project.toml`. julia> print(read(""Manifest.toml"", String)); # This file is machine-generated - editing it directly is not advised. [[AbstractFFTs]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""485ee0867925449198280d4af84bdb46a2a404d0""; uuid = ""621f4979-c628-5d54-868e-fcf4e3e8185c""; version = ""1.0.1"". [[Adapt]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""f1b523983a58802c4695851926203b36e28f09db""; uuid = ""79e6a3ab-5dfb-504d-930d-738a2a938a0e""; version = ""3.3.0"". [[ArrayInterface]]; deps = [""IfElse"", ""LinearAlgebra"", ""Requires"", ""SparseArrays"", ""Static""]; git-tree-sha1 = ""2fbfa5f372352f92191b63976d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d250",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:422,Adapt,Adapt,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"New parameters for `RiBasedVerticalDiffusivity` in this PR as well @simone-silvestri . https://user-images.githubusercontent.com/15271942/227622141-c682b9d5-8848-4f3d-9734-aa258463b2f3.mp4. Note the TKE variable has no dynamics, just a passive tracer for ri-based.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126:203,variab,variable,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126,1,['variab'],['variable']
Modifiability,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,adapt,adaptations,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615,1,['adapt'],['adaptations']
Modifiability,"Nice!. I was actually going to advocate for adding such a utility because I've found myself running a few tests where the time steps are likely to be diffusion limited:; 1. possibly stratified Couette flow sometimes,; 2. the Pearson vortex test from PR #336,; 3. more recently the [forced flow test](https://github.com/climate-machine/Oceananigans.jl/blob/5355044deae3120134b55cc20f6e38f637eea6a5/test/verification/forced_flow.jl) from (Brown, Cortez, & Minion, 2000) that I'm using to test whether our operator-splitting method is second-order accurate in both velocity and pressure. For geophysical flows, the time step will almost always be limited by advection, but there seem to be many other flows where the time step will be limited by diffusion. So if we want a package that is usable for not just geophysical flows, it would be nice to have adaptive time stepping that works with both advective and diffusive CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951:850,adapt,adaptive,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951,1,['adapt'],['adaptive']
Modifiability,"No need to apologize! To extend a method, you can `import` it:. ```julia; import Oceananigans.Grids: with_halo. with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. Alternative syntax is. ```julia; using Oceanigans.Grids. Grids.with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. These are identical and the difference is just a matter of style. Syntax for namespace management is documented here: https://docs.julialang.org/en/v1/manual/modules/#using-and-import-with-specific-identifiers,-and-adding-methods",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769:25,extend,extend,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769,1,['extend'],['extend']
Modifiability,"No worries about the late response! Here's a couple of comments, might have more later. > The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:302,variab,variable,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,2,['variab'],['variable']
Modifiability,None other than it requires typing the code and adding a test or two. Are you suggesting extending the capabilities of `FieldSlicer`? I think that's a nice idea if so!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134:89,extend,extending,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134,1,['extend'],['extending']
Modifiability,"Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709:68,variab,variable,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709,1,['variab'],['variable']
Modifiability,"Not really, it will call the fallback. But it's no cost to just have an adapt there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246:72,adapt,adapt,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246,1,['adapt'],['adapt']
Modifiability,"Not working yet --- we have to be able to calculate the isopycnal slope inside the vertically-implicit diffusion solver, so need some refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751:134,refactor,refactoring,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751,1,['refactor'],['refactoring']
Modifiability,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:290,extend,extend,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376,2,['extend'],"['extend', 'extends']"
Modifiability,"OK! I'll review this!. so in Oceananigans terms is the `e-ϵ` parameterization, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527:61,parameteriz,parameterization,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527,1,['parameteriz'],['parameterization']
Modifiability,"OK, I added some tests for variably spaced grids as well. @glwagner, what do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030:27,variab,variably,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030,1,['variab'],['variably']
Modifiability,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231:810,sandbox,sandbox,810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231,9,"['Sandbox', 'sandbox']","['Sandbox', 'sandbox']"
Modifiability,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:247,layers,layers,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445,1,['layers'],['layers']
Modifiability,"Oh yeah that should work. I'll wait and see what your implementation looks like then. I agree that something like `set_surface_temperature!(model, 300)` looks much more user-friendly and portable!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399:187,portab,portable,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399,1,['portab'],['portable']
Modifiability,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:852,config,configuration,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824,1,['config'],['configuration']
Modifiability,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:181,maintainab,maintainable,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940,1,['maintainab'],['maintainable']
Modifiability,"Ok here's a little more insight into the problem. The issue is actually with `view`, which doesn't work when called on windowed field. `view` can only _create_ a windowed field from a full field, right now. In other words, `view` cannot act on a `view`. Haha. I'm extending `view` to work correctly when the argument itself is already windowed. This is probably the issue with outputting the free surface too. I can't remember exactly what went wrong there though. The output issue could also hint that things are more convoluted than they should be. Still though, we should be able to create views into fields that are already views. It should be fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577:264,extend,extending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577,1,['extend'],['extending']
Modifiability,"Ok if its just for a quick test rather than extended work, that makes sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427:44,extend,extended,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427,1,['extend'],['extended']
Modifiability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:24,refactor,refactors,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['refactor'],['refactors']
Modifiability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:397,extend,extend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['extend'],['extend']
Modifiability,"Okay finally tests passed!. @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run. So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543:349,variab,variability,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543,1,['variab'],['variability']
Modifiability,"Okay so this MWE reproduces the error:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); time = defDim(ds,""time"",Inf); v = defVar(ds,""temp"",Float32,(""time"",)); ds[""temp""][1] = b. close(ds); ```. However, if I create a variable without an unbouded dimension (i.e. without time) and do the same thing, it works properly:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); v = defVar(ds,""temp"",Float32,()); ds[""temp""][] = b. close(ds); ```. So I think this is an edge case that NCDatasets doesn't yet handle well. I'm gonna create an issue there and see what they say.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454:294,variab,variable,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454,1,['variab'],['variable']
Modifiability,"Okkkk round 2. Let's see if this makes more sense. ```julia; # Two-parameter stretching:; h★ = 0.5 # controls spacing near surface (higher means finer spaced); Δh = 0.25 # normalized height where stretching becomes significant (here, 1/4 of domain height). h₀(k) = h★ + (1 - h★) * (k - 1) / (Nz + 1) # linear normalized height; h(k) = h₀(k) * tanh((k - 1) / (Δh * Nz)) / tanh(1 / Δh) # bottom-stretched normalized height. z_faces(k) = Lz * (h(k) - 1); ```. Hopefully that produces something more sensible. EDIT: ~~I guess this parameterization only works for small values of `Δh` (otherwise the grid is invalid). I'll keep thinking --- I think we can just replace the bottom-stretching function (the tanh) with something better behaved.~~ Fixed that in the above. Another issue is that spacing is linear near the bottom for large `Δh` so only the middle is stretched. So we could try a three-parameter function instead (maybe not worth it for this PR...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861:527,parameteriz,parameterization,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861,1,['parameteriz'],['parameterization']
Modifiability,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:5,refactor,refactoring,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464,4,['refactor'],['refactoring']
Modifiability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:58,refactor,refactor,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,4,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898,2,"['refactor', 'variab']","['refactoring', 'variable']"
Modifiability,"One thing that might be easier to ask for help with his, I wanted to print out the norm of the perturbation buoyancy in both cases. When we evolve the perturbation this is easy, but when we evolve the total field, I couldn't figure out how to do it. Do you have a recommendation? . This would be helpful to determine how the norm changes with resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691:140,evolve,evolve,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691,2,['evolve'],['evolve']
Modifiability,Or maybe to adapt the default based on the incoming grid?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164,1,['adapt'],['adapt']
Modifiability,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947:118,variab,variable,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947,4,['variab'],['variable']
Modifiability,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851,19,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,"Perhaps a more concise and extendable implementation would be. ```julia; compute!(collection::Union{Tuple, NamedTuple}) = map(compute!, collection); ```. inspired by [Adapt](https://github.com/JuliaGPU/Adapt.jl/blob/ff4419424b6b48b4440c5235f5a4070880fcdf79/src/base.jl#L3)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483:27,extend,extendable,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483,3,"['Adapt', 'extend']","['Adapt', 'extendable']"
Modifiability,"Perhaps start a git repo and post a link to it? It's best to include the julia environment you're using with the file (otherwise it will go stale as Oceananigans evolves). If you want to just post the file then you can use a [gist](https://gist.github.com), or copy/paste the code here if its short.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219:162,evolve,evolves,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219,1,['evolve'],['evolves']
Modifiability,"Perhaps we rename all variables to `closures` when they are tuples of 2 elements or more? Just a suggestion, feel free to ignore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730,1,['variab'],['variables']
Modifiability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:317,parameteriz,parameterization,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,2,['parameteriz'],['parameterization']
Modifiability,"Perhaps, there is no need for an environment variable that modify the filename, instead this is something that could be done if the user is using a checkpoint. But rather than using this convoluted workflow that will require renaming and deleting files, I thought the optimal implementation is to append to the previous existing file when using checkpoints. If the filename is `vel_fields.nc`, the expected files after the second pickup should be:; ```; vel_fields_part1.nc vel_fields_part3.nc vel_fields_part5.nc ; vel_fields_part2.nc vel_fields_part4.nc ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027:45,variab,variable,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027,1,['variab'],['variable']
Modifiability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:101,adapt,adaptive,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,1,['adapt'],['adaptive']
Modifiability,"Pressure is different from other variables because it doesn't have a dedicated `compute!` function. I do actually think it would be nice to ""regularize"" the code in this way by making the pressure (and eddy diffusivities) into `KernelComputedField`s (or other kinds of special fields) so that `compute!` works on them in the same way it works on other `ComputedField`s. The reason it is different is because while we have always had pressure auxiliary variables, `ComputedField`s are only a relatively recent addition to the code. In fact, it hadn't even occurred to me that it would be nice if we could use `compute!(hydrostatic_pressure)` until recently. More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be `1027` and in the other its `1024`. But otherwise I don't see why it wouldn't work and I am a bit stumped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341:33,variab,variables,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341,2,['variab'],['variables']
Modifiability,Pretty sure what I wrote will work. May need `adapt` as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146:46,adapt,adapt,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146,1,['adapt'],['adapt']
Modifiability,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:459,extend,extending,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965,4,['extend'],"['extend', 'extending']"
Modifiability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:595,parameteriz,parameterization,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['parameteriz'],['parameterization']
Modifiability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:781,extend,extend,781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,2,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:516,variab,variable,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740,1,['variab'],['variable']
Modifiability,Regarding vanishing layers: what MOM6 does (I think) is that layers never vanish but they are restricted to have height of 1e-10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473:20,layers,layers,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473,2,['layers'],['layers']
Modifiability,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354:121,extend,extended,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354,2,['extend'],['extended']
Modifiability,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:102,layers,layers,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343,2,['layers'],['layers']
Modifiability,"Right, another reason to allow the user to specify the time attribute when using `NetCDFOutputWriter`. The default `IncompressibleModel` uses seconds so that could be an argument for ""seconds"" being the default for `NetCDFOutputWriter`. But right now it's not configurable by the user so I'll keep this issue open until this is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283:260,config,configurable,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283,1,['config'],['configurable']
Modifiability,"Right. It serves the same purpose as the `OutputWriter` abstract type. It's dispatched on for functions like `run_diagnostic` and `time_to_run` in PR #352. https://github.com/climate-machine/Oceananigans.jl/blob/908ae4d23ce3e472d03fd69766edc457301df681/src/diagnostics.jl#L6. We did agree to refactor the diagnostics abstraction anyways, so maybe the need for an abstract `Diagnostics` type will disappear. I might hold off on this issue until it's clearer what `diagnostics.jl` will look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721:292,refactor,refactor,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721,1,['refactor'],['refactor']
Modifiability,"Run with implicit vertical diffusion and implicit free-surface, 20 minutes time step, 2.8 degree resolution and 18 vertical layers (constant spacing), ""realistic"" bathymetry, 30 years in about 2 hrs. https://user-images.githubusercontent.com/33547697/149965680-be56233d-3a08-4d2b-8115-cdb14edfd1af.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597:124,layers,layers,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597,1,['layers'],['layers']
Modifiability,"Running the example to t = 100 rather than t=150 would yield a quick 2/3. I think we can also decrease the resolution and increase the time-step. The resolution also is not isotropic, which essentially wastes grid points. The x dimension is 2pi but y is width 20. So if we use Ny = 128 then we might as well use something like Nx = 64 or 48. Further decreasing the resolution would also help a lot, because the time steps could be increased. And I think the movie doesn't need to plot so many frames. I think the writing and notation can also be improved. It's confusing to use `L_z` to refer to the reference depth. The `ShallowWaterModel` calls this variable `h`, and it's easy to confuse with the vertical extent of a 3D grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758:652,variab,variable,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758,1,['variab'],['variable']
Modifiability,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059,2,['extend'],['extending']
Modifiability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:9,extend,extend,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,4,"['config', 'extend', 'layers']","['configs', 'extend', 'layers']"
Modifiability,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,adapt,adapting,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087,1,['adapt'],['adapting']
Modifiability,Should we extend `mask_immersed_field` for `BinaryOperation`? And for `MultiaryOperation`? This might be useful also for post-processing,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711:10,extend,extend,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711,1,['extend'],['extend']
Modifiability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:642,Adapt,Adapt,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Adapt'],['Adapt']
Modifiability,"So [this section of the docs](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters) is misleading (or maybe just plain wrong), no?. We should probably rewrite that with an example using a callable. I think the MWE here would suffice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186:111,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186,2,"['rewrite', 'variab']","['rewrite', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:145,extend,extended,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,2,['extend'],['extended']
Modifiability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:160,variab,variables,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,2,['variab'],['variables']
Modifiability,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Adapt,Adapt,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['Adapt'],['Adapt']
Modifiability,"Some of the points that could be in the Goals/Mission section:. - Easy to install, understand and use; - Versatile: model is made in blocks that could be combined and easily configured across scales; - Modern: this might be no independent from the others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806:174,config,configured,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806,1,['config'],['configured']
Modifiability,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:1509,variab,variably,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777,2,['variab'],['variably']
Modifiability,"Some pretty promising Lagrangian particle tracking benchmarks!. Couple of takeaways (all assuming a model with 128^3 grid points and QAB2 time stepping):; 1. **Low overhead**: You can advect up to ~100,000 particles on the CPU and up to ~10,000,000 particles on a (Titan V) GPU before the model slows down by more than 30%.; 2. **Great on GPUs**: Seems that the GPU is great for advecting millions of particles. You can advect ~100,000,000 particles and your model only slows down by a factor of 4x. In this scenario, the GPU is ~620x faster than a single CPU core.; 3. Calculated using `(t_100000000 - t_0) / 100000000`, advecting a single particle on the CPU takes ~110 ns while on the GPU it only takes ~0.127 ns. This seems a little too good to be true but I'll double check this. I'll start refactoring this PR using @glwagner's and @zhenwu0728's feedback, but I think it would be really great if we can keep this performance. # Benchmarks. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Lagrangian particle tracking benchmarks; ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; │ CPU │ 1000 │ 378.076 ms │ 384.114 ms │ 383.611 ms │ 388.507 ms │ 297.16 KiB │ 1906 │; │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:796,refactor,refactoring,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['refactor'],['refactoring']
Modifiability,Some sandbox stuff might've been added by accident,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586:5,sandbox,sandbox,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586,1,['sandbox'],['sandbox']
Modifiability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,adapt,adapt,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:94,variab,variability,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216,1,['variab'],['variability']
Modifiability,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620:163,adapt,adapt,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620,4,['adapt'],['adapt']
Modifiability,"Something else I tried was deleting the `Project.toml` and `Manifest.toml` file as well as `~/.julia`, and after running the following:; ```; using Pkg; Pkg.activate("".""); Pkg.add(""CUDA""); Pkg.instantiate(); using CUDA; ```; I got:; ```; [57577] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:210; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Activating new project at `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer`; Installing known registries into `~/.julia`; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Adapt ─────────────────────── v4.0.4; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed SentinelArrays ────────────── v1.4.5; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ───────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:868,Adapt,Adapt,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Adapt'],['Adapt']
Modifiability,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Adapt,Adapt,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:974,variab,variable,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,3,"['Adapt', 'variab']","['Adapt', 'variable']"
Modifiability,"Sorry for the slow replies, I am currently away. I will put together a MWE when I am back. More out of interest, is there a benefit to passing variables explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727:143,variab,variables,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727,1,['variab'],['variables']
Modifiability,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1100,inherit,inherit,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312,1,['inherit'],['inherit']
Modifiability,Stochastic CI variability? I restarted them...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915:14,variab,variability,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915,1,['variab'],['variability']
Modifiability,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2072,adapt,adapt,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:602,config,configure,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['config'],['configure']
Modifiability,"Suggestions are definitely welcome for streamlining everything!. Note: in dedalus, this problem is handled by allowing users to accumulate parameters into something like `model.parameters` (in dedalus, this is essentially a dict whose keys are accessible by their names to any function/equation defined with a string expression). Having a ""global-like"" variable (like `model.parameters`) is pretty convenient, but also leads to more complicated code. The more democratic callable object strategy is a bit simpler and more modular, but may involve a slightly more complicated API (though I'm not 100% sure about that --- users must decide!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214:353,variab,variable,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214,1,['variab'],['variable']
Modifiability,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Adapt,Adapt,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Adapt'],['Adapt']
Modifiability,"Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:18.729] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:19.136] INFO Running shallow wat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10688,Config,Configuration,10688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Config'],['Configuration']
Modifiability,"Tests fail on v0.76.5 on GPU... weird... ```Julia; nc3020@gadi-gpu-v100-0100:/g/data/v45/nc3020/OC.jl$ julia-1.6 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:477,Adapt,Adapt,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:290,variab,variable,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:825,adapt,adaptive,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,2,['adapt'],['adaptive']
Modifiability,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,3,"['adapt', 'extend', 'rewrite']","['adapt', 'extended', 'rewrite']"
Modifiability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:390,maintainab,maintainable,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['maintainab'],['maintainable']
Modifiability,"Thank you for your feedback @maleadt! What is CUDAnative compilation? If you mean the precompilation phase when CUDAnative is first loaded, then it's not that as I start timing after all packages are loaded. I thought 6-7 minutes was normal/expected as @vchuravy et al. reported similar GPU compilation times for their shallow water model: https://github.com/JuliaLabs/ShallowWaterBench. I haven't done any rigorous benchmarking yet but out of those 6 minutes, ~1.5 minutes are spent on compiling code that creates CuFFT plans (the first plan takes 1.5 minutes then the others take <1 second). From watching the log I'm guessing the other 4.5 minutes are evenly split between setting up the model (creating CuArrays, initializing them, etc.) and the first time step (where the kernels are getting compiled presumably). I don't think we have that many kernels (just 5 bigger ones) but one of them; https://github.com/ali-ramadhan/Oceananigans.jl/blob/2b64d584c79ece0429f2421335ddb6bc0c6c6663/src/time_steppers.jl#L213; has several layers of inlining (it's inlining the majority of the functions in [operators/ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl)) after which it probably balloons up to be a pretty big kernel. They also have tons of arguments crammed in as the structs I was passing weren't `isbitstype` (working on this #59). I should come back and update this issue once we do some proper benchmarking (note to self: nvprof seems like it's being deprecated in favor of Nsight). Caching kernels between sessions sounds tough but will definitely look into timing compilations in CUDAnative, might provide some insight on how to speed things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765:1030,layers,layers,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765,1,['layers'],['layers']
Modifiability,"Thanks @ali-ramadhan. I agree and confirmed that where the derivative is computed on faces and centres, the following line and the line below. This should extend to higher orders of course. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Operators/derivative_operators.jl#L18",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886,1,['extend'],['extend']
Modifiability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:380,layers,layers,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['layers'],['layers']
Modifiability,"Thanks @glwagner and I agree, at the last time I definitely see more smaller scale features. Also, I agree that since velocity is always smoother than vorticity, that is perhaps a better field to use. Clever idea!. In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354:343,rewrite,rewrite,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354,1,['rewrite'],['rewrite']
Modifiability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:60,adapt,adapt,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,1,['adapt'],['adapt']
Modifiability,"Thanks @glwagner! We haven't been using background velocities in our setups, so won't have as much to say on that yet. But we'll continue testing the background tracer fluxes. @samlewin, are you using background shear in addition to background tracer fields in your configurations, or is the shear just in your initial conditions? This PR might be relevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204:266,config,configurations,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204,1,['config'],['configurations']
Modifiability,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:75,adapt,adapted,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['adapt'],['adapted']
Modifiability,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145,2,['variab'],['variable']
Modifiability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:512,adapt,adapt,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['adapt'],['adapt']
Modifiability,"Thanks for bringing these up! This stuff certainly needs some work, and we should probably make it clear what's e.g. a free parameter. > I see a few problems:; > * `f` is not a property of a planet. Agreed. Perhaps now that we're also thinking of channel models on a _β_-plane, we should also build a ""rotation"" abstraction to choose between _f_-plane, _β_-plane, and Coriolis force (possible with cosine term). > * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients. Yes. This should be addressed by incorporating a `TurbulentDiffusivity` struct like the one you proposed in #120. I agree with John that when we do this, isotropic and anisotropic diffusion should be options. > * A reference density is not a parameter in an equation of state.; Hmmm, but if ρ₀ is needed to calculate ρ then isn't it a parameter of the EOS?. Sounds like this issue is worth discussing and strategizing about. We could maybe get some ideas and inspiration from how CliMA.jl is handling parameters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405:423,config,configuration,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405,1,['config'],['configuration']
Modifiability,"Thanks for confirming!. So the two outstanding issues are:. - [ ] Do we want to divide by volumes instead of areas to be more general? (Cosmetic but maybe worth fixing); - [ ] Figure out how the height field should be included to achieve higher accuracy, which neither formulation is able to do.; - [ ] Do we evolve the tracer or thickness weighted tracers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785:309,evolve,evolve,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785,1,['evolve'],['evolve']
Modifiability,"Thanks for embarking on this @glwagner!. > It's a bit of a work in progress. Before merging we need:; > * tests (simple 1D test with temperature to see if budgets are correct?). Just added ""WIP"" (work in progress) to the PR title. We can work on the tests together. For testing, we should be able to extend the 1D column model example: https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/column_model.jl. > Also looks like Travis is failing; not sure why that is. Looks like it's just the one test in the time stepping section that's failing. Maybe something to do with how the boundary conditions are called during the time stepping? The Model test passes so it's not erroring during model initialization/construction. > I propose changing the struct `BoundaryConditions` to `ModelBoundaryConditions` for clarity. I'll always vote for clarity!. Just one initial question: I might be misunderstanding the purpose of `bc.calc` but why not `bc.impose(args...)` instead of `bc.calc(args...)` as we usually say that we _impose_ boundary conditions?. Have to run out but will have a more detailed look later today. Otherwise, looks really neat! On a more practical note, might end up being easier to discuss this PR in person.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606:300,extend,extend,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606,1,['extend'],['extend']
Modifiability,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:346,refactor,refactor,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,2,['refactor'],['refactor']
Modifiability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:926,variab,variable,926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"Thanks for the feedback! We were also thinking that if the ocean and atmosphere shared the same vertical indexing then maybe using some shared parameterizations would be easy but as pointed out, vertical indexing isn't necessarily a rigid thing in DG. Also sounds like the ocean and atmosphere don't need to agree as they're arbitrary decisions anyways. Interesting point about setting the vertical index to be the fastest running index to help speed up vertical integrals. We only have one vertical integral in the time stepping core so not sure if it'll make a big difference on the ocean side but something to think about! Might be relevant to #21. We decided to switch our convention and use _k=1_ at the bottom. I'll submit a PR soon with this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068:143,parameteriz,parameterizations,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068,1,['parameteriz'],['parameterizations']
Modifiability,"Thanks for the questions @simone-silvestri . I'll answer them here as it's probably easier for the discussion. **Q1**: You can certainly solve the equations in the non-conservative form and the method should work. But it does't have any advantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['extend'],['extend']
Modifiability,Thanks for the suggestions @simone-silvestri! And I noticed you started doing some refactoring in PR #3847 so I'll close this in favor of your PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850:83,refactor,refactoring,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850,1,['refactor'],['refactoring']
Modifiability,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:797,extend,extends,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651,1,['extend'],['extends']
Modifiability,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:929,config,configuration,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847,1,['config'],['configuration']
Modifiability,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155,1,['adapt'],['adapt']
Modifiability,"That was the main issue we discussed in #2740 with locating the free surface at `grid.Nz+1`. . (from #2740); > Well the issue is that if we want to save the output at the surface `(:, :, grid.Nz)` we cannot include the free surface if this is defined at `grid.Nz+1` (it would not exist at `grid.Nz`). ... `grid.Nz+1` won against `grid.Nz` so, for the moment, you should define two different `OutptWriters`, one for grid-sized variables and one for the free surface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238:426,variab,variables,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238,1,['variab'],['variables']
Modifiability,"That was used for smoothness indicators on variable grids (the previous `stretched_smoothness` in `WENO5(grid = grid, stretched_smoothness=true)`). I temporarily removed that keyword because it assumed that WENO was order 5. (also we weren't using it because it made everything quite slow). I had the plan to reintroduce it with the upcoming advection refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527:43,variab,variable,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:85,adapt,adapt,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['adapt'],['adapt']
Modifiability,"That's great that you want to do this @apaloczy ! I am also happy to help if I can. I think that @glwagner explained it very well. One question I will raise is, do we prefer to have to have height as a variable, or the free surface, which is more consistent with the hydrostatic model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766,1,['variab'],['variable']
Modifiability,"The Julia docs go into a lot of detail and have a useful summary (https://docs.julialang.org/en/v1.5/manual/modules/#Summary-of-module-usage-1) but I think `import` is used with the intention of extending a method via multiple dispatch. So you would `import Flux: σ` if you wanted to define a new method for `σ`, e.g. if you wanted to define a custom `σ(x::Complex)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366:195,extend,extending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366,1,['extend'],['extending']
Modifiability,"The MIT grid seems to just copy the metrics from the first cell... ```; julia> grid = ConformalCubedSphereGrid(cs32_filepath, CPU(), Nz=1, z=(-1, 0));; ┌ Warning: ConformalCubedSphereGrid is experimental: use with caution!; └ @ Oceananigans.CubedSpheres ~/Research/OC.jl/src/CubedSpheres/conformal_cubed_sphere_grid.jl:163. julia> fgrid = grid.faces[1]; 32×32×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 1×1×1 halo and with precomputed metrics; ├── longitude: FullyConnected λ ∈ [-45.0, 44.0312) variably spaced with min(Δλ)=80152.3, max(Δλ)=3.23804e5; ├── latitude: FullyConnected φ ∈ [-45.0, 42.2888) variably spaced with min(Δφ)=80152.3, max(Δφ)=3.23804e5; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> fgrid.Δxᶠᶠᵃ[0:3, 0:3]; 4×4 Matrix{Float64}:; 80152.3 80152.3 1.36265e5 170108.0; 80152.3 80152.3 1.36265e5 170108.0; 1.33313e5 1.33313e5 1.51133e5 1.76175e5; 1.69174e5 1.69174e5 1.75781e5 1.90232e5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750:545,variab,variably,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750,2,['variab'],['variably']
Modifiability,The `SplitExplicitFreeSurfaces` module is only temporary here for easier manipulation and refactoring of the code. We can remove it if we decide we don't want the free surface in a module,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537:90,refactor,refactoring,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537,1,['refactor'],['refactoring']
Modifiability,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:865,layers,layers,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,2,['layers'],['layers']
Modifiability,"The buoyancy is actually a buoyancy perturbation, showing the growth of diffusive boundary layers + waves. But the viscosity and diffusivity help dissipate the grid scale waves so that larger scale waves dominate later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450:91,layers,layers,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450,1,['layers'],['layers']
Modifiability,"The climate machine shallow water model used DG numerics. I agree with Greg; that it would be nice to do a side-by-side comparison of two; numerical approaches to the same underlying equations. Not sure it used a; Bernoulli formulation.; john; ps Francis - great that you are involved with oceananigans!. On Fri, Nov 13, 2020 at 11:53 AM Gregory L. Wagner <notifications@github.com>; wrote:. > 2. Climate Machine also has a shallow water model; > <https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl>.; > I don't know the details of what this does but I should probably learn how; > the two models will differ.; >; > I'm not 100% sure how its implemented but I think at the end it'd be great; > if both ClimateMachine and Oceananigans shallow water models used the same; > equation set, since we can then compare the numerics. We don't have the; > bandwidth to develop the ClimateMachine shallow water model, but possibly; > at the time the Oceananigans has a nice one we'll be motivated to flesh out; > ClimateMachine's model.; >; > I'm not sure about immersed boundaries --- does the method generalize in a; > simple way? I'm not sure whether a special treatment is required for the; > height field, compared to an ordinary velocity variable, or tracer.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWKUQJEBFEYXSOVQO3SPVQABANCNFSM4TQVNFEA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931:1282,variab,variable,1282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931,1,['variab'],['variable']
Modifiability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:309,config,configuration,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['config'],['configuration']
Modifiability,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:107,variab,variables,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803,1,['variab'],['variables']
Modifiability,"The convention we use for the other variables stored on faces is that our ""interior"" data spans from `i=1` to `i=N`. Thus we call the `i=N+1` a ""halo point"" for fields on faces, even though it really is not (its on the boundary, see #455). . In addition, we use a convention that face indices are ""left"" of cell indices. Thus `iFace=1` corresponds to the ""left"" boundary of the domain. `iCell=N` is the rightmost cell in the domain; and `iFace=N+1` corresponds to the rightmost boundary. Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this? This is confusing to me and I don't see why we would want to have an odd and surprising convention for the vertical coordinate. The fact is simply that the face at `i=N` is a very concrete and real place. It lies in the interior of the domain, to the left of the cell point `i=N`. This is a fact of our grid and must be internalized by anyone who wants to work with the discrete data and index fields directly by raw index. If/when we use named axis conventions for `fields` (see #457), we would be able to access the surface via `u[Z(At(0))]` (or some syntax like that. We can also create an alias `Surface() = Z(At(0))`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106:36,variab,variables,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106,1,['variab'],['variables']
Modifiability,The conversation around metrics is still unsettled. AFAICT there's no way to put those in the SGRID variable. There are [CF conventions](http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#cell-measures) for `cell_measures`: specifically `area` and `volume` but we would also need length. There is a `cell_thickness` standard_name that could be used for this. cc @jbusecke,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990:100,variab,variable,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990,1,['variab'],['variable']
Modifiability,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:28,parameteriz,parameterization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470,6,['parameteriz'],['parameterization']
Modifiability,"The easiest way to add additional fields into a forcing is to create them before the forcing, eg. ```julia; eddy_diffusivity = CenterField(grid); ```. Such a field can be passed into a forcing function as a parameter, for example. (It can also be captured inside a function as a global variable). To use this, you'll have to use the ""discrete form"" forcing. More on that in the docs: https://clima.github.io/OceananigansDocumentation/stable/model_setup/forcing_functions/. To compute this field, write a callback,. ```julia; function compute_eddy_diffusivity(sim); νₑ = sim.model.diffusivity_fields.νₑ; Pr = sim.model.closure.Pr; parent(eddy_diffusivity) .= parent(νₑ) ./ Pr; return nothing; end; ```. Next add the callback to the simulation,. ```julia; add_callback!(simulation, compute_eddy_diffusivity); ```. By default the callback is called every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354:286,variab,variable,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354,1,['variab'],['variable']
Modifiability,"The issues with the `HydrostaticFreeSurfaceModel` are the tendency kernels. The difference with the non-hydrostatic model is that we do not know a priori which RHS function to call (for example CATKE has an `:e` tracer that requires a different RHS function and the same goes with a 1 equation parameterization of mesoscales that evolves an additional tracer equation for the mesoscale energy `:K`). Our solution now is to infer the RHS function and pass it as an argument to the kernel. Apparently, this prevents compilation. I ll come up with a solution today",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926:294,parameteriz,parameterization,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926,2,"['evolve', 'parameteriz']","['evolves', 'parameterization']"
Modifiability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:336,coupling,coupling,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['coupling'],['coupling']
Modifiability,"The more I think about it, the more I like the idea of an environment variable to have a ""pickup mode"". Let's see what others think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022,1,['variab'],['variable']
Modifiability,"The next one I ran into is https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Advection/reconstruction_coefficients.jl#L215. So one alternative is to use named tuples instead of variables. ```; @inline function compute_reconstruction_coefficients(grid, FT, scheme; order). method = scheme == :Centered ? 1 : scheme == :Upwind ? 2 : 3. rect_metrics = (:xᶠᵃᵃ, :xᶜᵃᵃ, :yᵃᶠᵃ, :yᵃᶜᵃ, :zᵃᵃᶠ, :zᵃᵃᶜ). if grid isa Nothing; coeffs = (; (m => nothing for m in rect_metrics)...); else; metrics = coordinates(grid); dirsize = (:Nx, :Nx, :Ny, :Ny, :Nz, :Nz). arch = architecture(grid); Hx, Hy, Hz = halo_size(grid); new_grid = with_halo((Hx+1, Hy+1, Hz+1), grid); coeffs = (; (rect_metric => calc_reconstruction_coefficients(; FT, getfield(new_grid, metric), arch, getfield(new_grid, dir), Val(method); order = order); for (dir, metric, rect_metric) in zip(dirsize, metrics, rect_metrics))...); end. return tuple(coeffs...) # actually return named tuple to be order invariant; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102:218,variab,variables,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102,1,['variab'],['variables']
Modifiability,"The only distinction is that in the `VectorInvariantFormulation` (that evolves $u$ and $v$) you want to compute; $h^{-1} \nabla \nu h \nabla t$,; while in the `ConservativeFormulation` (that evolves $uh$ and $vh$) ; $\nabla \nu h \nabla t$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384:71,evolve,evolves,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384,2,['evolve'],['evolves']
Modifiability,"The reason that the advection term is the only term account for is because this is typically what one wants. If you want diffusion to act on the entire temperature profile (not just the perturbation), then perhaps you shouldn't use a background field at all. Instead you should initialize the temperature to `T(z) = N^2 * z + T'(z)` where `T'(z)` is the perturbation and evolve the entire temperature field. This is more correct anyways... Background fields are useful when one wants to consider either some kind of (implicit) forcing that maintains the background field, preventing it from evolving. If we include a diffusion term associated with the background field, then we defeat much of the purpose of having a background field feature in the first place. The same is true for boundary conditions. One important use case for background fields is when we can set up a problem where the perturbation is periodic even though the background is not. In that scenario the total field is not periodic, and we could not use a periodic domain. Enter `BackgroundFields`: decomposing the solution into background + perturbation allows us to model the perturbation in a periodic domain with periodic boundary conditions. If the periodic boundary condition were defined as a boundary condition on the total (background + perturbation), then we wouldn't be able to achieve this important case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716:371,evolve,evolve,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716,1,['evolve'],['evolve']
Modifiability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:88,variab,variable,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['variab'],['variable']
Modifiability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:52,extend,extended,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,4,['extend'],"['extend', 'extended']"
Modifiability,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:180,variab,variable,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953,1,['variab'],['variable']
Modifiability,"There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. When we find that we have to use `@allowscalar`, it often indicates that our `Field` infrastructure is somehow deficient / doesn't support necessary operations, which causes us to resort to indexing and other syntax that requires `@allowscalar`. @navidcy @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641:102,refactor,refactoring,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641,1,['refactor'],['refactoring']
Modifiability,"There are two things at play here. First, there is a refactoring of the equation set to allow for a generalized vertical coordinate. This actually involves rewriting the equations. To merge that generalization, I think we would also like to see the new equations that are being solved written up in the docs. When the equations are generalized, this would also involve implementing a new abstraction for the vertical coordinate, along with a `vertical_coordinate = ZVerticalCoordinate()` default, which preserves existing behavior. The second PR should then implement a `ZStarVerticalCoordinate()` (other better names are fine too). So to me this feels like we need two PRs, one with docs update and API design, and then a second with z* implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677:53,refactor,refactoring,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677,1,['refactor'],['refactoring']
Modifiability,"There is a choice we need to make about the third variable: the total depth (what we usually denote as `h`) or the free-surface (what we usually denote with `\eta`). In the equations you have above, the first set of equations is using `h` as the total depth, but the second uses it as a free-surface. I am fine with either but if we are using the variable `h`, I would vote for the layer depth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220,2,['variab'],['variable']
Modifiability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:150,layers,layers,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,2,['layers'],['layers']
Modifiability,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517,1,['adapt'],['adapt']
Modifiability,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:199,Config,Configuration,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627:153,config,configuration,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627,2,['config'],['configuration']
Modifiability,"There seems to be a problem with calculating fluxes in a `Flat` direction. . The `Horizontal` formulation It is trying to calculate the viscous flux in the horizontal direction using the vertical vorticity which requires at least 2 points in each horizontal direction. . (specifically these two lines); ```; @inline viscous_flux_vx(i, j, k, grid, closure::AHD, clock, U, args...) = - ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v); @inline viscous_flux_uy(i, j, k, grid, closure::AHD, clock, U, args...) = + ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v) ; ```. because this calls the circulation operator `Γᶠᶠᶜ`; which is calculated as. ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v) - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); ```. requiring `i-1` which we do not have if `x` is `Flat`. ; I wonder how it was even working before? Maybe a workaround we can implement is to extend the circulation operator for `Flat` directions. ```; @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, Flat}, u, v) = - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, <:Any, Flat}, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v); ```. Or maybe just put it to zero since it actually is zero",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703:945,extend,extend,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703,1,['extend'],['extend']
Modifiability,"There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly. We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`. ```julia; @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472:122,extend,extend,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472,1,['extend'],['extend']
Modifiability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:31,refactor,refactoring,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['refactor'],['refactoring']
Modifiability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:345,adapt,adaptive,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,1,['adapt'],['adaptive']
Modifiability,"Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488:145,refactor,refactor,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488,1,['refactor'],['refactor']
Modifiability,This PR might need to be closed or refactored. We now have `VerticallyImplicitTimeDiscretization`. A new turbulence closure called `ConvectiveAdjustmentDiffusivity` would probably useful for some users. For this the convective adjustment diffusivity should be precomputed. During this computation the vertical buoyancy gradient can be calculated on the fly with the function `∂z_b`; so there would be no need to store the vertical buoyancy gradient separately.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805:35,refactor,refactored,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805,1,['refactor'],['refactored']
Modifiability,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,adapt,adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518,1,['adapt'],['adapt']
Modifiability,This is an amazing refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527:19,refactor,refactor,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527,1,['refactor'],['refactor']
Modifiability,"This is for explicit free surface, I ll extend the benchmarks for implicit and weak scaling",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634:40,extend,extend,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634,1,['extend'],['extend']
Modifiability,This is great to see!. I imagine we could use this for the height field in `ShallowWaterModel` to allow for wetting and drying for a single layer. And also to prevent layer collapse in the case of multiple layers.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245:206,layers,layers,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245,1,['layers'],['layers']
Modifiability,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:750,layers,layers,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,2,['layers'],['layers']
Modifiability,This may help https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178:42,Adapt,Adapt,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178,1,['Adapt'],['Adapt']
Modifiability,This might be a duplicate of PR #3830 but looks like both will be superseded by PR #3847 which is doing the refactoring necessary for this fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690:108,refactor,refactoring,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690,1,['refactor'],['refactoring']
Modifiability,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:222,evolve,evolve,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,2,['evolve'],['evolve']
Modifiability,"This sounds like a good idea!. I guess it shouldn't be too hard to extend the implementation to support `fx`, `fy`, and `fz` like you're suggesting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944:67,extend,extend,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944,1,['extend'],['extend']
Modifiability,"This will further crystallize the distinction between linear distances (x, y, z) and ""native coordinate systems"" (Cartesian for Rectilinear, geographic for LatitudeLongitude). We already have this partially implemented; ie `Δx` returns a linear distance. But the implementation has not extended to xnodes, ynodes, etc. Kind of a side note but it'd be nice to figure out a cleaner / more concise way to implement the `with_halos` feature. It's hard to read the code as it is now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440:286,extend,extended,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440,1,['extend'],['extended']
Modifiability,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114,4,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"Those are all possible developments. To put fields in `closure` we have to implement a pattern (implemented for things like boundary conditions, though it's taken a lot of work to get it right) whereby users instantiate a ""template"" `closure`, to which fields / data are added later given knowledge of the grid in the model constructor. Otherwise, users have to provide `grid` as an argument when constructing both a closure and a model. Either pattern is possible --- but implementing a ""template + materialization"" design is complicated, whereas requiring users to provide `grid` when constructing a closure changes the API. When a complicated algorithm endows the code with more features, I feel it could be justified if the feature is good enough. But if its only purpose is to rearrange where array references are bound, it feels less worth the trade off of code maintenance and the work to implement it. Another solution is documentation. Storing constant values in `diffusivities` is possible, but could be interpreted as boilerplate. The coefficients need to be stored in `closure`, because that's where users specify them. So copying the constants or functions into `diffusivities` (this would have to be done individually for all closures) requires additional code. I think of all the changes to `diffusivities`, the one that makes the most sense is to eliminate that field and change the API so that `grid` is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. Note: I don't this will work for memory parallel models until #1825 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160:1524,refactor,refactor,1524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160,1,['refactor'],['refactor']
Modifiability,"Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2453,Adapt,Adapt,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:143,layers,layers,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259,1,['layers'],['layers']
Modifiability,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420,1,['extend'],['extend']
Modifiability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:277,evolve,evolve,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['evolve'],['evolve']
Modifiability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:407,variab,variables,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['variab'],['variables']
Modifiability,"Using the code from `fjp/benchmark-incompressiblemodel-WENO5` branch I get this:. ```Julia; julia> using Oceananigans; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/E3Wer/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:257,Config,Configuration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['Config'],['Configuration']
Modifiability,"Very cool. Many thanks!. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urld",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:715,config,configured,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['config'],['configured']
Modifiability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,1,['refactor'],['refactor']
Modifiability,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,adapt,adapt,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['adapt'],['adapt']
Modifiability,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:1058,parameteriz,parameterization,1058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,2,['parameteriz'],['parameterization']
Modifiability,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,adapt,adapt,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073,1,['adapt'],['adapt']
Modifiability,"We could also define this at the top level in `src/Oceananigans.jl`. For coupling, we will have to set these constants in the simulation constructor (hopefully we won't be changing source code)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495:73,coupling,coupling,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495,1,['coupling'],['coupling']
Modifiability,"We have variables `∇²eᵢⱼₖ` implying that `∇²` acts on `eᵢⱼₖ`. But that's not always the case, right?. Let's change all `∇²eᵢⱼₖ` -> `Aeᵢⱼₖ`? And add a small remark, e.g.,. ```Julia; eᵢⱼₖ = similar(template_field) # the basis vector; Aeᵢⱼₖ = similar(template_field) # A * eᵢⱼₖ; ```. I think everything should be here:; https://github.com/CliMA/Oceananigans.jl/blob/639d337b4449c7aa846b1005ce5109ba590ff786/src/Solvers/multigrid_solver.jl#L192-L233",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332:8,variab,variables,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332,1,['variab'],['variables']
Modifiability,We maybe need to adapt the constructor of the `KrylovSolvers` (workspaces) for your specific type.; Example: https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/src/krylov_solvers.jl#L162. It works fine for CPU / GPU arrays as well as various partitioned arrays but `Field` seems quite different.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678,1,['adapt'],['adapt']
Modifiability,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:369,config,configured,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,5,"['Config', 'config']","['Configuring', 'configuration', 'configured']"
Modifiability,"We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if netCDF allows unicode (and because I felt it was outside of the scope of that PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661:28,variab,variable,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661,1,['variab'],['variable']
Modifiability,"We think there is a race condition in the CI. Partly discussed on #3661 and also #3662, although one conclusions is that we should update to use the buildkite plugin (started on #3042)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885:159,plugin,plugin,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885,1,['plugin'],['plugin']
Modifiability,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Adapt,Adapting,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['Adapt'],['Adapting']
Modifiability,"We'll be refactoring the way grids and architectures work soon, so this PR isn't needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139,1,['refactor'],['refactoring']
Modifiability,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:84,config,configurations,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['config'],['configurations']
Modifiability,"Well, fractional indices work, just not `DateTimes` indices. I am not super familiar with what date-times supports in terms of operations, if it supports summation and division it is straightforward to extend indexing with to `DateTimes`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941:202,extend,extend,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941,1,['extend'],['extend']
Modifiability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:196,extend,extendable,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['extend'],['extendable']
Modifiability,"What do we think about the pros and cons of an alternative design that adds `state_callbacks` to `Simulation` and extends `time_step(model, dt, state_callbacks)` to accept the state callbacks as a positional argument?. It might be slightly less code and we don't have to bloat the model structs anymore. It also keeps the callback implementations in `Simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269:114,extend,extends,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269,1,['extend'],['extends']
Modifiability,"What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`?; `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels. (I really should have made this comment in #3488, but it's never too late..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056:197,config,configs,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056,1,['config'],['configs']
Modifiability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:416,rewrite,rewrite,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['rewrite'],['rewrite']
Modifiability,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:91,extend,extend,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404,1,['extend'],['extend']
Modifiability,"What is the intent of these tests? Are they intended to be included in CI, or are they more in the style of “benchmarks” that are run relatively infrequently?. @edoddridge A twist on option 1 is to design a forcing that exactly cancels the terms associated with nonlinear and linear terms in a given equation for some simple initial condition consisting of sines and cosines. For example, pick an initial condition, calculate all terms in a given equation, and then write a forcing that exactly cancels those terms. Then check that the initial condition doesn’t change after a few time-steps. This method allows a test at low resolution with low computational burden and allows each nonlinear and linear term in each equation to be assessed separately. . It would also be good to run “benchmarks” that are designed to be run less frequently, which is a category I think some of the suggested tests fall into (?) Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242:966,config,configuration,966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242,1,['config'],['configuration']
Modifiability,What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else... But I'm not sure if it's difficult to refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219:178,refactor,refactor,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219,1,['refactor'],['refactor']
Modifiability,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:339,variab,variable,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,2,['variab'],['variable']
Modifiability,"When `StepRangeLen` is adapted to GPU it goes through this `adapt_structure`:. https://github.com/JuliaGPU/Adapt.jl/blob/5ef7c5329609df7ffb5b19942d6747b3dcc162c2/src/base.jl#L79-L80. This is invalid though, because it does not preserve the type of the range. It calls this constructor in Julia's base:. https://github.com/JuliaLang/julia/blob/9850a3881221a57a382e98c9b9ae2bf97ac3966d/base/range.jl#L524-L525. specifically we get a range of type `typeof(ref+zero(step))`, which is `Float64` if `step isa Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630:23,adapt,adapted,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630,2,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Modifiability,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:601,Variab,Variable,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819,1,['Variab'],['Variable']
Modifiability,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,adapt,adapted,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007,1,['adapt'],['adapted']
Modifiability,Woops sorry I meant to delete the sandbox! Would be great to increase variety among the existing examples so it's a great idea.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067:34,sandbox,sandbox,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067,1,['sandbox'],['sandbox']
Modifiability,"Would it make sense to initialize with the analytical solution to the (linear or weakly nonlinear) barotropic problem? Even if a simple Laplacian viscosity is a poor parameterization for eddy effects, it should dramatically accelerate the equilibration process, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493:166,parameteriz,parameterization,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493,1,['parameteriz'],['parameterization']
Modifiability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1200,rewrite,rewrite,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['rewrite'],['rewrite']
Modifiability,"Yeah I agree with no code being better than broken code. So I guess that means nuke non-working scripts and they can always be revived later with the intention of maintaining them long-term. Also agree that sandbox is bad. We can discourage further short-term additions to `validation` and encourage people to use branches or other short-term repositories for them?. As for repo size yeah the biggest files are images and regression files which we could aim to get rid of in the long-term, maybe in one fell swoop with BFG repo cleaner. We've done in the past but it takes some preparation and is rewriting git history which is bad.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473:207,sandbox,sandbox,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473,1,['sandbox'],['sandbox']
Modifiability,"Yeah I think some of those one-off experiments in `validation` should probably be nuked. Maybe we should put them in a `sandbox` directory in the future. Ideally they would serve both as actual validation against existing results (e.g. convergence test, lid-driven cavity, viscous flow around a cylinder) and as advanced examples, so maybe they should become Literate examples (or Pluto examples/notebooks...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143:120,sandbox,sandbox,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143,1,['sandbox'],['sandbox']
Modifiability,Yeah for sure we should add docs before merging. This PR may be open for a bit because I'd like to refactor the tests. Right now they take almost 2 hours on average which I feel is much too slow.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491:99,refactor,refactor,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491,1,['refactor'],['refactor']
Modifiability,Yeah seems like it might be easiest to define a new `define_output_variable!` that dispatches on `WindowedTimeAverage{<:WindowedSpatialAverage}`. `define_output_variable!` is only used by `NetCDFOutputWriter` since it needs to know which dimensions belong to the variable.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252:263,variab,variable,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252,1,['variab'],['variable']
Modifiability,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Adapt,Adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971,1,['Adapt'],['Adapt']
Modifiability,"Yeah that would definitely help with modularization. They might need to take in the whole model, e.g. `validate_coriolis(model)`, `validate_advection(model)`, etc. since it seems hard to anticipate all the inconsistent configurations. I remember you raised the concern of slowdowns in the case of running tons of small/column models. So maybe a kwarg like `check_consistency=true` would be good to add with this feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103:219,config,configurations,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103,1,['config'],['configurations']
Modifiability,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,adapt,adaptive,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450,3,"['adapt', 'refactor']","['adapt', 'adaptive', 'refactor']"
Modifiability,Yeah... Let's put this in the pot for a potential buoyancy refactor (see #2022).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626:59,refactor,refactor,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626,1,['refactor'],['refactor']
Modifiability,"Yeap, I agree. So are you thinking a config similar to the examples (e.g., rectilinear), start with mean state + some prescribed perturbation and run for up to, e.g., t=20 and compare output? How does that sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032:37,config,config,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032,1,['config'],['config']
Modifiability,"Yeap, let’s add them now and enhance/improve later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429:29,enhance,enhance,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429,1,['enhance'],['enhance']
Modifiability,"Yep, we used nsys because our primary objective is to trace GPU execution. I think it will work also on CPU programs. ; There is nothing really specific about profiling julia with nsys, provided that MPI is correctly configured (i.e. your script works with MPI already). An example of a batch script that traces MPI calls is; ```; #!/bin/bash; #SBATCH -N 2; #SBATCH --ntasks-per-node=4; #SBATCH --cpus-per-task=16; #SBATCH --mem=500GB; #SBATCH --time 24:00:00; #SBATCH --gres=gpus:4. cat > launch.sh << EoF_s; #! /bin/sh; export CUDA_VISIBLE_DEVICES=0,1,2,3; exec \$*; EoF_s; chmod +x launch.sh. srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl ; ```; Here, `nsys` will produce one report per processor. You can use `mpirun` or `mpiexec` instead of `srun`.; If you want to insert GC (garbage collection) annotations in the report through nvtx you need to add the environment variable ([ref](https://github.com/JuliaGPU/NVTX.jl)) ; ```; export JULIA_NVTX_CALLBACKS=gc; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670:217,config,configured,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,"Yes that would be ideal!. Actually I guess right now it might be tricky since you have to create the grid first for stretched and curvilinear grids. But for multi-architectures, you need to pass the grid as the grid topology could change the rank connectivity. So you end up having to specify `CPU()` for the grid, then pass it to the `MultiCPU` constructor, then pass that to the model. Would be great if we can specify the architecture in one place, but might require some refactoring that we'd have to think more about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052:475,refactor,refactoring,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052,1,['refactor'],['refactoring']
Modifiability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1065,rewrite,rewrite,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,2,['rewrite'],['rewrite']
Modifiability,"Yes we have some notes on the Fourier Poisson solver here: https://climate-machine.github.io/Oceananigans.jl/latest/algorithm/#Discrete-Fourier-spectral-method-1. Yes we'd need a _new_ Poisson solver with Neumann boundary conditions in two directions but this would be a minor change. I think we'd just have to use the same wavenumbers in the _y_-direction as we do for the _z_-direction [see equations (47) and (48)] and use DCTs in the _y_-direction instead of FFTs. I think that should be it but not 100% sure if it's that simple. **Note**: It's only this simple if _Δy_ and _Δz_ are constants (well, _Δz_ can be variable #46). But if both _Δy_ and _Δz_ are variable, then the Poisson solve will become much slower and more difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198:616,variab,variable,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198,2,['variab'],['variable']
Modifiability,"Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394. And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395:26,adapt,adapted,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:377,adapt,adapt,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,2,['adapt'],"['adapt', 'adapting']"
Modifiability,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:848,adapt,adapt,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675,1,['adapt'],['adapt']
Modifiability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:629,extend,extend,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['extend'],['extend']
Modifiability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:823,extend,extending,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['extend'],['extending']
Modifiability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:423,variab,variable,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,2,['variab'],['variable']
Modifiability,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:259,extend,extended,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246,1,['extend'],['extended']
Modifiability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:171,layers,layers,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,5,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,[da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7057c7e9] Cassette v0.3.10; [d360d2e6] ChainRulesCore v1.15.0; [9e997f8a] ChangesOfVariables v0.1.3; [944b1d66] CodecZlib v0.7.1; [35d6a980] ColorSchemes v3.20.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.9.10; [5ae59095] Colors v0.12.10; [34da2185] Compat v3.43.0; [a216cea6] CompoundPeriods v0.5.1; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [9a962f9c] DataAPI v1.10.0; [124859b0] DataDeps v0.7.10; [864edb3b] DataStructures v0.18.12; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNu,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1917,Adapt,Adapt,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:264,adapt,adapt,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,2,['adapt'],['adapt']
Modifiability,"```; [e9e359dc] CUDA_jll v10.0.130+3; ```. That JLL is deprecated and shouldn't be used. For one, it `dlopen`s plenty of libraries eagerly, as can be seen at the start of the test:. ```; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ```. Opening many copies of CUDA libraries easily breaks the whole system, and might explain the CUBLAS failure here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:442,variab,variable,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Adapt,Adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:339,adapt,adapted,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,2,['adapt'],"['adapt', 'adapted']"
Modifiability,"```julia> using Pkg; pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.7; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.4.3; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.5; [d360d2e6] ChainRulesCore v0.9.38; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.12.0; [3da002f7] ColorTypes v0.10.12; [5ae59095] Colors v0.12.7; [34da2185] Compat v3.27.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.3+0; [0c68f7d7] GPUArrays v6.2.2; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.57.4; [d2c73de3] GR_jll v0.57.2+0; [5c1252a2] GeometryBasics v0.3.12; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.9.5; [615f187c] IfElse v0.1.0; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [c8e1da08] IterTools v1.3.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.3; [692b3bcd] JLLWrappers v1.3.0; [682c06a0] JSON v0.21.1; [0f8b85d8] JSON3 v1.8.0; [aacddb02] JpegTurbo_jll v2.0.1+3; [63c18a36] KernelAbstractions v0.5.5; [c1c5ebd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:135,Adapt,Adapt,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Adapt'],['Adapt']
Modifiability,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:23,variab,variable,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,4,['variab'],['variable']
Modifiability,"`interior` is interesting. Are we sure that we should extend this at all? It's main purpose would be debugging I guess, since any time you are using MultiRegion for real, you likely wouldn't want to call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688:54,extend,extend,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688,1,['extend'],['extend']
Modifiability,a 'simple forcing' script to reproduce this error is here:. https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547:157,sandbox,sandbox,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547,1,['sandbox'],['sandbox']
Modifiability,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2028,Adapt,Adapt,2028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ally $z_grid_type grid ...""; grid = lagrangian_particle_test_grid(arch, y_topo, z); # run_simple_particle_tracking_tests(arch, grid, timestepper); @show grid; end; ```. which would give us these 8 (per architecture) test cases. ```julia; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:1758,variab,variably,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:1470,variab,variable,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['variab'],['variable']
Modifiability,"annoying that the tests need a little refactoring too, but maybe its all for the best.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458:38,refactor,refactoring,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458,1,['refactor'],['refactoring']
Modifiability,"arshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It seems; > that a discrete forcing method overcomes this restriction and could prove; > crucial for geophysical problems that involve otherwise long time-steps.; >; > —; > You are receiving this becaus",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:1148,extend,extend,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['extend'],['extend']
Modifiability,"art @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1205,rewrite,rewrite,1205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['rewrite'],['rewrite']
Modifiability,"aryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Const{NamedTuple{(:c,), Tuple{BoundaryCondition{Flux, Nothing}}}}, Const{Nothing}, Const{NamedTuple{(), Tuple{}}}, Const{typeof(Oceananigans.Forcings.zeroforcing)}, Duplicated{Clock{Float64}}}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:82;   | [6] (::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)})(::Function, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:44;   | [7] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:17070,Config,ConfigWidth,17070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"ase.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ EnzymeExt /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:62;   | [8] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:18835,Config,ConfigWidth,18835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1280,variab,variables,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,2,['variab'],['variables']
Modifiability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:156,variab,variability,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['variab'],['variability']
Modifiability,"belms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1071,Config,Config,1071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['Config'],['Config']
Modifiability,"bservation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better...; <img width=""519"" alt=""image"" src=""https://user-images.githubusercontent.com/12438579/156286196-846d07eb-e8a2-4762-b2c8-3d3226401334.png"">. >Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:1346,parameteriz,parameterize,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704,1,['parameteriz'],['parameterize']
Modifiability,"but FYI:. ```; @setup example1; ```. is used to configure `@examples`, not doctests; that's why it didn't work. On a different note, using `# hide` notation won't work in the sense the code will run but it won't be hidden -- that's syntax from Literate.jl package and we are not liberating the docs; only examples.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921:48,config,configure,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921,1,['config'],['configure']
Modifiability,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1427,config,configurations,1427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configurations']
Modifiability,"cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_nod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:1066,variab,variably,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,2,['variab'],['variably']
Modifiability,"center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1852,extend,extend,1852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['extend'],['extend']
Modifiability,"chitectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1410,Config,Configuration,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Configuration']
Modifiability,"ckages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKerne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2099,Adapt,Adapt,2099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043:1876,flexible,flexible,1876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043,2,['flexible'],['flexible']
Modifiability,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1186,config,configurations,1186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,2,['config'],['configurations']
Modifiability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Adapt,Adapt,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['Adapt'],['Adapt']
Modifiability,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,adapt,adapt,6102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,2,['adapt'],['adapt']
Modifiability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:298,variab,variable,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1073,variab,variable,1073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"e change we could make would be instead write. ```Julia; ""Calculate the right-hand-side of the u-momentum equation at I, j, k.""; u_eqn(args..., F::Function i, j, k) = stuff + F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); u_eqn(args..., F::AbstractArray i, j, k) = stuff + F[i, j, k]; u_eqn(args..., F::Nothing, i, j, k) = stuff. ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = u_eqn(args..., F.u, i, j, k); # ...; ```; We could write even less code if we created an abstraction for the right hand side, something like. ```Julia; struct Equation{TF}; G::Function; F::TF; end. (eq::Equation{TF})(args..., i, j, k) where TF <: Function = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: AbstractArray = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: Nothing = eq.G(args..., i, j, k) . u_eqn = Equation(Gu, Fu). ...; @inbounds Gu[i, j, k] = u_eqn(args..., i, j, k); ```. We can then load all the equations we have into a `FieldVector` or `LabeledArray` to make things even better and do something like . ```julia; @loop for k in (1:Nz; blockIdx().z); @loop for j in (1:Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); for (Gφ, i) in enumerate(G); φ_eqn = equation[i]; Gφ[i, j, k] = φ_eqn(args... i, j, k); end; end; end; end; ```. With a time-stepping kernel of that form we can easily add and subtract tracers, equations, sub grid closure variables, etc. I think the inner loop gets unrolled when the array is static, so the compiled code is no different from what we currently have. . This is somewhere down the line hopefully. Maybe v0.6... or 1.0. Heh.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169:2405,variab,variables,2405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169,1,['variab'],['variables']
Modifiability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1817,parameteriz,parameterizations,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,['parameteriz'],['parameterizations']
Modifiability,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:2086,rewrite,rewrite,2086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rewrite'],['rewrite']
Modifiability,"e the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1106,variab,variable,1106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['variab'],['variable']
Modifiability,"e). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_mask_cos(x, y, z); if z₀ >= z > z₁; return 1/2 * (1 - cos( π*(z-z₀)/(z₁-z₀) )); elseif z₁ >= z #> z₂; return 1.0; else; return 0.0; end ; end. @inline sponge_u(x, y, z, t, u, p) = -bottom_mask_cos(x, y, z) * p.σ * u; @inline sponge_v(x, y, z, t, v, p) = -bottom_mask_cos(x, y, z) * p.σ * v; @inline sponge_w(x, y, z, t, w, p) = -bottom_mask_cos(x, y, z) * p.σ * w; @inline sponge_b(x, y, z, t, b, p) = -bottom_mask_cos(x, y, z) * p.σ * (b - b∞(0, 0, z, 0, p)). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; params.σ)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; params.σ)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; params.σ)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; params.σ, params.N²∞)); ```. The above are the forcing functions, and below is the background field. There are also parameters passed for the boundary conditions. ```julia; @inline b_bg(x, y, z, t, p) = p.M² * x; B_field = BackgroundField(b_bg, parameters = (; params.M²)); ```. Changing things so that variables that are currently passed as parameters are set as `const`ants helps (as you can see I did with `z₀`, etc.). However, that also means I can't run back-to-back simulations where those parameters differ, which is something that makes my workflow way more streamlined, so I'm trying to avoid that. (Although I'll ultimately have to do that if we can't figure this error out...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:3056,variab,variables,3056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['variab'],['variables']
Modifiability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2155,variab,variables,2155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,4,['variab'],['variables']
Modifiability,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:2010,evolve,evolve,2010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703,1,['evolve'],['evolve']
Modifiability,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5705,variab,variable,5705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16088,sandbox,sandbox,16088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,2,['sandbox'],['sandbox']
Modifiability,"ed MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = Field{Face, Center, Center}(rectilinear_grid); 128×128×64 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, u); 0.0. julia> v = Field{Center, Face, Center}(rectilinear_grid); 128×129×64 Field{Center, Face, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:2380,variab,variably,2380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['variab'],['variably']
Modifiability,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1426,adapt,adapts,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,2,['adapt'],['adapts']
Modifiability,"er_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: L",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17669,Adapt,Adapt,17669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"es because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for conne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4899,variab,variables,4899,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"escribes a time-evolving state. In this case, parent velocities and tracers are specified at each point in space and time -- both on the boundary, and inside the ""child"" `NonhydrostaticModel` domain. We can imagine that this case would involve a utility that takes in the parent state (or a filename / list of filenames) and returns boundary conditions on velocities and tracers. The utility might also return forcing functions that prescribe a sponge layer that relaxes the model solution to the parent state near the boundary, like [MITgcm's ""relaxation boundary conditions"" package](https://mitgcm.readthedocs.io/en/latest/phys_pkgs/rbcs.html). As for how the boundary conditions work, an arbitrary parent state will dictate wall-normal velocities that are variously either inward or outward (fluxing information out of the domain). Somehow, the inflow / outflow specified by the parent state has to be reconciled with the model state. The discussion on this PR seems to suggest that the outflow velocity used by the boundary condition may need to be _different_ than what is specified by the parent state (otherwise, why would we need to ""compute"" an outflow velocity?). But I don't understand anything further than that. I also don't understand the implications of a sponge layer, which almost certainly seems required. . 2. Constant or idealized inflows and outflows. This seems to be the case in the movie on the original post and also of @simone-silvestri 's movie. On one (or more?) boundaries, an inflow state is prescribed. The inflow boundaries could use 1) `OpenBoundaryCondition` on both velocities and tracers, or 2) `OpenBoundaryCondition` for velocities and `ValueBoundaryCondition` on tracers. The second case would be used when attempting to prescribe the tracer fluxes precisely. There are also outflow boundaries, which either have a prescribed outflow velocity, a computed-yet-still-spatially-uniform bulk outflow velocity, or a computed and spatially-variable outflow velocity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207:2130,variab,variable,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207,1,['variab'],['variable']
Modifiability,f2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:16102,Adapt,Adapt,16102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Adapt'],['Adapt']
Modifiability,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11070,Adapt,Adapt,11070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,for the GPU config you can see the hardware it is being run on here:; https://buildkite.com/clima/oceananigans-central/builds/8#5ef96bf8-7b5f-47d3-84fd-726b4cb3fc33/9-11,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232:12,config,config,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232,1,['config'],['config']
Modifiability,"g. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5483,variab,variables,5483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"githubusercontent.com/33547697/225382686-301b4f32-73b5-40a3-b5e3-74c52fa189f1.png). ~left is `k = grid.Nz-1` and right is `k = grid.Nz`. `grid.Nz-1` seems to be correct, while `grid.Nz` is completely off.; This is the code I used to generate the regridded data~. ```; using ClimaOcean; using ClimaOcean.DataWrangling; using Oceananigans ; using Oceananigans.BoundaryConditions; using DataDeps; using GLMakie; using JLD2 . regrid_in_z = true. path = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/"". dh = DataDep(""quarter_degree_near_global_lat_lon"",; ""Forcing data for global latitude longitude simulation"",; path * ""z_faces-50-levels.jld2""; ). DataDeps.register(dh). datadep""quarter_degree_near_global_lat_lon"". datadep_path = @datadep_str ""quarter_degree_near_global_lat_lon/z_faces-50-levels.jld2""; file_z_faces = jldopen(datadep_path); z_faces = file_z_faces[""z_faces""][3:end];. file_init = jldopen(""evolved-initial-conditions-1105days.jld2""). # A spherical domain; grid12 = LatitudeLongitudeGrid(size = (4320, 1800, 48),; longitude = (-180, 180),; latitude = (-75, 75),; z = z_faces,; precompute_metrics = true). T12 = set!(CenterField(grid12), file_init[""T""]); S12 = set!(CenterField(grid12), file_init[""S""]). @inline exponential_profile(z; Lz, h) = (exp(z / h) - exp( - Lz / h)) / (1 - exp( - Lz / h)) . function exponential_z_faces(Nz, Depth; h = Nz / 4.5). z_faces = exponential_profile.((1:Nz+1); Lz = Nz, h). # Normalize; z_faces .-= z_faces[1]; z_faces .*= - Depth / z_faces[end]; ; z_faces[1] = 0.0. return reverse(z_faces); end. Depth = - grid12.Lz. @info ""start regridding in Z!!""; grid12z = LatitudeLongitudeGrid(size = (4320, 1800, 120),; longitude = (-180, 180),; latitude = (-75, 75),; z = exponential_z_faces(120, Depth),; precompute_metrics = true). T12z = CenterField(grid12z); S12z = CenterField(grid12z). using Oceananigans.Fields: regrid!; fill_halo_regions!((T12, S12)); regrid!(T12z, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304:1213,evolve,evolved-initial-conditions-,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304,1,['evolve'],['evolved-initial-conditions-']
Modifiability,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:60,config,configuration,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201,1,['config'],['configuration']
Modifiability,"hat sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:2335,config,configuration,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['config'],['configuration']
Modifiability,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262:2450,extend,extending,2450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262,2,['extend'],['extending']
Modifiability,"hmmm I cannot reproduce the bug; ```; julia> underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:487,variab,variably,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"how about if we make it to something like. ```julia; julia> b′b′; mean! over dims (1,) of BinaryOperation at (Center, Center, Center); └── operand: BinaryOperation at (Center, Center, Center); call b′b′.operand to see the operation tree; └── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ```. I tried but I can't seem to be able to get the variable name as a string, e.g., a string with `""b′b′""` for this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192:384,variab,variable,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192,1,['variab'],['variable']
Modifiability,"iff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:2489,parameteriz,parameterized,2489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['parameteriz'],['parameterized']
Modifiability,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:2248,adapt,adapt,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,2,['adapt'],['adapt']
Modifiability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2180,adapt,adaptive,2180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['adapt'],['adaptive']
Modifiability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1960,adapt,adaptive,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['adapt'],['adaptive']
Modifiability,"in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit. The other option to not use MPI variables is to hardcode the number of processors",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696:84,variab,variables,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696,2,['variab'],['variables']
Modifiability,"inition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1210,Config,Config,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Config']
Modifiability,"interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1548,Variab,Variable,1548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['Variab'],['Variable']
Modifiability,"ismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1184,Variab,Variable,1184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Variab'],['Variable']
Modifiability,ll/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2601,parameteriz,parameterized,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"lliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUArrays]]; deps = [""AbstractFFTs"", ""Adapt"", ""LinearAlgebra"", ""Printf"", ""Random"", ""Serialization""]; git-tree-sha1 = ""9c95b2fd5c16bc7f97371e9f92f0fef77e0f5957""; uuid = ""0c68f7d7-f131-5f86-a1c3-88cf8149b2d7""; version = ""6.2.2"". [[GPUCompiler]]; deps = [""DataStructures"", ""InteractiveUtils"", ""LLVM"", ""Libdl"", ""Scratch"", ""Serialization"", ""TimerOutputs"", ""UUIDs""]; git-tree-sha1 = ""c853c810b52a80f9aad79ab109207889e57f41ef""; uuid = ""61eb1bfa-7361-4325-ad38-22787b887f55""; version = ""0.8.3"". [[Glob]]; git-tree-sha1 = ""4df9f7e06108728ebf00a0a11edee4b29a482bb2""; uuid = ""c27321d9-0574-5035-807b-f59d2c89b15c""; version = ""1.3.0"". [[HDF5_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""LibCURL_jll"", ""Libdl"", ""OpenSSL_jll"", ""Pkg"", ""Zlib_jll""]; git-tree-sha1 = ""fd83fa0bde42e01952757f01149dd968c06c4dba""; uuid = ""0234f1f7-429e-5d53-9886-15a909be8d59""; version = ""1.12.0+1"". [[IfElse]]; git-tree-sha1 = ""28e837ff3e7a6c3cdb252ce49fb412c8eb3caeef""; uuid = ""615f187c-cbe4-4ef1-ba3b-2fcf58d6d173""; version = ""0.1.0"". [[IntelOpenMP_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""d979e54b71da82f3a65",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:5373,Adapt,Adapt,5373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:76,config,configurations,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615,1,['config'],['configurations']
Modifiability,"losures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model using Oceananigans functionality and 2) a quasi-geostrophic model in Oceananigans (which would use the tridiagonal solver I mentioned earlier). What else? The best project is probably one that aligns with you and your students' research... ? Definitely happy to chat further and also collaborate on something if you'd like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2654,refactor,refactoring,2654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['refactor'],['refactoring']
Modifiability,"lsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1749,variab,variables,1749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,2,['variab'],['variables']
Modifiability,"lways have them together. At some point we have to get the external value, and if it's in the condition slot in `BoundaryCondition` we can get it like this:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L9. which can be e.g.; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L124-L133; which is called because of there being a `ContinuousBoundaryFunction` in the `BoundaryCondition` type:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L119; which was automatically set-up and then `regularize`-d. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/boundary_condition.jl#L53-L67. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L74-L75. But if we have this as part of the condition we get something like:; ```julia; BoundaryCondition{<:Open, <:OpenConditions{ES, MS}}; ```. then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. In the existing code the condition and classification are never directly accessed (except from inside `getbc`) and all of the other bits are based on the types:. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L15. so we can just write methods like:. ```julia; @inline function _fill_west_halo!(j, k, grid, c, bc::BoundaryCondition{Open{<:SomeMatchingScheme}}, loc, args...); ```. I don't really understand how it makes the code any harder to understand if we then get the condition as above v.s. writing new things so we can do `external_state = some_function(bc)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344:1370,rewrite,rewrite,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344,1,['rewrite'],['rewrite']
Modifiability,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Adapt,Adapt,7089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,more flexible and less code -- what can go wrong?. yeap!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920:5,flexible,flexible,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920,1,['flexible'],['flexible']
Modifiability,"n . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:4483,adapt,adaptive,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['adapt'],['adaptive']
Modifiability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:3004,refactor,refactoring,3004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['refactor'],['refactoring']
Modifiability,"ndaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:2788,parameteriz,parameterized,2788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['parameteriz'],['parameterized']
Modifiability,"nditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:195; ```. That is to say `NetCDFWriter` isn't correctly inferring the sizes for each variable when creating the NetCDF file. I think atm each file creating assumes all outputs are sliced similarly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:49725,variab,variable,49725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"ndom""]; git-tree-sha1 = ""6a8a2a625ab0dea913aba95c11370589e0239ff0""; uuid = ""1914dd2f-81c6-5fcd-8719-6d5c9610ff09""; version = ""0.5.6"". [[Markdown]]; deps = [""Base64""]; uuid = ""d6f4376e-aef5-505a-96c1-9c027394607a"". [[MbedTLS_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""0eef589dd1c26a3ac9d753fe1a8bcad63f956fa6""; uuid = ""c8ffd9c3-330d-5841-b78e-0817d7145fa1""; version = ""2.16.8+1"". [[MicrosoftMPI_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""e5c90234b3967684c9c6f87b4a54549b4ce21836""; uuid = ""9237b28f-5490-5468-be7b-bb81f5f5e6cf""; version = ""10.1.3+0"". [[Mmap]]; uuid = ""a63ad114-7e13-5084-954f-fe012c677804"". [[NCDatasets]]; deps = [""CFTime"", ""DataStructures"", ""Dates"", ""NetCDF_jll"", ""Printf""]; git-tree-sha1 = ""b71d83c87d80f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:10403,Adapt,Adapt,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"nearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:3222,variab,variably,3222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,2,['variab'],['variably']
Modifiability,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore ─ v1.7.2; Installed Tables ───────── v1.6.0; Installed Parsers ──────── v2.0.5; Installed StaticArrays ─── v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Adapt,Adapt,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Adapt'],['Adapt']
Modifiability,need a test too I think. Probably some refactoring to come for Lagrangian particles...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453:39,refactor,refactoring,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453,1,['refactor'],['refactoring']
Modifiability,"nvironment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1470,Config,Configuration,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['Config'],['Configuration']
Modifiability,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2466,parameteriz,parameterizations,2466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['parameteriz'],['parameterizations']
Modifiability,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,adapt,adapt,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['adapt'],['adapt']
Modifiability,"o: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; [ Info: Writing done: time=17.732 seconds, size=19.5 KiB, Δsize=0.0 B; [ Info: ... simulation initialization complete (18.528 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (30.965 seconds).; [ Info: Simulation is stopping after running for 49.565 seconds.; [ Info: Model iteration 4 equals or exceeds stop iteration 4.; ```. and then . ```Julia; julia> using NCDatasets. julia> ds = NCDataset(simulation.output_writers[:xz1_writer].filepath, ""r""); NCDataset: ./test.nc; Group: /. Dimensions; zC = 16; zF = 17; xC = 16; yF = 1; xF = 16; yC = 1; time = 1. Variables; zC (16); Datatype: Float64; Dimensions: zC; Attributes:; units = m; longname = Locations of the cell centers in the z-direction. zF (17); Datatype: Float64; Dimensions: zF; Attributes:; units = m; longname = Locations of the cell faces in the z-direction. xC (16); Datatype: Float64; Dimensions: xC; Attributes:; units = m; longname = Locations of the cell centers in the x-direction. yF (1); Datatype: Float64; Dimensions: yF; Attributes:; units = m; longname = Locations of the cell faces in the y-direction. xF (16); Datatype: Float64; Dimensions: xF; Attributes:; units = m; longname = Locations of the cell faces in the x-direction. yC (1); Datatype: Float64; Dimensions: yC; Attributes:; units = m; longname = Locations of the cell centers in the y-direction. time (1); Datatype: Float64; Dimensions: time; Attributes:; units = seconds; longname = Time. wτ3 (16 × 1 × 17 × 1); Datatype: Float64; Dimensions: xC × yC × zF × time. wτ2_yavg (16 × 17 × 1); Datatype: Float64; Dimensions: xC × zF × time. wτ6_yavg (16 × 17 × 1); Datatype: Float64; Dimension",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:2563,Variab,Variables,2563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['Variab'],['Variables']
Modifiability,"odel::NonhydrostaticModel{…}, callbacks::Vector{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:31; > [11] #apply_regionally!#56; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; > [12] apply_regionally!; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; > [13] macro expansion; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; > [14] update_state!(model::NonhydrostaticModel{…}, callbacks::Vector{…}; compute_tendencies::Bool); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:47; > [15] update_state!; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19 [inlined]; > [16] update_state!(model::NonhydrostaticModel{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19; > [17] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@NamedTuple{}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198; > [18] top-level scope; > @ REPL[5]:1; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Ok I fixed that. Probably we should use a `Field` rather than `ones` for the test and examples, because it automatically adapts to GPU, distributed, etc, so its a bit better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:5212,adapt,adapts,5212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,1,['adapt'],['adapts']
Modifiability,"ok, @simone-silvestri, I did what you were suggesting.; we now need to refactor the tests....... oh dear........",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771,1,['refactor'],['refactor']
Modifiability,"ok, now that #2522 is merged we can start thinking of multiple layers :) ; I put an overleaf doc with eqs at https://www.overleaf.com/read/mtyjxnnrjpqv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146:63,layers,layers,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146,1,['layers'],['layers']
Modifiability,"ok, so now we have. ```julia. julia> grid; 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.830909; ```. and. ```julia; julia> c; 32×32×24 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── data: 34×34×26 OffsetArray(::Array{Float64, 3}, 0:33, 0:33, 0:25) with eltype Float64 with indices 0:33×0:33×0:25; │ └── max=0.999994, min=0.000024, mean=0.497759; ├── grid: 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; ```. what do we think so far?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892:253,variab,variably,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892,1,['variab'],['variably']
Modifiability,"onal changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1031,config,config,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['config'],['config']
Modifiability,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Adapt,Adapt,7871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Adapt'],['Adapt']
Modifiability,"propriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie _on_ the boundary. A better name is welcome...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:2553,refactor,refactor,2553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['refactor'],['refactor']
Modifiability,"reates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1161,Variab,Variable,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['Variab'],['Variable']
Modifiability,"rettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:3265,config,configurable,3265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,"['config', 'variab']","['configurable', 'variables']"
Modifiability,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,adapt,adapting,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,2,['adapt'],['adapting']
Modifiability,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:2983,parameteriz,parameterized,2983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['parameteriz'],['parameterized']
Modifiability,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17418,sandbox,sandbox,17418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,['sandbox'],['sandbox']
Modifiability,"sBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:2444,variab,variably,2444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2557,variab,variable,2557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['variab'],['variable']
Modifiability,"sonally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:1059,extend,extending,1059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,2,['extend'],['extending']
Modifiability,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1091,evolve,evolved,1091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['evolve'],['evolved']
Modifiability,"t place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:2271,layers,layers,2271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,['layers'],['layers']
Modifiability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2410,evolve,evolve,2410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,2,"['evolve', 'refactor']","['evolve', 'refactoring']"
Modifiability,"t; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXXAHFI#issuecomment-502137749>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYEHNERHN4MHAGJQZH3P2OVODANCNFSM4HXEYRJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1640,refactor,refactored,1640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,2,['refactor'],"['refactor', 'refactored']"
